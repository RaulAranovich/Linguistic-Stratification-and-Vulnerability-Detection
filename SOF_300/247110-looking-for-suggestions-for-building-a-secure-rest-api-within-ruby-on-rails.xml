<?xml version="1.0" encoding="utf-8"?>
<post><title>Looking for suggestions for building a secure REST API within Ruby on Rails - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm getting started on building a REST API for a project I'm working on, and it led me to do a little research as to the best way to build an API using RoR. I find out pretty quickly that by default, models are open to the world and can be called via URL by simply putting a ".xml" at the end of the URL and passing appropriate parameters.</p>
<p>So then the next question came. How do I secure my app to prevent unauthorized changes? In doing some research I found a couple articles talking about <code>attr_accessible</code> and <code>attr_protected</code> and how they can be used. The particular URL I found talking about these was posted back in May of '07 (<a href="http://railscasts.com/episodes/26-hackers-love-mass-assignment" rel="noreferrer">here</a>). </p>
<p>As with all things ruby, I'm sure that things have evolved since then. So my question is, is this still the best way to secure a REST API within RoR?</p>
<p>If not what do you suggest in either a "new project" or an "existing project"scenario?</p>
</div></text><author><a href="/users/319931/mechanical-snail">Mechanical snail</a></author><comments><comment><text><span class="comment-copy">If the client knows how to manipulate your URIs (by appending .xml or otherwise) then your API is not REST.</span></text><author><a class="comment-user" href="/users/89373/aehlke" title="6,608 reputation">aehlke</a></author></comment><comment><text><span class="comment-copy">this is a good Oauth 2.0 Server library for ruby <a href="https://github.com/Lelylan/rest-oauth2-server" rel="nofollow noreferrer">github.com/Lelylan/rest-oauth2-server</a></span></text><author><a class="comment-user" href="/users/946478/sparkle" title="2,245 reputation">sparkle</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>There are several schemes for authenticating API requests, and they're different than normal authentication provided by plugins like restful_authentication or acts_as_authenticated.  Most importantly, clients will not be maintaining sessions, so there's no concept of a login.</p>
<p><strong>HTTP Authentication</strong></p>
<p>You can use basic HTTP authentication.  For this, API clients will use a regular username and password and just put it in the URL like so:</p>
<pre class="lang-rb prettyprint prettyprinted" style=""><code><span class="pln">http</span><span class="pun">:/</span><span class="str">/myusername:mypass@www.someapp.com/</span></code></pre>
<p>I believe that restful_authentication supports this out of the box, so you can ignore whether or not someone is using your app via the API or via a browser.</p>
<p>One downside here is that you're asking users to put their username and password in the clear in every request.  By doing it over SSL, you can make this safe.</p>
<p>I don't think I've ever actually seen an API that uses this, though.  It seems like a decently good idea to me, especially since it's supported out of the box by the current authentication schemes, so I don't know what the problem is.</p>
<p><strong>API Key</strong></p>
<p>Another easy way to enable API authentication is to use API keys.  It's essentially a username for a remote service.  When someone signs up to use your API, you give them an API key.  This needs to be passed with each request.</p>
<p>One downside here is that if anyone gets someone else's API key, they can make requests as that user.  I think that by making all your API requests use HTTPS (SSL), you can offset this risk somewhat.</p>
<p>Another downside is that users use the same authentication credentials (the API key) everywhere they go. If they want to revoke access to an API client their only option is to change their API key, which will disable all other clients as well. This can be mitigated by allowing users to generate multiple API keys.</p>
<p><strong>API Key + Secret Key signing</strong></p>
<p><em>Deprecated(sort of) - see OAuth below</em></p>
<p>Significantly more complex is signing the request with a secret key.  This is what Amazon Web Services (S3, EC2, and such do).  Essentially, you give the user 2 keys: their API key (ie. username) and their secret key (ie. password).  The API key is transmitted with each request, but the secret key is not.  Instead, it is used to sign each request, usually by adding another parameter.</p>
<p>IIRC, Amazon accomplishes this by taking all the parameters to the request, and ordering them by parameter name.  Then, this string is hashed, using the user's secret key as the hash key.  This new value is appended as a new parameter to the request prior to being sent.  On Amazon's side, they do the same thing.  They take all parameters (except the signature), order them, and hash using the secret key.  If this matches the signature, they know the request is legitimate.</p>
<p>The downside here is complexity.  Getting this scheme to work correctly is a pain, both for the API developer and the clients.  Expect lots of support calls and angry emails from client developers who can't get things to work.</p>
<p><strong>OAuth</strong></p>
<p>To combat some of the complexity issues with key + secret signing, a standard has emerged called <a href="http://oauth.net/" rel="noreferrer">OAuth</a>. At the core OAuth is a flavor of key + secret signing, but much of it is standardized and has been included into <a href="http://oauth.net/code/" rel="noreferrer">libraries for many languages</a>.</p>
<p>In general, it's much easier on both the API producer and consumer to use OAuth rather than creating your own key/signature system.</p>
<p>OAuth also inherently segments access, providing different access credentials for each API consumer. This allows users to selectively revoke access without affecting their other consuming applications.</p>
<p>Specifically for Ruby, there is an <a href="http://oauth.rubyforge.org/" rel="noreferrer">OAuth gem</a> that provides support out of the box for both producers and consumers of OAuth. I have used this gem to build an API and also to consume OAuth APIs and was very impressed. If you think your application needs OAuth (as opposed to the simpler API key scheme), then I can easily recommend using the OAuth gem.</p>
</div></text><author><a href="/users/19964/micah">Micah</a></author><comments><comment><text><span class="comment-copy">many people are going down the API key + signing path, anyone know if there is a 'better way'?!</span></text><author><a class="comment-user" href="/users/21596/matthewford" title="2,484 reputation">MatthewFord</a></author></comment><comment><text><span class="comment-copy">Nice answer - this finally cleared it up for me with the different levels.  Thanks!</span></text><author><a class="comment-user" href="/users/76486/brian-armstrong" title="11,611 reputation">Brian Armstrong</a></author></comment><comment><text><span class="comment-copy">There are two big problems with HTTP "Authorization:". The first is that the server decides on the auth scheme, which means that Digest authentication doesn't prevent password-compromise by a MITM (just pretend that you only support Basic).  The second is that Basic authentication isn't limited to a path, so anyone on a shared webserver can get anyone else's password (a lot of people are switching to subdomains for this reason, along with cookies and generally more sane Apache config).</span></text><author><a class="comment-user" href="/users/349112/tc" title="29,466 reputation">tc.</a></author></comment><comment><text><span class="comment-copy">What is not clear is whether this creates an inconsistency in websites that support (the now ubiquitous) OAuth-style delegated authentication. If my site promotes Twitter or Facebook login, then I <i>do not</i> provide any user name and password for browser access. I simply delegate it to Twitter/Fb via oauth. But when I need to provide programmatic access to my users, I have to generate and provide an API_KEY to the same users. IMO, this is equivalent to providing user name and password even when browser access to your website relies on delegated authentication.</span></text><author><a class="comment-user" href="/users/437506/kedar-mhaswade" title="3,042 reputation">Kedar Mhaswade</a></author></comment><comment><text><span class="comment-copy">FYI, it is generally safe to not have <code>csrf</code> for API calls as the particular vulnerability can only be executed through a web browser.</span></text><author><a class="comment-user" href="/users/914986/hengjie" title="3,012 reputation">Hengjie</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>How do I secure my app to prevent
  unauthorized changes?</p>
</blockquote>
<p><code>attr_accessible</code> and <code>attr_protected</code> are both useful for controlling the ability to perform mass-assignments on an ActiveRecord model.  You definitely want to use attr_protected to prevent form injection attacks; see <a href="http://b.lesseverything.com/2008/3/11/use-attr_protected-or-we-will-hack-you" rel="nofollow noreferrer">Use attr_protected or we will hack you</a>.</p>
<p>Also, in order to prevent anyone from being able to access the controllers in your Rails app, you're almost certainly going to need some kind of user authentication system and put a <code>before_filter</code> in your controllers to ensure that you have an authorized user making the request before you allow the requested controller action to execute.</p>
<p>See the <a href="http://guides.rails.info/security.html" rel="nofollow noreferrer">Ruby on Rails Security Guide</a> (part of the Rails Documentation Project) for tons more helpful info.</p>
</div></text><author><a href="/users/30632/gabe-hollombe">Gabe Hollombe</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm facing similar questions as you at the moment because i'm also building out a REST api for a rails application.</p>
<p>I suggest making sure that only attributes that can be user edited are marked with attr_accessible.  This will set up a white list of attributes that can be assigned using update_attributes.</p>
<p>What I do is something like this:</p>
<pre class="lang-rb prettyprint prettyprinted" style=""><code><span class="pln">   </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Model</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> </span><span class="typ">ActiveRecord</span><span class="pun">::</span><span class="typ">Base</span><span class="pln">  
       attr_accessible </span><span class="kwd">nil</span><span class="pln">  
   </span><span class="kwd">end</span></code></pre>
<p>All my models inherit from that, so that they are forced to define attr_accessible for any fields they want to make mass assignable.  Personally, I wish there was a way to enable this behaviour by default (there might be, and I don't know about it).</p>
<p>Just so you know someone can mass assign a property not only using the REST api but also using a regular form post.</p>
</div></text><author><a href="/users/4590/jonnii">jonnii</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Another approach that saves building a lot of the stuff yourself is to use something like <a href="http://www.3scale.net/" rel="nofollow">http://www.3scale.net/</a> which handles keys, tokens, quotas etc. for individual developers. It also does analytics and creates a developer portal. </p>
<p>There's a ruby/rails plugin <a href="https://github.com/3scale/3scale_ws_api_for_ruby" rel="nofollow">ruby API plugin</a> which will apply to policies to traffic as it arrives - you can use it in conjunction with the <a href="http://oauth.rubyforge.org/" rel="nofollow">oAuth gem</a>. You can also us it by dropping varnish in front of the app and using the varnish lib mod: <a href="https://github.com/3scale/libvmod-3scale/" rel="nofollow">Varnish API Module</a>.</p>
</div></text><author><a href="/users/70088/steve">steve</a></author><comments/></answer></answers></post>