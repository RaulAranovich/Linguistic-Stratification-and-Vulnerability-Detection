<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How can I throttle user login attempts in PHP - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I was just reading this post <a href="http://stackoverflow.com/questions/549/the-definitive-guide-to-website-authentication-beta#477585">The definitive guide to form-based website authentication</a> on Preventing Rapid-Fire Login Attempts.  </p>
<p>Best practice #1: A short time delay that increases with the number of failed attempts,   like:</p>
<p>1 failed attempt = no delay<br/>
2 failed attempts = 2 sec delay<br/>
3 failed attempts = 4 sec delay<br/>
4 failed attempts = 8 sec delay<br/>
5 failed attempts = 16 sec delay<br/>
etc.  </p>
<p>DoS attacking this scheme would be very impractical, but on the other hand, potentially devastating, since the delay increases exponentially.</p>
<p><strong>I am curious how I could implement something like this for my login system in PHP?</strong></p>
</div></text><author><a href="/users/1190388/hjpotter92">hjpotter92</a></author><comments><comment><text><span class="comment-copy">Just make sure there is no arithmetic overflow or you might get a negative delay.</span></text><author><a class="comment-user" href="/users/231677/hamish-grubijan" title="3,472 reputation">Hamish Grubijan</a></author></comment><comment><text><span class="comment-copy">Don't do a delay, just block completely after <i>x</i> number of attempts. Send a 404 when the bot tries to log in. No reason to over complicate by adjusting the delay. Plus it is not out of the question that a <i>human</i> will fail 3 times (and get the long delay)</span></text><author><a class="comment-user" href="/users/285/sestocker" title="2,225 reputation">sestocker</a></author></comment><comment><text><span class="comment-copy">@sestocker Actually, I'd recommend <code>418 I'm a teapot</code> instead of a 404 here. <a href="http://en.wikipedia.org/wiki/Http_status_codes" rel="nofollow noreferrer">en.wikipedia.org/wiki/Http_status_codes</a> ;o)</span></text><author><a class="comment-user" href="/users/476/deceze" title="324,016 reputation">deceze<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@deceze 418 I'm a teapot is like a parody/joke right?</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">@deceze thats hilarious. Going to have to start using that more often.</span></text><author><a class="comment-user" href="/users/285/sestocker" title="2,225 reputation">sestocker</a></author></comment><comment><text><span class="comment-copy">@jason Yes, read the linked article. I'd still use it though. :)</span></text><author><a class="comment-user" href="/users/476/deceze" title="324,016 reputation">deceze<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@jasondavis the wikipedia page says it was an april fools joke.</span></text><author><a class="comment-user" href="/users/285/sestocker" title="2,225 reputation">sestocker</a></author></comment><comment><text><span class="comment-copy">@sestocker bots don't follow the rules - so why should we with error messages?</span></text><author><a class="comment-user" href="/users/99923/xeoncross" title="22,901 reputation">Xeoncross</a></author></comment><comment><text><span class="comment-copy">Why are you asking about a DoS attack when your question is about login security? The two are separate issues and preventing a DoS attack is best handled at the server level as mentioned in one of the answers.</span></text><author><a class="comment-user" href="/users/240361/calvinlough" title="192 reputation">calvinlough</a></author></comment><comment><text><span class="comment-copy">@sestocker: you don't want to block logins for many reasons; DoS is one reason, practicality is another (if your site has millions of accounts, you don't want to reactivate your users manually). Besides, 4 or 8 seconds isn't a 'long' delay for a human, but it's a serious nuisance in a brute force attack. You should probably cap the delay around 15 or 30 minutes though, and provide an IP- or cookie-based 'direct line' so the real user can't be locked out by repeated failed attempts. Read the linked post for details.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">4 or 8 seconds <i>is</i> a long delay for a human who has forgot his password and wants to check a dozen variants ("was that a ! or a @ at the end?"). Look what android does with screen lock: 5 attempts, delay, 5 attempts, delay... that's a more humane approach.</span></text><author><a class="comment-user" href="/users/399317/kos" title="42,102 reputation">Kos</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p><strong>You cannot simply prevent DoS attacks by chaining throttling down to a single IP or username.  Hell, you can't even really prevent rapid-fire login attempts using this method.</strong> </p>
<p><strong><em>Why?</em></strong> <em>Because the attack can span multiple IPs and user accounts for the sake of bypassing your throttling attempts.</em></p>
<p>I have seen posted elsewhere that ideally you should be tracking all failed login attempts across the site and associating them to a timestamp, perhaps:</p>
<pre><code>CREATE TABLE failed_logins (
    id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(16) NOT NULL,
    ip_address INT(11) UNSIGNED NOT NULL,
    attempted DATETIME NOT NULL,
    INDEX `attempted_idx` (`attempted`)
) engine=InnoDB charset=UTF8;
</code></pre>
<p>A quick note on the ip_address field: You can store the data and retrieve the data, respectively, with INET_ATON() and INET_NTOA() which essentially equate to converting an ip address to and from an unsigned integer.</p>
<pre><code># example of insertion
INSERT INTO failed_logins SET username = 'example', ip_address = INET_ATON('192.168.0.1'), attempted = CURRENT_TIMESTAMP;
# example of selection
SELECT id, username, INET_NTOA(ip_address) AS ip_address, attempted;
</code></pre>
<p>Decide on certain delay thresholds based on the <em>overall</em> number of failed logins in a given amount of time (15 minutes in this example).  You should base this on statistical data pulled from your <code>failed_logins</code> table as it will <em>change over time</em> based on the number of users and how many of them can recall (and type) their password.</p>
<hr/>
<pre><code>&gt; 10 failed attempts = 1 second
&gt; 20 failed attempts = 2 seconds
&gt; 30 failed attempts = reCaptcha
</code></pre>
<hr/>
<p>Query the table on every failed login attempt to find the number of failed logins for a given period of time, say 15 minutes:</p>
<hr/>
<pre><code>SELECT COUNT(1) AS failed FROM failed_logins WHERE attempted &gt; DATE_SUB(NOW(), INTERVAL 15 minute);
</code></pre>
<hr/>
<p>If the number of attempts over the given period of time is over your limit, either enforce throttling or force all user's to use a captcha (i.e. reCaptcha) until the number of failed attempts over the given time period is less than the threshold.      </p>
<pre><code>// array of throttling
$throttle = array(10 =&gt; 1, 20 =&gt; 2, 30 =&gt; 'recaptcha');

// retrieve the latest failed login attempts
$sql = 'SELECT MAX(attempted) AS attempted FROM failed_logins';
$result = mysql_query($sql);
if (mysql_affected_rows($result) &gt; 0) {
    $row = mysql_fetch_assoc($result);

    $latest_attempt = (int) date('U', strtotime($row['attempted']));

    // get the number of failed attempts
    $sql = 'SELECT COUNT(1) AS failed FROM failed_logins WHERE attempted &gt; DATE_SUB(NOW(), INTERVAL 15 minute)';
    $result = mysql_query($sql);
    if (mysql_affected_rows($result) &gt; 0) {
        // get the returned row
        $row = mysql_fetch_assoc($result);
        $failed_attempts = (int) $row['failed'];

        // assume the number of failed attempts was stored in $failed_attempts
        krsort($throttle);
        foreach ($throttle as $attempts =&gt; $delay) {
            if ($failed_attempts &gt; $attempts) {
                // we need to throttle based on delay
                if (is_numeric($delay)) {
                    $remaining_delay = time() - $latest_attempt - $delay;
                    // output remaining delay
                    echo 'You must wait ' . $remaining_delay . ' seconds before your next login attempt';
                } else {
                    // code to display recaptcha on login form goes here
                }
                break;
            }
        }        
    }
}
</code></pre>
<p>Using reCaptcha at a certain threshold would ensure that an attack from multiple fronts would be stopped and normal site users would not experience a significant delay for legitimate failed login attempts.</p>
</div></text><author><a href="/users/185882/corey-ballou">Corey Ballou</a></author><comments><comment><text><span class="comment-copy">This is a good point, I was thinking of this actually since I have seen software that can attempy logins on myspace with email/password files of 100,000 logins and another password of IP address to use, then it could alternate the IP for each request somehow so this would stop things like that I think</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">It's good to note that the throttle times should be low enough to not annoy normal users but long enough to deter bots from repeatedly firing cURL requests.  A user won't even notice a 2 second delay as their next login attempt will likely exceed 2 seconds since the previous attempt.  A bot, on the other hand, will be affected greatly by having to wait 2 seconds before another attempt.  Script kiddies will likely go elsewhere since a small delay will <i>greatly</i> reduce the number of overall requests they can make.</span></text><author><a class="comment-user" href="/users/185882/corey-ballou" title="23,902 reputation">Corey Ballou</a></author></comment><comment><text><span class="comment-copy">I like the idea. Maybe you could have a look at this post: <a href="http://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure" title="what is the best distributed brute force countermeasure">stackoverflow.com/questions/479233/…</a>  It discusses exactly the same issue (distributed brute force) and it would be nice if you could post your idea in detail there as well</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">I think that "$remaining_delay = time() - $latest_attempt - $delay;" is wrong.  Shouldn't it be this instead?:  "$remaining_delay = $delay - (time() - $latest_attempt);"</span></text><author><a class="comment-user" href="/users/1112241/curt" title="556 reputation">Curt</a></author></comment><comment><text><span class="comment-copy">I created a class based off your concept laid out in this comment with some improvements called BruteForceBlocker for anyone who wants to use it <a href="https://github.com/ejfrancis/BruteForceBlocker" rel="nofollow noreferrer">github.com/ejfrancis/BruteForceBlocker</a></span></text><author><a class="comment-user" href="/users/1916501/ejfrancis" title="1,264 reputation">ejfrancis</a></author></comment><comment><text><span class="comment-copy">I've got a question. Would it be OK if I block the IP address of the username? For example, if IP address AND username had been attempted 10 times, then block the IP address from trying that username. But, the real user can log in normally with their username because their IP address is different. Is this method OK, or should I integrate it with the above answer?</span></text><author><a class="comment-user" href="/users/1869726/martynogea" title="154 reputation">Martynogea</a></author></comment><comment><text><span class="comment-copy">I'm curious why the <code>id</code> column is necessary in the <code>failed_logins</code> table? Assuming you empty the table routinely that is. But perhaps there's another reason? Thanks for the excellent answer by the way.</span></text><author><a class="comment-user" href="/users/993623/kosta-kontos" title="1,553 reputation">Kosta Kontos</a></author></comment><comment><text><span class="comment-copy">You know... I stumbled on this question and answer, and it doesn't have anything to do with what I'm working on.  But your answer is fantastic.  I hadn't thought to take that approach and will be using it on future projects.</span></text><author><a class="comment-user" href="/users/1707086/mike" title="1,444 reputation">Mike</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You have three basic approaches: store session information, store cookie information or store IP information.</p>
<p>If you use session information the end user (attacker) could forcibly invoke new sessions, bypass your tactic, and then login again with no delay.  Sessions are pretty simple to implement, simply store the last known login time of the user in a session variable, match it against the current time, and make sure the delay has been long enough.</p>
<p>If you use cookies, the attacker can simply reject the cookies, all in all, this really isn't something viable.</p>
<p>If you track IP addresses you'll need to store login attempts from an IP address somehow, preferably in a database.  When a user attempts to log on, simply update your recorded list of IPs.  You should purge this table at a reasonable interval, dumping IP addresses that haven't been active in some time.  The pitfall (there's always a pitfall), is that some users may end up sharing an IP address, and in boundary conditions your delays may affect users inadvertantly.  Since you're tracking failed logins, and only failed logins, this shouldn't cause too much pain.</p>
</div></text><author><a href="/users/21441/mark-elliot">Mark Elliot</a></author><comments><comment><text><span class="comment-copy">IP addresses are not a good solution: 1) they are often shared 2) its easy to keep changing the address using TOR</span></text><author><a class="comment-user" href="/users/223992/symcbean" title="35,653 reputation">symcbean</a></author></comment><comment><text><span class="comment-copy">@symcbean I've addressed multiple solutions, any combination of which will thwart some attackers, there's no magical solution. That IP adresses are shared is less of an issue, as I discuss in my answer; that someone may change it using TOR seems less likely than someone forcing new sessions. Is there a 4th option I've missed?</span></text><author><a class="comment-user" href="/users/21441/mark-elliot" title="48,597 reputation">Mark Elliot</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<pre><code>session_start();
$_SESSION['hit'] += 1; // Only Increase on Failed Attempts
$delays = array(1=&gt;0, 2=&gt;2, 3=&gt;4, 4=&gt;8, 5=&gt;16); // Array of # of Attempts =&gt; Secs

sleep($delays[$_SESSION['hit']]); // Sleep for that Duration.
</code></pre>
<p>or as suggested by Cyro:</p>
<pre><code>sleep(2 ^ (intval($_SESSION['hit']) - 1));
</code></pre>
<p>It's a bit rough, but the basic components are there. If you refresh this page, each time you refresh the delay will get longer.</p>
<p>You could also keep the counts in a database, where you check the number of failed attempts by IP. By using it based on IP and keeping the data on your side, you prevent the user from being able to clear their cookies to stop the delay.</p>
<p>Basically, the beginning code would be:</p>
<pre><code>$count = get_attempts(); // Get the Number of Attempts

sleep(2 ^ (intval($count) - 1));

function get_attempts()
{
    $result = mysql_query("SELECT FROM TABLE WHERE IP=\"".$_SERVER['REMOTE_ADDR']."\"");
    if(mysql_num_rows($result) &gt; 0)
    {
        $array = mysql_fetch_assoc($array);
        return $array['Hits'];
    }
    else
    {
        return 0;
    }
}
</code></pre>
</div></text><author><a href="/users/58088/tyler-carter">Tyler Carter</a></author><comments><comment><text><span class="comment-copy">You can also use: sleep(2 ^ (intval($_SESSION['hit']) - 1));</span></text><author><a class="comment-user" href="/users/169006/nortron" title="3,465 reputation">nortron</a></author></comment><comment><text><span class="comment-copy">The obvious problem being that a serious brute force attacker wouldn't bother to actually handle cookies, so the session becomes worthless.</span></text><author><a class="comment-user" href="/users/476/deceze" title="324,016 reputation">deceze<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">sleep(2 ^ (intval($count) - 1));  I kind of like the array so I can set the amount of time to wait but I am curious, how does this equate?  Also if I were to save to DB, once a user log's in would I delete there hits from the DB so it is a fresh start when they try to login next time after being logged in?</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">You would set an expire time, as the delay should expire after a certain amount of time. Anything else is up to you. If someone logs in/out and tries to log back in, you might or might not want to keep their past delay timer. Thats your call.</span></text><author><a class="comment-user" href="/users/58088/tyler-carter" title="42,111 reputation">Tyler Carter</a></author></comment><comment><text><span class="comment-copy">Also remember that Cryo's answer doesn't use the array.</span></text><author><a class="comment-user" href="/users/58088/tyler-carter" title="42,111 reputation">Tyler Carter</a></author></comment><comment><text><span class="comment-copy">-1 because anyone trying to do this wouldn't enable cookies for their bot.</span></text><author><a class="comment-user" href="/users/296308/lotus-notes" title="3,917 reputation">Lotus Notes</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Store fail attempts in the database by IP. (Since you have a login system, I assume you know well how to do this.)</p>
<p>Obviously, sessions is a tempting method, but someone really dedicated can quite easily realize that they can simply delete their session cookie on failed attempts in order to circumvent the throttle entirely.</p>
<p>On attempt to log in, fetch how many recent (say, last 15 minutes) login attempts there were, and the time of the latest attempt.</p>
<pre><code>$failed_attempts = 3; // for example
$latest_attempt = 1263874972; // again, for example
$delay_in_seconds = pow(2, $failed_attempts); // that's 2 to the $failed_attempts power
$remaining_delay = time() - $latest_attempt - $delay_in_seconds;
if($remaining_delay &gt; 0) {
    echo "Wait $remaining_delay more seconds, silly!";
}
</code></pre>
</div></text><author><a href="/users/107415/matchu">Matchu</a></author><comments><comment><text><span class="comment-copy">Database is definitely the way to do it. That way you also have a history to look back at as well.</span></text><author><a class="comment-user" href="/users/285/sestocker" title="2,225 reputation">sestocker</a></author></comment><comment><text><span class="comment-copy">I was thinking of something like this, I think vbulletin forums do something like this, session could be reset by closing the browser and coming back as well I think</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">Can you explain what kind of time this creates pow(2, $failed_attempts) ?</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">I wouldn't suggest that you use sleep, since it would block that instance of PHP until the sleep finishes. If the attacker would open up a bunch of connections to bruteforce the server, it would very quickly backup with PHP requests. It would be better to fail all login attempts during the "delay" time period for that IP.</span></text><author><a class="comment-user" href="/users/188044/kendall-hopkins" title="21,316 reputation">Kendall Hopkins</a></author></comment><comment><text><span class="comment-copy">See the PHP docs for pow() - it returns 2 to the power of $failed_attempts :)</span></text><author><a class="comment-user" href="/users/107415/matchu" title="55,337 reputation">Matchu</a></author></comment><comment><text><span class="comment-copy">@SoftwareElves I think that is how the vbulletin forums work, if you fail login and try again too soon, they will print to screen a message saying try again in X amount of seconds</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">Yeah, I misinterpreted the "delay" concept. Edits coming in...</span></text><author><a class="comment-user" href="/users/107415/matchu" title="55,337 reputation">Matchu</a></author></comment><comment><text><span class="comment-copy">I would cap <code>$remaining_delay = min(3600, $remaining_delay);</code>.</span></text><author><a class="comment-user" href="/users/89771/alix-axel" title="93,655 reputation">Alix Axel</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The login process needs reduce its speed for both successful and unsuccessful login.  The login attempt itself should never be faster than about 1 second.  If it is, brute force uses the delay to know that the attempt failed because success is shorter than failure.  Then, more combinations can be evaluated per second.  </p>
<p>The number of simultaneous login attempts per machine needs to be limited by the load balancer.  Finally, you just need to track if the same user or password is re-used by more than one user/password login attempt.  Humans cannot type faster than about 200 words per minite.  So, successive or simultaneous login attempts faster than 200 words per minite are from a set of machines.  These can thus be piped to a black list safely as it is not your customer.  Black list times per host do not need to be greater than about 1 second.  This will never inconvenience a human, but plays havoc with a brute force attempt whether in serial or parallel.</p>
<p>2 * 10^19 combinations at one combination per second, run in parallel on 4 billion separate IP addresses, will take 158 years to exhaust as a search space.   To last one day per user against 4 billion attackers, you need a fully random alphanumeric password 9 places long at a minimum.  Consider training users in pass phrases at least 13 places long, 1.7 * 10^20 combinations.</p>
<p>This delay, will motivate the attacker to steal your password hash file rather than brute force your site. Use approved, named, hashing techniques.  Banning the entire population of Internet IP for one second, will limit the effect of parallel attacks without a dealy a human would appreciate.  Finally, if your system allows more than 1000 failed logon attempts in one second without some response to ban systems, then your security plans have bigger problems to work on.  Fix that automated response first of all.</p>
</div></text><author><a href="/users/1874139/don-turnblade">Don Turnblade</a></author><comments><comment><text><span class="comment-copy">Some fascinating insights, thanks. +1 for <code>The login attempt itself should never be faster than about 1 second. If it is, brute force uses the delay to know that the attempt failed because success is shorter than failure.</code></span></text><author><a class="comment-user" href="/users/993623/kosta-kontos" title="1,553 reputation">Kosta Kontos</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use sessions. Anytime the user fails a login, you increase the value storing the number of attempts. You can figure the required delay from the number of attempts, or you can set the actual time the user is allowed to try again in the session as well.</p>
<p>A more reliable method would be to store the attempts and new-try-time in the database for that particular ipaddress.</p>
</div></text><author><a href="/users/54680/sampson">Sampson</a></author><comments><comment><text><span class="comment-copy">I currently do something like this but I was thinking if there was a DoS attack I wasn't sure if a bot or anything would still work with sessions but I guess it would have to work</span></text><author><a class="comment-user owner" href="/users/143030/jasondavis" title="18,570 reputation">JasonDavis</a></author></comment><comment><text><span class="comment-copy">The bot can easily choose to ignore the session cookie. Use database with IP and the bot can't do nothin' about it besides switching IP.</span></text><author><a class="comment-user" href="/users/107415/matchu" title="55,337 reputation">Matchu</a></author></comment><comment><text><span class="comment-copy">@Matchu - if you do this, you risk making thousands or millions of unnecessary DB calls and taxing your resources in other ways. I believe there are combined solutions which work better than your suggestion.</span></text><author><a class="comment-user" href="/users/337690/jm4" title="3,145 reputation">JM4</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I generally create login history and login attempt tables. The attempt table would log username, password, ip address, etc. Query against the table to see if you need to delay. I would recommend blocking completely for attempts greater than 20 in a given time (an hour for example).</p>
</div></text><author><a href="/users/285/sestocker">sestocker</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As per discussion above, sessions, cookies and IP addresses are not effective - all can be manipulated by the attacker.</p>
<p>If you want to prevent brute force attacks then the only practical solution is to base the number of attempts on the username provided, however note that this allows the attacker to DOS the site by blocking valid users from logging in.</p>
<p>e.g.</p>
<pre><code>$valid=check_auth($_POST['USERNAME'],$_POST['PASSWD']);
$delay=get_delay($_POST['USERNAME'],$valid);

if (!$valid) {
   header("Location: login.php");
   exit;
}
...
function get_delay($username,$authenticated)
{
    $loginfile=SOME_BASE_DIR . md5($username);
    if (@filemtime($loginfile)&lt;time()-8600) {
       // last login was never or over a day ago
       return 0;
    }
    $attempts=(integer)file_get_contents($loginfile);
    $delay=$attempts ? pow(2,$attempts) : 0;
    $next_value=$authenticated ? 0 : $attempts + 1;
    file_put_contents($loginfile, $next_value);
    sleep($delay); // NB this is done regardless if passwd valid
    // you might want to put in your own garbage collection here
 }
</code></pre>
<p>Note that as written, this procedure leaks security information - i.e. it will be possible for someone attacking the system to see when a user logs in (the response time for the attackers attempt will drop to 0). You might also tune the algorithm so that the delay is calculated based on the previous delay and the timestamp on the file.</p>
<p>HTH</p>
<p>C.</p>
</div></text><author><a href="/users/223992/symcbean">symcbean</a></author><comments><comment><text><span class="comment-copy">a more practical approach is to log all failed logins and see if the number of failed attempts in the last ~10 minutes if troublesome, otherwise an attacker could just keep alternating usernames. I wrote a class that does this for you <a href="https://github.com/ejfrancis/BruteForceBlocker" rel="nofollow noreferrer">github.com/ejfrancis/BruteForceBlocker</a></span></text><author><a class="comment-user" href="/users/1916501/ejfrancis" title="1,264 reputation">ejfrancis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>IMHO, defense against DOS attacks is better dealt with at the web server level (or maybe even in the network hardware), not in your PHP code.</p>
</div></text><author><a href="/users/212215/vicatcu">vicatcu</a></author><comments><comment><text><span class="comment-copy">True, but sometimes you must fight with the stick you have in your hand.</span></text><author><a class="comment-user" href="/users/99923/xeoncross" title="22,901 reputation">Xeoncross</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Cookies or session-based methods are of course useless in this case. The application has to check the IP address or timestamps (or both) of previous login attempts.</p>
<p>An IP check can be bypassed if the attacker has more than one IP to start his/her requests from and can be troublesome if multiple users connect to your server from the same IP. In the latter case, someone failing login for several times would prevent everyone who shares the same IP from logging in with that username for a certain period of time.</p>
<p>A timestamp check has the same problem as above: everyone can prevent everyone else from logging in a particular account just by trying multiple times. Using a captcha instead of a long wait for the last attempt is probably a good workaround.</p>
<p>The only extra things the login system should prevent are race conditions on the attempt checking function. For example, in the following pseudocode</p>
<pre><code>$time = get_latest_attempt_timestamp($username);
$attempts = get_latest_attempt_number($username);

if (is_valid_request($time, $attempts)) {
    do_login($username, $password);
} else {
    increment_attempt_number($username);
    display_error($attempts);
}
</code></pre>
<p>What happens if an attacker sends <em>simultaneous</em> requests to the login page? Probably all the requests would run at the same priority, and chances are that no request gets to the increment_attempt_number instruction before the others are past the 2nd line. So every request gets the same $time and $attempts value and is executed. Preventing this kind of security issues can be difficult for complex applications and involves locking and unlocking some tables/rows of the database, of course slowing the application down.</p>
</div></text><author><a>NONE</a></author><comments><comment><text><span class="comment-copy">Standard applications run on VPS or share hosts can only handle about 5-30 requests per second. So your method does work, but it is possible 30 attempts might make it before you can block them. Also check your apache logs for stuff like this (post requests especially).</span></text><author><a class="comment-user" href="/users/99923/xeoncross" title="22,901 reputation">Xeoncross</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The short answer is: Do not do this. You will not protect yourself from brute forcing, you could even make your situation worse.</p>
<p>None of the proposed solutions would work. If you use the IP as any parameter for throttling, the attacker will just span the attack across a huge number of IPs. If you use the session(cookie), the attacker will just drop any cookies. The sum of all you can think of is, that there is absolutely nothing a brute forcing attacker could not overcome.</p>
<p>There is one thing, though - you just rely on the username that tried to log in. So, not looking at all the other parameters you track how often a user tried to log in and throttle. But an attacker wants to harm you. If he recognizes this, he will just also brute force user names.</p>
<p>This will result in almost all of your users being throttled to your maximum value when they try to log in. Your website will be useless. Attacker: success.</p>
<p>You could delay the password check in general for around 200ms - the website user will almost not notice that. But a brute-forcer will. (Again he could span across IPs) However, nothing of all this will protect you from brute forcing or DDoS - as you can not programatically.</p>
<p>The only way to do this is using the infrastructure.</p>
<p>You should use bcrypt instead of MD5 or SHA-x to hash your passwords, this will make decrypting your passwords a LOT harder if someone steals your database (because I guess you are on a shared or managed host)</p>
<p>Sorry for disappointing you, but all the solutions here have a weakness and there is no way to overcome them inside the back-end logic.</p>
</div></text><author><a href="/users/857958/nico-gawenda">nico gawenda</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>cballuo provided an excellent answer. I just wanted to return the favor by providing an updated version that supports mysqli. I slightly changed up the table/field columns in the sqls and other small things but it should help anyone looking for the mysqli equivalent.</p>
<pre><code>function get_multiple_rows($result) {
  $rows = array();
  while($row = $result-&gt;fetch_assoc()) {
    $rows[] = $row;
  }
  return $rows;
}

$throttle = array(10 =&gt; 1, 20 =&gt; 2, 30 =&gt; 5);

$query = "SELECT MAX(time) AS attempted FROM failed_logins";    

if ($result = $mysqli-&gt;query($query)) {

    $rows = get_multiple_rows($result);

$result-&gt;free();

$latest_attempt = (int) date('U', strtotime($rows[0]['attempted'])); 

$query = "SELECT COUNT(1) AS failed FROM failed_logins WHERE time &gt; DATE_SUB(NOW(), 
INTERVAL 15 minute)";   

if ($result = $mysqli-&gt;query($query)) {

$rows = get_multiple_rows($result);

$result-&gt;free();

    $failed_attempts = (int) $rows[0]['failed'];

    krsort($throttle);
    foreach ($throttle as $attempts =&gt; $delay) {
        if ($failed_attempts &gt; $attempts) {
                echo $failed_attempts;
                $remaining_delay = (time() - $latest_attempt) - $delay;

                if ($remaining_delay &lt; 0) {
                echo 'You must wait ' . abs($remaining_delay) . ' seconds before your next login attempt';
                }                

            break;
        }
     }        
  }
}
</code></pre>
</div></text><author><a href="/users/1509401/jason328">jason328</a></author><comments><comment><text><span class="comment-copy">I wrote a more recent version, made into a class and using PDO <a href="https://github.com/ejfrancis/BruteForceBlocker" rel="nofollow noreferrer">github.com/ejfrancis/BruteForceBlocker</a></span></text><author><a class="comment-user" href="/users/1916501/ejfrancis" title="1,264 reputation">ejfrancis</a></author></comment></comments></answer></answers></post>