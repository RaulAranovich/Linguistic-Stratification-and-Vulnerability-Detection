<?xml version="1.0" encoding="utf-8"?>
<post><title>Exposing database IDs - security risk? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I've heard that exposing database IDs (in URLs, for example) is a security risk, but I'm having trouble understanding why.</p>
<p>Any opinions or links on why it's a risk, or why it isn't?</p>
<p>EDIT: of course the access is scoped, e.g. if you can't see resource <code>foo?id=123</code> you'll get an error page. Otherwise the URL itself should be secret.</p>
<p>EDIT: if the URL is secret, it will probably contain a generated token that has a limited lifetime, e.g. valid for 1 hour and can only be used once.</p>
<p>EDIT (months later): my current preferred practice for this is to use UUIDS for IDs and expose them. If I'm using sequential numbers (usually for performance on some DBs) as IDs I like generating a UUID token for each entry as an alternate key, and expose that.</p>
</div></text><author><a href="/users/37020/orip">orip</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Given the proper conditions, exposing identifiers is not a security risk. And, in practice, it would be extremely burdensome to design a web application without exposing identifiers.</p>
<p>Here are some good rules to follow:</p>
<ol>
<li>Use role-based security to control access to an operation. How this is done depends on the platform and framework you've chosen, but many support a declarative security model that will automatically redirect browsers to an authentication step when an action requires some authority.</li>
<li>Use programmatic security to control access to an object. This is harder to do at a framework level. More often, it is something you have to write into your code and is therefore more error prone. This check goes beyond role-based checking by ensuring not only that the user has authority for the operation, but also has necessary rights on the specific object being modified. In a role-based system, it's easy to check that only managers can give raises, but beyond that, you need to make sure that the employee belongs to the particular manager's department.</li>
<li>For most database records, conditions 1 and 2 are sufficient. But adding unpredictable IDs can be thought of as a little extra insurance, or "security in depth," if you buy into that notion. One place where unpredictable identifiers is a necessity, however, is in session IDs or other authentication tokens, where the ID itself authenticates a request. These should be generated by a cryptographic RNG.</li>
</ol>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">IMO, adding unpredictable IDs is a "security through obscurity" approach and can lead to a false sense of security. It's better to focus on (1) and (2) and make sure your access control is solid.</span></text><author><a class="comment-user" href="/users/21379/stucampbell" title="2,578 reputation">stucampbell</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It depends on what the IDs stand for.</p>
<p>Consider a site that for competitive reason don't want to make public how many members they have but by using sequential IDs reveals it anyway in the URL: <a href="http://some.domain.name/user?id=3933" rel="noreferrer">http://some.domain.name/user?id=3933</a></p>
<p>On the other hand, if they used the login name of the user instead: <a href="http://some.domain.name/user?id=some" rel="noreferrer">http://some.domain.name/user?id=some</a> they haven't disclosed anything the user didn't already know.</p>
</div></text><author><a href="/users/36866/some">some</a></author><comments><comment><text><span class="comment-copy">if you're using sequential IDs you're right, but if not then that doesn't expose anything</span></text><author><a class="comment-user owner" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">@orip: Like I said, it depends on what someone can discover by examining several id's. Is there a pattern? Can they use that information to gain information they are not intended to have?</span></text><author><a class="comment-user" href="/users/36866/some" title="29,236 reputation">some</a></author></comment><comment><text><span class="comment-copy">@John: Thanks for the edit. English isn't my native language :)</span></text><author><a class="comment-user" href="/users/36866/some" title="29,236 reputation">some</a></author></comment><comment><text><span class="comment-copy">I've done exactly this: used sequential ID numbers to determine the size of a competitor's userbase.</span></text><author><a class="comment-user" href="/users/19964/micah" title="8,769 reputation">Micah</a></author></comment><comment><text><span class="comment-copy">They are everywhere. Many shoppingsites use a sequential number for the order id. Place one order at one date, and one at another date and you know how many orders they got during that period. Even if you don't know how much money the orders are worth, you still get an indication of how the well the business goes.</span></text><author><a class="comment-user" href="/users/36866/some" title="29,236 reputation">some</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The general thought goes along these lines: "Disclose as little information about the inner workings of your app to anyone."</p>
<p>Exposing the database ID counts as disclosing some information.</p>
<p>Reasons for this is that hackers can use any information about your apps inner workings to attack you, or a user can change the URL to get into a database he/she isn't suppose to see?</p>
</div></text><author><a href="/users/19594/arjan-einbu">Arjan Einbu</a></author><comments><comment><text><span class="comment-copy">Accessing resources they aren't supposed to see - only if I don't check permissions (which I do, otherwise I have a different security problem). Disclosing information about the "inner workings" - that's exactly my question. Why is it a problem?</span></text><author><a class="comment-user owner" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">@orip:  It's all about being as secure as possible.  If you are the kind of programmer who doesn't make mistakes, then it's not an issue.  Otherwise, exposing fewer details makes it more difficult to exploit your code if (when) you do make mistakes.  By itself, you're right, it doesn't add security.</span></text><author><a class="comment-user" href="/users/21632/adam-bellaire" title="65,074 reputation">Adam Bellaire</a></author></comment><comment><text><span class="comment-copy">@Adam: superficial security can be worse than no security. With no security you're explicit, with superficial security you could think it adds something non-neglible.</span></text><author><a class="comment-user owner" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>We use GUIDs for database ids. Leaking them is a lot less dangerous.</p>
</div></text><author><a href="/users/14768/joshua">Joshua</a></author><comments><comment><text><span class="comment-copy">This is what I would suggest. Lot less likely to guess the GUIDs in your database.</span></text><author><a class="comment-user" href="/users/1950/jon-erickson" title="57,887 reputation">Jon Erickson</a></author></comment><comment><text><span class="comment-copy">This comes at a performance penalty. See <a href="http://kccoder.com/mysql/uuid-vs-int-insert-performance/" rel="nofollow noreferrer">here</a></span></text><author><a class="comment-user" href="/users/473637/jeshurun" title="14,747 reputation">Jeshurun</a></author></comment><comment><text><span class="comment-copy">Interesting thing 1 about using guids is that you can let clients generate database ids.  Interesting thing 2 is that they have no problem with sharded databases the way auto incrementing ids do.</span></text><author><a class="comment-user" href="/users/1695398/brian-white" title="1,116 reputation">Brian White</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you are using integer IDs in your db, you may make it easy for users to see data they shouldn't by changing qs variables. </p>
<p>E.g.  a user could easily change the id parameter in this qs and see/modify data they shouldn't <a href="http://someurl?id=1" rel="nofollow noreferrer">http://someurl?id=1</a></p>
</div></text><author><a href="/users/10639/jason">Jason</a></author><comments><comment><text><span class="comment-copy">If I don't check permissions I have a different security problem.</span></text><author><a class="comment-user owner" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">but the answer is accurate: "may"</span></text><author><a class="comment-user" href="/users/6475/seun-osewa" title="3,850 reputation">Seun Osewa</a></author></comment><comment><text><span class="comment-copy">The question isn't if you will check permissions.  It's if the new hire you don't know will check permissions.</span></text><author><a class="comment-user" href="/users/1695398/brian-white" title="1,116 reputation">Brian White</a></author></comment><comment><text><span class="comment-copy">@BrianWhite - which is why you want a code review process in place, so that you can educate them before it hits production.</span></text><author><a class="comment-user" href="/users/2113342/candu" title="1,468 reputation">candu</a></author></comment><comment><text><span class="comment-copy">Sure.  Most places have a code review policy in place.  And simultaneously, security issues abound on the web.  SQL injection is one of the most common despite all the education</span></text><author><a class="comment-user" href="/users/1695398/brian-white" title="1,116 reputation">Brian White</a></author></comment><comment><text><span class="comment-copy">What we do is encrypt the integer ids when used in the URL or form variables.</span></text><author><a class="comment-user" href="/users/1695398/brian-white" title="1,116 reputation">Brian White</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>When you send database id's to your client you are <em>forced</em> to check security in both cases. If you keep the id's in your web session you can choose if you want/need to do it, meaning potentially less processing.</p>
<p>You are constantly trying to delegate things to your access control ;)  This <em>may</em> be the case in your application but I have never seen such a consistent back-end system in my entire career. Most of them have security models that were designed for non-web usage and some have had additional roles added posthumously, and some of these have been bolted on outside of the core security model (because the role was added in a different operational context, say before the web). </p>
<p>So we use synthetic session local id's because it hides as much as we can get away with.</p>
<p>There is also the issue of non-integer key fields, which may be the case for enumerated values and similar. You can try to sanitize that data, but chances are you'll end up like <a href="http://xkcd.com/327" rel="nofollow noreferrer">little bobby drop tables</a>. </p>
</div></text><author><a href="/users/23691/krosenvold">krosenvold</a></author><comments><comment><text><span class="comment-copy">Interesting, though I would think that checking all input (including URL parameters) for every request is very appropriate for the web.</span></text><author><a class="comment-user owner" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment></comments></answer></answers></post>