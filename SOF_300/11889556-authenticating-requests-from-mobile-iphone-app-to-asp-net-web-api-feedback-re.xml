<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Authenticating requests from mobile (iPhone) app to ASP.Net Web API (Feedback requested on my design) - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm designing a web site that will have a mobile companion (initally iPhone only). The web site will be an ASP.Net MVC 3 application. I'll also have an ASP.Net Web API site (MVC 4) to expose services to the iPhone application. The iPhone app will have its own form to capture username and password from the user and send that to the web API in JSON headers.</p>
<p>I want to consider security from the start rather than an after thought. <em>I'm not a security expert by any means.</em> I've done a good deal of research to see how other's are handling authentication of a mobile application client from a web service. I think I've come up with a decent solution that doesn't involve hooking into to third party oAuths.</p>
<p>I would greatly appreciate any and all opinions, advice, criticism and general WTFs that any of you can offer. :)</p>
<p>My biggest concerns are:</p>
<ol>
<li>Ensuring that calls made to the web API are authorized</li>
<li>Minimizing the risk of replay attacks (hence timestamps in the calls below)</li>
</ol>
<p>The iPhone app will be developed as such:<br/>
<em>Two strings are hard-coded into the iPhone app (same values for every user):</em></p>
<ol>
<li><b>Application ID</b><br/>This is a string that is used to identify the type of client that is accessing the web API (iPhone, Android, Windows phone, etc).</li><br/>
<li><b>Application's Hashing Salt</b><br/>This is a string that is used to salt hashes for user-agnostic requests.</li>
</ol>
<p><em>Two strings are stored in the iPhone app's local database (values unique to each user):</em></p>
<ol>
<li><b>API User Access Token</b><br/>This is a string (token) provided to the client by the web API upon successful authentication and allows the client to access the web API without sending the username and password in each request.<br/></li>
<li><b>User's Hashing Salt</b><br/>This is a string that is used to salt hashes for requests made against established user accounts.</li>
</ol>
<p><br/>
<br/>
The iPhone will make calls to the web API in the following manner:<br/><br/>
<b>API Method: Create Account</b><br/>
Client Sends:</p>
<ul>
<li>New Account Data (Username, Password, First Name, Last Name, etc..)</li>
<li>Application ID</li>
<li>UTC Timestamp</li>
<li>Hash of UTC Timestamp + Application ID salted with Application's Hashing Salt</li>
</ul>
<p>API Returns:</p>
<ul>
<li>New User's Hashing Salt<br/><br/>The idea here is that, when creating an account, I can use the application's hardcoded salt since it's not a huge security risk if that salt ever got out (through decompilation or some other means).<br/><br/>
But for methods that access and modify the user's data I'll use a salt that is owned only by that user so it can't be used by an attacker to impersonate others.</li>
</ul>
<p><br/>
<b>API Method: Get Account</b><br/>(Used for getting user's hashing salt for accounts that were created on the web site but haven't yet been synced on the iPhone. This happens when a user tries to log in on the iPhone and iPhone detects that it has no record for that username.)<br/>
<br/>
Client Sends:</p>
<ul>
<li>Username</li>
<li>Password (hashed with Application's Hashing Salt)</li>
<li>Application ID</li>
<li>UTC Timestamp</li>
<li>Hash of UTC Timestamp + Application ID salted with Application's Hashing Salt</li>
</ul>
<p>API Returns:</p>
<ul>
<li>Existing User's Hashing Salt</li>
</ul>
<p><br/>
<b>API Method: Log In (Authenticate)</b><br/>
Client Sends:</p>
<ul>
<li>Username</li>
<li>Password (hashed with User's Hashing Salt)</li>
<li>Application ID</li>
<li>UTC Timestamp</li>
<li>Hash of UTC Timestamp + Application ID salted with User's Hashing Salt</li>
</ul>
<p>API Returns:</p>
<ul>
<li>API User Access Token</li>
</ul>
<p><br/>
<b>API Method: Any Command (i.e. Create Post, Update Profile, Get Messages, etc...)</b><br/>
Client Sends:</p>
<ul>
<li>Command Data</li>
<li>API User Access Token</li>
<li>Application ID</li>
<li>UTC Timestamp</li>
<li>Hash of UTC Timestamp + Application ID + API User Access Token salted with User's Hashing Salt</li>
</ul>
</div></text><author><a href="/users/1521661/stoop">Stoop</a></author><comments><comment><text><span class="comment-copy">Your question is helpful to me Joe, as I'm trying to do something similar. I have a question though - when a user creates an account, you're sending the username and password without hashing them. Seems OK since it's just once. But if the phone tries to login to an account that's already created, you hash their username and password with the app salt. Is this really THAT much better than sending it unhashed again? I mean, I know it's a bit better, but sending unhashed info twice isn't much more unsecure than sending it once. Or am I missing something?</span></text><author><a class="comment-user" href="/users/1083648/andrew-b-schultz" title="833 reputation">Andrew B Schultz</a></author></comment><comment><text><span class="comment-copy">@AndrewBSchultz, you're right, and I wound up not encrypting on that first call. Since it's SSL and since that initial call happens only one time, there's a negligible risk of exposure.</span></text><author><a class="comment-user owner" href="/users/1521661/stoop" title="615 reputation">Stoop</a></author></comment><comment><text><span class="comment-copy">Sending "unhashed" info any number of times is insecure.  But the real point is that the entire API is protected with SSL, so all of the transfers are encrypted.  Passing the user's salt from the server to the client is questionable.  What's the point of that, really?  Among other things, it means that you're computing password hashes in multiple places, which makes it very difficult to upgrade your password hashing algorithm when you discover that your existing one is broken (and eventually you will).  Just pass the username and password, protected with SSL, and let the server do the hashing.</span></text><author><a class="comment-user" href="/users/618649/craig" title="3,150 reputation">Craig</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>My suggestions</p>
<ol>
<li>Authentication and Authorization. Build it on 2 different servers(In some projects I have used 3 as well). Reverse proxy servers are really good with this. Authenticate on one server and authorize it on the other.</li>
</ol>
<p>This is the most important step I think that is needed in mobile security that use Web APIs.</p>
<ol>
<li><p>Encapsulate everything.</p></li>
<li><p>Use SSL for all secure information. In my case I use it for everything.</p></li>
<li><p>For your timestamp select a suitable time for which you can have authorization. Do not make this very short as your app will become slow or too long as network sniffers can access the packets.</p></li>
</ol>
<p>If you want a 3 server architecture For your requests have an application key as well that you use to generate a access key (from Server 1). This access key will authenticate your requests which after successful authentication(from server 2) you can use that key to authorize your requests from another server(server 3)</p>
<p>The requests you have mentioned are standard norms. Don't really see a problem with that.</p>
</div></text><author><a href="/users/576369/s-p">S.P.</a></author><comments><comment><text><span class="comment-copy">I had to lookup <a href="http://publib.boulder.ibm.com/infocenter/sametime/v8r5/index.jsp?topic=%2Fcom.ibm.help.sametime.v851.doc%2Fconfig%2Fst_adm_port_rvprxy_overview_c.html" rel="nofollow noreferrer">Reverse Proxy Server</a>. Interesting concept and one that I will explore more.  What do you mean by "Encapsulate everything"?</span></text><author><a class="comment-user owner" href="/users/1521661/stoop" title="615 reputation">Stoop</a></author></comment><comment><text><span class="comment-copy">ASP.Net Web API that you would be creating do NOT expose any thing else than public APIs you have mentioned. We have had quite a few developers giving us a scare.</span></text><author><a class="comment-user" href="/users/576369/s-p" title="2,393 reputation">S.P.</a></author></comment><comment><text><span class="comment-copy">Also in our case we use nginx for reverse proxy. Its very stable and very fast.</span></text><author><a class="comment-user" href="/users/576369/s-p" title="2,393 reputation">S.P.</a></author></comment><comment><text><span class="comment-copy">Thanks for the info. I will research this further regarding reverse proxies.  From your first post, what did you mean when you said Encapsulate Everything? Are you referring to the data (model) that will be sent with the api calls (for example, a Put)? If so, what should that data be encapsulated in?  The messages will be transmitted as JSON.</span></text><author><a class="comment-user owner" href="/users/1521661/stoop" title="615 reputation">Stoop</a></author></comment><comment><text><span class="comment-copy">Yes,encapsulate the Data Model. You need to encrypt the Application ID as well. Yes, JSON is perfect for this.</span></text><author><a class="comment-user" href="/users/576369/s-p" title="2,393 reputation">S.P.</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In VS 2013 you can use the "Asp MVC SPA Application" template to generate a working implementation that is generating a Oauth2 token bearer on login and authorizing it for WebApi controller calls using [Authorize] attributes. It uses Membership and Entity Framework to store users and hashes locally in a SQL Server. Just delete the asp mvc parts you don't need and keep the Auth part for WebApi. More details here: <a href="http://msdnrss.thecoderblogs.com/2013/09/understanding-security-features-in-the-spa-template-for-vs2013-rc/" rel="nofollow">http://msdnrss.thecoderblogs.com/2013/09/understanding-security-features-in-the-spa-template-for-vs2013-rc/</a></p>
</div></text><author><a href="/users/3012979/johan-o">Johan O</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I did it using asp.net mvc 4.0/web api basic membership. you may find it helpful.</p>
<p>Yeah, Use SSL for sure</p>
<p><a href="https://github.com/aamir-poswal/Mobile-Apps-Authentication-Authorization-ASP.NET-WEB-MVC-4.0" rel="nofollow">https://github.com/aamir-poswal/Mobile-Apps-Authentication-Authorization-ASP.NET-WEB-MVC-4.0</a></p>
</div></text><author><a href="/users/739655/aamir-sajjad">aamir sajjad</a></author><comments/></answer></answers></post>