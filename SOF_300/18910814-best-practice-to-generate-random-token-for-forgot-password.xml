<?xml version="1.0" encoding="utf-8"?>
<post><title>php - best practice to generate random token for forgot password - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I want to generate identifier for forgot password . I read i can do it by using timestamp with   mt_rand(), but some people are saying that time stamp might not be unique every time. So i am bit of confused here. Can i do it with using time stamp with this ?</p>
<p><strong>Question</strong><br/>
What's best practice to generate random/unique tokens of custom length?</p>
<p>I know there are lot of questions asked around here but i am getting more confused after reading different opinion from the different people. </p>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments><comment><text><span class="comment-copy">@AlmaDoMundo: A computer can't divide time unlimited.</span></text><author><a class="comment-user" href="/users/575376/juergen-d" title="135,741 reputation">juergen d</a></author></comment><comment><text><span class="comment-copy">@juergend - sorry, do not get that.</span></text><author><a class="comment-user" href="/users/2637490/alma-do" title="28,617 reputation">Alma Do</a></author></comment><comment><text><span class="comment-copy">You will get the same timestamp if you call it for instance a nano second apart. Some time functions for instance can only return time in 100ns steps, some only in seconds step.</span></text><author><a class="comment-user" href="/users/575376/juergen-d" title="135,741 reputation">juergen d</a></author></comment><comment><text><span class="comment-copy">@juergend ah, that. Yes. I mentioned 'classic' timestamp with seconds only. But if act like you've said - yes (that only leaves us an option with time machine to get non-unique timestamp)</span></text><author><a class="comment-user" href="/users/2637490/alma-do" title="28,617 reputation">Alma Do</a></author></comment><comment><text><span class="comment-copy">tried to generate 2 tokens in a second.</span></text><author><a class="comment-user owner" href="/users/2189626/keen" title="1,297 reputation">keen</a></author></comment><comment><text><span class="comment-copy">Head's up, the accepted answer does not leverage a <a href="https://paragonie.com/blog/2015/07/how-safely-generate-random-strings-and-integers-in-php" rel="nofollow noreferrer">CSPRNG</a>.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>In PHP, use <a href="https://secure.php.net/random_bytes" rel="noreferrer"><code>random_bytes()</code></a>. Reason: your are seeking the way to get a password reminder token, and, if it is a one-time login credentials, then you actually have a data to protect (which is - whole user account)</p>
<p>So, the code will be as follows:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">//$length = 78 etc</span><span class="pln">
$token </span><span class="pun">=</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">random_bytes</span><span class="pun">(</span><span class="pln">$length</span><span class="pun">));</span></code></pre>
<hr/>
<p><strong>Update</strong>: <em><a href="http://stackoverflow.com/posts/18910943/revisions#3">previous versions</a> of this answer was referring to <code>uniqid()</code> and that is incorrect if there is a matter of security and not only uniqueness. <code>uniqid()</code> is essentially just <code>microtime()</code> with some encoding. There are simple ways to get accurate predictions of the <code>microtime()</code> on your server. An attacker can issue a password reset request and then try through a couple of likely tokens. This is also possible if more_entropy is used, as the additional entropy is similarly weak. Thanks to <a href="http://stackoverflow.com/users/385378/nikic">@NikiC</a> and <a href="http://stackoverflow.com/users/2224584/scott-arciszewski">@ScottArciszewski</a> for pointing this out.</em></p>
<p>For more details see </p>
<ul>
<li><a href="http://phpsecurity.readthedocs.org/en/latest/Insufficient-Entropy-For-Random-Values.html" rel="noreferrer">http://phpsecurity.readthedocs.org/en/latest/Insufficient-Entropy-For-Random-Values.html</a></li>
</ul>
</div></text><author><a href="/users/2637490/alma-do">Alma Do</a></author><comments><comment><text><span class="comment-copy">Note that <a href="http://php.net/manual/en/function.random-bytes.php" rel="nofollow noreferrer"><code>random_bytes()</code></a> is only available as of PHP7. For older versions, the answer by @yesitsme seems to be the best option.</span></text><author><a class="comment-user" href="/users/212107/gerald-schneider" title="12,187 reputation">Gerald Schneider</a></author></comment><comment><text><span class="comment-copy">@GeraldSchneider or <a href="https://github.com/paragonie/random_compat" rel="nofollow noreferrer">random_compat</a>, which is the polyfill for these features that has received the most peer review ;)</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">I made a varchar(64) field in my sql database to store this token.  I set $length to 64, but the string returned is 128 characters long.  How can I get a string with a fixed size (here, 64 then) ?</span></text><author><a class="comment-user" href="/users/782013/gordie" title="337 reputation">gordie</a></author></comment><comment><text><span class="comment-copy">@gordie Set the length to 32, each byte is 2 hex characters</span></text><author><a class="comment-user" href="/users/1375714/johnhoulderuk" title="368 reputation">JohnHoulderUK</a></author></comment><comment><text><span class="comment-copy">What should be <code>$length</code> ? The id of user? Or what?</span></text><author><a class="comment-user" href="/users/5259594/stack" title="2,475 reputation">stack</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><a href="https://security.stackexchange.com/questions/40310/generating-an-unguesable-token-for-confirmation-e-mails">https://security.stackexchange.com/questions/40310/generating-an-unguesable-token-for-confirmation-e-mails</a></p>
<p>this answers best random</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$token </span><span class="pun">=</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="lit">16</span><span class="pun">));</span></code></pre>
</div></text><author><a href="/users/4535386/yesitsme">yesitsme</a></author><comments><comment><text><span class="comment-copy"><code>openssl_random_pseudo_bytes($length)</code> - support: PHP 5 &gt;= 5.3.0 , .......................................................... (For PHP 7 and up, use <code>random_bytes($length)</code>) .......................................... (For PHP below 5.3 - don't use PHP below 5.3)</span></text><author><a class="comment-user" href="/users/1835470/jave-web" title="4,012 reputation">jave.web</a></author></comment><comment><text><span class="comment-copy">For php 5.3 to php7 use <a href="https://github.com/paragonie/random_compat" rel="nofollow noreferrer">github.com/paragonie/random_compat</a></span></text><author><a class="comment-user" href="/users/119116/dsas" title="1,267 reputation">dsas</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The earlier version of the accepted answer (<code>md5(uniqid(mt_rand(), true))</code>) is insecure and only offers about 2^60 possible outputs -- well within the range of a brute force search in about a week's time for a low-budget attacker:</p>
<ul>
<li><a href="http://www.openwall.com/php_mt_seed"><code>mt_rand()</code> is predictable</a> (and only adds up to 31 bits of entropy)</li>
<li><a href="http://securitymaverick.com/php-uniqid-entropy-analysis-and-potentially-vulnerable-apps"><code>uniqid()</code> only adds up to 29 bits of entropy</a></li>
<li><code>md5()</code> doesn't add entropy, it just mixes it deterministically</li>
</ul>
<p>Since a <a href="https://www.cloudcracker.com/blog/2012/07/29/cracking-ms-chap-v2/">56-bit DES key can be brute-forced in about 24 hours</a>, and an average case would have about 59 bits of entropy, we can calculate 2^59 / 2^56 = about 8 days. Depending on how this token verification is implemented, <a href="https://wingolog.org/archives/2014/12/02/there-are-no-good-constant-time-data-structures">it might be possible to practically leak timing information and infer the first N bytes of a valid reset token</a>.</p>
<p>Since the question is about "best practices" and opens with...</p>
<blockquote>
<p>I want to generate identifier for forgot password</p>
</blockquote>
<p>...we can infer that this token has implicit security requirements. And when you add security requirements to a random number generator, the best practice is to always use a <strong>cryptographically secure pseudorandom number generator</strong> (abbreviated CSPRNG).</p>
<hr/>
<h3>Using a CSPRNG</h3>
<p>In PHP 7, you can use <code>bin2hex(random_bytes($n))</code> (where <code>$n</code> is an integer larger than 15). </p>
<p>In PHP 5, you can use <a href="https://github.com/paragonie/random_compat"><code>random_compat</code></a> to expose the same API. </p>
<p>Alternatively, <code>bin2hex(mcrypt_create_iv($n, MCRYPT_DEV_URANDOM))</code> if you have <code>ext/mcrypt</code> installed. Another good one-liner is <code>bin2hex(openssl_random_pseudo_bytes($n))</code>.</p>
<h3>Separating the Lookup from the Validator</h3>
<p>Pulling from my previous work on <a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2">secure "remember me" cookies in PHP</a>, the only effective way to mitigate the aforementioned timing leak (typically introduced by the database query) is to separate the lookup from the validation.</p>
<p>If your table looks like this (MySQL)...</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">CREATE TABLE account_recovery </span><span class="pun">(</span><span class="pln">
    id INTEGER</span><span class="pun">(</span><span class="lit">11</span><span class="pun">)</span><span class="pln"> UNSIGNED NOT NULL AUTO_INCREMENT 
    userid INTEGER</span><span class="pun">(</span><span class="lit">11</span><span class="pun">)</span><span class="pln"> UNSIGNED NOT NULL</span><span class="pun">,</span><span class="pln">
    token CHAR</span><span class="pun">(</span><span class="lit">64</span><span class="pun">),</span><span class="pln">
    expires DATETIME</span><span class="pun">,</span><span class="pln">
    PRIMARY KEY</span><span class="pun">(</span><span class="pln">id</span><span class="pun">)</span><span class="pln">
</span><span class="pun">);</span></code></pre>
<p>... you need to add one more column, <code>selector</code>, like so:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">CREATE TABLE account_recovery </span><span class="pun">(</span><span class="pln">
    id INTEGER</span><span class="pun">(</span><span class="lit">11</span><span class="pun">)</span><span class="pln"> UNSIGNED NOT NULL AUTO_INCREMENT 
    userid INTEGER</span><span class="pun">(</span><span class="lit">11</span><span class="pun">)</span><span class="pln"> UNSIGNED NOT NULL</span><span class="pun">,</span><span class="pln">
    selector CHAR</span><span class="pun">(</span><span class="lit">16</span><span class="pun">),</span><span class="pln">
    token CHAR</span><span class="pun">(</span><span class="lit">64</span><span class="pun">),</span><span class="pln">
    expires DATETIME</span><span class="pun">,</span><span class="pln">
    PRIMARY KEY</span><span class="pun">(</span><span class="pln">id</span><span class="pun">),</span><span class="pln">
    KEY</span><span class="pun">(</span><span class="pln">selector</span><span class="pun">)</span><span class="pln">
</span><span class="pun">);</span></code></pre>
<p>Use a CSPRNG When a password reset token is issued, send both values to the user, store the selector and a SHA-256 hash of the random token in the database. Use the selector to grab the hash and User ID, calculate the SHA-256 hash of the token the user provides with the one stored in the database using <a href="https://secure.php.net/hash_equals"><code>hash_equals()</code></a>.</p>
<h3>Example Code</h3>
<p>Generating a reset token in PHP 7 (or 5.6 with random_compat) with PDO:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$selector </span><span class="pun">=</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">random_bytes</span><span class="pun">(</span><span class="lit">8</span><span class="pun">));</span><span class="pln">
$token </span><span class="pun">=</span><span class="pln"> random_bytes</span><span class="pun">(</span><span class="lit">32</span><span class="pun">);</span><span class="pln">

$urlToEmail </span><span class="pun">=</span><span class="pln"> </span><span class="str">'http://example.com/reset.php?'</span><span class="pun">.</span><span class="pln">http_build_query</span><span class="pun">([</span><span class="pln">
    </span><span class="str">'selector'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $selector</span><span class="pun">,</span><span class="pln">
    </span><span class="str">'validator'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">$token</span><span class="pun">)</span><span class="pln">
</span><span class="pun">]);</span><span class="pln">

$expires </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">DateTime</span><span class="pun">(</span><span class="str">'NOW'</span><span class="pun">);</span><span class="pln">
$expires</span><span class="pun">-&gt;</span><span class="pln">add</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">DateInterval</span><span class="pun">(</span><span class="str">'PT01H'</span><span class="pun">));</span><span class="pln"> </span><span class="com">// 1 hour</span><span class="pln">

$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"INSERT INTO account_recovery (userid, selector, token, expires) VALUES (:userid, :selector, :token, :expires);"</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">([</span><span class="pln">
    </span><span class="str">'userid'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $userId</span><span class="pun">,</span><span class="pln"> </span><span class="com">// define this elsewhere!</span><span class="pln">
    </span><span class="str">'selector'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $selector</span><span class="pun">,</span><span class="pln">
    </span><span class="str">'token'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> hash</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $token</span><span class="pun">),</span><span class="pln">
    </span><span class="str">'expires'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $expires</span><span class="pun">-&gt;</span><span class="pln">format</span><span class="pun">(</span><span class="str">'Y-m-d\TH:i:s'</span><span class="pun">)</span><span class="pln">
</span><span class="pun">]);</span></code></pre>
<p>Verifying the user-provided reset token:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"SELECT * FROM account_recovery WHERE selector = ? AND expires &gt;= NOW()"</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">([</span><span class="pln">$selector</span><span class="pun">]);</span><span class="pln">
$results </span><span class="pun">=</span><span class="pln"> $stmt</span><span class="pun">-&gt;</span><span class="pln">fetchAll</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">FETCH_ASSOC</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">empty</span><span class="pun">(</span><span class="pln">$results</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $calc </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> hex2bin</span><span class="pun">(</span><span class="pln">$validator</span><span class="pun">));</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hash_equals</span><span class="pun">(</span><span class="pln">$calc</span><span class="pun">,</span><span class="pln"> $results</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="str">'token'</span><span class="pun">]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// The reset token is valid. Authenticate the user.</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// Remove the token from the DB regardless of success or failure.</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>These code snippets are not complete solutions (I eschewed the input validation and framework integrations), but they should serve as an example of what to do.</p>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments><comment><text><span class="comment-copy">When you verify the user-provided reset token, why do you use the binary representation of the random token? Do you think it will be possible (and secure?) to: 1) store in DB the hashed hex value of the token with <code>hash('sha256', bin2hex($token))</code>, 2) verify with <code>if (hash_equals(hash('sha256', $validator), $results[0]['token'])) {...</code>? Thanks!</span></text><author><a class="comment-user" href="/users/1123127/guicara" title="619 reputation">Guicara</a></author></comment><comment><text><span class="comment-copy">Yes, comparing hex strings is secure too. It's really a matter of preference. I prefer to do all crypto operations on raw binary and only ever convert to hex/base64 for transmission or storage.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can also use DEV_RANDOM, where 128 = 1/2 the generated token length. Code below generates 256 token.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$token </span><span class="pun">=</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">mcrypt_create_iv</span><span class="pun">(</span><span class="lit">128</span><span class="pun">,</span><span class="pln"> MCRYPT_DEV_RANDOM</span><span class="pun">));</span></code></pre>
</div></text><author><a href="/users/591626/graham-t">Graham T</a></author><comments><comment><text><span class="comment-copy">I would suggest <code>MCRYPT_DEV_URANDOM</code> over <code>MCRYPT_DEV_RANDOM</code>.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use 
echo str_shuffle('ASGDHFfdgfdre5475433fd');</p>
</div></text><author><a href="/users/5425314/saif">saif</a></author><comments><comment><text><span class="comment-copy">Hahaha yes this!</span></text><author><a class="comment-user" href="/users/4233593/jeff-puckett-ii" title="7,696 reputation">Jeff Puckett II</a></author></comment></comments></answer></answers></post>