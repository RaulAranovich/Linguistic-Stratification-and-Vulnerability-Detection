<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How to send password securely over HTTP? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>If on a login screen user submits a form with his username and password, the password is sent in plain text (even with POST, correct me if I am wrong). </p>
<p>So the question is what is the right way to protect the user and his password against the third party who might be eavesdropping on the communication data?</p>
<p><em>I am aware that HTTPS is asolution to the problem, but is there any way to ensure at least some level of security using standard HTTP protocol (POST request)? (perhaps using javascript in some way)</em></p>
<p><strong>EDIT</strong>
I may have left out some important things.</p>
<p>What I was about was a page - that is PHP generated login page, which is of course sent to user in HTTP GET request as a HTML file. There is no (@Jeremy Powel) connection established between server and the client so I can't create such handshaking protocol. And I want the complete process to be transparent to the user - he wants to submit a password, not deal with cryptography.</p>
<p>Thanks.</p>
</div></text><author><a href="/users/12178/shoban">Shoban</a></author><comments><comment><text><span class="comment-copy">Good point about the persistent connection.</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">You probably won't be able to accomplish this without the client using cryptography, but the user doesn't have to see such a process. He just enters his password and the code your PHP generates (javascript for example) handles it all for you.</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">The problem you describe is the reason HTTPS was invented. If you send a secret down to the client to encrypt the password an eavesdropper will be able to sniff it and decrypt the password on the return trip.</span></text><author><a class="comment-user" href="/users/123067/jnoss" title="1,542 reputation">jnoss</a></author></comment><comment><text><span class="comment-copy">So S in your suggestion could be only password (or username+password combined in any way), as this is the only "secret" the user has. Am I correct?  So the solution would be as folows: - Server provides the HTML page with a hidden form field R - The user enters the password, and before the password is sent, the javascript calculates H(R,S) and sends it to the server, perhaps even by using AJAX - The server calculates H(R,S) and compares it with received and sends a response to ajax request whether the authentification passed - The javascript redirects the browser to desired webpage</span></text><author><a class="comment-user owner" href="/users/93770/kornelije-petak" title="4,350 reputation">Kornelije Petak</a></author></comment><comment><text><span class="comment-copy">But I'm guessing the last step is some kind of security issue.  Anyway, I will look into HTTPS option as well.</span></text><author><a class="comment-user owner" href="/users/93770/kornelije-petak" title="4,350 reputation">Kornelije Petak</a></author></comment><comment><text><span class="comment-copy">I really think HTTPS is a good idea. :) Don't use it for everything. Once you get that authentication token (cookie) you don't need SSL anymore, so you'll only need it in one small place.</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">@jeremy powell - while what you describe is common practice, it is also vulnerable to an intermediary who can sniff the cookie from a header and impersonate the user by reusing the cookie. Man in the middle attacks are hard to secure against unless you are using HTTPS</span></text><author><a class="comment-user" href="/users/123067/jnoss" title="1,542 reputation">jnoss</a></author></comment><comment><text><span class="comment-copy">@electronherder: Agreed.</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">For whoever gets to this question in the future: AFTER logging in, you also need to secure the session cookie. (So: using HTTPS is really so much easier.)</span></text><author><a class="comment-user" href="/users/84237/arjan" title="12,438 reputation">Arjan</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Using HTTP with SSL will make your life much easier and you can rest at ease very smart people (smarter than me at least!) have scrutinized this method of confidential communication for years.</p>
</div></text><author><a href="/users/132377/jeremy-powell">Jeremy Powell</a></author><comments><comment><text><span class="comment-copy">...and <i>"But I have to pay for an SSL certificate!!"</i> is not a valid complaint, since you can get them for $30 these days.  Is your data really not worth 30 bucks to protect?</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">What if the webhost you subscribed to does not support adding SSL certificates?</span></text><author><a class="comment-user" href="/users/58805/calmarius" title="6,593 reputation">Calmarius</a></author></comment><comment><text><span class="comment-copy">@Calmarius - then you move to a real webhost</span></text><author><a class="comment-user" href="/users/1057791/borntocode" title="3,241 reputation">BornToCode</a></author></comment><comment><text><span class="comment-copy">@BornToCode This technically means you need to have a dedicated IP and you need to own the server hardware (or at least a VPS) to use HTTPS. Shared webhosts cannot do HTTPS, unless the entire server is protected with the host owner's certificate.</span></text><author><a class="comment-user" href="/users/58805/calmarius" title="6,593 reputation">Calmarius</a></author></comment><comment><text><span class="comment-copy">shared webhosts certainly can do https, using <a href="http://en.wikipedia.org/wiki/Server_Name_Indication" rel="nofollow noreferrer">en.wikipedia.org/wiki/Server_Name_Indication</a></span></text><author><a class="comment-user" href="/users/752695/brian-minton" title="1,693 reputation">Brian Minton</a></author></comment><comment><text><span class="comment-copy">@BRianMinton you're 100% right. I run a linode hosting multiple domains and only some of them have SSL, some running SSL on non-standard ports, etc. This could easily be done on a non-vps as well, since it's just a matter of throwing a few lines in to the apache config for the domain in question.</span></text><author><span class="comment-user">user562566</span></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Secure authentication is a broad topic but in a nutshell as @jeremy-powell mentioned always favour sending credentials over HTTPS instead of HTTP. It will take away a lot of security related headaches. </p>
<p>TSL/SSL certificates are pretty cheap these days. In fact if you don't want to spend money at all there is a free <strong>letsencryt.org</strong> - authomated Certificate Authority. They provide totally FREE and automated certificates.</p>
<p>You can go one step further and use <strong>caddyserver.com</strong> which call letsencrypt in the background.</p>
<p>Now, once we got HTTPS out of the way... </p>
<p>You shouldn't send login and password via POST payload or GET parameters. Use Authorization header (Basic access authentication scheme) instead, which is constructed as follows:</p>
<blockquote>
<ul>
<li>The username and password are combined into a string separated by a
  colon, e.g.: username:password  </li>
<li>The resulting string is encoded using
  the RFC2045-MIME variant of Base64, except not limited to 76
  char/line. </li>
<li>The authorization method and a space i.e. "Basic " is then
  put before the encoded string.  </li>
</ul>
<p>source: <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">Wikipedia: Authorization header</a></p>
</blockquote>
<p>It might seem a bit complicated but it is not.
There are plenty good libraries out there that will provide this functionality for you out of the box.</p>
<p>There few good reasons you should use Authorization header</p>
<ol>
<li>It is a standard</li>
<li>Simplicity (once you did it at least once)</li>
<li>It will allow you to login from URL level, like this: <code>https://user:password@your.domain.com/login</code> (Chrome, for example will automatically convert it into <code>Authorization</code> header) </li>
</ol>
<p><strong>IMPORTANT:</strong><br/>
As pointed out by @zaph in his comment below, sending sensitive info as GET query is not good idea as it will most likely end up in server logs.</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/p9u53.png"/></p>
</div></text><author><a href="/users/6096446/fullstackforger">FullStackForger</a></author><comments><comment><text><span class="comment-copy">The problem with sending credentials (password) as GET parameters is that the user/password pair will probably end up in server logs which is not a good idea. It is best to send credentials in a POST.</span></text><author><a class="comment-user" href="/users/451475/zaph" title="83,978 reputation">zaph</a></author></comment><comment><text><span class="comment-copy">Ahh... not at all. Screenshot you are seeing is modified to illustrate what is happening in a browser. The moment you hit enter browser will convert your url creating a <code>Authorization</code> header. Just give it a go. Logs will remind clean.  And of course if you making a call from the server (if that is the scenario you are worrying about) you should generate header programmatically of course.</span></text><author><a class="comment-user" href="/users/6096446/fullstackforger" title="173 reputation">FullStackForger</a></author></comment><comment><text><span class="comment-copy">You can not log what you can not see. <code>username:password@url</code> from the browser translates to: <code>url</code> + <code>Authorization</code> request header. As for GET queries... well like I said, use Authroziation header. It is better.</span></text><author><a class="comment-user" href="/users/6096446/fullstackforger" title="173 reputation">FullStackForger</a></author></comment><comment><text><span class="comment-copy">I my current project I require JWT authorization for all the routes. To do so the token has to be obtained first by logging in first. <code>/auth/login</code> allows both POST and GET method. POST expected to have a payload with <code>login</code> and <code>password</code> and GET requires basic Authorization (header). When you login from either SPA or mobile app you will either call POST with payload or call GET with the header or as a pure <b>convenience</b> type `user:pass@url' into a browser address bar, which converts to a GET with header header. Logs are clean in all cases.</span></text><author><a class="comment-user" href="/users/6096446/fullstackforger" title="173 reputation">FullStackForger</a></author></comment><comment><text><span class="comment-copy">Hope I made it clear @zaph. But regardless of what you find here please run some tests for yourself and take a look at links from my post, those should help.</span></text><author><a class="comment-user" href="/users/6096446/fullstackforger" title="173 reputation">FullStackForger</a></author></comment><comment><text><span class="comment-copy">@zaph I apologise if my English wasn't clear enough. Also, I have read your comment twice. Did the same with mine :)  and honestly I have never suggested to send sensitive data with as GET params. I totally agree with you on that one. In yesterday's comment I have described production setup referring to your concerns, hoping it may help to clarify few things. Hope it helps.</span></text><author><a class="comment-user" href="/users/6096446/fullstackforger" title="173 reputation">FullStackForger</a></author></comment><comment><text><span class="comment-copy">@zaph Thanks for your input. I have updated my answer (both content and the image as well)</span></text><author><a class="comment-user" href="/users/6096446/fullstackforger" title="173 reputation">FullStackForger</a></author></comment><comment><text><span class="comment-copy">I agree: "I have never suggested to send sensitive data with as GET params." But some developers do and I just felt your statements would benift from a clarification for that instance. I'm deleting most of my comments and tis on later, they are no longer relevant.</span></text><author><a class="comment-user" href="/users/451475/zaph" title="83,978 reputation">zaph</a></author></comment><comment><text><span class="comment-copy">You don't address the point of the question: protecting sensitive data from man-in-the-middle eavesdropping. The focus is not to find an alternative and/or more standardized way to pass credentials, but protect them over an insecure channel.</span></text><author><a class="comment-user" href="/users/277389/lord-of-the-goo" title="495 reputation">Lord of the Goo</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use a challenge response scheme. Say the the client and server both know a secret S. Then the server can be sure that the client knows the password (without giving it away) by:</p>
<ol>
<li>Server sends a random number, R, to client.</li>
<li>Client sends H(R,S) back to the server (where H is a cryptographic hash function, like SHA-256)</li>
<li>Server computes H(R,S) and compares it to the client's response. If they match, the server knows the client knows the password.</li>
</ol>
<p><strong>Edit:</strong></p>
<p><strike>There is an issue here with the freshness of R and the fact that HTTP is  stateless. This can be handled by having the server create a secret, call it Q, that <em>only the server knows</em>. Then the protocol goes like this:</strike></p><strike>
<ol>
<li>Server generates random number R. It then sends to the client H(R,Q) (which cannot be forged by the client).</li>
<li>Client sends R, H(R,Q), and computes H(R,S) and sends all of it back to the server (where H is a cryptographic hash function, like SHA-256)</li>
<li>Server computes H(R,S) and compares it to the client's response. Then it takes R and computes (again) H(R,Q). If the client's version of H(R,Q) and H(R,S) match the server's re-computation, the server deems the client authenticated.</li>
</ol>
</strike><p><strike>To note, since H(R,Q) cannot be forged by the client, H(R,Q) acts as a cookie (and could therefore be implemented actually as a cookie).</strike></p>
<p><strong>Another Edit:</strong></p>
<p>The previous edit to the protocol is incorrect as anyone who has observed H(R,Q) seems to be able to replay it with the correct hash. The server has to remember which R's are no longer fresh. I'm CW'ing this answer so you guys can edit away at this and work out something good.</p>
</div></text><author><a href="/users/132377">Jeremy Powell</a></author><comments><comment><text><span class="comment-copy">+1 - you'll need to compute the response on the client side with javascript (or Flash/Silverlight/etc.)</span></text><author><a class="comment-user" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">I was just going to say the same thing.  Not sure of any js libraries out there to do this.  It will be interesting to follow this post.</span></text><author><a class="comment-user" href="/users/180385/j-hendrix" title="1,085 reputation">J.Hendrix</a></author></comment><comment><text><span class="comment-copy">The sending of R can be done with a hidden form field (the server needs to then validate that the R it received was fresh and not used before)</span></text><author><a class="comment-user" href="/users/47527/yuliy" title="11,943 reputation">Yuliy</a></author></comment><comment><text><span class="comment-copy">Doesn't stop man in the middle or impersonation attacks. E.g. through wifi. Seems like this will just give a false sense of security, IMO.</span></text><author><a class="comment-user" href="/users/4725/tom-hawtin-tackline" title="113,096 reputation">Tom Hawtin - tackline</a></author></comment><comment><text><span class="comment-copy">Added a little freshness. :)</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">That protects against passive attacks, but a Man in the Middle can still attack.</span></text><author><a class="comment-user" href="/users/3978/douglas-leeder" title="38,915 reputation">Douglas Leeder</a></author></comment><comment><text><span class="comment-copy">man, it sure isn't my day for typos. The server also sends R in step 1.</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">Also it requires the server to know the original password.</span></text><author><a class="comment-user" href="/users/3978/douglas-leeder" title="38,915 reputation">Douglas Leeder</a></author></comment><comment><text><span class="comment-copy">@Douglas: yes. unfortunately. is there a way to do this by saving the hash of the password to the server?</span></text><author><a class="comment-user" href="/users/132377/jeremy-powell" title="2,270 reputation">Jeremy Powell</a></author></comment><comment><text><span class="comment-copy">Wrong, wrong, wrong, wrong, <b>wrong</b></span></text><author><a class="comment-user" href="/users/192839/mike-graham" title="38,385 reputation">Mike Graham</a></author></comment><comment><text><span class="comment-copy">Don't reinvent crypto! (in production)</span></text><author><a class="comment-user" href="/users/1918818/bryanph" title="797 reputation">bryanph</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I would use a server-side and client-side Diffie-Hellman key exchange system with AJAX or multiple form submits(I recommend the former), although I don't see any good implementations thereof on the internet. Remember that a JS library can always be corrupted or changed by MITM. Local storage can be used to help combat this, to an extent.</p>
</div></text><author><a href="/users/1424875/hexafraction">hexafraction</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If your webhost allows it, or you will need to deal with sensitive data, then use HTTPS, period. (It's often required by the law afaik).</p>
<p>Otherwise if you want to do something over HTTP. I would do something like this. </p>
<ol>
<li>The server embeds its public key into the login page. </li>
<li>The client populates the login form and clicks submit.</li>
<li>An AJAX request gets the current timestamp from the server. </li>
<li>Client side script concatenates the credentials, the timestamp and a salt (hashed from analog data eg. mouse movements, key press events), encrypts it using the public key.</li>
<li>Submits the resulting hash. </li>
<li>Server decrypts the hash</li>
<li>Checks if the timestamp is recent enough (allows a short 5-10 second window only). Rejects the login if the timestamp is too old.</li>
<li>Stores the hash for 20 seconds. Rejects the same hash for login during this interval. </li>
<li>Authenticates the user.</li>
</ol>
<p>So this way the password is protected and the same authentication hash cannot be replayed. </p>
<p>About the security of the session token. That's a bit harder. But it's possible to make reusing a stolen session token a bit harder.</p>
<ol>
<li>The server sets an extra session cookie which contains a random string.</li>
<li>The browser sends back this cookie on the next request.</li>
<li>The server checks the value in the cookie, if it's different then it destroys the session, otherwise all is okay.</li>
<li>The server sets the cookie again with different text.</li>
</ol>
<p>So if the session token got stolen, and a request is sent up by someone else, then on the original user's next request the session will be destroyed. So if the user actively browsing the site, clicking on links often, then the thief won't go far with the stolen token. This scheme can be fortified by requiring another authentication for the sensitive operations (like account deletion).</p>
<p>About the implementation: RSA is probably to most known algorithm, but it's quite slow for long keys. I don't know how fast a PHP or Javascript implementation of would be. But probably there are a faster algorithms.</p>
</div></text><author><a href="/users/58805/calmarius">Calmarius</a></author><comments><comment><text><span class="comment-copy">In this case is the password really protected? Couldn't someone sniff out what is sent and decrypt it using the public key and then just update the timestamp when they use it later? Am I missing something?</span></text><author><a class="comment-user" href="/users/557358/michaellindahl" title="925 reputation">michaellindahl</a></author></comment><comment><text><span class="comment-copy">@michaellindahl asymmetric encryption means that only the private key - which never leaves the server - can be used to decrypt things. Public keys can only be used to encrypt.</span></text><author><a class="comment-user" href="/users/1073868/dan-pantry" title="4,729 reputation">Dan Pantry</a></author></comment><comment><text><span class="comment-copy">A computer between the browser and the server could change the public key on login page.</span></text><author><a class="comment-user" href="/users/1719245/antti" title="353 reputation">Antti</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>HTTPS is so powerful because it uses asymmetric cryptography.  This type of cryptography not only allows you to create an encrypted tunnel but you can verify that you are talking to the right person,  and not a hacker. </p>
<p>Here is Java source code which uses the asymmetric cipher RSA (used by PGP) to communicate:
<a href="http://www.hushmail.com/services/downloads/" rel="nofollow noreferrer">http://www.hushmail.com/services/downloads/</a></p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use <a href="http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol" rel="nofollow noreferrer">SRP</a> to use secure passwords over an insecure channel.  The advantage is that even if an attacker sniffs the traffic, or compromises the server, they can't use the passwords on a different server. <a href="https://github.com/alax/jsrp" rel="nofollow noreferrer">https://github.com/alax/jsrp</a> is a javascript library that supports secure passwords over HTTP in the browser, or server side (via node).</p>
</div></text><author><a href="/users/752695/brian-minton">Brian Minton</a></author><comments/></answer></answers></post>