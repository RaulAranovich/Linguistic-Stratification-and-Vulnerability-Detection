<?xml version="1.0" encoding="utf-8"?>
<post><title>c - How can a Format-String vulnerability be exploited? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I was reading about vulnerabilities in code and came across this <em>Format-String Vulnerability</em>. </p>
<p><a href="http://en.wikipedia.org/wiki/Uncontrolled_format_string" rel="noreferrer">Wikipedia</a> says:</p>
<blockquote>
<p>Format string bugs most commonly appear when a programmer wishes to
  print a string containing user supplied data. The programmer may
  mistakenly write printf(buffer) instead of printf("%s", buffer). The
  first version interprets buffer as a format string, and parses any
  formatting instructions it may contain. The second version simply
  prints a string to the screen, as the programmer intended.</p>
</blockquote>
<p>I got the problem with printf(buffer) version, but I still didn't get how this vulnerability can be used by attacker to execute harmful code. Can someone please tell me how this vulnerability can be <strong>exploited</strong> by an example?</p>
</div></text><author><a href="/users/489852/atul-goyal">Atul Goyal</a></author><comments><comment><text><span class="comment-copy">For reference, the buffer overflow attack question is here: <a href="http://stackoverflow.com/questions/7344226/buffer-overflow-attack" title="buffer overflow attack">stackoverflow.com/questions/7344226/buffer-overflow-attack</a></span></text><author><a class="comment-user" href="/users/922184/mysticial" title="310,840 reputation">Mysticial</a></author></comment><comment><text><span class="comment-copy">possibly related: <a href="http://stackoverflow.com/questions/5672996/format-string-vulnerability-printf" title="format string vulnerability printf">stackoverflow.com/questions/5672996/â€¦</a></span></text><author><a class="comment-user" href="/users/855395/eran-zimmerman" title="2,832 reputation">Eran Zimmerman</a></author></comment><comment><text><span class="comment-copy">@Mehrdad: Why should <code>printf</code> pop anything off the stack? It's not like it knows (or cares) how many arguments (or even how big) were originally pushed...</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">Thanks, I'm familiar with buffer overflow attack, I'm still trying to understand how attacker gains control of return address using printf. Meanwhile if possible, someone plz post an example to make it more clear.</span></text><author><a class="comment-user owner" href="/users/489852/atul-goyal" title="2,136 reputation">Atul Goyal</a></author></comment><comment><text><span class="comment-copy">@Mehrdad: It doesn't <b>pop</b> anything off the stack, though. It just reads them. Take note that the caller might have even pushed <i>more</i> arguments than the callee expects, and yet the <b>caller</b> does the cleanup. The callee doesn't know or care -- all it does is read the data. That's why you can't have callee-cleanup with varargs in C.</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">I thought you guys were talking to yourselves for a second there...</span></text><author><a class="comment-user" href="/users/622647/quasiverse" title="5,363 reputation">quasiverse</a></author></comment><comment><text><span class="comment-copy">@Mehrdad Now you've got me thinking... seems you're right. It definitely reads more data from stack, but that doesn't necessarily imply popping as it reads.</span></text><author><a class="comment-user" href="/users/33708/mehrdad-afshari" title="295,903 reputation">Mehrdad Afshari</a></author></comment><comment><text><span class="comment-copy">@quasiverse: lol</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>You may be able to exploit a format string vulnerability in many ways, directly or indirectly. Let's use the following as an example (assuming no relevant OS protections, which is very rare anyways):</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">int</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">**</span><span class="pln">argv</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">char</span><span class="pln"> text</span><span class="pun">[</span><span class="lit">1024</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> some_value </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">72</span><span class="pun">;</span><span class="pln">

    strcpy</span><span class="pun">(</span><span class="pln">text</span><span class="pun">,</span><span class="pln"> argv</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]);</span><span class="pln"> </span><span class="com">/* ignore the buffer overflow here */</span><span class="pln">

    printf</span><span class="pun">(</span><span class="str">"This is how you print correctly:\n"</span><span class="pun">);</span><span class="pln">
    printf</span><span class="pun">(</span><span class="str">"%s"</span><span class="pun">,</span><span class="pln"> text</span><span class="pun">);</span><span class="pln">
    printf</span><span class="pun">(</span><span class="str">"This is how not to print:\n"</span><span class="pun">);</span><span class="pln">
    printf</span><span class="pun">(</span><span class="pln">text</span><span class="pun">);</span><span class="pln">

    printf</span><span class="pun">(</span><span class="str">"some_value @ 0x%08x = %d [0x%08x]"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">some_value</span><span class="pun">,</span><span class="pln"> some_value</span><span class="pun">,</span><span class="pln"> some_value</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>The basis of this vulnerability is the behaviour of functions with variable arguments. A function which implements handling of a variable number of parameters has to read them from the stack, essentially. If we specify a format string that will make <code>printf()</code> expect two integers on the stack, and we provide only one parameter, the second one will have to be something else on the stack. By extension, and if we have control over the format string, we can have the two most fundamental primitives:</p>
<hr/>
<h1>Reading from arbitrary memory addresses</h1>
<p>[EDIT] <strong>IMPORTANT:</strong> I'm making some assumptions about the stack frame layout here. You can ignore them if you understand the basic premise behind the vulnerability, and they vary across OS, platform, program and configuration anyways.</p>
<p>It's possible to use the <code>%s</code> format parameter to read data. You can read the data of the original format string in <code>printf(text)</code>, hence you can use it to read anything off the stack:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pun">./</span><span class="pln">vulnerable AAAA</span><span class="pun">%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pln">
</span><span class="typ">This</span><span class="pln"> is how you print correctly</span><span class="pun">:</span><span class="pln">
AAAA</span><span class="pun">%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pln">
</span><span class="typ">This</span><span class="pln"> is how not to print</span><span class="pun">:</span><span class="pln">
AAAA</span><span class="pun">.</span><span class="pln">XXXXXXXX</span><span class="pun">.</span><span class="pln">XXXXXXXX</span><span class="pun">.</span><span class="pln">XXXXXXXX</span><span class="pun">.</span><span class="lit">41414141</span><span class="pln">
some_value </span><span class="pun">@</span><span class="pln"> </span><span class="lit">0x08049794</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">72</span><span class="pln"> </span><span class="pun">[</span><span class="lit">0xffffffb8</span><span class="pun">]</span></code></pre>
<hr/>
<h1>Writing to arbitrary memory addresses</h1>
<p>You can use the <code>%n</code> format specifier to write to an arbitrary address (almost). Again, let's assume our vulnerable program above, and let's try changing the value of <code>some_value</code>, which is located at <code>0x08049794</code>, as seen above:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pun">./</span><span class="pln">vulnerable $</span><span class="pun">(</span><span class="pln">printf </span><span class="str">"\x94\x97\x04\x08"</span><span class="pun">)%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="pln">n
</span><span class="typ">This</span><span class="pln"> is how you print correctly</span><span class="pun">:</span><span class="pln">
</span><span class="pun">??%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="lit">08x</span><span class="pun">.%</span><span class="pln">n
</span><span class="typ">This</span><span class="pln"> is how not to print</span><span class="pun">:</span><span class="pln">
</span><span class="pun">??</span><span class="pln">XXXXXXXX</span><span class="pun">.</span><span class="pln">XXXXXXXX</span><span class="pun">.</span><span class="pln">XXXXXXXX</span><span class="pun">.</span><span class="pln">
some_value </span><span class="pun">@</span><span class="pln"> </span><span class="lit">0x08049794</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">31</span><span class="pln"> </span><span class="pun">[</span><span class="lit">0x0000001f</span><span class="pun">]</span></code></pre>
<p>We've overwritten <code>some_value</code> with the number of bytes written before the <code>%n</code> specifier was encountered (<code>man printf</code>). We can use the format string itself, or field width to control this value:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pun">./</span><span class="pln">vulnerable $</span><span class="pun">(</span><span class="pln">printf </span><span class="str">"\x94\x97\x04\x08"</span><span class="pun">)%</span><span class="pln">x</span><span class="pun">%</span><span class="pln">x</span><span class="pun">%</span><span class="pln">x</span><span class="pun">%</span><span class="pln">n
</span><span class="typ">This</span><span class="pln"> is how you print correctly</span><span class="pun">:</span><span class="pln">
</span><span class="pun">??%</span><span class="pln">x</span><span class="pun">%</span><span class="pln">x</span><span class="pun">%</span><span class="pln">x</span><span class="pun">%</span><span class="pln">n
</span><span class="typ">This</span><span class="pln"> is how not to print</span><span class="pun">:</span><span class="pln">
</span><span class="pun">??</span><span class="pln">XXXXXXXXXXXXXXXXXXXXXXXX
some_value </span><span class="pun">@</span><span class="pln"> </span><span class="lit">0x08049794</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">21</span><span class="pln"> </span><span class="pun">[</span><span class="lit">0x00000015</span><span class="pun">]</span></code></pre>
<p>There are many possibilities and tricks to try (direct parameter access, large field width making wrap-around possible, building your own primitives), and this just touches the tip of the iceberg. I would suggest reading more articles on fmt string vulnerabilities (Phrack has some mostly excellent ones, although they may be a little advanced) or a book which touches on the subject.</p>
<hr/>
<p>Disclaimer: the examples are taken [although not verbatim] from the book <em>Hacking: The art of exploitation (2nd ed)</em> by Jon Erickson.</p>
</div></text><author><a href="/users/149530/michael-foukarakis">Michael Foukarakis</a></author><comments><comment><text><span class="comment-copy">hi, I'm wondering how <code>$(printf "\x94\x97\x04\x08")%08x.%08x.%08x.%n</code> works? why is "??" printed out for the whole lot in front? How did it reach the memory address 0x09049794? Thanks a lot</span></text><author><a class="comment-user" href="/users/3109672/user3109672" title="520 reputation">user3109672</a></author></comment><comment><text><span class="comment-copy">The ?? is printed becuase $(printf "\x94\x97\x04\x08") will try to convert these values into characters. Because these values are not printable characters, your terminal will print a ? instead. (try printf "\x41\x42\x43\x44", wich will print ABCD because these are valid ascii values)</span></text><author><a class="comment-user" href="/users/503424/freek-kalter" title="485 reputation">Freek Kalter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h3>Ah, the answer is in the article!</h3>
<blockquote>
<p>Uncontrolled format string is a type of software vulnerability, discovered around 1999, that can be used in security exploits. Previously thought harmless, format string exploits can be used to <em>crash a program</em> or to <strong>execute harmful code</strong>.</p>
<p>A typical exploit uses a combination of these techniques to force a program to overwrite the address of a library function or the return address on the stack with a pointer to some malicious shellcode. The padding parameters to format specifiers are used to control the number of bytes output and the <code>%x</code> token is used to pop bytes from the stack until the beginning of the format string itself is reached. The start of the format string is crafted to contain the address that <strong>the <code>%n</code> format token can then overwrite with the address of the malicious code to execute</strong>.</p>
</blockquote>
<p>This is because <code>%n</code> <strong>causes <code>printf</code> to <em>write</em> data to a variable</strong>, which is on the stack. But that means it could write to something arbitrarily. All you need is for someone to use that variable (it's relatively easy if it happens to be a function pointer, whose value you just figured out how to control) and they can make you execute anything arbitrarily.</p>
<p>Take a look at the links in the article; they <a href="http://en.wikipedia.org/wiki/Uncontrolled_format_string#cite_note-3" rel="noreferrer">look interesting</a>.</p>
</div></text><author><a href="/users/541686/mehrdad">Mehrdad</a></author><comments><comment><text><span class="comment-copy">should be an edit to your other answer</span></text><author><a class="comment-user" href="/users/505088/david-heffernan" title="455,416 reputation">David Heffernan</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It is interesting that no-one has mentioned the <code>n$</code> notation supported by POSIX.  If you can control the format string as the attacker, you can use notations such as:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="str">"%200$p"</span></code></pre>
<p>to read the 200<sup>th</sup> item on the stack (if there is one).  The intention is that you should list all the <code>n$</code> numbers from 1 to the maximum, and it provides a way of resequencing how the parameters appear in a format string, which is handy when dealing with I18N (L10N, G11N, M18N<sup>*</sup>).</p>
<p>However, some (probably most) systems are somewhat lackadaisical about how they validate the <code>n$</code> values and this can lead to abuse by attackers who can control the format string.  Combined with the <code>%n</code> format specifier, this can lead to writing at pointer locations.</p>
<hr/>
<p><sup>*</sup> The acronyms I18N, L10N, G11N and M18N are for internationalization, localization, globalization, and multinationalization respectively.  The number represents the number of omitted letters.</p>
</div></text><author><a href="/users/15168/jonathan-leffler">Jonathan Leffler</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would recommend reading <a href="http://www.cis.syr.edu/%7Ewedu/Teaching/cis643/LectureNotes_New/Format_String.pdf" rel="nofollow">this</a> lecture note about format string vulnerability.
It describes in details what happens and how, and has some images that might help you to understand the topic.</p>
</div></text><author><a href="/users/1100913/andreyp">AndreyP</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>AFAIK it's mainly because it can crash your program, which is considered to be a denial-of-service attack. All you need is to give an invalid address (practically <strong>anything</strong> with a few <code>%s</code>'s is guaranteed to work), and it becomes a simple denial-of-service (DoS) attack.</p>
<p>Now, it's theoretically <em>possible</em> for that to trigger anything in the case of an exception/signal/interrupt handler, but figuring out how to do that is beyond me -- you need to figure out how to <em>write</em> arbitrary data to memory as well.</p>
<p>But why does anyone care if the program crashes, you might ask? Doesn't that just inconvenience the user (who deserves it anyway)?</p>
<p>The problem is that some programs are accessed by multiple users, so crashing them has a non-negligible cost. Or sometimes they're critical to the running of the system (or maybe they're in the middle of doing something very critical), in which case this can be damaging to your data. Of course, if you crash Notepad then no one might care, but if you crash CSRSS (which I believe actually had a similar kind of bug -- a double-free bug, specifically) then yeah, the entire system is going down with you.</p>
<hr/>
<h3>Update:</h3>
<p>See <a href="http://www.exploit-db.com/exploits/3052/" rel="nofollow">this link</a> for the CSRSS bug I was referring to.</p>
<hr/>
<h2>Edit:</h2>
<p>Take note that <strong>reading arbitrary data can be just as dangerous</strong> as executing arbitrary code! If you read a password, a cookie, etc. then it's just as serious as an arbitrary code execution -- and this is <em>trivial</em> if you just have enough time to try enough format strings.</p>
</div></text><author><a href="/users/541686/mehrdad">Mehrdad</a></author><comments><comment><text><span class="comment-copy">Thanks Mehrdad, I think crashing a program would still be generally easier than being able to run your own code. So, specifically I'm looking for an answer to execution of attacker's code. But still I must upvote for a good answer :)</span></text><author><a class="comment-user owner" href="/users/489852/atul-goyal" title="2,136 reputation">Atul Goyal</a></author></comment><comment><text><span class="comment-copy">@Atul: Haha thanks. :) Yeah, if anyone can come up with an actual arbitrary code execution example then I'd DEFINITELY want to see it!</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">@Atul: I posted another answer, from the article itself. If I manage to write the code then I'll do that, too -- but that one is a direct attack of the kind you're looking for.</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">This answer is nonsense. You should delete it in light of your <i>correct</i> answer.</span></text><author><a class="comment-user" href="/users/310574/gabe" title="63,695 reputation">Gabe</a></author></comment><comment><text><span class="comment-copy">@Gabe: Why is it nonsense? DoS is an attack, isn't it? Also, an exception handler that tries to handle an access violation (by calling a function through a pointer or something) could cause this to execute unintended code, right? It's not likely, but still possible.</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">The OP wanted to know how <code>printf</code> can be exploited to execute harmful code. You wrote about a DoS attack. That may be an exploit, but it doesn't explain how to execute harmful code. The CSRSS doesn't use <code>printf</code>, so it doesn't answer the OP's question either.</span></text><author><a class="comment-user" href="/users/310574/gabe" title="63,695 reputation">Gabe</a></author></comment><comment><text><span class="comment-copy">@Gabe: I'll probably leave it here, just because I think the information can still be useful to someone who might see it later. Sorry you didn't find it helpful.</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">@Gabe: I think Mehrdad's point is fair enough as even though it's not about how an attacker can execute his code, but still it touches an important exploit using the vulnerability in question. To me, this answer is not non-sense atleast.</span></text><author><a class="comment-user owner" href="/users/489852/atul-goyal" title="2,136 reputation">Atul Goyal</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><a href="http://en.wikipedia.org/wiki/Uncontrolled_format_string" rel="nofollow">Explanation</a>. Remember that any varargs function in c needs to know how many parameters it is receiving. In printf this is done by parsing the 1st parameter. If you change the 1st parameter so that printf thinks it has some extra arguments, more things will be popped out of the stack. (The link to wikipedia should cover this in more detail).</p>
</div></text><author><a href="/users/855395/eran-zimmerman">Eran Zimmerman</a></author><comments><comment><text><span class="comment-copy">Huh? I thought the C calling convention was caller-cleanup? Why should the callee pop anything off the stack?</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment><comment><text><span class="comment-copy">Why would you post the same link as the OP and then make up nonsense about popping the stack?</span></text><author><a class="comment-user" href="/users/310574/gabe" title="63,695 reputation">Gabe</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>An easy "Do it yourself" example : ( I know it works on winxp-win7 , don't know about win8)
open a command prompt in windows </p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">C</span><span class="pun">:</span><span class="pln">\&gt;sort idontexists
idontexistsThe system cannot find the file specified</span><span class="pun">.</span><span class="pln">

C</span><span class="pun">:</span><span class="pln">\&gt;sort idontexists</span><span class="pun">%</span><span class="pln">s
idontexists</span><span class="str">"</span><span class="typ">The</span><span class="pln"> system cannot find the file specified</span><span class="pun">.</span><span class="pln">

C</span><span class="pun">:</span><span class="pln">\&gt;sort idontexists</span><span class="pun">%</span><span class="pln">s
idontexists</span><span class="pun">,</span><span class="typ">The</span><span class="pln"> system cannot find the file specified</span><span class="pun">.</span><span class="pln">

C</span><span class="pun">:</span><span class="pln">\&gt;sort idontexists</span><span class="pun">%</span><span class="pln">s
idontexists</span><span class="pun">Ã³</span><span class="typ">The</span><span class="pln"> system cannot find the file specified</span><span class="pun">.</span><span class="pln">

C</span><span class="pun">:</span><span class="pln">\&gt;sort idontexists</span><span class="pun">%</span><span class="pln">s
idontexists</span><span class="pun">!</span><span class="typ">The</span><span class="pln"> system cannot find the file specified</span><span class="pun">.</span><span class="pln">

C</span><span class="pun">:</span><span class="pln">\&gt;sort idontexists</span><span class="pun">%</span><span class="pln">s
idontexists</span><span class="pun">Âº</span><span class="typ">The</span><span class="pln"> system cannot find the file specified</span><span class="pun">.</span></code></pre>
<p>When there is no file found , The program echo's the first argument 
and it replaces the %s with some value from the stack...</p>
</div></text><author><a href="/users/2355640/hermani">Hermani</a></author><comments/></answer></answers></post>