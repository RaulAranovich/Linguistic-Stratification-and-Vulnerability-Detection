<?xml version="1.0" encoding="utf-8"?>
<post><title>.net - Is “Code Access Security” of any real world use? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<h1>Warning:</h1>
<p>Newer versions of .Net and .Net core has have removed and/or changed “Code Access Security” (CAS) since this question was asked.</p>
<h1>Original Question:</h1>
<p>I am in the process of studying for the <a href="http://www.microsoft.com/learning/en/us/Exam.aspx?ID=70-536&amp;Locale=en-us" rel="nofollow noreferrer">70-536 .NET Framework - Application Development Foundation Exam</a>, as I have been programming .net for many years, this should not be hard!</p>
<p>However I am having to learn about “Code Access Security” (CAS),  As I have never had a need to use or configure it, I was wondering if anyone else has found a real life usage for it?</p>
<p>Please provide examples of when you have used CAS and it has been part of the solution rather then the problem.</p>
<p>(So far everything else has had some relationship to task I have had to do in my years of .NET programming)</p>
<hr/>
<p><strong>Related questions:</strong></p>
<ul>
<li><a href="http://stackoverflow.com/questions/420854/why-to-use-cas-code-access-security">Why to use CAS (Code Access Security)?</a> - This has very few real world examples apart from how Microsoft uses it.</li>
<li><a href="http://stackoverflow.com/questions/170844/anyone-really-using-code-access-security-to-protect-their-assemblies-and-or-metho">Anyone really using Code Access Security to protect their assemblies and/or methods?</a></li>
<li><a href="http://stackoverflow.com/questions/737995/what-is-code-access-security-in-net">What is Code Access Security in .NET</a> - Defines CAS well, but does not give real examples.</li>
<li>.<a href="http://stackoverflow.com/questions/1047243/net-code-access-security-useful-or-just-overcomplicated">NET Code Access Security: Useful or just overcomplicated?</a></li>
</ul>
<hr/>
<p><strong>Results so far.</strong></p>
<ul>
<li><p>CAS is useful when you are hosting 3rd party code.  E.g. a web hosting company can use it to stop their customer's Asp.net code doing damage to the servers.  (Office also make use of it when .NET is used as a replacement for VBA)</p></li>
<li><p>The only detailed example of it being used outside of a Microsoft application so far are:</p>
<blockquote>
<p>A recent project I did had something
  similar: allow the user to upload a
  library, and test it for performance
  ("who makes the best algorithm").
  Needless to say, we needed CAS heavily
  there.</p>
</blockquote></li>
<li><p>CAS seems to be useful to get JITDC certification, that is like by the US department of defence, however I don’t know if CAS was of any real value, or if it was just box ticking.</p></li>
</ul>
<p>(If you need to bypass a host that uses CAS and you have admin rights on them machine, you can just put your assemblies in the GAC.)</p>
<p>Looking forward, <a href="http://blogs.msdn.com/shawnfa/archive/2009/05/21/security-policy-in-the-v4-clr.aspx" rel="nofollow noreferrer">CAS is a bit less complex in .net 4</a>. </p>
<hr/>
<p>At least it looks like the new Microsoft exams will not have a “foundation” exam that includes CAS.  I don’t know if it will make it into the new Winforms/WPF exams.</p>
</div></text><author><a href="/users/57159/ian-ringrose">Ian Ringrose</a></author><comments><comment><text><span class="comment-copy">I had the same reaction when studying for this exam; my opinion is that this is a key part of the .NET framework internally, used by Microsoft to close lots of security holes, and they exposed it so that other people could use it too.  But I also have never used it myself, or known anyone who has used it in a business application.</span></text><author><a class="comment-user" href="/users/2194/guy-starbuck" title="17,772 reputation">Guy Starbuck</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I encounter code access security quite often in the "real world", often when I least expect it. And in a way, SilverLight would be an excellent real-world application of it, were it not that SilverLight <a href="http://web.archive.org/web/20141221100628/http://msdn.microsoft.com/en-us/magazine/cc765416.aspx" rel="nofollow noreferrer"><em>chose not to employ CAS</em></a> at all in the end.</p>
<h2>Hosting providers</h2>
<p>The places where you see it in action is where a secured environment is needed: ASP.NET itself of course, but ASP.NET hosting providers use a <em>modified security model</em> to prevent intrusion in their precious systems. I know for a fact that Webhost4Life uses this (no information on their site about it, but I've worked with them, it's there, really). Looking further, other ASP.NET hosting providers do the same, but they are not very clear about it either: <a href="http://www.velocityreviews.com/FORUMS/t598839-aspcompat-attribute-not-allowed.html" rel="nofollow noreferrer">thread on godaddy.com not</a> wanting to change the CAS (and no clarity what's supported and what not) or <a href="http://support.bugnetproject.com/Bugs/BugDetail.aspx?bid=323" rel="nofollow noreferrer">this related discussion on 1&amp;1</a>. Some cloud hosting sites (rackspacecloud) took it a bit further and <em>"worked with Microsoft for a modified full trust level"</em> whatever that may be. </p>
<p>In short: if you find an ASP.NET host, most likely they've used CAS to prevent you from doing things they don't want you to do. They can even use it make difference between "basic" (many restrictions) hosting and "enterprise" (few restrictions) hosting which gives a whole other meaning to CAS.</p>
<h2>Other applications of CAS</h2>
<p>So much for a few real-world situations that I encountered myself. A recent project I did had something similar: allow the user to upload a library, and test it for performance ("who makes the best algorithm"). Needless to say, we needed CAS heavily there. Other examples or interesting resources:</p>
<ul>
<li><a href="http://www.codeproject.com/KB/install/NARLoader.aspx" rel="nofollow noreferrer">NAR Loader</a> (a codeproject application) uses it's own CAS</li>
<li><a href="http://www.codeproject.com/KB/dotnet/LR_Evaluator.aspx" rel="nofollow noreferrer">LR Evaluator</a> (also codeproject app) uses CAS</li>
<li>ClickOnce (see below) uses CAS</li>
<li><a href="http://www.codeproject.com/KB/architecture/CASDesignPatterns.aspx" rel="nofollow noreferrer">CAS Design Patterns</a>: it's popularity "assumes" CAS is being used</li>
<li><a href="http://www.codeproject.com/KB/security/UB_CAS_NET.aspx" rel="nofollow noreferrer">Understanding CAS</a>: even greater popularity and some comments imply applications</li>
<li>Microsoft <a href="http://msdn.microsoft.com/en-us/library/dd583158%28office.11%29.aspx" rel="nofollow noreferrer">SharePoint uses CAS</a> all the way, it seems (sorry, I'm not an SP specialist)</li>
</ul>
<p>For any situation where you are simply in full control yourself, you build your own app and code (or have it built) and are in complete control of your system, I don't think you'll need CAS too often. It's more something you'd use the minute you get to run code from lesser trusted sources (which is basically everything that's not in your full control).</p>
<h2>CAS vs ClickOnce</h2>
<p>Default CAS settings limit the capabilities of code run from a network share or other non-local sources. This makes sense but the stringent restrictions make it hard to have a central repository for distributed application. .NET 2.0 introduced ClickOnce, which was supposed to elevate the security (<a href="http://www.leastprivilege.com/BewareBeAwareOfClickOnceDefaultSettings.aspx" rel="nofollow noreferrer">discussion here</a>). </p>
<p>ClickOnce itself <a href="http://en.wikipedia.org/wiki/ClickOnce" rel="nofollow noreferrer">uses CAS</a>, to prevent the installer from calling into system functions. As such, I believe it is arguably <em>the best well known application that relies on CAS</em>.</p>
<p>Point being: you need to understand CAS to be able to create something that can run directly from a share, or you ignore it all and use ClickOnce.</p>
<h2>Microsoft's Survey on CAS</h2>
<p>In 2005, Microsoft <a href="http://blogs.msdn.com/brada/archive/2005/03/06/386172.aspx" rel="nofollow noreferrer">summoned a survey</a> to find out why CAS was so unpopular, hoping to improve it to make it better applicable. Unfortunately, I couldn't find the actual survey results, other then <a href="http://www.codinghorror.com/blog/archives/000820.html" rel="nofollow noreferrer">this post somewhat detailing</a> why CAS is underused. </p>
<h2>CAS in another world</h2>
<p>That post, however, does point at an intriguing niche: CAS applied to another world: Unix / Linux. They don't call it CAS, instead it's <a href="http://wiki.laptop.org/go/OLPC_Bitfrost" rel="nofollow noreferrer">BitFrost</a>. How's that for a real-world application: the <a href="http://wiki.laptop.org/go/One_Laptop_per_Child" rel="nofollow noreferrer">"One Laptop Per Child" project</a>, which relies on BitFrost as a replacement for the traditional Unix security model.</p>
<p><strong><em>Update:</em></strong><em> section on CAS in Unix/Linux as BitFrost and section on survey.<br/>
<strong>Update:</strong> added CAS vs ClickOnce section<br/>
<strong>Update:</strong> added list of resources using CAS (and apologies for all these updates in a row!)</em></p>
</div></text><author><a href="/users/111575/abel">Abel</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Technically, it's very useful as it allows a very fine grained permission specification. This is both good for you (as theoretically it makes exploiting security vulnerabilities a lot harder - even if an attacker gains full control over your app, he is still locked in the CAS Sandbox) and for your customer (as they can see exactly what your application can do and run their own security audit).</p>
<p>In practical use, it's mostly meaningless. I think it's too complex, too little supported by the available dev tools and most users don't care anyway.</p>
<p>There are exceptions of course (Governments and customers who really know .net/CAS) and I would love to say that CAS is absolutely useful and mandatory, but the reality speaks a clear language.</p>
</div></text><author><a href="/users/91/michael-stum">Michael Stum</a></author><comments><comment><text><span class="comment-copy">So yet another good ideal that does not pass the “real life” test, pity we all have to learn it to pass the exams…</span></text><author><a class="comment-user owner" href="/users/57159/ian-ringrose" title="27,314 reputation">Ian Ringrose</a></author></comment><comment><text><span class="comment-copy">Sadly yes. I see the main problem with the fact that there simply is no tooling for it. I simply do not know which permissions I need (at least not their internal names) and the stuff is quite complex. Ideally I would like to execute my app in a "Sandbox" and then get a report "Your app needed these permissions" so that I can review them and create the CAS policy from it, but such a sandbox does (AFAIK) not exist.</span></text><author><a class="comment-user" href="/users/91/michael-stum" title="101,279 reputation">Michael Stum<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">This is a great succint explanation and I can see value in it, it may be worth the extra headache.</span></text><author><a class="comment-user" href="/users/1810774/dellyjm" title="148 reputation">dellyjm</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Note to reader: see the two comments below; it sounds like I'm accidentally inflating the definition of CAS to (incorrectly) include RBS. I'll leave the answer here for reference, but note the distinction.</p>
<hr/>
<p>There are two havles to CAS; the thing you'll see most about <em>in that exam</em> is all the nuances for code calling other code, which <em>may</em> be useful for partial trust, but most of the time it is simply a pain - and worse: if your code has full trust (which most / too-much does) <strong>none of it actually executes</strong> (it is skipped entirely).</p>
<p>The <em>useful</em> part of <s>CAS</s> RBS is principal permission, which <em>is</em> used; of course, your UI should verify access to features, but you can put (in your low-down logic):</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pun">[</span><span class="typ">PrincipalPermission</span><span class="pun">(</span><span class="typ">SecurityAction</span><span class="pun">.</span><span class="typ">Demand</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Role</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ADMIN"</span><span class="pun">)]</span><span class="pln">
</span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="typ">DeleteOrder</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> id</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">}</span></code></pre>
<p>This will be enforced even in full trust; you can define your own principal (tied to the user) by implementing <code>IPrincipal</code> (look at <code>IsInRole()</code>). And since principals are supported in most environments (winforms, webforms, mvc, wcf, etc) this can make for a very flexible way to double-check security at the business layer <strong>without having to reference the specific security model</strong>. Note that the above check would work in <em>any</em> environment.</p>
<p>You can also perhaps use this to drive your UI. I did have a usenet post that enabled / disabled winforms controls based on the principal (using runtime properties to specify the role per control, a bit like <code>ToolTip</code> etc) - I can't find it at the minute, though (edit: <a href="http://groups.google.com/group/microsoft.public.dotnet.languages.csharp/browse_thread/thread/3c9eb4ca945ae674/e92fe84f600f56e1" rel="nofollow noreferrer">maybe this one</a>).</p>
</div></text><author><a href="/users/23354/marc-gravell">Marc Gravell</a></author><comments><comment><text><span class="comment-copy">AFAIK, PrincipalPermission does not fall under CAS, but instead under Role-Based Security. CAS places the trust determination in the hands of the site administrator. RBS places the trust determination in the hands of the developer. Huge fundamental difference.</span></text><author><a class="comment-user" href="/users/29805/g-wiz" title="6,037 reputation">G-Wiz</a></author></comment><comment><text><span class="comment-copy">I don't think CAS includes securing code based on Principal or user identity. In fact according to the definition of CAS from microsoft (<a href="http://msdn.microsoft.com/en-us/library/930b76w0.aspx" rel="nofollow noreferrer">msdn.microsoft.com/en-us/library/930b76w0.aspx</a>) it is explicitly described as something <i>beyond</i> giving permissions based on user identity, which is characterized as useful but not nearly sufficient.</span></text><author><a class="comment-user" href="/users/48082/cheeso" title="120,646 reputation">Cheeso</a></author></comment><comment><text><span class="comment-copy">@gWiz, @Cheeso - OK; thanks for the clarification. They are, then, merely <i>related</i> concepts. In which case, I guess my answer could be a lot shorter: "IMO, not so much" ;-p</span></text><author><a class="comment-user" href="/users/23354/marc-gravell" title="664,860 reputation">Marc Gravell<span class="mod-flair" title="moderator">♦</span></a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The thing to understand about Code Access Security is that it is of very little use to an application developer beyond understanding how it is being used and at what permission level for API's that you may be calling.  The only exception to this, that I have really found useful is a CAS called PrincipalPermission, it basically doesn't allow certain code to be executed if the right Role isn't defined for the current Principal.  See this post on it:</p>
<p><a href="http://www.coderjournal.com/2008/03/securing-mvc-controller-actions/" rel="nofollow noreferrer">http://www.coderjournal.com/2008/03/securing-mvc-controller-actions/</a></p>
<p>The developers that really need to pay attention to CAS and how it should be implemented in their application is the framework and code library developers.  Because there is certain levels of trust that you need to demand inorder for your application to work especially when dealing with unmanaged resources such as files, network streams, serial ports, etc.  Or if you are creating the code for that unmanaged resource like some speicalized server, or any kind of low level access in to your assemblies you will want to create some code access security around it so that people aren't allowed to execute something that has been strictly denied to them.</p>
<p>It doesn't help that Microsoft hasn't really done that great of a job explaining how CAS should be used in every day application.  So that is really the reason for lack of use.  However CAS is one of the many reasons that .NET is such a secure language and suffers from a lot fewer problems than its competitors.</p>
</div></text><author><a href="/users/17/nick-berardi">Nick Berardi</a></author><comments><comment><text><span class="comment-copy">PrincipalPermission is technically not Code Access Security, it is Role-Based Security. The difference is that Role-Based Security relies on the CurrentPrincipal as its evidence, whereas Code Access Security relies on the machine's security policy and assembly strong-naming. CurrentPrincipal is modifiable by the caller, so the trust lies in the developer's hands. Security policy is set by local adminstrator, so the trust lies in the operator's hands.</span></text><author><a class="comment-user" href="/users/29805/g-wiz" title="6,037 reputation">G-Wiz</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I was the development lead on a project to get <a href="http://jitc.fhu.disa.mil/dice/" rel="nofollow noreferrer">JITC certification</a> (US Department of Defense) for a .NET based solution, and the CAS settings were scrutinized very closely during the certification testing.</p>
<p>Like most of the other certification requirements, the code could only use the privileges it needed to work and no more. </p>
<p>If you are planning to get security certifications CAS can definitely be important.</p>
</div></text><author><a href="/users/67386/dana-holt">Dana Holt</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>One thing you should know is that Code Access Security is pretty much broken as a method for tamper-proofing.  See:</p>
<blockquote>
<p><a href="http://www.offbyzero.com/resources/cas_broken" rel="nofollow noreferrer">CAS Tamper-Proofing is Broken: Consequences for Software Licensing</a></p>
<p>...</p>
<p>Code Access Security can no longer be relied upon to prevent the use of tampered assemblies in shipped products. This means that if your application is dependent upon Code Access Security to perform licensing checks, it is trivial for an attacker to replace your licensing assembly with another, thereby gaining free access to your application. </p>
<p>...</p>
</blockquote>
</div></text><author><a href="/users/181452/duncan-bayne">Duncan Bayne</a></author><comments><comment><text><span class="comment-copy">This is more about removing the requirement for digitally signed "childed" assemblies rather then CAS.  You have always been able to disassemble the host remove the signing checks and then reassemble it.   How you can do it with a few mouse clicks...  +1 for pointing out that CAS is only as good as the protection you have on the host.</span></text><author><a class="comment-user owner" href="/users/57159/ian-ringrose" title="27,314 reputation">Ian Ringrose</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Although I've never used it, my understanding of CAS was that it could also be used to expand object-oriented design mechanics. For example, say you are developing a massive data access package for a bank that must implement database access and caching. Even though they are part of the same deployment package, given the hypothetical size of the project, the logic should be implemented in separate assemblies since they are sufficiently different problem sets that hinge on different external forces (database infrastructure vs consumer usage).</p>
<p>However, the caching code might need to access some sensitive classes or methods in the data access assembly that consumers of the overall package shouldn't have access to. Therefore these data access classes and methods can't simply be <code>public</code>. Protected methods in the data access assembly with subclasses in the caching assembly could get around some cases, but often times it's an abuse of inheritance. It might simply be more elegant to leave them <code>public</code> with LinkDemands placed on callers for a custom Permission (e.g. <code>DataPackagePermisson</code>) that administrators would only grant to the caching assembly.</p>
</div></text><author><a href="/users/29805/g-wiz">G-Wiz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>We used CAS for our Applications was not really to hard, since we'd only tried to stop unauthuorized code execution. Problems came up once using our software from local network share,  but a cas-policy cleaned the problem out.</p>
<ol>
<li>We secured all our assemblies using a strong name.</li>
<li>We created a cas-policy for all assemblies with our strong name and allowed code signed with our strong name to start from local area network and locally placed code. </li>
<li>Assemblies loaded from local area network needing local file access (component for burning data cds) needed to get the link-demand attribute on all public classes.</li>
</ol>
<p>Since update of .NET3.5 our problems were not existent anymore, since code on local area network is now handled like local code.</p>
</div></text><author><a href="/users/44532/oliver-friedrich">Oliver Friedrich</a></author><comments/></answer></answers></post>