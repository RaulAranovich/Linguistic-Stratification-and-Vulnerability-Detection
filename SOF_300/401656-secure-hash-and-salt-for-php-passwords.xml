<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Secure hash and salt for PHP passwords - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>It is currently said that MD5 is partially unsafe. Taking this into consideration, I'd like to know which mechanism to use for password protection.</p>
<p>This question, <a href="http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once">Is “double hashing” a password less secure than just hashing it once?</a> 
suggests that hashing multiple times may be a good idea, whereas <a href="http://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904">How to implement password protection for individual files?</a> suggests using salt.</p>
<p>I'm using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I'd prefer the result to have a constant number of characters.</p>
<ol>
<li>The hashing mechanism must be available in PHP</li>
<li>It must be safe</li>
<li>It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)</li>
</ol>
<p>Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?</p>
<p>In case I wasn't clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.</p>
<p><em>Related questions that don't quite cover my question:</em></p>
<p><a href="http://stackoverflow.com/questions/157998/whats-the-difference-between-sha-and-md5-in-php">What's the difference between SHA and MD5 in PHP</a><br/>
<a href="http://stackoverflow.com/questions/30946/simple-password-encryption">Simple Password Encryption</a><br/>
<a href="http://stackoverflow.com/questions/198803/secure-methods-of-storing-keys-passwords-for-asp-net">Secure methods of storing keys, passwords for asp.net</a><br/>
<a href="http://stackoverflow.com/questions/205153/how-would-you-implement-salted-passwords-in-tomcat-5-5">How would you implement salted passwords in Tomcat 5.5</a></p>
</div></text><author><a href="/users/426671/bluefeet">bluefeet</a></author><comments><comment><text><span class="comment-copy"><a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">openwall.com/phpass</a> is also very good library</span></text><author><a class="comment-user" href="/users/11926/alfred" title="40,598 reputation">Alfred</a></author></comment><comment><text><span class="comment-copy">Md5 is now completely unsafe</span></text><author><a class="comment-user" href="/users/578091/exceptionslayer" title="623 reputation">ExceptionSlayer</a></author></comment><comment><text><span class="comment-copy">@NSAwesomeGuy That depends on what you're using it for. It's trivial to rainbow-match or just brute force unsalted MD5 passwords, sure, but with decent salting it's still exceedingly impractical to build a rainbow table for fast cracking of sets of passwords, and brute force is a no-hoper.</span></text><author><a class="comment-user" href="/users/398670/craig-ringer" title="149,232 reputation">Craig Ringer</a></author></comment><comment><text><span class="comment-copy">PHP 5.5+ has a secure password hash built in <a href="http://php.net/manual/en/function.password-hash.php" rel="nofollow noreferrer">php.net/manual/en/function.password-hash.php</a></span></text><author><a class="comment-user" href="/users/621490/terence-johnson" title="1,541 reputation">Terence Johnson</a></author></comment><comment><text><span class="comment-copy"><a href="http://php.net/faq.password" rel="nofollow noreferrer">php.net/faq.password</a></span></text><author><a class="comment-user" href="/users/367456/hakre" title="140,478 reputation">hakre</a></author></comment><comment><text><span class="comment-copy"><a href="http://www.dev-metal.com/use-php-5-5-password-hashing-functions/" rel="nofollow noreferrer">How to use the PHP 5.5 password hashing functions</a></span></text><author><a class="comment-user" href="/users/1114320/sliq" title="7,257 reputation">Sliq</a></author></comment><comment><text><span class="comment-copy">Also see Openwall's <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">Portable PHP password hashing framework</a> (PHPass). Its hardened against a number of common attacks on user passwords.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>DISCLAIMER</strong>: This answer was written in 2008.</p>
<p>Since then, PHP has given us <a href="http://php.net/manual/en/function.password-hash.php" rel="noreferrer"><code>password_hash</code></a> and <a href="http://php.net/manual/en/function.password-verify.php" rel="noreferrer"><code>password_verify</code></a> and, since their introduction, they are the recommended password hashing &amp; checking method.</p>
<p>The theory of the answer is still a good read though.</p>
</blockquote>
<h2>TL;DR</h2>
<h3>Don'ts</h3>
<ul>
<li>Don't limit what characters users can enter for passwords. Only idiots do this.</li>
<li>Don't limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don't prevent them from using it.</li>
<li>Never store your user's password in plain-text.</li>
<li>Never email a password to your user <em>except when they have lost theirs, and you sent a temporary one.</em></li>
<li>Never, ever log passwords in any manner.</li>
<li>Never hash passwords with <a href="http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/" rel="noreferrer">SHA1</a> or MD5 or even SHA256! <a href="http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/" rel="noreferrer">Modern crackers</a> can exceed 60 and 180 billion hashes/second (respectively).</li>
<li>Don't mix <a href="http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html" rel="noreferrer">bcrypt and with the <em>raw</em> output of hash()</a>, either use hex output or base64_encode it. (This applies to any input that may have a rogue <code>\0</code> in it, which can seriously weaken security.)</li>
</ul>
<h3>Dos</h3>
<ul>
<li>Use scrypt when you can; bcrypt if you cannot.</li>
<li>Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.</li>
<li>Reset everyone's passwords when the database is compromised.</li>
<li>Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the "What makes a good password?" section for some debate.)</li>
</ul>
<h2>Why hash passwords anyway?</h2>
<p>The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.</p>
<p>Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at <em>least</em> lock the system down, if not change every password in the database.</p>
<p>Jeremiah Grossman, CTO of Whitehat Security, <a href="http://blog.whitehatsec.com/cracking-aes-256-dmgs-and-epic-self-pwnage/" rel="noreferrer">stated on his blog</a> after a recent password recovery that required brute-force breaking of his password protection:</p>
<blockquote>
<p>Interestingly, in living out this nightmare, I learned A LOT I didn’t know about password cracking, storage, and complexity. <em>I’ve come to appreciate why password storage is ever so much more important than password complexity. If you don’t know how your password is stored, then all you really can depend upon is complexity.</em> This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.</p>
</blockquote>
<p>(Emphasis mine.)</p>
<h2>What makes a <em>good</em> password anyway?</h2>
<p><a href="http://xkcd.com/936/" rel="noreferrer">Entropy</a>. (Not that I fully subscribe to Randall's viewpoint.)</p>
<p>In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that's only 26 characters. That isn't much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That's a lot better than just letters. One problem is, to make our passwords memorable we insert patterns—which reduces entropy. Oops!</p>
<p>Password entropy is <a href="https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/" rel="noreferrer">approximated</a> easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.</p>
<p>There's a longer discussion of password entropy on the <a href="https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password">Crypto StackExchange</a> site. A good Google search will also turn up a lot of results.</p>
<p>In the comments I talked with @popnoodles, who pointed out that <em>enforcing</em> a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.</p>
<p>So far as I've been able to tell, making the world's best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.</p>
<h2>Best practices</h2>
<p>Bcrypt and <a href="http://www.tarsnap.com/scrypt.html" rel="noreferrer">scrypt</a> are the current best practices. <a href="http://www.tarsnap.com/scrypt.html" rel="noreferrer">Scrypt</a> will be better than bcrypt in time, but it hasn't seen adoption as a standard by Linux/Unix or by webservers, and hasn't had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an <a href="http://rubygems.org/gems/scrypt" rel="noreferrer">scrypt gem</a> that will help you out, and Node.js now has its own <a href="https://npmjs.org/package/scrypt" rel="noreferrer">scrypt</a> package. You can use Scrypt in PHP either via the <a href="https://pecl.php.net/package/scrypt" rel="noreferrer">Scrypt</a> extension or the <a href="https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md" rel="noreferrer">Libsodium</a> extension (both are available in PECL).</p>
<p>I highly suggest reading the documentation for the <a href="http://us.php.net/crypt" rel="noreferrer">crypt function</a> if you want to understand how to use bcrypt, or finding yourself a <a href="http://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021">good</a> <a href="https://gist.github.com/1070401" rel="noreferrer">wrapper</a> or use something like <a href="http://www.openwall.com/phpass/" rel="noreferrer">PHPASS</a> for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.</p>
<p>I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish's key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish's already expensive key schedule.</p>
<h2>Average practices</h2>
<p>I almost can't imagine this situation anymore. <a href="http://www.openwall.com/phpass/" rel="noreferrer">PHPASS</a> supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginable—and should be used if you don't <em>know for certain</em> that your environment supports bcrypt.</p>
<p>But suppose that you cannot use bcrypt or PHPASS at all. What then?</p>
<p>Try an implementation of <a href="http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard" rel="noreferrer">PDKBF2</a> with the <a href="https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256">maximum number of rounds</a> that your environment/application/user-perception can tolerate. The lowest number I'd recommend is 2500 rounds. Also, make sure to use <a href="http://php.net/hash_hmac" rel="noreferrer">hash_hmac()</a> if it is available to make the operation harder to reproduce.</p>
<h2>Future Practices</h2>
<p>Coming in PHP 5.5 is a <a href="http://php.net/manual/en/ref.password.php" rel="noreferrer">full password protection library</a> that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a <a href="https://github.com/ircmaxell/password_compat" rel="noreferrer">compatibility layer</a> for the coming API that is backward compatible to PHP 5.3.7.</p>
<h2>Cryptography Recap &amp; Disclaimer</h2>
<p>The computational power required to actually <em>crack</em> a hashed password doesn't exist. The only way for computers to "crack" a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.</p>
<p>You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users <strong>up front</strong>. If you do not, then you might even miss the fact that you were attacked until it's too late... <em>and you're liable</em>. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user's accounts or access their data. If you don't test the security of your system, then you cannot blame anyone but yourself.</p>
<p>Lastly: I am not a cryptographer. Whatever I've said is my opinion, but I happen to think it's based on good ol' common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.</p>
</div></text><author><a href="/users/24950/robert-k">Robert K</a></author><comments><comment><text><span class="comment-copy">I see. But in my case, the person may have multiple emails. Should I use the ID(BIGINT primary key) instead?</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">@luiscubal: as long as the values for your salt come from a sufficiently large space, it will be a good salt.  Your ID value will probably suffice, especially if the number of records is large (the number of IDs will be large).</span></text><author><a class="comment-user" href="/users/10861/rmeador" title="18,301 reputation">rmeador</a></author></comment><comment><text><span class="comment-copy">you could use anything that the user only has one of, but ideally something that doesn't change.</span></text><author><a class="comment-user" href="/users/22224/tom-haigh" title="43,196 reputation">Tom Haigh</a></author></comment><comment><text><span class="comment-copy">I'd include something secret as well. The point is, you want the hash function's input to be consistent for a correct password, but you also want it to be nonguessable so someone can't brute-force guess the password offline. (vs. having to do it through your webpage which is much slower)</span></text><author><a class="comment-user" href="/users/44330/jason-s" title="91,124 reputation">Jason S</a></author></comment><comment><text><span class="comment-copy">a secret doesn't help as your password DB is supposed to be secret anyway - if they can get hold of that DB, they can also find whatever secret you're using. it is however important that the salt is random.</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment><comment><text><span class="comment-copy">note, it's not really true that 'the computational power to decrypt' doesn't exist yet. since most passwords are dictionary words or dictionary derived, a dictionary based attack is usually very effective (hence the use of password policies and iteration counts).</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment><comment><text><span class="comment-copy">Frank, while what you say is true, the algorithmic cycles it takes to generate the words doesn't make it feasible.  Don't forget the inclusion of the salt.  Brute force will always work if they know your hash algorithm and salt, otherwise it's <i>virtually</i> impossible.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">But that doesn't make insecure passwords any safer.  It just makes the database rows safer if compromised, at which point you should change your salt immediately and inform your users to change their passwords.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">Even when the salt and algorithm are known, finding a password by brute-force search will take many years if the proper method is used. Passwords are cracked when they are predicted by following a pattern, such as transforming dictionary words and incorporating other cribs. An essential part of the method is some sort of computationally intensive key stretching technique, like using thousands of iterations of the hash function.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">42, if I were designing a truly secure system, I'd suggest a military grade hash algorithm anyway with a ~16bit randomly generated number stored in the database.  In general use, a salt with a password is better than none--unless either is compromised.  I'm not claiming to be an expert, nothing is better than enforced password rotation plus a military-grade algorithm, but for basic non-critical software this is enough.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@wicked flea, I'm not arguing with you.  Just pointing out how convoluted and complex this area of our work is.  I keep hoping to get schooled by the be-all, end-all smartest, best practice for setting up a small web site's content management system.  I'm still learning here.  ...every time I read something that makes sense, I soon notice 5 other posts that contradict it.  that round-and-round gets dizzying quickly :)</span></text><author><a class="comment-user" href="/users/70870/m42" title="1,898 reputation">m42</a></author></comment><comment><text><span class="comment-copy">Absolutely!  I've just shared what I've found.  I found a number of things from Shneier on Security and a very long (convoluted) discussion on a news site (don't remember which now).</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy"><i>"Even MD5 is still safe, as aside from a brute-force attack the computational power needed to decrypt doesn't exist yet."</i> OMG, I don't believe it. MD5 can't be "decrypted", period. But it is definitly <i>not</i> safe, as it is. <b>Ever heard of rainbow tables?</b></span></text><author><a class="comment-user" href="/users/207655/o0" title="6,978 reputation">o0'.</a></author></comment><comment><text><span class="comment-copy">Look, if you're using MD5 on software that requires high security (like a store) then YOU'RE the fool, not me.  I know that MD5 is extremely fast, but if you're designing forum software with good practices it's still generally secure.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">Interesting revision. Is the user ID(say, an auto increment BIGINT) a good nonce? Or since it's not random it isn't good? Also, I'll have to store the nonce for each user in the database... Does the site key + nonce + HMAC provide significant improved security over a salted(with user ID) hash iterated multiple times? Similarly, is iterating HMAC multiple times good for security?</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">Excellent post. Answered many of my own questions. However, I am uncertain of what it means to save the site_key in the file system. Could you please explain? For me, even a .php file in a folder on the server is the file system.</span></text><author><a class="comment-user" href="/users/383148/francisc" title="26,229 reputation">Francisc</a></author></comment><comment><text><span class="comment-copy">The article that <b>42</b> linked 404s—here's a copy <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">chargen.matasano.com/chargen/2007/9/7/…</a></span></text><author><a class="comment-user" href="/users/17339/drew-stephens" title="7,411 reputation">Drew Stephens</a></author></comment><comment><text><span class="comment-copy">I'll update it about bcrypt sometime. I've been busy and the scheme I suggested is at least moderately effective. Better that than someone just throwing a plain md5/sha1 hashed password in their DB.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">no other way to save random number of $nonce except save it to db?  If the hacker can get hashed_password from db, sure he able to get nonce from db too</span></text><author><a class="comment-user" href="/users/650312/zac1987" title="960 reputation">zac1987</a></author></comment><comment><text><span class="comment-copy">Great revision. I've been using bcrypt for some time now, and I guess I'll start looking into scrypt for future projects.</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">I think even emailing a new password in case of a lost one is a bad idea. Why not email a link to a secure site that allows the user to change his password? That's much more comfortable (no need to change the password after logging in with the random one) and more secure since no password went over the wire unencrypted - remember, users are lazy and chances are good that they do not change the random password.</span></text><author><a class="comment-user" href="/users/298479/thiefmaster" title="201,303 reputation">ThiefMaster<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Sending a temporary password through email that requires the user to change it the first time they use it and sending a "secure" link over email that allows them to set their password are equally risky. In either case anyone who intercepts the email can access the account as long as they use the link or password before the intended recipient does.</span></text><author><a class="comment-user" href="/users/186541/tim-gautier" title="15,853 reputation">Tim Gautier</a></author></comment><comment><text><span class="comment-copy">Regarding your most recent edit: "require at least 1 upper case letter, 1 lower case letter, a number, and a symbol" is in direct contradiction with the xkcd comic in the link. It shows an example of a password with <i>no symbols</i>, but <i>high entropy</i>.</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">@luiscubal I'm not sure Randall is right, so I don't 100% endorse his suggestion though I've tried it. With lowercase/spaces your entropy is ~4.75/character, which for 28 characters is about 131-133 bits of entropy. But there's only four words there, with ~1 million words in the English language that's 1e+24 combinations versus upper/lower/symbols at 28 characters is 3.18855e+55 or so. Anyway, I'm not 100% convinced.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@RobertK Humans are imperfect random number generators, which greatly lowers the entropy in both cases. They won't pick a perfectly random <code>[a-zA-Z0-9_$%#]{28}</code> sequence - they are more likely to just pick something like <code>$justinBieber28</code>.</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">@luiscubal You are correct. However a password manager that can do just that is <i>invaluable</i>. Which is the other problem with Randall's suggestion: his method produces pseudorandom combinations less random than our pseudorandom gibberish passwords. That's why it was only a suggestion of something to do. One's probably as secure as the other (for now).</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@RobertK Note that he never truly checks the entropy of "complete gibberish", because people tend not to use complete gibberish for passwords. Computer-generated passwords can be much better than human-generated passwords, but how many people would just hit the "regenerate" button until they got something easy to remember? Or even tweak the result to be simpler? All that lowers entropy.</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">@luiscubal I said a password <i>manager</i> not just a generator. I personally use LastPass to generate/remember passwords, and just make the best password I can to lock that service down. That keeps entropy high for other sites. As a user it's the best solution I've come across so far.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">Just read the update, and it looks much better. Removing my -1. Perhaps it would be worth mentioning the new 5.5 APIs: <a href="http://php.net/manual/en/ref.password.php" rel="nofollow noreferrer">php.net/manual/en/ref.password.php</a> and the compatibility project: <a href="https://github.com/ircmaxell/password_compat" rel="nofollow noreferrer">github.com/ircmaxell/password_compat</a> And thanks for updating the answer!!!</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">requiring at least 1 upper case letter, 1 lower case letter, a number, and a symbol will not improve the entropy of the password, it will just make it harder for people to remember.</span></text><author><a class="comment-user" href="/users/822711/popnoodles" title="21,690 reputation">Popnoodles</a></author></comment><comment><text><span class="comment-copy">@popnoodles By expanding the character set and the number of used characters it expands the bits of entropy per character, it does NOT safeguard against non-random passwords by users.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@RobertK By expanding the character set yes it increases, BUT by forcing all passwords to to follow rules decreases the amount of possible options. Let's say someone was to get a password by brute force. By telling them the user's password has  1 upper case letter, 1 lower case letter, a number, and a symbol, it means the number of tries they need is significantly less. By allowing the user to decide what they want, the hacker has to try harder.</span></text><author><a class="comment-user" href="/users/822711/popnoodles" title="21,690 reputation">Popnoodles</a></author></comment><comment><text><span class="comment-copy">@popnoodles That's an excellent point that I totally missed: I gave the suggestion as placing a hard-requirement that would limit the number of possible plaintexts. Thanks for pointing that out!</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">"This will improve the entropy of the password" - if you force somebody to use at least one number then you've reduced the entropy of the password as there are only 10 digits to choose from</span></text><author><a class="comment-user" href="/users/209744/pp" title="8,299 reputation">PP.</a></author></comment><comment><text><span class="comment-copy">@RobertK not sure why you personally attacked me with sarcasm there - "cliff-notes version". I'll ask the moderators to give you a temporary suspension because it was out of order.</span></text><author><a class="comment-user" href="/users/209744/pp" title="8,299 reputation">PP.</a></author></comment><comment><text><span class="comment-copy">@PP. I don't understand what you read as sarcasm. The TL;DR section at the top of my answer is the "cliff-notes version" of the long part of my answer. All I asked was that you respond to specific points in the relevant section, rather than the TL;DR summary which doesn't contain any of the debate about the subject.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">Also consider hashing it on client side, this way even if the server got corrupted in any way, the original passwords cannot be retrieved!</span></text><author><span class="comment-user">user2509223</span></author></comment><comment><text><span class="comment-copy">@derylius Unless your log in code is delivered in a plugin, you cannot verify that the javascript code is your original code with no compromises. Also, sending a hash to be compared against a hash in the DB is just as dangerous (it takes the place of the password). This isn't a very good, or safe, idea. It's better to rely upon connection security than it is javascript security.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@RobertK I guess you misunderstood me. I didn't say do this instead of setting up a secure connection, what I suggested is to do this in addition, cause even if the connection is secure, if the server get compromised, then every single request sent to that server potentially shows plain passwords to the attackers. So my point is, that as a user I don't want to trust any server, but that doesn't mean I want to remember a 64 character long hash string instead of the color of my favorite fruit. (Further explanation here: <a href="http://xkcd.com/936/" rel="nofollow noreferrer">xkcd.com/936</a>)</span></text><author><span class="comment-user">user2509223</span></author></comment><comment><text><span class="comment-copy">@derylius Yeah, I probably misunderstood. However, sending the hash to the server is just as bad. Though I think <a href="https://www.grc.com/sqrl/sqrl.htm" rel="nofollow noreferrer">SQRL</a> by Steve Gibson shows really good promise.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@RobertK its really just a small addition that protects the password itself, not the environment. But since the passwords must be hashed anyway to store it, hashing it on client side instead of server side is not so much extra code adding some to the security without taking out any of it.</span></text><author><span class="comment-user">user2509223</span></author></comment><comment><text><span class="comment-copy">I'm also of the opinion that passwords should not expire. Forcing users to create new passwords and disallowing them from using previously used passwords results in users choosing worse and worse combinations as they can never remember them. Sure they shouldn't be remembering anyway, but I'm talking reality not ideal world.</span></text><author><a class="comment-user" href="/users/2438830/mryellow" title="424 reputation">MrYellow</a></author></comment><comment><text><span class="comment-copy">@MrYellow In general I dislike password expiry too. But preventing the use of previous passwords is a good idea for high security applications. After all, you wouldn't want somebody alternating passwords on something highly sensitive. But I left those out because they felt like subjective conclusions. Those are harder to prove than "X algorithm can be calculated in Y M-hashes/sec".</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">@RobertK I've heard strategies from people who will just reset their password 15 times to expire the "previously used" list and get back to a password they can remember... yeah agree the numbers aren't cut and dry on this part of the question. It's debatable and the correct choice is different depending on systems purpose.</span></text><author><a class="comment-user" href="/users/2438830/mryellow" title="424 reputation">MrYellow</a></author></comment><comment><text><span class="comment-copy">@MrYellow Yeah, I'm not surprised. About the only way the password expiry scheme would work is if past passwords were stored, then levenshtein distance was used to validate a new password. It's tyrannical, but it's about the only way to ensure users don't pick "password" then "password1", then "password2", etc. (Not that I advise doing this...)</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">Regarding forcing users to implement a password with every type of character: first it will piss them off and make them go away, two, it is not even necessary/useful. Instead just start locking out the account after too many attempts/too quick of attempts Even if you just restrict it to 1 password attempt per second, you've crippled a brute force cracker's options, no?</span></text><author><a class="comment-user" href="/users/3093731/andrew" title="3,061 reputation">Andrew</a></author></comment><comment><text><span class="comment-copy">How to recover password when users forgot it?</span></text><author><a class="comment-user" href="/users/3760297/iman-marashi" title="854 reputation">Iman Marashi</a></author></comment><comment><text><span class="comment-copy">@ImanMarashi the way I would do it is(and please do correct me if I am a dumbass:P): make a forgot password page and let him fill in a field with his email address. When the user clicks on send you generate a random password <a href="http://stackoverflow.com/questions/6101956/generating-a-random-password-in-php">maybe this will help</a> (which ofcourse should be hashed again) and send an email to him with the random password inside and a link the page of his account and tell him to change his password. That's how I would do it maybe I am totally wrong but then I'm interested to see how it should be done</span></text><author><a class="comment-user" href="/users/5396496/broebie" title="353 reputation">BRoebie</a></author></comment><comment><text><span class="comment-copy">@BRoebie I don't advise changing the user's password, because someone fishing for users/emails could then lock users out. Instead, generate a token with a short expiry time (like &lt; 15 minutes) and use that token in the email's link to a reset page. That's more secure. But reseting passwords via email is never particularly secure (IMO).</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">Thank you for your reply. I will definitely use that method. I will look around the internet for some examples. Can you give me a timestamp I should use before it expires. For example would an hour be acceptable too? I know that it would be less secure but some mail services are quite slow</span></text><author><a class="comment-user" href="/users/5396496/broebie" title="353 reputation">BRoebie</a></author></comment><comment><text><span class="comment-copy">I have to disagree with requiring an uppercase letter, lowercase letter, a number, and a symbol all at once. All that's going to do, is make people enter "Password1!" instead of "password". Or worse, they'd write it down on post-its. Such restrictions are irrelevant for password manager users, but even then, don't implement such harsh restrictions unless you're a bank or payment service.</span></text><author><a class="comment-user" href="/users/3714134/hugo-zink" title="165 reputation">Hugo Zink</a></author></comment><comment><text><span class="comment-copy">In place of scrypt and bcrypt you should nowadays probably be looking at <a href="https://password-hashing.net/" rel="nofollow noreferrer">argon2</a>, which won the password hashing competition.</span></text><author><a class="comment-user" href="/users/248065/thom-wiggers" title="4,421 reputation">Thom Wiggers</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A much shorter and safer answer - <strong>don't write your own password mechanism at all</strong>, use a tried and tested mechanism.</p>
<ul>
<li>PHP 5.5 or higher: <a href="http://php.net/manual/en/function.password-hash.php" rel="nofollow noreferrer">password_hash()</a> is good quality and part of PHP core.</li>
<li>Older PHP versions: OpenWall's <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">phpass</a> library is much better than most custom code and used in WordPress, Drupal, etc.</li>
</ul>
<p>Most programmers just don't have the expertise to write crypto related code safely without introducing vulnerabilities.</p>
<p><strong>Quick self-test:</strong> what is password stretching and how many iterations should you use?  If you don't know the answer, you should use <code>password_hash()</code> or <code>phpass</code>, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of <a href="http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/" rel="nofollow noreferrer">GPUs and FPGAs</a> to crack passwords at rates of <a href="http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches" rel="nofollow noreferrer">billions of guesses per second</a> (with GPUs).</p>
<p>For example, you can <a href="http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/" rel="nofollow noreferrer">crack all 8-character Windows passwords in 6 hours</a> using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking <em>every 8-character Windows password</em>, including special characters, and is not a dictionary attack. That was in 2012, as of 2016 you could use fewer GPUs.</p>
<p>There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.  All this is because Windows <em>still</em> <a href="https://superuser.com/a/118279/90231">doesn't salt or stretch</a> its passwords - don't make the same mistake as Microsoft did!</p>
<p><strong>See also:</strong> </p>
<ul>
<li><a href="http://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919">excellent answer</a> with more about why <code>password_hash()</code> or <code>phpass</code> are the best way to go.</li>
<li><a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/" rel="nofollow noreferrer">good blog article</a> giving recommmended 'work factors' (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.</li>
</ul>
</div></text><author><a href="/users/992887/richvel">RichVel</a></author><comments><comment><text><span class="comment-copy">but these systems are better known and maybe already compromised. but it beats making your own when you don't know what your doing.</span></text><author><a class="comment-user" href="/users/578091/exceptionslayer" title="623 reputation">ExceptionSlayer</a></author></comment><comment><text><span class="comment-copy">Re "these systems are better known and maybe already compromised" - there is no reason why a well designed system for authentication should become "already compromised" just because it is better known.  Libraries such as phpass are written by experts and reviewed by many people in detail - the fact they are well known goes along with detailed review by different people and is more likely to mean they are secure.</span></text><author><a class="comment-user" href="/users/992887/richvel" title="1,920 reputation">RichVel</a></author></comment><comment><text><span class="comment-copy">Given the recent password hash dumps from LinkedIn, Last.fm and others, this is quite topical.  You are in good company in not knowing how to write your own password mechanism!</span></text><author><a class="comment-user" href="/users/992887/richvel" title="1,920 reputation">RichVel</a></author></comment><comment><text><span class="comment-copy">"don't write your own password mechanism at all" - but the truly paranoid will want to write their own to minimise probability the NSA have a backdoor.</span></text><author><a class="comment-user" href="/users/209744/pp" title="8,299 reputation">PP.</a></author></comment><comment><text><span class="comment-copy">@PP - the chances of a peer-reviewed password hashing algorithm having an NSA backdoor are very low, in my view.  The chances of someone who is not a real crypto expert writing a new password hashing mechanism without other vulnerabilities is much lower.  And the typical webapp uses just MD5 or SHA-1 hashing, which is terrible  - even Chris Shiflett's otherwise great Essential PHP Security book recommends MD5 ...</span></text><author><a class="comment-user" href="/users/992887/richvel" title="1,920 reputation">RichVel</a></author></comment><comment><text><span class="comment-copy">my heart bleeds, when i read that</span></text><author><a class="comment-user" href="/users/2441561/yamm" title="89 reputation">YAMM</a></author></comment><comment><text><span class="comment-copy">phpass is NOT the best way to go.  Never has been and likely never will be.  I reviewed the code several years ago and it is NOT secure on Windows or any platform where /dev/urandom is not available.  It does NOT follow best-practices when it comes to security, using a combination of md5() and microtime() when it should be terminating the application instead of making false claims about security.  It hasn't seen any updates since I reviewed the code despite PHP itself moving ahead in the security space with bcrypt in core.  Stay FAR away from phpass.</span></text><author><a class="comment-user" href="/users/917198/cubiclesoft" title="639 reputation">CubicleSoft</a></author></comment><comment><text><span class="comment-copy">@CubicleSoft - can you recommend another PHP library for password hashing?  Unless there's a better library, phpass will still be better than the vast majority of custom code that uses unsalted and unstretched MD5.</span></text><author><a class="comment-user" href="/users/992887/richvel" title="1,920 reputation">RichVel</a></author></comment><comment><text><span class="comment-copy">@RichVel - The password_hash() function.  As mentioned earlier, it's built into PHP core (aka /ext/standard).</span></text><author><a class="comment-user" href="/users/917198/cubiclesoft" title="639 reputation">CubicleSoft</a></author></comment><comment><text><span class="comment-copy">@CubicleSoft - password_hash() defaults to bcrypt and has a cost function for stretching, so it seems good for people on PHP 5.5 or higher - <a href="http://php.net/manual/en/function.password-hash.php" rel="nofollow noreferrer">php.net/manual/en/function.password-hash.php</a>.  phpass supports earlier PHP versions where it is certainly better than <i>most people's</i> custom code built on MD5 etc.</span></text><author><a class="comment-user" href="/users/992887/richvel" title="1,920 reputation">RichVel</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.</p>
</div></text><author><a href="/users/22224/tom-haigh">Tom Haigh</a></author><comments><comment><text><span class="comment-copy">not for password hashing. the attacker only needs to break one hash to retrieve the password. the point is moot anyway as neither MD5 nor SHA1 have any practical breaks available in the password scenario.</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment><comment><text><span class="comment-copy">sorry, i misread your answer as recommending using two hashes...you are in fact correct. Using two hashes weakens the system in the password case, as they only need to break the weaker hash.</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer. </p>
<p>More explanation is available at- <a href="http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/" rel="noreferrer">http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/</a></p>
<blockquote>
<p>Recently I had a discussion whether password hashes salted with random
  bits are more secure than the one salted with guessable or known
  salts. Let’s see: If the system storing password is compromised as
  well as the system which stores the random salt, the attacker will
  have access to hash as well as salt, so whether the salt is random or
  not, doesn’t matter. The attacker will can generate pre-computed
  rainbow tables to crack the hash. Here comes the interesting part- it
  is not so trivial to generate pre-computed tables. Let us take example
  of WPA security model. Your WPA password is actually never sent to
  Wireless Access Point. Instead, it is hashed with your SSID (the
  network name- like Linksys, Dlink etc). A very good explanation of how
  this works is here. In order to retrieve password from hash, you will
  need to know the password as well as salt (network name). Church of
  Wifi has already pre-computed hash tables which has top 1000 SSIDs and
  about 1 million passwords. The size is of all tables is about 40 GB.
  As you can read on their site, someone used 15 FGPA arrays for 3 days
  to generate  these tables. Assuming victim is using the SSID as
  “a387csf3″ and password as “123456″, will it be cracked by those
  tables? No! .. it cannot. Even if the password is weak, the tables
  don’t have hashes for SSID a387csf3.  This is the beauty of having
  random salt. It will deter crackers who thrive upon pre-computed
  tables. Can it stop a determined hacker? Probably not. But using
  random salts does provide additional layer of defense. While we are on
  this topic, let us discuss additional advantage of storing random
  salts on a separate system. Scenario #1 : Password hashes are stored
  on system X and salt values used for hashing are stored on system Y.
  These salt values are guessable or known (e.g. username) Scenario#2 :
  Password hashes are stored on system X and salt values used for
  hashing are stored on system Y. These salt values are random. In case
  system X has been compromised, as you can guess, there is a huge
  advantage of using random salt on a separate system (Scenario #2) .
  The attacker will need to guess addition values to be able to crack
  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2
  billion) iterations will can be required for each password guessed.</p>
</blockquote>
</div></text><author><a href="/users/271497/gaurav-kumar">Gaurav Kumar</a></author><comments><comment><text><span class="comment-copy">Even if the attacker gets the salt, a "sitesalt:usersalt:password" string is still resistant to precomputed tables, since the attacker needs to generate the tables for every user(so the attack becomes far slower), unless of course a specific user is being targeted...</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">Regarding "Even if the attacker gets the salt, a "sitesalt:usersalt:password" string is still resistant to precomputed tables" , Totally agree. My point is that sitesalt if made random and long, will make system more secure than it (sitesalt) being predictable. I've seen some people recommending use of email id etc as salt, and I discourage that.</span></text><author><a class="comment-user" href="/users/271497/gaurav-kumar" title="229 reputation">Gaurav Kumar</a></author></comment><comment><text><span class="comment-copy">You missed what I originally wrote. I said to use a random nonce, stored with the record, PLUS the email address. The addition of the email address makes for extra entropy for the hacker to work on. I've since rewritten my answer in favor of bcrypt.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I just want to point out that PHP 5.5 includes a <a href="http://www.php.net/manual/en/ref.password.php">password hashing API</a> that provides a wrapper around <code>crypt()</code>. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a <a href="https://github.com/ircmaxell/password_compat">compatibility pack</a> (in the form of a single password.php file that you simply <code>require</code> to use), for those using PHP 5.3.7 and later and want to use this right now.</p>
<p>It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a "secure" salt if you do not explicitly define your own.</p>
<p>The API exposes four functions:</p>
<ul>
<li><code>password_get_info()</code> - returns information about the given hash</li>
<li><code>password_hash()</code> - creates a password hash</li>
<li><code>password_needs_rehash()</code> - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary</li>
<li><code>password_verify()</code> - verifies that a password matches a hash</li>
</ul>
<p>At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT "may change in newer PHP releases when newer, stronger hashing algorithms are supported." Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.</p>
<p>EDIT: I just realised that this is mentioned briefly in Robert K's answer. I'll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don't know security.</p>
</div></text><author><a href="/users/918406/jonocoetzee">JonoCoetzee</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, <a href="http://php.net/manual/en/function.password-hash.php" rel="noreferrer">password_hash()</a> and <a href="http://php.net/manual/en/function.password-verify.php" rel="noreferrer">password_verify()</a></p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$password </span><span class="pun">=</span><span class="pln"> </span><span class="str">'anna'</span><span class="pun">;</span><span class="pln">
$hash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> PASSWORD_DEFAULT</span><span class="pun">);</span><span class="pln">
$expensiveHash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> PASSWORD_DEFAULT</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="str">'cost'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="lit">20</span><span class="pun">));</span><span class="pln">

password_verify</span><span class="pun">(</span><span class="str">'anna'</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">);</span><span class="pln"> </span><span class="com">//Returns true</span><span class="pln">
password_verify</span><span class="pun">(</span><span class="str">'anna'</span><span class="pun">,</span><span class="pln"> $expensiveHash</span><span class="pun">);</span><span class="pln"> </span><span class="com">//Also returns true</span><span class="pln">
password_verify</span><span class="pun">(</span><span class="str">'elsa'</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">);</span><span class="pln"> </span><span class="com">//Returns false</span></code></pre>
<p>When <code>password_hash()</code> is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) <code>password_verify()</code> then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.</p>
<p>Providing the <code>PASSWORD_DEFAULT</code> instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.</p>
<p>Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server's CPU.</p>
<p>Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and <code>password_verify()</code> picks up on it.</p>
</div></text><author><a href="/users/2457005/alliterativealice">AlliterativeAlice</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm using <a href="http://www.openwall.com/phpass/">Phpass</a> which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also <a href="http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4">The H</a>.</p>
<p>By default it used strongest available encryption that is implemented in Phpass, which is <code>bcrypt</code> and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.</p>
<p>The returned hash could be stored in database as it is. Sample use for generating hash is:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$t_hasher </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">PasswordHash</span><span class="pun">(</span><span class="lit">8</span><span class="pun">,</span><span class="pln"> FALSE</span><span class="pun">);</span><span class="pln">
$hash </span><span class="pun">=</span><span class="pln"> $t_hasher</span><span class="pun">-&gt;</span><span class="typ">HashPassword</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">);</span></code></pre>
<p>To verify password, one can use:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$t_hasher </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">PasswordHash</span><span class="pun">(</span><span class="lit">8</span><span class="pun">,</span><span class="pln"> FALSE</span><span class="pun">);</span><span class="pln">
$check </span><span class="pun">=</span><span class="pln"> $t_hasher</span><span class="pun">-&gt;</span><span class="typ">CheckPassword</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/672452/rabudde">rabudde</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Google says SHA256 is available to PHP.</p>
<p>You should definitely use a salt. I'd recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.</p>
</div></text><author><a href="/users/34479/aticusfinch">AticusFinch</a></author><comments><comment><text><span class="comment-copy">64 bits ought to be enough for anyone?</span></text><author><a class="comment-user" href="/users/327563/konerak" title="28,671 reputation">Konerak</a></author></comment><comment><text><span class="comment-copy">@Konerak, I'd get back to this after 20 years. :) But yep SHA256 is indeed available. If you want to know how secure SHA256 is, you might want to check  this out: <a href="http://security.stackexchange.com/questions/90064/how-secure-are-sha256-salt-hashes-for-password-storage" title="how secure are sha256 salt hashes for password storage">security.stackexchange.com/questions/90064/…</a></span></text><author><a class="comment-user" href="/users/2888922/vincent-edward-gedaria-binua" title="171 reputation">Vincent Edward Gedaria Binua</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>THINGS TO REMEMBER</strong></p>
<p>A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.</p>
<p><strong>SERVER</strong></p>
<p><em>PORTS</em></p>
<p>No matter how good your encryption is if you don't properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system. </p>
<p><em>USERNAME</em></p>
<p>For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.</p>
<p><em>PASSWORD</em></p>
<p>You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.</p>
<p><strong>DATABASE</strong></p>
<p><em>SERVER</em></p>
<p>Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.</p>
<p><em>USER</em></p>
<p>Always have your application have its own account to access the DB, and only give it the privileges it will need. </p>
<p>Then have a separate user account for you that is not stored anywhere on the server, not even in the application. </p>
<p>Like always DO NOT make this root or something similar.</p>
<p><em>PASSWORD</em></p>
<p>Follow the same guidelines as with all good passwords. Also don't reuse the same password on any SERVER or DB accounts on the same system.</p>
<p><strong>PHP</strong></p>
<p><em>PASSWORD</em></p>
<p>NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.</p>
<p><em>HASHING</em></p>
<p>ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don't reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn't know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.</p>
<p>There are a lot of good hashing functions out there (<code>password_hash</code>, <code>hash</code>, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.) </p>
<p>When hashing speed is the key, the slower the more resistant to Brute Force attacks. </p>
<p>One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.</p>
<p><em>SALTING</em></p>
<p>Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don't appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them. </p>
<p>When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker. </p>
<p><em>USERS CREATING PASSWORDS</em></p>
<p>If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL's Heartbleed flaw is an example of this). </p>
<p>Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.</p>
<p>Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.</p>
<p>Here is a PHP class that creates a hash and salt for a password easily</p>
<p><a href="http://git.io/mSJqpw">http://git.io/mSJqpw</a></p>
</div></text><author><a href="/users/2630704/wmfrancia">wmfrancia</a></author><comments><comment><text><span class="comment-copy">You should strike SHA512 from your list of decent hash algorithms, because it is too fast. Use it only in combination with PBKDF2. While BCrypt is based on blowfish, blowfish itself is an algorithm for encryption, not for hashing.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">How do you store the random salt in the DB? I think you don't hash it (cannot be used for verification) nor store in clear (no real benefits if the attacker can read the DB). So, how you do it?</span></text><author><a class="comment-user" href="/users/1155168/iazel" title="1,075 reputation">Iazel</a></author></comment><comment><text><span class="comment-copy">wmfrancia wrote: "Salting adds a random string to the password so similar passwords don't appear the same in the DB". This does not make sense to me. Hashes in the DB will already appear dissimilar because that is a property of hash functions.</span></text><author><a class="comment-user" href="/users/427155/h2onacl" title="3,217 reputation">H2ONaCl</a></author></comment><comment><text><span class="comment-copy">wmfancia wrote in regard to a constant salt: "once an attacker figures out one password salt he has the salt for all of them". The same can be said that if the hacker figures out which DB field is the salt, he has the salts for all of them. Since a constant salt would probably not be in the DB, that is a good thing about a constant salt.</span></text><author><a class="comment-user" href="/users/427155/h2onacl" title="3,217 reputation">H2ONaCl</a></author></comment><comment><text><span class="comment-copy">Of course, these comments are not to suggest a random salt per user is not better than one salt per application. It is better.</span></text><author><a class="comment-user" href="/users/427155/h2onacl" title="3,217 reputation">H2ONaCl</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.</p>
</div></text><author><a href="/users/50023/max">Max</a></author><comments><comment><text><span class="comment-copy">multiple hashing also protects against dictionary and brute force attacks - i.e. it simply makes them take longer to compute.</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment><comment><text><span class="comment-copy">double hashing won't give you a significant advantage but multi round hashing iterations are still a feasible defense against dictionary and bruce force attacks. Industrial strength password hashes use 1000+ rounds. PKCS#5's PBKDF1 suggests 1000 rounds minimum.</span></text><author><a class="comment-user" href="/users/49709/berk-d-demir" title="3,837 reputation">Berk D. Demir</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).</p>
<p>SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you're preventing the use of a generic <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="nofollow noreferrer">rainbow table</a> to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that's why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.</p>
</div></text><author><a href="/users/10861/rmeador">rmeador</a></author><comments><comment><text><span class="comment-copy">constant salt is not a great idea...probably not a fatal flaw but it unnecessarily weakens the scheme.</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment><comment><text><span class="comment-copy">MD5 and SHA1 are fast, so this is a bad diea.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><a href="http://php.net/sha1" rel="nofollow noreferrer">SHA1</a> and a salt should suffice (depending, naturally, on whether you are coding something for <a href="http://en.wikipedia.org/wiki/United_States_Bullion_Depository" rel="nofollow noreferrer">Fort Knox</a> or a login system for your shopping list) for the foreseeable future. If SHA1 isn't good enough for you, use <a href="http://php.net/manual/en/function.hash.php" rel="nofollow noreferrer">SHA256</a>.</p>
<p>The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is <code>d41d8cd98f00b204e9800998ecf8427e</code>. So, if someone with good enough a memory would see that hash and know that it's the hash of an empty string. But if the string is salted (say, with the string "<code>MY_PERSONAL_SALT</code>"), the hash for the 'empty string' (i.e. "<code>MY_PERSONAL_SALT</code>") becomes <code>aeac2612626724592271634fb14d3ea6</code>, hence non-obvious to backtrace. What I'm trying to say, that it's better to use <em>any</em> salt, than not to. Therefore, it's not too much of an importance to know <em>which</em> salt to use.</p>
<p>There are actually <a href="http://gdataonline.com/seekhash.php" rel="nofollow noreferrer">websites that do just this</a> - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.</p>
<p>Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This <em>could</em> be regarded as another form of salting, but I wouldn't recommend it.</p>
</div></text><author><a href="/users/2238/henrik-paul">Henrik Paul</a></author><comments><comment><text><span class="comment-copy">The target site shouldn't contain anything too sensitive(it's not a bank), but still I'd rather have it secured.</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">double hashing does not reduce the result space. iterative hashing is a common control against dictionary and brute force attacks (it slows them down much more than it slows down your password checking).</span></text><author><a class="comment-user" href="/users/42404/frankodwyer" title="11,167 reputation">frankodwyer</a></author></comment><comment><text><span class="comment-copy">@frankodwyer: yes, it is bad. <code>sha1(sha1($foo))</code> effectively reduces the output space, because any collision of the inner function will automatically become a collision of the outer one. The degradation is linear, but it's still a concern. The iterative hashing methods feed data back in on each round, such as <code>$hash = sha1(sha1($salt . $password) . $salt)</code>. But that's still not good... Stick with PBKDF2 or Bcrypt...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I found perfect topic on this matter here: <a href="https://crackstation.net/hashing-security.htm" rel="nofollow">https://crackstation.net/hashing-security.htm</a>, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
</span><span class="com">/*
 * Password hashing with PBKDF2.
 * Author: havoc AT defuse.ca
 * www: https://defuse.ca/php-pbkdf2.htm
 */</span><span class="pln">

</span><span class="com">// These constants may be changed without breaking existing hashes.</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"PBKDF2_HASH_ALGORITHM"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"sha256"</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"PBKDF2_ITERATIONS"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1000</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"PBKDF2_SALT_BYTES"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">24</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"PBKDF2_HASH_BYTES"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">24</span><span class="pun">);</span><span class="pln">

define</span><span class="pun">(</span><span class="str">"HASH_SECTIONS"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"HASH_ALGORITHM_INDEX"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"HASH_ITERATION_INDEX"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"HASH_SALT_INDEX"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln">
define</span><span class="pun">(</span><span class="str">"HASH_PBKDF2_INDEX"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> create_hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="com">// format: algorithm:iterations:salt:hash</span><span class="pln">
    $salt </span><span class="pun">=</span><span class="pln"> base64_encode</span><span class="pun">(</span><span class="pln">mcrypt_create_iv</span><span class="pun">(</span><span class="pln">PBKDF2_SALT_BYTES</span><span class="pun">,</span><span class="pln"> MCRYPT_DEV_URANDOM</span><span class="pun">));</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> PBKDF2_HASH_ALGORITHM </span><span class="pun">.</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> PBKDF2_ITERATIONS </span><span class="pun">.</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><span class="pun">.</span><span class="pln">  $salt </span><span class="pun">.</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> 
        base64_encode</span><span class="pun">(</span><span class="pln">pbkdf2</span><span class="pun">(</span><span class="pln">
            PBKDF2_HASH_ALGORITHM</span><span class="pun">,</span><span class="pln">
            $password</span><span class="pun">,</span><span class="pln">
            $salt</span><span class="pun">,</span><span class="pln">
            PBKDF2_ITERATIONS</span><span class="pun">,</span><span class="pln">
            PBKDF2_HASH_BYTES</span><span class="pun">,</span><span class="pln">
            </span><span class="kwd">true</span><span class="pln">
        </span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> validate_password</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> $good_hash</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    $params </span><span class="pun">=</span><span class="pln"> explode</span><span class="pun">(</span><span class="str">":"</span><span class="pun">,</span><span class="pln"> $good_hash</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">count</span><span class="pun">(</span><span class="pln">$params</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> HASH_SECTIONS</span><span class="pun">)</span><span class="pln">
       </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"> 
    $pbkdf2 </span><span class="pun">=</span><span class="pln"> base64_decode</span><span class="pun">(</span><span class="pln">$params</span><span class="pun">[</span><span class="pln">HASH_PBKDF2_INDEX</span><span class="pun">]);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> slow_equals</span><span class="pun">(</span><span class="pln">
        $pbkdf2</span><span class="pun">,</span><span class="pln">
        pbkdf2</span><span class="pun">(</span><span class="pln">
            $params</span><span class="pun">[</span><span class="pln">HASH_ALGORITHM_INDEX</span><span class="pun">],</span><span class="pln">
            $password</span><span class="pun">,</span><span class="pln">
            $params</span><span class="pun">[</span><span class="pln">HASH_SALT_INDEX</span><span class="pun">],</span><span class="pln">
            </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln">$params</span><span class="pun">[</span><span class="pln">HASH_ITERATION_INDEX</span><span class="pun">],</span><span class="pln">
            strlen</span><span class="pun">(</span><span class="pln">$pbkdf2</span><span class="pun">),</span><span class="pln">
            </span><span class="kwd">true</span><span class="pln">
        </span><span class="pun">)</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// Compares two strings $a and $b in length-constant time.</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> slow_equals</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">,</span><span class="pln"> $b</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    $diff </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$b</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">$i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">&lt;</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> $i </span><span class="pun">&lt;</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$b</span><span class="pun">);</span><span class="pln"> $i</span><span class="pun">++)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        $diff </span><span class="pun">|=</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">[</span><span class="pln">$i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">$b</span><span class="pun">[</span><span class="pln">$i</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $diff </span><span class="pun">===</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> 
</span><span class="pun">}</span><span class="pln">

</span><span class="com">/*
 * PBKDF2 key derivation function as defined by RSA's PKCS #5: https://www.ietf.org/rfc/rfc2898.txt
 * $algorithm - The hash algorithm to use. Recommended: SHA256
 * $password - The password.
 * $salt - A salt that is unique to the password.
 * $count - Iteration count. Higher is better, but slower. Recommended: At least 1000.
 * $key_length - The length of the derived key in bytes.
 * $raw_output - If true, the key is returned in raw binary format. Hex encoded otherwise.
 * Returns: A $key_length-byte key derived from the password and salt.
 *
 * Test vectors can be found here: https://www.ietf.org/rfc/rfc6070.txt
 *
 * This implementation of PBKDF2 was originally created by https://defuse.ca
 * With improvements by http://www.variations-of-shadow.com
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> pbkdf2</span><span class="pun">(</span><span class="pln">$algorithm</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">,</span><span class="pln"> $count</span><span class="pun">,</span><span class="pln"> $key_length</span><span class="pun">,</span><span class="pln"> $raw_output </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    $algorithm </span><span class="pun">=</span><span class="pln"> strtolower</span><span class="pun">(</span><span class="pln">$algorithm</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln">in_array</span><span class="pun">(</span><span class="pln">$algorithm</span><span class="pun">,</span><span class="pln"> hash_algos</span><span class="pun">(),</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">))</span><span class="pln">
        </span><span class="kwd">die</span><span class="pun">(</span><span class="str">'PBKDF2 ERROR: Invalid hash algorithm.'</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$count </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> $key_length </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">die</span><span class="pun">(</span><span class="str">'PBKDF2 ERROR: Invalid parameters.'</span><span class="pun">);</span><span class="pln">

    $hash_length </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">$algorithm</span><span class="pun">,</span><span class="pln"> </span><span class="str">""</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">));</span><span class="pln">
    $block_count </span><span class="pun">=</span><span class="pln"> ceil</span><span class="pun">(</span><span class="pln">$key_length </span><span class="pun">/</span><span class="pln"> $hash_length</span><span class="pun">);</span><span class="pln">

    $output </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">$i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">&lt;=</span><span class="pln"> $block_count</span><span class="pun">;</span><span class="pln"> $i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// $i encoded as 4 bytes, big endian.</span><span class="pln">
        $last </span><span class="pun">=</span><span class="pln"> $salt </span><span class="pun">.</span><span class="pln"> pack</span><span class="pun">(</span><span class="str">"N"</span><span class="pun">,</span><span class="pln"> $i</span><span class="pun">);</span><span class="pln">
        </span><span class="com">// first iteration</span><span class="pln">
        $last </span><span class="pun">=</span><span class="pln"> $xorsum </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="pln">$algorithm</span><span class="pun">,</span><span class="pln"> $last</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
        </span><span class="com">// perform the other $count - 1 iterations</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> $j </span><span class="pun">&lt;</span><span class="pln"> $count</span><span class="pun">;</span><span class="pln"> $j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            $xorsum </span><span class="pun">^=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$last </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="pln">$algorithm</span><span class="pun">,</span><span class="pln"> $last</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">));</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        $output </span><span class="pun">.=</span><span class="pln"> $xorsum</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$raw_output</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$output</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $key_length</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">else</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">substr</span><span class="pun">(</span><span class="pln">$output</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $key_length</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
</div></text><author><a href="/users/2777820/jason-ooo">Jason OOO</a></author><comments><comment><text><span class="comment-copy">You give us solution without no usage no usage</span></text><author><a class="comment-user" href="/users/4844512/michael" title="325 reputation">Michael</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>ok
in the fitsy we need salt
salt must be unique
so let generate it</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">   </span><span class="com">/**
     * Generating string
     * @param $size
     * @return string
     */</span><span class="pln">
    </span><span class="kwd">function</span><span class="pln"> </span><span class="typ">Uniwur_string</span><span class="pun">(</span><span class="pln">$size</span><span class="pun">){</span><span class="pln">
        $text </span><span class="pun">=</span><span class="pln"> md5</span><span class="pun">(</span><span class="pln">uniqid</span><span class="pun">(</span><span class="pln">rand</span><span class="pun">(),</span><span class="pln"> TRUE</span><span class="pun">));</span><span class="pln">
        RETURN substr</span><span class="pun">(</span><span class="pln">$text</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $size</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
<p>also we need the hash
I`m using sha512
it is the best and it is in php </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">   </span><span class="com">/**
     * Hashing string
     * @param $string
     * @return string
     */</span><span class="pln">
    </span><span class="kwd">function</span><span class="pln"> hash</span><span class="pun">(</span><span class="pln">$string</span><span class="pun">){</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> hash</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $string</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
<p>so now we can use this functions to generate safe password</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">// generating unique password</span><span class="pln">
$password </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Uniwur_string</span><span class="pun">(</span><span class="lit">20</span><span class="pun">);</span><span class="pln"> </span><span class="com">// or you can add manual password</span><span class="pln">
</span><span class="com">// generating 32 character salt</span><span class="pln">
$salt </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Uniwur_string</span><span class="pun">(</span><span class="lit">32</span><span class="pun">);</span><span class="pln">
</span><span class="com">// now we can manipulate this informations</span><span class="pln">

</span><span class="com">// hashin salt for safe</span><span class="pln">
$hash_salt </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="pln">$salt</span><span class="pun">);</span><span class="pln">
</span><span class="com">// hashing password</span><span class="pln">
$hash_psw </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">.</span><span class="pln">$hash_salt</span><span class="pun">);</span></code></pre>
<p>now we need to save in database our $hash_psw variable value and $salt variable</p>
<p>and for authorize we will use same steps...</p>
<p>it is the best way to safe our clients passwords...</p>
<p>P.s. for last 2 steps you can use your own algorithm...
but be sure that you can generate this hashed password in the future 
when you need to authorize user...</p>
</div></text><author><a href="/users/3839284/shalvasoft">shalvasoft</a></author><comments><comment><text><span class="comment-copy">This question was about hashes for passwords. 1 execution of <code>sha512</code> (even if salted) is widely considered to not be good enough for password protection. (also that RNG is not cryptographically secure, so using it for password generation is risky).</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment><comment><text><span class="comment-copy">You have no idea what you're doing. Read the top answers in this post and you can see why your code is not just insecure, but makes no sense.</span></text><author><a class="comment-user" href="/users/1592648/cryptic-%e3%83%84" title="12,286 reputation">cryptic ツ</a></author></comment><comment><text><span class="comment-copy">ok. my code is not secure. so let me know why are you using in your algorithms ony sha256??? I know that sha512 is the best why not use it???</span></text><author><a class="comment-user" href="/users/3839284/shalvasoft" title="41 reputation">shalvasoft</a></author></comment><comment><text><span class="comment-copy">@shalvasoft sha512 is pretty good for general purpose hashing, but password protection requires hashes with very specific properties ("being slow" is strangely a <i>good thing</i>, for instance, and sha512 is pretty fast). Some people have used sha512 as a building block to create password hashing functions, but nowadays the recommended approach is "use bcrypt and keep an eye on scrypt".</span></text><author><a class="comment-user owner" href="/users/32775/luiscubal" title="12,779 reputation">luiscubal</a></author></comment></comments></answer></answers></post>