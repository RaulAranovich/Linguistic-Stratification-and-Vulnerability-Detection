<?xml version="1.0" encoding="utf-8"?>
<post><title>security - PHP Session Fixation / Hijacking - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm trying to understand more about PHP <a href="https://www.owasp.org/index.php/Session_fixation">Session Fixation</a> &amp; hijacking and how to prevent these problems. I've been reading the following two articles on Chris Shiflett's website: </p>
<ul>
<li><a href="http://shiflett.org/articles/session-fixation">Session Fixation</a></li>
<li><a href="http://shiflett.org/articles/session-hijacking">Session Hijacking</a></li>
</ul>
<p>However, I'm not sure I'm understanding things correctly. </p>
<p>To help prevent session fixation is it enough to call session_regenerate_id(true); after successfully logging someone in? I think I understand that correctly.</p>
<p>He also talks about using tokens passed along in urls via $_GET to prevent session hijacking. How would this be done exactly? I'm guessing when someone logs in you generate their token &amp; store it in an session variable, then on each page you'd compare that session variable with the value of the $_GET variable?</p>
<p>Would this token need to be changed only once per session or on each page load? </p>
<p>Also is their a good way of preventing hijacking without having to pass a value along in the urls? this would be alot easier.</p>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments><comment><text><span class="comment-copy">Maybe you could add links to the pages where you’ve found these recommendations.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,771 reputation">Gumbo</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Ok, there are two separate but related problems, and each is handled differently.</p>
<h2>Session Fixation</h2>
<p>This is where an attacker explicitly sets the session identifier of a session for a user.  Typically in PHP it's done by giving them a url like <code>http://www.example.com/index...?session_name=sessionid</code>. Once the attacker gives the url to the client, the attack is the same as a session hijacking attack.</p>
<p>There are a few ways to prevent session fixation (do all of them):</p>
<ul>
<li><p>Set <a href="http://us2.php.net/manual/en/session.configuration.php#ini.session.use-trans-sid"><code>session.use_trans_sid = 0</code></a> in your <code>php.ini</code> file.  This will tell PHP not to include the identifier in the URL, and not to read the URL for identifiers.</p></li>
<li><p>Set <a href="http://us2.php.net/manual/en/session.configuration.php#ini.session.use-only-cookies"><code>session.use_only_cookies = 1</code></a> in your <code>php.ini</code> file.  This will tell PHP to never use URLs with session identifiers.</p></li>
<li><p>Regenerate the session ID anytime the session's status changes.  That means any of the following:</p>
<ul>
<li>User authentication</li>
<li>Storing sensitive info in the session</li>
<li>Changing anything about the session</li>
<li>etc...</li>
</ul></li>
</ul>
<h2>Session Hijacking</h2>
<p>This is where an attacker gets a hold of a session identifier and is able to send requests as if they were that user.  That means that since the attacker has the identifier, they are all but indistinguishable from the valid user with respect to the server.</p>
<p>You cannot directly prevent session hijacking.  You can however put steps in to make it very difficult and harder to use.</p>
<ul>
<li><p>Use a strong session hash identifier: <a href="http://us2.php.net/manual/en/session.configuration.php#ini.session.hash-function"><code>session.hash_function</code></a> in <code>php.ini</code>.  If PHP &lt; 5.3, set it to <code>session.hash_function = 1</code> for SHA1.  If PHP &gt;= 5.3, set it to <code>session.hash_function = sha256</code> or <code>session.hash_function = sha512</code>.</p></li>
<li><p>Send a strong hash: <a href="http://us2.php.net/manual/en/session.configuration.php#ini.session.hash-bits-per-character"><code>session.hash_bits_per_character</code></a> in <code>php.ini</code>.  Set this to <code>session.hash_bits_per_character = 5</code>.  While this doesn't make it any <em>harder</em> to crack, it does make a difference when the attacker tries to guess the session identifier.  The ID will be shorter, but uses more characters.</p></li>
<li><p>Set an additional entropy with <a href="http://www.php.net/manual/en/session.configuration.php#ini.session.entropy-file"><code>session.entropy_file</code></a> and <a href="http://www.php.net/manual/en/session.configuration.php#ini.session.entropy-length"><code>session.entropy_length</code></a> in your <code>php.ini</code> file. Set the former to <code>session.entropy_file = /dev/urandom</code> and the latter to the number of bytes that will be read from the entropy file, for example <code>session.entropy_length = 256</code>. </p></li>
<li><p>Change the name of the session from the default PHPSESSID.  This is accomplished by calling <a href="http://us2.php.net/manual/en/function.session-name.php"><code>session_name()</code></a> with your own identifier name as the first parameter prior to calling <code>session_start</code>.  </p></li>
<li><p>If you're <strong>really</strong> paranoid you could rotate the session name too, but beware that all sessions will automatically be invalidated if you change this (for example, if you make it dependent on the time).  But depending on your use-case, it may be an option...</p></li>
<li><p>Rotate your session identifier often.  I wouldn't do this every request (unless you <strong>really</strong> need that level of security), but at a random interval.  You want to change this often since if an attacker does hijack a session you don't want them to be able to use it for too long.</p></li>
<li><p>Include the <a href="http://php.net/manual/en/reserved.variables.server.php">user agent from <code>$_SERVER['HTTP_USER_AGENT']</code></a> in the session.  Basically, when the session starts, store it in something like <code>$_SESSION['user_agent']</code>.  Then, on each subsequent request check that it matches.  Note that this can be faked so it's not 100% reliable, but it's better than not.</p></li>
<li><p>Include the <a href="http://php.net/manual/en/reserved.variables.server.php">user's IP address from <code>$_SERVER['REMOTE_ADDR']</code></a> in the session.  Basically, when the session starts, store it in something like <code>$_SESSION['remote_ip']</code>.  This may be problematic from some ISPs that use multiple IP addresses for their users (such as AOL used to do).  But if you use it, it will be much more secure.  The only way for an attacker to fake the IP address is to compromise the network at some point between the real user and you.  And if they compromise the network, they can do far worse than a hijacking (such as MITM attacks, etc).</p></li>
<li><p>Include a token in the session and on the browsers side that you increment and compare often.  Basically, for each request do <code>$_SESSION['counter']++</code> on the server side.  Also do something in JS on the browsers side to do the same (using a local storage).  Then, when you send a request, simply take a nonce of a token, and verify that the nonce is the same on the server.  By doing this, you should be able to detect a hijacked session since the attacker won't have the exact counter, or if they do you'll have 2 systems transmitting the same count and can tell one is forged.  This won't work for all applications, but is one way of combating the problem.</p></li>
</ul>
<h2>A note on the two</h2>
<p>The difference between Session Fixation and Hijacking is only about how the session identifier is compromised. In fixation, the identifier is set to a value that the attacker knows before hand.  In Hijacking it's either guessed or stolen from the user.  Otherwise the effects of the two are the same once the identifier is compromised.</p>
<h2>Session ID Regeneration</h2>
<p>Whenever you regenerate the session identifier using <a href="http://us2.php.net/manual/en/function.session-regenerate-id.php"><code>session_regenerate_id</code></a> the old session should be deleted.  This happens transparently with the core session handler.  However some <a href="http://us2.php.net/manual/en/function.session-set-save-handler.php">custom session handlers using <code>session_set_save_handler()</code></a> do not do this and are open to attack on old session identifiers.  Make sure that if you are using a custom session handler, that you keep track of the identifier that you open, and if it's not the same one that you save that you explicitly delete (or change) the identifier on the old one.  </p>
<p>Using the default session handler, you're fine with just calling <code>session_regenerate_id(true)</code>.  That will remove the old session information for you.  The old ID is no longer valid and will cause a new session to be created if the attacker (or anyone else for that matter) tries to use it.  Be careful with custom session handlers though....</p>
<h2>Destroying a Session</h2>
<p>If you're going to destroy a session (on logout for example), make sure you destroy it thoroughly.  This includes unsetting the cookie. Using <a href="http://us2.php.net/manual/en/function.session-destroy.php"><code>session_destroy</code></a>:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> destroySession</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $params </span><span class="pun">=</span><span class="pln"> session_get_cookie_params</span><span class="pun">();</span><span class="pln">
    setcookie</span><span class="pun">(</span><span class="pln">session_name</span><span class="pun">(),</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln"> time</span><span class="pun">()</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">42000</span><span class="pun">,</span><span class="pln">
        $params</span><span class="pun">[</span><span class="str">"path"</span><span class="pun">],</span><span class="pln"> $params</span><span class="pun">[</span><span class="str">"domain"</span><span class="pun">],</span><span class="pln">
        $params</span><span class="pun">[</span><span class="str">"secure"</span><span class="pun">],</span><span class="pln"> $params</span><span class="pun">[</span><span class="str">"httponly"</span><span class="pun">]</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
    session_destroy</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">Using 5 instead of 4 bits per character doesn’t change the “strength” in any way (whatever “strength” means in this case). But although your points are advisable in general, they lack some important details. For example what happens to the session that is associated to the old session ID or how a session with an old session ID should be handled after it got invalid.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,771 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo Couldn't get your last sentence completely but, wouldn't an old session migrate to the new one in case of an id regeneration; and what is the problem with an invalidated session?</span></text><author><a class="comment-user" href="/users/372654/halil-%c3%96zg%c3%bcr" title="10,650 reputation">Halil Özgür</a></author></comment><comment><text><span class="comment-copy">@battal: No, that’s the point. <code>session_regenerate_id</code> does not invalidate the session that is still associated to the old ID; only if the <i>delete_old_session</i> parameter is set to true the session will be destroyed. But what if an attacker initiated this ID regeneration?</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,771 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">I disagree with session regeneration every time you change a session variable,  it should only be done on login/logout.  Also checking the user-agent is meaningless and checking REMOTE_ADDR is problematic.   One thing i would like to add is <code>session.entropy_file = /dev/urandom</code>.  PHP's internal entropy generation is proven to be extremely weak and the entropy pool provided by /dev/random or /dev/uranom is the best you can get on a web server without a hardware rng.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Also you should add <code>session.cookie_httponly</code> and <code>session.cookie_secure</code>.  The first one helps thwart xss (but its not perfect).  The 2nd is the best way to stop OWASP A9...</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Gumbo Ah, I see, it persists per page view. These look like important points for any non-trivial app. Interesting conversion in the comments section of <a href="http://php.net/manual/en/function.session-regenerate-id.php" rel="nofollow noreferrer"><code>session_regenerate_id</code></a> manual page. What do you think of those, especially <a href="http://www.php.net/manual/en/function.session-regenerate-id.php#87905" rel="nofollow noreferrer">comment 87905</a>?</span></text><author><a class="comment-user" href="/users/372654/halil-%c3%96zg%c3%bcr" title="10,650 reputation">Halil Özgür</a></author></comment><comment><text><span class="comment-copy">@ircmaxell <i>"While this doesn't make it any harder to crack, it does make a difference when the attacker tries to guess the session identifier"</i> - what kind of difference does it make in terms of security, if the hash entropy is same? And to the start of the sentence <i>"Send a strong hash"</i> - I think it doesn't have anything to do with the "strength" of the hash, only the readable representation of it.</span></text><author><a class="comment-user" href="/users/372654/halil-%c3%96zg%c3%bcr" title="10,650 reputation">Halil Özgür</a></author></comment><comment><text><span class="comment-copy">@battal: I don’t see the point why the old session ID and thus the old session should be valid for further 60 seconds. It’s like having a security doors that closes automatically not until 60 seconds after you passed it and busts everyone that passed after you. This would only make sense to use it to detect an attacker (in case of Session Hijacking) or a victim (in case of Session Fixation). But you can’t quite tell who is who.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,771 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo: The solution in those comments tries to hand old session back to the already running scripts (normally they can't access it until the script doing a regen id finishes). And since they started running before the session change, should we call it a vuln.? Wouldn't it be ambiguous to run half of a script with some session and other half with another session (except for push things etc)?</span></text><author><a class="comment-user" href="/users/372654/halil-%c3%96zg%c3%bcr" title="10,650 reputation">Halil Özgür</a></author></comment><comment><text><span class="comment-copy">@battal: No, it’s the new session ID that is used after ID regeneration and the session data in <code>$_SESSION</code> remains unchanged. But frankly, calling <code>session_regenerate_id</code> doesn’t write the session data of <code>$_SESSION</code> back to the storage. So the local change of <code>$_SESSION['OBSOLETE']</code> and <code>$_SESSION['EXPIRES']</code> does only alter the data of the current session with the newly generated ID but not the old one. To set those values for the old session you would rather need to call <code>session_write_close</code> <i>before</i> <code>session_regenerate_id</code>.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,771 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">You can also change the default session name (PHPSESSID) using: <code>session.name = blah</code> instead of calling <code>session_name()</code></span></text><author><a class="comment-user" href="/users/1053103/mike-causer" title="5,211 reputation">Mike Causer</a></author></comment><comment><text><span class="comment-copy">@MikeCauser But using <code>session_name()</code> is more portable; imagine servers that don't provide access to <code>php.ini</code> or <code>.htacess</code>.</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,258 reputation">Ja͢ck</a></author></comment><comment><text><span class="comment-copy">More portable yes, but heaps slower. I could understand php.ini not being exposed in a shared environment, but surely .htaccess would be available</span></text><author><a class="comment-user" href="/users/1053103/mike-causer" title="5,211 reputation">Mike Causer</a></author></comment><comment><text><span class="comment-copy">@MikeCauser: slower? Really? You're going to make that argument? We're talking <i>literally</i> microseconds. And since it's never going to be in a loop anyway (shouldn't, unless you're doing something horribly wrong). I would use <code>session_name()</code> simply from the standpoint that it keeps application config in the application.</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">Don't understand such a great answer but missing the most import piece: use SSL/HTTPS. The counter increment is a source of problem with multiple request fast after each other, a user refreshes a page twice or hits a submit buttons twice. The IP address solution is a problem nowadays with all the mobile users and ever changing IP's. You could look at the first set of the IP, but still it's asking for trouble. Best is preventing the discovering of the session id at the first place and that is using SSL/HTTPS.</span></text><author><a class="comment-user" href="/users/930883/sanne" title="694 reputation">Sanne</a></author></comment><comment><text><span class="comment-copy">@Rook: I agree with you the session should not be regenerated every time since it's an overkill, but what about regeneration of the id only, using session_regenerate_id(false), to make SID guessing more hard?</span></text><author><a class="comment-user" href="/users/1763602/marco-sulla" title="5,240 reputation">Marco Sulla</a></author></comment><comment><text><span class="comment-copy">@Lucas Malor  there is no attack that this prevents.  The id should be large enough to prevent brute force in our life time.   If you have an owasp a9 violation or HTTP Response Splitting/XSS/CSRF/Clickjakcing then regenerating the  ID isn't going to help.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook: Of course, but if I have a session that expires after a long time, say 2 week as Google account does, an attacker have 2 weeks to try to get my SID. Is this improbable in your opinion if I have a SID generated by a strong hashing function, or someone could try?</span></text><author><a class="comment-user" href="/users/1763602/marco-sulla" title="5,240 reputation">Marco Sulla</a></author></comment><comment><text><span class="comment-copy">@Lucas Malor Well that depends what you are hashing.  If you are using your platform's session manager (which is what you should be doing),  then you are probably using /dev/urandom,  which is a sah1 hash of an entropy pool.  In this case,  you will probably need a few thousand years to guess this session id.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Another important point about the counter and changing it on the client: the cookie should be made HttpOnly... so obviously the client JavaScript has no access to the cookie and cannot increment a counter. It would be wise to explain that 2 cookies are required in that case.</span></text><author><a class="comment-user" href="/users/212378/alexis-wilke" title="7,761 reputation">Alexis Wilke</a></author></comment><comment><text><span class="comment-copy">Isn't 256 bytes of entropy overkill? 32 should be sufficient. 32 bytes = 256 bits after all.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">what about <code>session.use_strict_mode</code>?</span></text><author><a class="comment-user" href="/users/3599237/akam" title="514 reputation">Akam</a></author></comment><comment><text><span class="comment-copy">@Akam "strict mode" is a bandaid for everything else identified in the post. If you regenerate on privilege escalation as indicated in the post, strict mode literally does nothing for you.</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell: thanks, I prefer to add this note to your answer also.</span></text><author><a class="comment-user" href="/users/3599237/akam" title="514 reputation">Akam</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Both session attacks have the same goal: Gain access to a legitimate session of another user. But the attack vectors are different:</p>
<ul>
<li><p>In a <a href="http://www.owasp.org/index.php/Session_fixation" rel="noreferrer"><strong>Session Fixation</strong> attack</a>, the attacker already has access to a valid session and tries to force the victim to use this particular session.</p></li>
<li><p>In a <a href="http://www.owasp.org/index.php/Session_hijacking_attack" rel="noreferrer"><strong>Session Hijacking</strong> attack</a>, the attacker tries to get the ID of a victim’s session to use his/her session.</p></li>
</ul>
<p>In both attacks the session ID is the sensitive data these attack are focused on. So it’s the session ID that needs to be protected for both a read access (Session Hijacking) and a write access (Session Fixation).</p>
<p>The general rule of protecting sensitive data by using HTTPS applies in this case, too. Additionally, you should to do the following:</p>
<p>To prevent <strong>Session Fixation</strong> attacks, make sure that:</p>
<ul>
<li>the session ID is only accepted from a cookie (set <a href="http://php.net/manual/en/session.configuration.php#ini.session.use-only-cookies" rel="noreferrer"><em>session.use_only_cookies</em></a> to <code>true</code>) and make it for HTTPS only if possible (set <a href="http://php.net/manual/en/session.configuration.php#ini.session.cookie-secure" rel="noreferrer"><em>session.cookie_secure</em></a> to <code>true</code>); you can do both with <a href="http://php.net/session_set_cookie_params" rel="noreferrer"><code>session_set_cookie_params</code></a>.</li>
</ul>
<p>To prevent <strong>Session Hijacking</strong> attacks, make sure that:</p>
<ul>
<li>the session ID in the cookie is only readable by your server (set <a href="http://php.net/manual/en/session.configuration.php#ini.session.cookie-httponly" rel="noreferrer"><em>session.cookie_httponly</em></a> to <code>true</code>)</li>
<li>an additional source of entropy is used (see <a href="http://php.net/manual/en/session.configuration.php#ini.session.entropy-file" rel="noreferrer"><em>session.entropy_file</em></a>) as <a href="http://seclists.org/fulldisclosure/2010/Mar/519" rel="noreferrer">PHP’s random number generator has a known weakness</a>; many security advisories suggest at least 128 bit of entropy length (see <a href="http://php.net/manual/en/session.configuration.php#ini.session.entropy-length" rel="noreferrer"><em>session.entropy_length</em></a>)</li>
<li>a strong cryptographic hash function is used (see <a href="http://php.net/manual/en/session.configuration.php#ini.session.hash-function" rel="noreferrer"><em>session.hash_function</em></a>); at best it is a <a href="http://www.cryptopp.com/benchmarks.html" rel="noreferrer">computationally expensive hash function</a> like <a href="http://en.wikipedia.org/wiki/Whirlpool_%28cryptography%29" rel="noreferrer">Whirlpool</a> that for example is five times slower than MD5 and thus allows only a fifth of the number of hash operations in opposite to MD5.</li>
</ul>
<p>To prevent <strong>both</strong> session attacks, make sure that:</p>
<ul>
<li>to only accept sessions that your application have initiated. You can do this by fingerprinting a session on initiation with client specific information. You can use the <em>User-Agent</em> ID but don’t use the remote IP address or any other information that might change from between requests.</li>
<li>to change the session ID using <a href="http://php.net/session_regenerate_id" rel="noreferrer"><code>session_regenerate_id(true)</code></a> after an authentication attempt (<code>true</code> only on success) or a change of privileges and destroy the old session. (Make sure to store any changes of <code>$_SESSION</code> using <code>session_write_close</code> <em>before</em> regenerating the ID if you want to preserved the session associated to the old ID; otherwise only the session with the new ID will be affected by those changes.)</li>
<li>to use a proper session expiration implementation (see <a href="http://stackoverflow.com/questions/520237/how-do-i-expire-a-php-session-after-30-minutes/1270960#1270960"><em>How do I expire a PHP session after 30 minutes?</em></a>).</li>
</ul>
</div></text><author><a href="/users/53114/gumbo">Gumbo</a></author><comments><comment><text><span class="comment-copy">Awesome post, especially the last section.</span></text><author><a class="comment-user" href="/users/213738/mattis" title="2,680 reputation">Mattis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The tokens you mention are a "nonce" - number used once. They don't necessarily have to be used only once, but the longer they're used, the higher the odds that the nonce can be captured and used to hijack the session. </p>
<p>Another drawback to nonces is that it's very hard to build a system that uses them and allows multiple parallel windows on the same form. e.g. the user opens two windows on a forum, and starts working on two posts:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">window </span><span class="str">'A'</span><span class="pln"> loads first </span><span class="kwd">and</span><span class="pln"> gets nonce </span><span class="str">'P'</span><span class="pln">
window </span><span class="str">'B'</span><span class="pln"> loads second </span><span class="kwd">and</span><span class="pln"> gets nonce </span><span class="str">'Q'</span></code></pre>
<p>If you have no way of tracking multiple windows, you'll only have stored one nonce - that of window B/Q. When the user then submits their post from window A and passes in nonce 'P', ths system will reject the post as <code>P != Q</code>.</p>
</div></text><author><a href="/users/118068/marc-b">Marc B</a></author><comments><comment><text><span class="comment-copy">So what does this have to do with session fixation?</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">He has a valid point especially in the realm of using many AJAX requests simultaneously.</span></text><author><a class="comment-user" href="/users/708155/danielg" title="107 reputation">DanielG</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I did not read Shiflett's article, but I think you have misunderstood something.</p>
<p>By default PHP passes the session token in the URL whenever the client does not accept cookies. Oherwise in the most common case the session token is stored as a cookie.</p>
<p>This means that if you put a session token in the URL PHP will recognize it and try to use it subsequently. Session fixation happens when someone creates a session and then tricks another user to share the same session by opening a URL which contains the session token. If the user authenticates in some way, the malicious user then knows the session token of an authenticated one, who might have different privileges.</p>
<p>As I'm sure Shiflett explains, the usual thing to do is to regenerate a different token each time the privileges of a user change.</p>
</div></text><author><a href="/users/249001/andrea">Andrea</a></author><comments><comment><text><span class="comment-copy">To add to this, please be certain to destroy any previously opened sessions as they will still be valid with the existing user permissions.</span></text><author><a class="comment-user" href="/users/389930/corrodedmonkee" title="373 reputation">corrodedmonkee</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Yes you could prevent session fixation by regenerating the session id once upon login.   This way if the attacker will not know the cookie value of the newly authenticated session.   Another approach which totally stops the problem is set <code>session.use_only_cookies=True</code> in your runtime configuration.   An attacker cannot set the value of a cookie in the context of another domain.  Session fixation is relying on sending the cookie value as a GET or POST. </p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments/></answer></answers></post>