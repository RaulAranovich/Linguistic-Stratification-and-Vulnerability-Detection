<?xml version="1.0" encoding="utf-8"?>
<post><title>security - If you can decode JWT how are they secure? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I love JWT, it's really fun to work with. My question is, if I get a JWT and I can decode the payload, how is that secure? Couldn't I just grab the token out of the header, decode and change the user information in the payload and send it back with the same correct encoded secret?</p>
<p>I know they must be, I just really like to understand the technologies. What am I missing? Thanks!</p>
</div></text><author><a href="/users/1013298/pixmach">PixMach</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>JWTs can be either signed, encrypted or both. If a token is signed, but not encrypted, everyone can read the contents of the token, but when you don't know the private key, you can't change it. Otherwise, the receiver will notice that the signature won't match anymore. </p>
<p>Answer to your comment: I'm not sure if I understand your comment the right way. Just to be sure: do you know and understand digital signatures? I'll just briefly explain one variant (HMAC, which is symmetrical, but there are many others). </p>
<p>Let's assume Alice wants to send a JWT to Bob. They both know some shared secret. Mallory doesn't know that secret, but wants to interfere and change the JWT. To prevent that, Alice calculates Hash(payload + secret) and appends this as signature. 
When receiving the message, Bob can also calculate Hash(payload + secret) to check whether the signature matches. 
If however, Mallory changes something in the content, she isn't able to calculate the matching signature (which would be Hash(newContent + secret)). She doesn't know the secret and has no way of finding it out. 
This means if she changes something, the signature won't match anymore, and Bob will simply not accept the JWT anymore. </p>
<p>Let's suppose, I send another person the message <code>{"id":1}</code> and sign it with <code>Hash(content + secret)</code>. (+ is just concatenation here). I use the SHA256 Hash function, and the signature I get is: <code>330e7b0775561c6e95797d4dd306a150046e239986f0a1373230fda0235bda8c</code>. Now it's your turn: play the role of Mallory and try to sign the message <code>{"id":2}</code>. You can't because you don't know which secret I used. If I suppose that the recipient knows the secret, he CAN calculate the signature of any message and check if it's correct. </p>
</div></text><author><a href="/users/1076143/misch">Misch</a></author><comments><comment><text><span class="comment-copy">So the signature is changed when the payload is changed? I was under the impression the token was in the format [header].[payload].[signature]   is the signature calculated by combination of the payload and secret?  If that was the case, wouldn't a payload with a different id be the same for that secret? Like if the data was { id:1 } and that is used to calculate the signature part of the token with the secret, wouldn't that mean that { id:2 } would be valid for user 2, and so user 1 could change id to 2 and the token would be the same?</span></text><author><a class="comment-user owner" href="/users/1013298/pixmach" title="829 reputation">PixMach</a></author></comment><comment><text><span class="comment-copy">For instance I'm going here and changing the data in the payload and it says signature valid unless i enter invalid characters: <a href="http://jwt.io/" rel="nofollow noreferrer">jwt.io</a> <a href="http://grab.by/CNGS" rel="nofollow noreferrer">grab.by/CNGS</a></span></text><author><a class="comment-user owner" href="/users/1013298/pixmach" title="829 reputation">PixMach</a></author></comment><comment><text><span class="comment-copy">@PixMach Edited the answer</span></text><author><a class="comment-user" href="/users/1076143/misch" title="3,829 reputation">Misch</a></author></comment><comment><text><span class="comment-copy">Thanks, but it seems like if Mallory changes the hash by changing the id in the payload, Hash(newContent+secret) would be valid. So does this mean I have to send the user with the request to match against the JWT? I am wondering if I can't rely on the payload to tell me who is doing the request.</span></text><author><a class="comment-user owner" href="/users/1013298/pixmach" title="829 reputation">PixMach</a></author></comment><comment><text><span class="comment-copy">I did give you an example to make things still clearer, but I won't explain you the whole concept of digital signatures and HMACs to you. Please read up about those things, there is a lot of material explaining it.</span></text><author><a class="comment-user" href="/users/1076143/misch" title="3,829 reputation">Misch</a></author></comment><comment><text><span class="comment-copy">Oh I understand now. I don't know why I was missing the idea that the secret hash would not be correct when you changed the payload because the secret hash would have to be recalculated. For some reason I was still thinking that it was independent. That last bit really drilled it home for me. Thanks for walking me through it.</span></text><author><a class="comment-user owner" href="/users/1013298/pixmach" title="829 reputation">PixMach</a></author></comment><comment><text><span class="comment-copy">I have a related question. What's preventing someone from impersonating Alice with the copied JWT?</span></text><author><a class="comment-user" href="/users/256405/morrowless" title="3,333 reputation">Morrowless</a></author></comment><comment><text><span class="comment-copy">If someone has the JWT they can impersonate Alice. So you need to be careful how you store and send it. You should also set an expiry for it in the payload. That way if someone steals the JWT they have a limited timeframe to use it.  Have a look at <a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" rel="nofollow noreferrer">stormpath.com/blog/â€¦</a></span></text><author><a class="comment-user" href="/users/2255594/geraint-anderson" title="373 reputation">Geraint Anderson</a></author></comment><comment><text><span class="comment-copy">@Morrowless I've ran into the issue of users "sharing" tokens. What we did to improve security was to use the user's IP address as part of the decrypting process. Because this happened in the back-end; a user could share a token with another but get denied not knowing why. At the same time we destroyed/invalidated the shared token so both users would have to sign in again and get a new token. Of course, this is not perfect because you could still get away with it if you were connected to the same network. What I'd love to see is a browser enforced session ID passed via the headers.</span></text><author><a class="comment-user" href="/users/2348067/calcazar" title="302 reputation">calcazar</a></author></comment><comment><text><span class="comment-copy">if someone with copied jwt can impersonate alice, then what is the use of jwt then , is not is better to use a simple encrypted key that is different for every user and generated at the time of signup and saved in database.atleast to save development time.</span></text><author><a class="comment-user" href="/users/1850787/dragon" title="793 reputation">Dragon</a></author></comment><comment><text><span class="comment-copy">@calcazar Why would they do that ?</span></text><author><a class="comment-user" href="/users/4299560/ced" title="2,528 reputation">Ced</a></author></comment><comment><text><span class="comment-copy">@Ced I should clarify... "Malicious Users" :)  Trying to get around the system. These were sales people who also had in-depth knowledge of computers and had a tendency of getting in to trouble.  These were the kind of people who would call into IT and when IT opened a command prompt as admins, they would unplug their ethernet cables and use the admin prompt to install applications on the machine and such.  Needless to say the org flushed these people out but the fact that they were capable has always left an impact on my development when security is concerned :)</span></text><author><a class="comment-user" href="/users/2348067/calcazar" title="302 reputation">calcazar</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can go to <a href="https://jwt.io/" rel="noreferrer"><code>jwt.io</code></a>, paste your token and read the contents. This is jarring for a lot of people initially.</p>
<p>The short answer is that JWT doesn't concern itself with encryption. It cares about validation. That is to say, it can always get the answer for "Have the contents of this token manipulated"? This means user manipulation of the JWT token is futile because the server will know and disregard the token. The server adds a signature based on the payload when issuing a token to the client. Later on it verifies the payload and matching signature.</p>
<p>The logical question is what is the motivation for not concerning itself with encrypted contents?</p>
<ol>
<li><p>The simplest reason is because it assumes this is a solved problem for the most part. If dealing with a client like the web browser for example, you can store the JWT tokens in a cookie that is <code>secure + httpsOnly</code> (can't be read by Javascript + can't be read by HTTP) and talks to the server over an encrypted channel (HTTPS). Once you know you have a secure channel between the server and client you can securely exchange JWT or whatever else you want.</p></li>
<li><p>This keeps thing simple. A simple implementation makes adoption easier but it also lets each layer do what it does best (let HTTPS handle encryption).</p></li>
<li><p>JWT isn't meant to store sensitive data. Once the server receives the JWT token and validates it, it is free to lookup the user ID in its own database for additional information for that user (like permissions, postal address, etc). This keeps JWT small in size and avoids inadvertent information leakage because everyone knows not to keep sensitive data in JWT.</p></li>
</ol>
<p>It's not too different from how cookies themselves work. Cookies often contain unencrypted payloads. If you are using HTTPS then everything is good. If you aren't then it's advisable to encrypt sensitive cookies themselves. Not doing so will mean that a man-in-the-middle attack is possible--a proxy server or ISP reads the cookies and then replays them later on pretending to be you. For similar reasons, JWT should always be exchanged over a secure layer like HTTPS.</p>
</div></text><author><a href="/users/50475/aleemb">aleemb</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The contents in a json web token (JWT) are not inherently secure, but there is a built-in feature for verifying token authenticity. A JWT is three hashes separated by periods. The third is the signature. In a public/private key system, the issuer signs the token signature with a private key which can only be verified by its corresponding public key.</p>
<p>It is important to understand the distinction between issuer and verifier. The recipient of the token is responsible for verifying it.</p>
<p>There are two critical steps in using JWT securely in a web application: 1) send them over an encrypted channel, and 2) verify the signature immediately upon receiving it. The asymmetric nature of public key cryptography makes JWT signature verification possible. A public key verifies a JWT was signed by its matching private key. No other combination of keys can do this verification, thus preventing impersonation attempts. Follow these two steps and we can guarantee with mathematical certainty the authenticity of a JWT.</p>
<p>More reading: <a href="http://stackoverflow.com/questions/18257185/how-does-a-public-key-verify-a-signature#comment26779432_18259395">How does a public key verify a signature?</a></p>
</div></text><author><a href="/users/1161948/thisclark">ThisClark</a></author><comments/></answer></answers></post>