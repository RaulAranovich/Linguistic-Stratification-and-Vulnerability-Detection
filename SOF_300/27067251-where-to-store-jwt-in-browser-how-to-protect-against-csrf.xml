<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Where to store JWT in browser? How to protect against CSRF? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I know cookie-based authentication. SSL and HttpOnly flag can be applied to protect cookie-based authentication from MITM and XSS. However, more special measures will be needed to apply in order to  protect it from CSRF. They are just a bit complicated. (<a href="http://sitr.us/2011/08/26/cookies-are-bad-for-you.html">reference</a>)</p>
<p>Recently, I discover that JSON Web Token(JWT) is quite hot as an solution for authentication. I know the stuffs about encoding, decoding and verifying JWT. However, I don't understand why some websites/tutorials tell no need CSRF protection if JWT is used. I have read quite a lot and try to summarize the problems below. I just want someone can provide the big picture of JWT and clarify the concepts I misunderstood about JWT.</p>
<ol>
<li><p>If the JWT is stored in cookie, I think it is as same as cookie-based authentication except that the server does not need to have sessions to verify the cookie/token. There is still risk about CSRF if no special measure is implemented. Isn't JWT stored in cookie?</p></li>
<li><p>If the JWT is stored in localStorage/sessionStorage, then no cookie so don't need to protect against CRSF. The question is how to send the JWT to server. I found <a href="http://www.sitepoint.com/using-json-web-tokens-node-js/">here</a> suggests using jQuery to send the JWT by HTTP header of ajax requests. So, only the ajax requests can do the authentication?</p></li>
<li><p>Also, I found one more <a href="https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/">blog</a> shows to use "Authorization header" and "Bearer" to send the JWT. I don't understand the method the blog talks about. Could someone please explain more about "Authorization header" and "Bearer"? Does this make the JWT transmitted by HTTP header of ALL requests? If yes, how about CSRF?</p></li>
</ol>
</div></text><author><a href="/users/18044/mvdd">MvdD</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>JWT tokens are popular since they are used as the default token format in new authorization and authentication protocols like <a href="http://oauth.net/2/">OAuth 2.0</a> and <a href="http://openid.net/connect/">OpenID Connect</a>.</p>
<p>When the token is stored in a cookie, the browser will automatically send it along with each request to the same domain and this is still vulnerable to CSRF attacks.</p>
<p>Bearer authentication is one of the <a href="http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">authentication schemes</a> defined in HTTP. It basically means that <code>YOU</code> stick the (JWT) token in the Authorization HTTP header of a request. The browser will <code>NOT</code> do this for you automatically, so it's not suitable for protecting your website. As the browser does not automatically add the header to your request, it is not vulnerable to a CSRF attack, which depends on your authentication info being submitted automatically to the original domain.</p>
<p>The bearer scheme is often used to protect web APIs (REST services) that are consumed via AJAX calls or from mobile clients.</p>
</div></text><author><a href="/users/18044/mvdd">MvdD</a></author><comments><comment><text><span class="comment-copy">So the only way to do Bearer authentication is via ajax request?</span></text><author><a class="comment-user owner" href="/users/1675581/timespace7" title="1,078 reputation">Timespace7</a></author></comment><comment><text><span class="comment-copy">@Timespace7 No, JWT tokens are also often used from native clients. OAuth 2.0 has flows specifically targetting native (mobile) clients. The thing they don't do is implicit browser authentication (like cookies or basic auth.).</span></text><author><a class="comment-user" href="/users/18044/mvdd" title="8,684 reputation">MvdD</a></author></comment><comment><text><span class="comment-copy">Let me summarize, you say that:  - If we dispatch our JWT to our user, we save it in a cookie and then whenever we make a call to our api add the Authoritzation header manually, we are protected against CSRF attacks?</span></text><author><a class="comment-user" href="/users/4289649/borjante" title="1,149 reputation">Borjante</a></author></comment><comment><text><span class="comment-copy">I'm saying that if your API only retrieves the JWT token from the Authorization header, it is not vulnerable to CSRF. Any site or API that gets the token from a cookie needs CSRF mitigation.</span></text><author><a class="comment-user" href="/users/18044/mvdd" title="8,684 reputation">MvdD</a></author></comment><comment><text><span class="comment-copy">Does this mean we can effectively store the jwt in a cookie and it will be secure if we send requests with it in the Authorization header?</span></text><author><a class="comment-user" href="/users/1807164/cameronroe" title="1,255 reputation">cameronroe</a></author></comment><comment><text><span class="comment-copy">@cameronjroe you can store it in your cookies but only if you don't use your cookies for authentication (you use your headers in this case)</span></text><author><a class="comment-user" href="/users/1880700/jaakko" title="446 reputation">Jaakko</a></author></comment><comment><text><span class="comment-copy">@MvdD As you said, JWT is not suitable for protecting website because browser will not auto send it. So does it mean JWT is not meant for <code>authenticating requests originated from a browser</code>? What if all requests are issued with <code>ajax</code>, which means my JS will <code>always</code> send the token explicitly rather than rely on browser sending the cookie implicitly.</span></text><author><a class="comment-user" href="/users/264052/smwikipedia" title="14,382 reputation">smwikipedia</a></author></comment><comment><text><span class="comment-copy">AJAX calls also originate from the browser. JWT tokens are mostly used to authenticate web APIs (serving data) vs cookies used to authenticate web apps (serving markup, images, css and JavaScript)</span></text><author><a class="comment-user" href="/users/18044/mvdd" title="8,684 reputation">MvdD</a></author></comment><comment><text><span class="comment-copy">I was wondering also how to send the jwt token to the client without cookies  right after the client has authenticated along side with html document of my web app. But until now I could not mange to find a natural feeling, easy way. Is there a way to this? I have asked it here: <a href="http://stackoverflow.com/questions/34837751/sending-jwt-alongside-html-document" title="sending jwt alongside html document">stackoverflow.com/questions/34837751/…</a></span></text><author><a class="comment-user" href="/users/2605049/i%c5%9f%c4%b1k" title="710 reputation">Işık</a></author></comment><comment><text><span class="comment-copy">any token stored in a cookie will be vulnerable to CSRF attack irrespective of the fact that you are sending it via authentication header, on the other hand if you send the token in your request header without using a cookie, you may be exposed to XSS attack (cross-site-script) which means that a peace of javascript code written by a hacker can run on your domain (on the client side) and that peace of code can steal the token and use it, I found this article helpful : <a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" rel="nofollow noreferrer">link</a></span></text><author><a class="comment-user" href="/users/2071008/aran-dehkharghani" title="196 reputation">Aran Dehkharghani</a></author></comment><comment><text><span class="comment-copy">@MvdD It is not clear to me how / where you store the token to be able to access it to send in the Bearer authentication header. If it can be read from a cookie via javascript then it is vulnerable to XSS. Local storage is similarly vulnerable to XSS. Cookie authentication with a X-XSRF-TOKEN header as iman-sedighi mentions in his post sounds more secure (of course with other XSS protection and disabling TRACE requests, etc)</span></text><author><a class="comment-user" href="/users/206622/carl-pritchett" title="471 reputation">Carl Pritchett</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>We need to store the JWT in the client computer. If we store it in a LocalStorage/SessionStorage then it can be easily grabbed by XSS attack. If we store it in cookies then hacker can use it (without reading it) in CSRF attack and impersonate the user and  contact our API and send requests to do actions or get information on behalf of a user. But there are several ways to secure the JWT in cookies to not to be stolen easily (but there are still some advanced techniques to steal them). But if you wanna rely on LocalStorage/SessionStorage then it can be accessed by a simple XSS attack. </p>
<p>So to solve the CSRF problem I used Double Submit Cookies in my application.</p>
<h2>Double Submit Cookies Method</h2>
<p>1- Store JWT in a HTTPonly cookie and used it in secure mode to transfer over HTTPS.</p>
<p>2- Most of CSRF attacks have a different origin or referrer header with your original host in their requests. So check if you have any of them in the header, are they coming from your domain or not! If not reject them. If both origin and referrer are not available in the request then no worries. You can rely on the result of X-XSRF-TOKEN header validation results which I explain in the next step.</p>
<p>3- While the browser will automatically supply your cookies for the domain of the request, there is one useful limitation: the JavaScript code that is running on a website cannot read the cookies of other websites. We can leverage this to create our CSRF solution. To prevent CSRF attacks, we must create an extra Javascript readable cookie which is called: XSRF-TOKEN. This cookie must be created when the user is logged in, and should contain a random, un-guessable string. We also save this number in the JWT itself as a private claim. Every time the JavaScript application wants to make a request, it will need to read this token and send it along in a custom HTTP header. Because these operations (reading the cookie, setting the header) can only be done on the same domain of the JavaScript application, we can know that this is being done by a real user who is using our JavaScript application.</p>
<h2>Angular JS makes your life easy</h2>
<p>Fortunately I am using Angular JS in our platform and Angular packages the CSRF token approach, making it simpler for us to implement. For every request that our Angular application makes of the server, the Angular $http service will do these things automatically:
Look for a cookie named XSRF-TOKEN on the current domain.
If that cookie is found, it reads the value and adds it to the request as the X-XSRF-TOKEN header.</p>
<p>Thus the client-side implementation is handled for you, automatically! We just need to set a cookie named XSRF-TOKEN on the current domain in server side and when our API got any call from client, it must check X-XSRF-TOKEN header and compare it with the XSRF-TOKEN in the JWT. if they are matched then user is real. if not matched then its a forged request and you can ignore this request. This method is inspired by Double Submit Cookie Method.   </p>
<h1>Caution</h1>
<p>In reality you are still susceptible to XSS, it's just that attacker can't steal you JWT token for later use, but he can still make requests on your users behalf using XSS.</p>
<p><strong>Whether you store your JWT in a localStorage or you store your XSRF-token in not http-only cookie, both can be grabbed easily by XSS. Even your JWT in HttpOnly cookie can be grabbed by an advanced XSS attack like <a href="https://www.owasp.org/index.php/Cross_Site_Tracing" rel="noreferrer">XST METHOD</a>.</strong></p>
<p>So in addition of the Double Submit Cookies method, you must always follow best practices against XSS including escaping contents. This means removing any executable code that would cause the browser to do something you don’t want it to. Typically this means removing // 

</p><p>Read more here:</p>
<p><a href="https://stormpath.com/blog/angular-xsrf" rel="noreferrer">Angular’s XSRF: How It Works</a></p>
<p><a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" rel="noreferrer">Where to Store your JWTs – Cookies vs HTML5 Web Storage</a></p>
</div></text><author><a href="/users/2716838/iman-sedighi">Iman Sedighi</a></author><comments><comment><text><span class="comment-copy">Thanks for super detailed response. It it a good idea if I store the jwt in a httpOnly cookie and the signature of jwt as CSRF token in another cookie - <code>X-XSRF-TOKEN</code>, which is used automatically by Angular ?  The reason to use signature in CSRF token is that it can be easily verified</span></text><author><a class="comment-user" href="/users/948312/shadykiller" title="520 reputation">ShadyKiller</a></author></comment><comment><text><span class="comment-copy">@ShadyKiller yes, this way is also an example of Double Submit Cookies Method. You can store the signature of JWT in the X-XSRF-TOKEN for angular. As reading the cookie and setting the header can only be done on the same domain of the JavaScript application, you are safe from CSRF. However you must verify the signature  in server side to make sure JWT and the signature issued by you (and your secret key).</span></text><author><a class="comment-user" href="/users/2716838/iman-sedighi" title="2,058 reputation">Iman Sedighi</a></author></comment><comment><text><span class="comment-copy">Hi Iman, thanks for the response, is this <b>XSRF-TOKEN</b> setup prevents the <b>replay attack</b> as well? to me it does as the attacker can not replay the message because they cannot imitate the xsrf-token, if so then why JID is used specially for replay attack prevention?</span></text><author><a class="comment-user" href="/users/2071008/aran-dehkharghani" title="196 reputation">Aran Dehkharghani</a></author></comment><comment><text><span class="comment-copy">@AranDehkharghani yes I guess it prevents replay attack especially if you change JWT and expire the previous JWT every time it used by API. it means your JWT will become like a one-time password (OTP).  You can use JWT in different ways depends on how much do you care about security in your platform.</span></text><author><a class="comment-user" href="/users/2716838/iman-sedighi" title="2,058 reputation">Iman Sedighi</a></author></comment><comment><text><span class="comment-copy">@ImanSedighi thanks for the response, if I implement OTP then it implies I only can use it for one further request, now what could be the solution if I need to send concurrent requests from javascript, maybe returning a JWT pool to the client when a request receives? doesn't sound very elegant</span></text><author><a class="comment-user" href="/users/2071008/aran-dehkharghani" title="196 reputation">Aran Dehkharghani</a></author></comment><comment><text><span class="comment-copy">As you mentioned, if a website is vulnerable to XSS, then it is just a matter of time before the user is exploited. It seems like we are trading significant complexity for a very small increase in security.</span></text><author><a class="comment-user" href="/users/1787388/shusson" title="1,187 reputation">shusson</a></author></comment><comment><text><span class="comment-copy">@shusson You must take care of XSS and XSRF attacks to protect your JWT. I don't agree that you are trading significant complexity for a very small increase in security. If security matters, then you need to put all efforts to not to have XSS vulnerabilities. This method is designed to protect your token from XSRF attacks.  but it doesn't mean that you can ignore XSS vulnerabilities.</span></text><author><a class="comment-user" href="/users/2716838/iman-sedighi" title="2,058 reputation">Iman Sedighi</a></author></comment><comment><text><span class="comment-copy">@ImanSedighi I wasn't clear, by storing the jwt in a cookie you are adding complexity and you now have to protect against XSRF. So why not just use local storage with short life tokens and concentrate on preventing XSS?</span></text><author><a class="comment-user" href="/users/1787388/shusson" title="1,187 reputation">shusson</a></author></comment><comment><text><span class="comment-copy">There is a downside using xsrf-token, you have to send it as an X-XSRF-TOKEN header , adding a header is only possible if you can read the cookie with JS, you can read the cookie with JS only if it's not HTTP cookie, if it's HTTP cookie, you can't do CORS so your app has to be on the same domain. Did you found a solution for that ? That's why I removed csrf protection from my REST api.</span></text><author><a class="comment-user" href="/users/2127277/bigdong" title="1,086 reputation">BigDong</a></author></comment><comment><text><span class="comment-copy">OWASP are a great recourse for web vulnerabilities <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29" rel="nofollow noreferrer">owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a></span></text><author><a class="comment-user" href="/users/2687918/alex" title="143 reputation">Alex</a></author></comment><comment><text><span class="comment-copy">@ImanSedighi Does it work if we simply store the JWT in a cookie, and require all XHR requests to include the JWT in the authorization header by using Javascript to read from the cookie, and change the server to read from the header (INSTEAD OF THE COOKIE). Storing in cookie protect us from XSS by nature, and to eliminate CSRF, we read the cookie using our own JS code and attach the JWT to the header. I don't see where the XSRF-TOKEN comes into play necessarily, but I bet I'm missing sth..</span></text><author><a class="comment-user" href="/users/2461213/leo-lei" title="558 reputation">Leo Lei</a></author></comment><comment><text><span class="comment-copy">^ I missed a critical point above when I said cookie protect us from XSS by nature. It was important that the cookies are HTTP-only for it to be safe from XSS. So ignore what I said above.</span></text><author><a class="comment-user" href="/users/2461213/leo-lei" title="558 reputation">Leo Lei</a></author></comment><comment><text><span class="comment-copy">@ImanSedighi  On a second thought, isn't the double submit method you suggested still vulnerable to an XSS followed by a CSRF? To be clear, a hacker can use XSS to retrieve the XSRF-TOKEN cookie which is not HTTP-only, then he can use CSRF on his website to send AJAX requests with XSRF-TOKEN as one of the headers to the vulnerable host. In this case, the cookies will also be sent along as the vulnerable host's domain matches the cookies domain. What do you mean by "it's just that attacker can't steal you[r] JWT token for later use"? Why not?</span></text><author><a class="comment-user" href="/users/2461213/leo-lei" title="558 reputation">Leo Lei</a></author></comment><comment><text><span class="comment-copy"><i>I completely disagree</i>. An origin header can easily be spoof with a proxy wireshark. The right way of mitigating CSRF is with another unknown(!!!!!!!!!)  value (to the attacker) which is like GUID input sent initially to the form. ( hidden field.</span></text><author><a class="comment-user" href="/users/859154/royi" title="61,237 reputation">Royi</a></author></comment></comments></answer></answers></post>