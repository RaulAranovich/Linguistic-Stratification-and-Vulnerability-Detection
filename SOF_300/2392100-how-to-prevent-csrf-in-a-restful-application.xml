<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How to prevent CSRF in a RESTful application? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Cross Site Request Forgery (CSRF) is typically prevent with one of the following methods:</p>
<ul>
<li>Check referer - RESTful but unreliable</li>
<li>insert token into form and store the token in the server session - not really RESTful</li>
<li>cryptic one time URIs - not RESTful for the same reason as tokens</li>
<li>send password manually for this request (not the cached password used with HTTP auth) - RESTful but not convenient</li>
</ul>
<p>My idea is to use a user secret, a cryptic but static form id and JavaScript to generate tokens. </p>
<pre><code>&lt;form method="POST" action="/someresource" id="7099879082361234103"&gt;
    &lt;input type="hidden" name="token" value="generateToken(...)"&gt;
    ...
&lt;/form&gt;
</code></pre>
<ol>
<li><code>GET /usersecret/john_doe</code> fetched by the JavaScript from the authenticated user.</li>
<li>Response: <code>OK 89070135420357234586534346</code> This secret is conceptionally static, but can be changed every day/hour ... to improve security. This is the only confidential thing.</li>
<li>Read the cryptic (but static for all users!) form id with JavaScript, process it together with the user secret: <code>generateToken(7099879082361234103, 89070135420357234586534346)</code></li>
<li>Send the form along with the generated token to the server.</li>
<li>Since the server knows the user secret and the form id, it is possible to run the same generateToken function as the client did before sending and compare both results. Only when both values are equal the action will be authorized.</li>
</ol>
<p>Is something wrong with this approach, despite the fact that it doesn't work without JavaScript?</p>
<p><strong>Addendum:</strong></p>
<ul>
<li><a href="http://appsandsecurity.blogspot.de/2012/01/stateless-csrf-protection.html" rel="noreferrer">Stateless CSRF Protection</a></li>
</ul>
</div></text><author><a href="/users/238134/deamon">deamon</a></author><comments><comment><text><span class="comment-copy">Your usersecret isn't unique to the user, an attacker simply needs to get that number and adjust their scripts to use the new calculation. How are you authenticating users if you have no state at all?</span></text><author><a class="comment-user" href="/users/54376/mike" title="1,832 reputation">Mike</a></author></comment><comment><text><span class="comment-copy">The user secret is unique per user and can only be retrieved after authentication (HTTP basic or digest authentication or certificate authentication)</span></text><author><a class="comment-user owner" href="/users/238134/deamon" title="28,457 reputation">deamon</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>There are a lot of answers here, and problems with quite a few of them.</p>
<p>Things you should NOT do:</p>
<ol>
<li><p>If you need to read the session token from JavaScript, you're doing something horribly wrong.  Your session identifier cookie should ALWAYS have HTTPOnly set on it so its not available to scripts. </p>
<p>This one protection makes it so that the impact of XSS is considerably reduced, since an attacker will no longer be able to get a logged in users session token, which for all intents and purposes are the equivalent of credentials in the application. You don't want one error to give keys to the kingdom.</p></li>
<li><p>The session identifier should not be written to the contents of the page. This is for the same reasons you set HTTPOnly. This means that that your session token can not be your session id. They need to be different values.</p></li>
</ol>
<p>Things you should do:</p>
<ol>
<li><p>Follow <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP's guidance</a>:</p></li>
<li><p>Specifically, if this is a REST application you can <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookie">require double-submission of CSRF tokens</a>:</p></li>
</ol>
<p>Simply create something cryptographically random, store it in ASCII Hex or Base64 encode, and add it as a cookie and to your forms when the server returns the page. On the server side make sure that the cookie value matches the form value. Voila, you've killed CSRF, avoided extra prompts for your users, and not opened yourself up to more vulnerabilities.</p>
</div></text><author><a href="/users/543770/doug">Doug</a></author><comments><comment><text><span class="comment-copy">XSS with a session cookie is just as vulnerable as a XSS with a token that can be read from JavaScript. If can still craft an AJAX request that transfers money from user account to my account, and the server will gladly accept it.</span></text><author><a class="comment-user" href="/users/320471/ghayes" title="6,887 reputation">ghayes</a></author></comment><comment><text><span class="comment-copy">@ghayes I disagree. Your session token is much more sensitive than your CSRF token. With your session token I can access the application fully, as you, from my machine. With the CSRF token, I can potentially have a list of pre-scripted sensitive actions that get executed in your browser. The 2nd scenario is much more difficult to pull off, requires knowledge of the app, takes a larger window of time to execute, and the actions are limited to what you've planned beforehand. 1st scenario takes one line of code for any website, and a Cookie Manager app for the attacker to use on his machine.</span></text><author><a class="comment-user" href="/users/543770/doug" title="2,089 reputation">Doug</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You definitely need some state on the server to authenticate/authorize. It need not be the http session though, you could store it in a distributed cache (like memcached) or a database.</p>
<p><strike>
If you use cookies for authentication, the easiest solution is to double-submit the cookie value. Before you submit the form, read the session id from the cookie, store it in a hidden field and then submit it. On the server side, confirm that the value in the request is the same as the session id (that you got from the cookie). Evil script from another domain will not be able to read the session id from the cookie, thus preventing CSRF.</strike></p><strike>
</strike><p><strike>This scheme uses a single identifier across the session. 
</strike></p>
<p>If you want more protection, generate a unique id per-session per-form.</p>
<p>Also, DO NOT generate tokens in JS. Anybody can copy the code and run it from a different domain to attack your site.</p>
</div></text><author><a href="/users/242940/sripathi-krishnan">Sripathi Krishnan</a></author><comments><comment><text><span class="comment-copy">Sessions are not required for authentication as demonstrated by HTTP authentication. The JavaScript code to generate the token is not secret - only the user secret has to be secret.</span></text><author><a class="comment-user owner" href="/users/238134/deamon" title="28,457 reputation">deamon</a></author></comment><comment><text><span class="comment-copy">@Sri  although I agree that a session is the best way to handle this from a security and performance respective.  This isn't RESTful because it requires the server to keep track of per-user state which can cause problems for scalability.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Is it correct to say that the double cookie submission would not work if the page is vulnerable to XSS attacks? Because then you would be able to submit a form directly from within the domain itself and the value would be sent both through cookie and form.</span></text><author><a class="comment-user" href="/users/151377/gabriele-cirulli" title="3,278 reputation">Gabriele Cirulli</a></author></comment><comment><text><span class="comment-copy">@GabrieleCirulli Yes, it is fair statement. XSS beats most CSRF protections. Captcha's are perhaps the only form of CSRF that is still effective.</span></text><author><a class="comment-user" href="/users/242940/sripathi-krishnan" title="22,613 reputation">Sripathi Krishnan</a></author></comment><comment><text><span class="comment-copy">You mean CSRF protection? :P But yes, I agree.</span></text><author><a class="comment-user" href="/users/151377/gabriele-cirulli" title="3,278 reputation">Gabriele Cirulli</a></author></comment><comment><text><span class="comment-copy">@GabrieleCirulli: A way to XSS protect your CSRF is to add a hash to the CSRF token that is the access_code + salt. When the CSRF cookie comes back you can regenerate the hash and compare it to what is submitted.. if they don't match, the CSRF is invalid. In short the access token should be an httpOnly cookie that can't be read from JS. The csrf is a cookie that can be read from JS so that the csrf header can be created. We also create new access codes on each request so the csrf token and access token become a pair.. if the two don't match, invalid request</span></text><author><a class="comment-user" href="/users/52629/matt" title="1,481 reputation">Matt</a></author></comment><comment><text><span class="comment-copy">This answer is asking for trouble. First off, session id's should have the HTTPOnly flag set which will prevent being read from scripts. This prevents an XSS vulnerability from compromising the full session. In a similar manner, the session id should not be your CSRF token. Since one component of the CSRF token needs to be submitted as a form variable, it will be available to scripts (and thereby available to XSS).</span></text><author><a class="comment-user" href="/users/543770/doug" title="2,089 reputation">Doug</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Am I getting this right:</p>
<ul>
<li>You want protection against CSRF for users logged in via cookies.</li>
<li>And at the same time you want RESTful interface for Basic, OAuth and Digest authenticated requests from apps.</li>
</ul>
<p>So, why not check <strong>whether users is logged in via cookie</strong> and <strong>apply CSRF only then</strong>?</p>
<p>I'm not sure but is possible for another site to forge things like Basic auth or headers?</p>
<p>As far as I know , CSRF is <strong>all about cookies</strong>? RESTful auth doesn't happen with cookies.</p>
</div></text><author><a href="/users/339872/antitoxic">antitoxic</a></author><comments><comment><text><span class="comment-copy">I was wondering about this too! According to this article <a href="https://mathieu.fenniak.net/is-your-web-api-susceptible-to-a-csrf-exploit/" rel="nofollow noreferrer">mathieu.fenniak.net/â€¦</a> It should be possible to switch on CSRF checks if someone is coming via a cookie/session, and switch it off, if the request is coming through some sort of stateless authentication scheme Basic.. etc.</span></text><author><a class="comment-user" href="/users/582917/cmcdragonkai" title="2,326 reputation">CMCDragonkai</a></author></comment><comment><text><span class="comment-copy">Take careful with Basic authentication - it is effectively equivalent to a user logged in via a cookie since browsers will send the provided Authorization header on subsequent requests as a user convenience.</span></text><author><a class="comment-user" href="/users/2766/simon-lieschke" title="9,959 reputation">Simon Lieschke</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The static form ID provides no protection at all; an attacker can fetch it himself. Remember, the attacker is not constrained to using JavaScript on the client; he can fetch the static form ID server-side.</p>
<p>I'm not sure I entirely understand the proposed defense; where does the <code>GET /usersecret/john_doe</code> come from? Is that part of the page JavaScript? Is that the literal proposed URL? If so, I'm assuming that <code>username</code> is not a secret, which means that evil.ru can recover user secrets if a browser or plugin bug allows cross-domain GET requests. Why not store the user secret in a cookie upon authentication rather than let anyone who can do cross-domain GETs retrieve it?</p>
<p>I would read <a href="http://crypto.stanford.edu/websec/csrf/csrf.pdf" rel="noreferrer">"Robust Defenses for Cross-Site Forgery"</a> really carefully before I implemented my own authentication system that I wanted to be resistant to CSRF. In fact, I would reconsider implementing my own authentication system at all.</p>
</div></text><author><a href="/users/280016/scott-wolchok">Scott Wolchok</a></author><comments><comment><text><span class="comment-copy">The form ID is something like a public key. You're right, <code>GET /usersecret/john_doe</code> is part of the JavaScript. The username itself is not the secret, but the ID fetched with this request by an authenticated(!) user.  Thank you for the link.</span></text><author><a class="comment-user owner" href="/users/238134/deamon" title="28,457 reputation">deamon</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use an <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Checking_Referer_Header" rel="nofollow">HTTP referer</a> check to prevent CSRF without requiring a per-user state.</p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments><comment><text><span class="comment-copy">This is dangerous advice, while it is difficult to spoof the HTTP referer it is not impossible, also the referer header ist not guaranteed (and not sending a referer header will breaking your app).</span></text><author><a class="comment-user" href="/users/4512/relaxnow" title="1,763 reputation">RelaXNow</a></author></comment><comment><text><span class="comment-copy">@RelaXNow  Check out this CSRF exploit framework I wrote: <a href="https://github.com/TheRook/CSRF-Request-Builder" rel="nofollow noreferrer">github.com/TheRook/CSRF-Request-Builder</a> .  It allows you to specify arbitrary http headers, as well as body.  However,  it <b>cannot change the http referer</b> because this is banned by Flash.  The CSRF prevention cheat sheet is very good, you should read the link in my post.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Fair point, in the context of CSRF an attacker will not be able to (as far as I know) spoof the Referer header of the victim, however the header is still not guaranteed and requiring it for your API should only be done if you can guarantee that it will always be sent (like for an internal application for a company).</span></text><author><a class="comment-user" href="/users/4512/relaxnow" title="1,763 reputation">RelaXNow</a></author></comment><comment><text><span class="comment-copy">@RelaXNow If the request originates from an HTTPS page the referer will be committed from the request. which should be seen as a failure (mentioned in the link above).   People are working on this problem,  Mozilla has introduced the "Origin" http header,  which awesome and worth looking into,  it not only can be used to solve this problem of RESTful csrf protection,  but a lot of other abuses such as json inclusion attacks and click-jacking.   The problem is that not every browser supports it :(.  Also i edited my post,  just in case you wanted to get rid of the -1.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">s/comitted/omitted/ :). Good points / information but I withdrew my -1 a long time ago and upvoted your comments for helpful info.</span></text><author><a class="comment-user" href="/users/4512/relaxnow" title="1,763 reputation">RelaXNow</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>Is something wrong with this approach, despite the fact that it
  doesn't work without JavaScript?</p>
</blockquote>
<p>Your user secret is not a secret if you send it to the client. We usually use such secrets to generate hashes and send them with the form, and wait them back for comparison.</p>
<p>If you want to be RESTful, the request has to contain every information about how to process it. The ways you can do this:</p>
<ul>
<li><p>Add a csrf token cookie with your REST client and send the same token in hidden input with your forms. If the service and the client are under different domains, you have to share the credentials. On the service you have to compare the 2 tokens, and if they are the same, the request is valid...</p></li>
<li><p>You can add the csrf token cookie with your REST service and send the same token with the representations of your resources (hidden inputs, etc...). Everything else is the same as the end of the previous solution. This solution is on the edge of RESTfulness. (It is okay until the client do not call the service to modify the cookie. If the cookie is http only, the client should not know about it, if it is not, then the client should set it.) You can do a more complex solution if you add different tokens to each forms and add expiration time to the cookies. You can send the expiration time back with the forms as well, so you will know the reason when a token validation fails.</p></li>
<li><p>You can have a user secret (different by each user) in the resource state on you service. By building representations, you can generate a token (and expiration time) for each form. You can generate a hash from the actual token (and expiration time, method, url, etc...) and the user secret, and send that hash with the form as well. You keep the "user secret" in secret of course, so you never send that with the form. After that if your service gets a request, you can generate the hash from the request parameters and user secret again, and compare them. If the don't match, the request is invalid...</p></li>
</ul>
<p>None of them will protect you if your REST client is javascript injectable, so you have to check all your user content against HTML entities, and remove all of them, or use TextNodes always instead of innerHTML. You have to protect yourself against SQL injection and HTTP header injection as well. Never use simple FTP to refresh your site. And so on... There are many ways to inject evil code into your site...</p>
<p>I almost forgot to mention, that GET requests are always for reading by the service and by the client either. By the service this is obvious, by the client setting any url in the browser must result a representation of a resource or multiple resources, it should never call a POST/PUT/DELETE method on a resource. For example <code>GET http://my.client.com/resource/delete -&gt; DELETE http://my.api.com/resource</code> is a very-very bad solution. But this is very basic skill if you want to hinder CSRF.</p>
</div></text><author><a href="/users/607033/inf3rno">inf3rno</a></author><comments/></answer></answers></post>