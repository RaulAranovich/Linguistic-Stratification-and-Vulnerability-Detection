<?xml version="1.0" encoding="utf-8"?>
<post><title>node.js - JWT (JSON Web Token) automatic prolongation of expiration - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I would like to implement JWT-based authentication to our new REST API. But since the expiration is set in the token, is it possible to automatically prolong it? I don't want users to need to sign in after every X minutes if they were actively using the application in that period. That would be a huge UX fail. </p>
<p>But prolonging the expiration creates a new token (and the old one is still valid until it expires). And generating a new token after each request sounds silly to me. Sounds like a security issue when more than one token is valid at the same time. Of course I could invalidate the old used one using a blacklist but I would need to store the tokens. And one of the benefits of JWT is no storage.</p>
<p>I found how Auth0 solved it. They use not only JWT token but also a refresh token:
<a href="https://docs.auth0.com/refresh-token">https://docs.auth0.com/refresh-token</a></p>
<p>But again, to implement this (without Auth0) I'd need to store refresh tokens and maintain their expiration. What is the real benefit then? Why not have only one token (not JWT) and keep the expiration on the server?</p>
<p>Are there other options? Is using JWT not suited for this scenario?</p>
</div></text><author><a href="/users/769871/cchamberlain">cchamberlain</a></author><comments><comment><text><span class="comment-copy">Actually there is probably no security issue with many valid tokens at once... There are actually infinite number of valid tokens... So, why to have a refresh token then? I will regenerate them after each request, it should actually be not an issue.</span></text><author><a class="comment-user owner" href="/users/1475865/maryo" title="1,411 reputation">maryo</a></author></comment><comment><text><span class="comment-copy">For SPA, checkout my blog post: <a href="http://blog.wong2.me/2017/02/20/refresh-auth0-token-in-spa/" rel="nofollow noreferrer">blog.wong2.me/2017/02/20/refresh-auth0-token-in-spa</a></span></text><author><a class="comment-user" href="/users/325241/wong2" title="11,023 reputation">wong2</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I work at Auth0 and I was involved in the design of the refresh token feature.</p>
<p>It all depends on the type of application and here is our recommended approach.</p>
<h3>Web applications</h3>
<p>A good pattern is to refresh the token before it expires.</p>
<p>Set the token expiration to one week and refresh the token every time the user open the web application and every one hour. If a user doesn't open the application for more than a week, they will have to login again and this is acceptable web application UX.</p>
<p>To refresh the token your API needs a new endpoint that receives a valid, not expired JWT and returns the same signed JWT with the new expiration field. Then the web application will store the token somewhere.</p>
<h3>Mobile/Native applications</h3>
<p>Most native applications do login once and only once. </p>
<p>The idea is that the refresh token never expires and it can be exchanged always for a valid JWT.</p>
<p>The problem with a token that never expires is that <strong>never</strong> means never. What do you do if you lose your phone? So, it needs to be identifiable by the user somehow and the application needs to provide a way to revoke access. We decided to use the device's name, e.g. "maryo's iPad". Then the user can go to the application and revoke access to "maryo's iPad".</p>
<p>Another approach is to revoke the refresh token on specific events. An interesting event is changing the password.</p>
<p>We believe that JWT is not useful for these use cases so we use a random generated string and we store it on our side.</p>
</div></text><author><a href="/users/234047/jos%c3%a9-f-romaniello">José F. Romaniello</a></author><comments><comment><text><span class="comment-copy">For the web applications recommended approach, if the token is valid for a week are we not concerned with someone intercepting the token and then being able to use it for such a long time? Disclaimer: I don't quite know what I'm talking about.</span></text><author><a class="comment-user" href="/users/2905173/wbeange" title="1,550 reputation">wbeange</a></author></comment><comment><text><span class="comment-copy">@wbeange yes interception is an issue, even with cookies. You should use https.</span></text><author><a class="comment-user" href="/users/234047/jos%c3%a9-f-romaniello" title="6,297 reputation">José F. Romaniello</a></author></comment><comment><text><span class="comment-copy">@JoséF.Romaniello Can you clarify what you mean by 'We believe that JWT is not useful for these use cases so we use a random generated string and we store it on our side.' Which use cases and what is the random string for?</span></text><author><a class="comment-user" href="/users/3184884/devfox" title="419 reputation">DevFox</a></author></comment><comment><text><span class="comment-copy">@DevFox I meant that the refresh token is not a JWT but an opaque token.</span></text><author><a class="comment-user" href="/users/234047/jos%c3%a9-f-romaniello" title="6,297 reputation">José F. Romaniello</a></author></comment><comment><text><span class="comment-copy">I used an angular interceptor to implement the refresh with each http request.</span></text><author><a class="comment-user" href="/users/1563654/daniel-watrous" title="627 reputation">Daniel Watrous</a></author></comment><comment><text><span class="comment-copy"><b>Web app</b>: if you don't like refreshing every hour or you want to try an alternative solution, you could make all API requests pass through a server-side proxy that stores in a persistent way the users' refresh tokens and intercepts the 401 responses and exchange tokens before logging the users out. Note that in this way the refresh tokens are not exposed to the client, and the users would experience the same authentication as in native apps</span></text><author><a class="comment-user" href="/users/843310/fab" title="76 reputation">Fab</a></author></comment><comment><text><span class="comment-copy">@JoséF.Romaniello, when you discuss generating a random string and storing it. Could you elaborate? Do you mean you store in on the mobile device, or on the server? What happens if they get a hold of the name of the device, or this random string (assuming it is on client) Wouldn't this let them get around any tokens being revoked?</span></text><author><a class="comment-user" href="/users/180253/thejedicowboy" title="2,293 reputation">TheJediCowboy</a></author></comment><comment><text><span class="comment-copy">Also, to clarify...the refresh token you reference..is that meant to not expire in both web and mobile?</span></text><author><a class="comment-user" href="/users/180253/thejedicowboy" title="2,293 reputation">TheJediCowboy</a></author></comment><comment><text><span class="comment-copy">@JoséF.Romaniello In your web application example, everything makes sense to me except having to store the token.  I thought the beauty of JWT was stateless authentication - meaning the web application does NOT have to store the token as it is signed.  I would think the server could just check the validity of the token, make sure it's within the expiration period, and then issue a renewed JWT token. Could you please elaborate on this?  Maybe I just don't understand JWTs enough yet.</span></text><author><a class="comment-user" href="/users/269876/lo-tan" title="2,159 reputation">Lo-Tan</a></author></comment><comment><text><span class="comment-copy">@JoséF.Romaniello I have the same question as Lo-Tan. If we are storing  tokens in the database how is it different from the traditional web sessions?</span></text><author><a class="comment-user" href="/users/1870400/user1870400" title="631 reputation">user1870400</a></author></comment><comment><text><span class="comment-copy">@user1870400 Sorry for the confusion, I meant client-side in the browser, like local storage or a cookie.</span></text><author><a class="comment-user" href="/users/234047/jos%c3%a9-f-romaniello" title="6,297 reputation">José F. Romaniello</a></author></comment><comment><text><span class="comment-copy">Two questions/concerns: 1- Web Application case: why can't expired token be allowed to get a refresh? Say we set short expiration (1 hour) &amp; make renew calls to the backend server when a token expires, as you said. 2- Is there a security concern with storing the hashed (with random salt) password in the token? The idea is that if it's there, the backend server can check against the stored password in the DB when asked for a renewal, &amp; deny request if passwords don't match. This would cover the Mobile/Native app password change, allowing the solution to be extended to Mobile use case.</span></text><author><a class="comment-user" href="/users/2788095/psamaan" title="241 reputation">psamaan</a></author></comment><comment><text><span class="comment-copy">@psamaan Your comment realizes the trouble with stolen devices, similar somehow to the logic when  password changes. I believe if you already have the refresh token persisted on the server side, for validation when a token needs to be refreshed, there is no need to include in the token the hashed password as you would only simply need to delete all previous refresh tokens of the user after he changes is password.  Also you get the benefit that in you backend the user can check all his opened sessions based on the refresh tokens and can invalidate. Like facebook, gmail does</span></text><author><a class="comment-user" href="/users/1015034/le0diaz" title="1,078 reputation">le0diaz</a></author></comment><comment><text><span class="comment-copy">@le0diaz I should have clarified that I'm trying to reach a solution where I don't persist a refresh token on the backend &amp; rely purely on a client JWT, the reason is that I'm trying to allow the backend to scale horizontally without maintaining a common cache (i.e. a fully distributed system)</span></text><author><a class="comment-user" href="/users/2788095/psamaan" title="241 reputation">psamaan</a></author></comment><comment><text><span class="comment-copy">But what if someone have refresh token which never expire? He will have access to your account forever?</span></text><author><a class="comment-user" href="/users/4207462/vladimir" title="344 reputation">Vladimir</a></author></comment><comment><text><span class="comment-copy">@psamaan Some time later, what did you end up with? I'm having the same thoughts as you for the same reasons. By putting a hash of the user PW and scopes in the Access token, this hash could be compared with the current values in the backend each time an Access Token expires. If these values are not changed, and the account is not locked, (and possibly, the Access Token is not in a blacklist), the expired Access Token is enough to issue a new Access Token. This makes the expiry time in an Access Token becomes a "heart beat" describing how often to validate a request towards the backend DB.</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment><comment><text><span class="comment-copy">for web app, I don't think refresh the token before it expires solve any sercurity problem but increase complexity .compare with the JWT token with a short expire time it works the same way. using an unsecure token to get another unsecure token not make sence to me!  Although I use Auth0...</span></text><author><a class="comment-user" href="/users/4985526/tyan" title="492 reputation">tyan</a></author></comment><comment><text><span class="comment-copy">@AndreasLundgren I still think it's a good solution. I've talked to people who have been very uncomfortable with storing a hashed password in the token though. I'm not sure why exactly, since having the token means having the password (or being able to change it) during its validity period anyway. A safer option would be having a second, randomly generated "password" (similar to the refresh token idea) that's in the payload of the access token, that's what gets checked for validity on refresh. You'd change this "password" when user password changes, or when you revoke access for example.</span></text><author><a class="comment-user" href="/users/2788095/psamaan" title="241 reputation">psamaan</a></author></comment><comment><text><span class="comment-copy">@psamaan I agree. (In some services you cannot change your pw with just the token, but a pw change require the user to enter the pw again.) I meant a hash of the "salted and hashed pw"+scope+accountStatus just to avoid bugs about regenerating the random "refresh token" when these values changes. But to explicitly regenerate a random refresh token is a write similar solution.</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment><comment><text><span class="comment-copy">@JoséF.Romaniello You said in the Web App example that it is best to "Set the token expiration to one week" - I can't figure out at all how to set the expiry of a refresh token - I thought they lasted forever unless they were revoked. I'm a bit confused! Thanks!</span></text><author><a class="comment-user" href="/users/1895789/steven-winston" title="62 reputation">Steven Winston</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In the case where you handle the auth yourself (i.e don't use a provider like Auth0), the following may work:</p>
<ol>
<li>Issue JWT token with relatively short expiry, say 15min.</li>
<li>Application checks token expiry date before any transaction requiring a token (token contains expiry date). If token has expired, then it first asks API to 'refresh' the token (this is done transparently to the UX).</li>
<li>API gets token refresh request, but first checks user database to see if a 'reauth' flag has been set against that user profile (token can contain user id). If the flag is present, then the token refresh is denied, otherwise a new token is issued.</li>
<li>Repeat.</li>
</ol>
<p>The 'reauth' flag in the database backend would be set when, for example, the user has reset their password. The flag gets removed when the user logs in next time.</p>
<p>In addition, let's say you have a policy whereby a user must login at least once every 72hrs. In that case, your API token refresh logic would also check the user's last login date from the user database and deny/allow the token refresh on that basis.</p>
</div></text><author><a href="/users/202311/ianb">IanB</a></author><comments><comment><text><span class="comment-copy">I don't think this would be secure. If I was an attacker and stole your token and sent it to the server, the server would check and see the flag is set to true which is great as it would block a refresh. The problem I think would be if the victim changed their password the flag would be set to false and now the attacker can use that original token to refresh.</span></text><author><a class="comment-user" href="/users/2924127/user2924127" title="1,394 reputation">user2924127</a></author></comment><comment><text><span class="comment-copy">@user2924127 no auth solution is perfect, and there will always be tradeoffs. If an attacker is in a position to 'steal your token', then you may have greater issues to worry about. Setting a maximum token lifetime would be a useful tweak to the above.</span></text><author><a class="comment-user" href="/users/202311/ianb" title="1,325 reputation">IanB</a></author></comment><comment><text><span class="comment-copy">instead of having another field in the database, reauth flag, you can include  for hash(bcrypt_password_hash) in the token. Then when refreshing token, you just confirm if hash(bcrypt_password_hash) is equal to a value from the token. In order to deny token refresh, one has to just update password hash.</span></text><author><a class="comment-user" href="/users/192601/bas" title="483 reputation">bas</a></author></comment><comment><text><span class="comment-copy">@bas, thinking of in optimizations and performance, I think the password hash  validation would be redundant and have more server implications. Increase the size of the token so signature firm/validation takes more time. additional hash calculations for server for the password. with the extra field approach you just validate in the recalculation with a simple boolean. Db updates is less frequent for the extra field, but is more frequent token refreshes. And you get the optional service of force individual re logins for any existing session (mobile, web, etc).</span></text><author><a class="comment-user" href="/users/1015034/le0diaz" title="1,078 reputation">le0diaz</a></author></comment><comment><text><span class="comment-copy">@le0diaz I didn't suggest password hashing but to hash a string (can be modified_at, password or any data that should trigger logout) with a fast hashing function, let's say md5. Nowadays, doing md5(short_string) is not a performance issue. If you need to force "individual re logins", then reauth won't help here either.</span></text><author><a class="comment-user" href="/users/192601/bas" title="483 reputation">bas</a></author></comment><comment><text><span class="comment-copy">I think the first comment by user2924127 is actually wrong. When the password is changed, the account is marked as requiring a re-authentication, so any existing expired tokens will be invalid.</span></text><author><a class="comment-user" href="/users/96233/ralph" title="12,257 reputation">Ralph</a></author></comment><comment><text><span class="comment-copy">I like this method, its kind a hybrid solution.</span></text><author><a class="comment-user" href="/users/954602/selim-ok" title="654 reputation">Selim Ok</a></author></comment><comment><text><span class="comment-copy">@Ralph I think the other way around, if the password is changed, old expired tokens will still be valid. The <i>first</i> hit will require an reauthentication, but then successive calls will pass again. So the existing expired tokens will very much still be valid. Just like user2924127 mentioned.</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment><comment><text><span class="comment-copy">@bas This is good unless you ever want to put in more triggers in your hash. Maybe a to force re-login when changing IP to the other side of the world in 1 second or something like that. Then if you change your algorithm for calculation the hash, all your users will need to re-login on the next BE invocation. One solution could be to store the hash in the DB and check agains that hash each time an Access Token needs to get renewed.</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment><comment><text><span class="comment-copy">@user2924127 Very much a valid point! No only if an attacker is invloved. If you are logged in on multiple deviced, the end user will have a very odd behaviour. Having to re-login only on the first device after a password update... Let's say you logged in at a friends computer, or a computer at a internet Cafe, work school etc. You would expect a password change to lock the account on your those computers.</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment><comment><text><span class="comment-copy">@AndreasLundgren this is true. Remember that each token has a creation time, so one workaround would be to simply compare the password reset time with the token creation time - tokens created prior to the last password reset would not get renewed.</span></text><author><a class="comment-user" href="/users/202311/ianb" title="1,325 reputation">IanB</a></author></comment><comment><text><span class="comment-copy">@AndreasLundgren end user will have to re-login on every device unless his token is obtained by login session that used current password. So password change will lock the account on all computers.</span></text><author><a class="comment-user" href="/users/192601/bas" title="483 reputation">bas</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I was tinkering around when moving our applications to HTML5 with RESTful apis in the backend. The solution that I came up with was:</p>
<ol>
<li>Client is issued with a token with a session time of 30 mins (or whatever the usual server side session time) upon successful login.</li>
<li>A client-side timer is created to call a service to renew the token before its expiring time. The new token will replace the existing in future calls.</li>
</ol>
<p>As you can see, this reduces the frequent refresh token requests. If user closes the browser/app before the renew token call is triggered, the previous token will expire in time and user will have to re-login.</p>
<p>A more complicated strategy can be implemented to cater for user inactivity (e.g. neglected an opened browser tab). In that case, the renew token call should include the expected expiring time which should not exceed the defined session time. The application will have to keep track of the last user interaction accordingly.</p>
<p>I don't like the idea of setting long expiration hence this approach may not work well with native applications requiring less frequent authentication.</p>
</div></text><author><a href="/users/3151014/coolersport">coolersport</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<h3><a href="https://npmjs.com/package/jwt-autorefresh" rel="nofollow">jwt-autorefresh</a></h3>
<p>If you are using node (React / Redux / Universal JS) you can install <code>npm i -S jwt-autorefresh</code>.</p>
<p>This library schedules refresh of JWT tokens at a user calculated number of seconds prior to the access token expiring (based on the exp claim encoded in the token). It has an extensive test suite and checks for quite a few conditions to ensure any strange activity is accompanied by a descriptive message regarding misconfigurations from your environment.</p>
<p><strong>Full example implementation</strong></p>
<pre class="lang-js prettyprint prettyprinted" style=""><code><span class="kwd">import</span><span class="pln"> autorefresh from </span><span class="str">'jwt-autorefresh'</span><span class="pln">

</span><span class="com">/** Events in your app that are triggered when your user becomes authorized or deauthorized. */</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> onAuthorize</span><span class="pun">,</span><span class="pln"> onDeauthorize </span><span class="pun">}</span><span class="pln"> from </span><span class="str">'./events'</span><span class="pln">

</span><span class="com">/** Your refresh token mechanism, returning a promise that resolves to the new access tokenFunction (library does not care about your method of persisting tokens) */</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> refresh </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> init </span><span class="pun">=</span><span class="pln">  </span><span class="pun">{</span><span class="pln"> method</span><span class="pun">:</span><span class="pln"> </span><span class="str">'POST'</span><span class="pln">
                </span><span class="pun">,</span><span class="pln"> headers</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">'Content-Type'</span><span class="pun">:</span><span class="pln"> </span><span class="pun">`</span><span class="pln">application</span><span class="pun">/</span><span class="pln">x</span><span class="pun">-</span><span class="pln">www</span><span class="pun">-</span><span class="pln">form</span><span class="pun">-</span><span class="pln">urlencoded</span><span class="pun">`</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
                </span><span class="pun">,</span><span class="pln"> body</span><span class="pun">:</span><span class="pln"> </span><span class="pun">`</span><span class="pln">refresh_token</span><span class="pun">=</span><span class="pln">$</span><span class="pun">{</span><span class="pln">localStorage</span><span class="pun">.</span><span class="pln">refresh_token</span><span class="pun">}&amp;</span><span class="pln">grant_type</span><span class="pun">=</span><span class="pln">refresh_token</span><span class="pun">`</span><span class="pln">
                </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> fetch</span><span class="pun">(</span><span class="str">'/oauth/token'</span><span class="pun">,</span><span class="pln"> init</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">then</span><span class="pun">(</span><span class="pln">res </span><span class="pun">=&gt;</span><span class="pln"> res</span><span class="pun">.</span><span class="pln">json</span><span class="pun">())</span><span class="pln">
    </span><span class="pun">.</span><span class="pln">then</span><span class="pun">(({</span><span class="pln"> token_type</span><span class="pun">,</span><span class="pln"> access_token</span><span class="pun">,</span><span class="pln"> expires_in</span><span class="pun">,</span><span class="pln"> refresh_token </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      localStorage</span><span class="pun">.</span><span class="pln">access_token </span><span class="pun">=</span><span class="pln"> access_token
      localStorage</span><span class="pun">.</span><span class="pln">refresh_token </span><span class="pun">=</span><span class="pln"> refresh_token
      </span><span class="kwd">return</span><span class="pln"> access_token
    </span><span class="pun">})</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">/** You supply a leadSeconds number or function that generates a number of seconds that the refresh should occur prior to the access token expiring */</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> leadSeconds </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">/** Generate random additional seconds (up to 30 in this case) to append to the lead time to ensure multiple clients dont schedule simultaneous refresh */</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> jitter </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">floor</span><span class="pun">(</span><span class="typ">Math</span><span class="pun">.</span><span class="pln">random</span><span class="pun">()</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">30</span><span class="pun">)</span><span class="pln">

  </span><span class="com">/** Schedule autorefresh to occur 60 to 90 seconds prior to token expiration */</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">60</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> jitter
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">let</span><span class="pln"> start </span><span class="pun">=</span><span class="pln"> autorefresh</span><span class="pun">({</span><span class="pln"> refresh</span><span class="pun">,</span><span class="pln"> leadSeconds </span><span class="pun">})</span><span class="pln">
</span><span class="kwd">let</span><span class="pln"> cancel </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
onAuthorize</span><span class="pun">(</span><span class="pln">access_token </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  cancel</span><span class="pun">()</span><span class="pln">
  cancel </span><span class="pun">=</span><span class="pln"> start</span><span class="pun">(</span><span class="pln">access_token</span><span class="pun">)</span><span class="pln">
</span><span class="pun">})</span><span class="pln">

onDeauthorize</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> cancel</span><span class="pun">())</span></code></pre>
<p><strong>disclaimer: I am the maintainer</strong></p>
</div></text><author><a href="/users/769871/cchamberlain">cchamberlain</a></author><comments><comment><text><span class="comment-copy">Question about this, I saw the decode function it uses. Does it assume the JWT can be decoded without using a secret? Does it work with JWT that were signed with a secret?</span></text><author><a class="comment-user" href="/users/2911851/gian-franco-zabarino" title="146 reputation">Gian Franco Zabarino</a></author></comment><comment><text><span class="comment-copy">Yes, the decode is a client-only decode and should not be aware of the secret. The secret is used to sign the JWT token server-side to verify that your signature was used to generate the JWT originally and should never be used from the client. The magic of JWT is that its payload can be decoded client-side and the claims inside can be used to build your UI without the secret. The only thing <code>jwt-autorefresh</code> decodes it for is to extract the <code>exp</code> claim so it can determine how far out to schedule the next refresh.</span></text><author><a class="comment-user" href="/users/769871/cchamberlain" title="5,640 reputation">cchamberlain</a></author></comment><comment><text><span class="comment-copy">Oh good to know, something didn't make sense but now it does. Thanks for the answer.</span></text><author><a class="comment-user" href="/users/2911851/gian-franco-zabarino" title="146 reputation">Gian Franco Zabarino</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>How about this approach:</p>
<ul>
<li>For every client request, the server compares the expirationTime of the token with (currentTime - lastAccessTime)</li>
<li>If <strong>expirationTime &lt; (currentTime - lastAccessedTime)</strong>, it changes the last lastAccessedTime to currentTime.</li>
<li>In case of inactivity on the browser for a time duration exceeding expirationTime or in case the browser window was closed and <strong>the expirationTime &gt; (currentTime - lastAccessedTime)</strong>, and then the server can expire the token and ask the user to login again.</li>
</ul>
<p>We don't require additional end point for refreshing the token in this case.
Would appreciate any feedack.</p>
</div></text><author><a href="/users/4984475/sjaiswal">sjaiswal</a></author><comments><comment><text><span class="comment-copy">Is it a good choice in this day, It's look pretty much easy for implementation.</span></text><author><a class="comment-user" href="/users/3187183/b-ben" title="107 reputation">b.ben</a></author></comment><comment><text><span class="comment-copy">In this case, where do you store lastAccessedTime? You have to do it on backend and per request, so it becomes a not desired stateful solution.</span></text><author><a class="comment-user" href="/users/3971900/antgar9" title="199 reputation">antgar9</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Good question- and there is wealth of information in the question itself.</p>
<p>The article <a href="https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/" rel="nofollow">Refresh Tokens: When to Use Them and How They Interact with JWTs</a> gives a good idea for this scenario. Some points are:-</p>
<ul>
<li>Refresh tokens carry the information necessary to get a new access
token. </li>
<li>Refresh tokens can also expire but are rather long-lived. </li>
<li>Refresh tokens are usually subject to strict storage requirements to
ensure they are not leaked. </li>
<li>They can also be blacklisted by the  authorization server.</li>
</ul>
<p>Also take a look at <a href="https://github.com/auth0/angular-jwt" rel="nofollow">auth0/angular-jwt</a> angularjs</p>
<p>For Web API. read <a href="http://bitoftech.net/2014/07/16/enable-oauth-refresh-tokens-angularjs-app-using-asp-net-web-api-2-owin/" rel="nofollow">Enable OAuth Refresh Tokens in AngularJS App using ASP .NET Web API 2, and Owin</a></p>
</div></text><author><a href="/users/696627/lijo">Lijo</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I actually implemented this in PHP using the Guzzle client to make a client library for the api, but the concept should work for other platforms.</p>
<p>Basically, I issue two tokens, a short (5 minute) one and a long one that expires after a week.  The client library uses middleware to attempt one refresh of the short token if it receives a 401 response to some request.  It will then try the original request again and if it was able to refresh gets the correct response, transparently to the user.  If it failed, it will just send the 401 up to the user.</p>
<p>If the short token is expired, but still authentic and the long token is valid and authentic, it will refresh the short token using a special endpoint on the service that the long token authenticates (this is the only thing it can be used for).  It will then use the short token to get a new long token, thereby extending it another week every time it refreshes the short token.</p>
<p>This approach also allows us to revoke access within at most 5 minutes, which is acceptable for our use without having to store a blacklist of tokens.</p>
</div></text><author><a href="/users/6806936/byteporter">BytePorter</a></author><comments/></answer></answers></post>