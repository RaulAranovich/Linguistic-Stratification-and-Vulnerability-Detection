<?xml version="1.0" encoding="utf-8"?>
<post><title>security - What are the best practices for avoiding xss attacks in a PHP site - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I have PHP configured so that magic quotes are on and register globals are off.</p>
<p>I do my best to always call htmlentities() for anything I am outputing that is derived from user input.</p>
<p>I also occasionally seach my database for common things used in xss attached such as...</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">&lt;script</span></code></pre>
<p>What else should I be doing and how can I make sure that the things I am trying to do are <strong>always</strong> done.</p>
</div></text><author><a href="/users/4012/rik-heywood">Rik Heywood</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Escaping input is not the best you can do for successful XSS prevention. Also output must be escaped. If you use Smarty template engine, you may use <code>|escape:'htmlall'</code> modifier to convert all sensitive characters to HTML entities (I use own <code>|e</code> modifier which is alias to the above).</p>
<p>My approach to input/output security is:</p>
<ul>
<li>store user input not modified (no HTML escaping on input, only DB-aware escaping done via PDO prepared statements)</li>
<li>escape on output, depending on what output format you use (e.g. HTML and JSON need different escaping rules)</li>
</ul>
</div></text><author><a href="/users/2169/micha%c5%82-rudnicki">Michał Rudnicki</a></author><comments><comment><text><span class="comment-copy">htmlentities() is an overkill and it's encoding-sensitive. htmlspecialchars() protects just as well.</span></text><author><a class="comment-user" href="/users/27009/kornel" title="66,242 reputation">Kornel</a></author></comment><comment><text><span class="comment-copy">htmlspecialchars may not be your friend : <a href="http://stackoverflow.com/questions/110575/do-htmlspecialchars-and-mysqlrealescapestring-keep-my-php-code-safe-from-injec" title="do htmlspecialchars and mysqlrealescapestring keep my php code safe from injec">stackoverflow.com/questions/110575/…</a></span></text><author><a class="comment-user" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">@Cheekysoft: Just set the <a href="http://au.php.net/htmlspecialchars#refsect1-function.htmlspecialchars-parameters" rel="nofollow noreferrer">appropriate flags</a></span></text><author><a class="comment-user" href="/users/165495/casebash" title="39,042 reputation">Casebash</a></author></comment><comment><text><span class="comment-copy">As I think It would be better to escape first and then save it in Database because in this way you will have to escape only once but if you just store it DB and escape everytime user visits site can make work a bit server loaded. And most of the escaping are same for PHP and Node.js. So better Escape first and then save.</span></text><author><a class="comment-user" href="/users/2026065/abdul-jabbar-webbestow" title="2,305 reputation">Abdul Jabbar WebBestow</a></author></comment><comment><text><span class="comment-copy">@AbdulJabbarWebBestow absolutely not. Data base is a place where you store data in output agnostic format. Different output devices require different escaping rules, thus by escaping for HTML output before hitting the database you lock yourself out from writing APIs, PDF exports, etc. Don't worry about server load. It's their job to be loaded.</span></text><author><a class="comment-user" href="/users/2169/micha%c5%82-rudnicki" title="10,578 reputation">Michał Rudnicki</a></author></comment><comment><text><span class="comment-copy">@MichałRudnicki I am not really ironing but can you give some different examples where we need different escaping because as far as I know escaping is same for all. And about database load then it's probable our duty to decrease load as much as possible otherwise this gonna take down your server. And most of the times about 75% it's html which requires same escaping and when the time comes for PDF or else you can use decode functions to reverse.</span></text><author><a class="comment-user" href="/users/2026065/abdul-jabbar-webbestow" title="2,305 reputation">Abdul Jabbar WebBestow</a></author></comment><comment><text><span class="comment-copy">@AbdulJabbarWebBestow Quotes <code>"</code> need to be escaped as <code>&amp;quot;</code> for use in HTML, but <code>\"</code> for use in most other languages.</span></text><author><a class="comment-user" href="/users/1016716/mr-lister" title="27,573 reputation">Mr Lister</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm of the opinion that one shouldn't escape anything during input, only on output. Since (most of the time) you can not assume that you know where that data is going. Example, if you have form that takes data that later on appears in an email that you send out, you need different escaping (otherwise a malicious user could rewrite your email-headers). </p>
<p>In other words, you can only escape at the very last moment the data is "leaving" your application:</p>
<ul>
<li>List item</li>
<li>Write to XML file, escape for XML</li>
<li>Write to DB, escape (for that particular DBMS)</li>
<li>Write email, escape for emails</li>
<li>etc</li>
</ul>
<p>To go short:</p>
<ol>
<li>You don't know where your data is going</li>
<li>Data might actually end up in more than one place, needing different escaping mechanism's BUT NOT BOTH</li>
<li>Data escaped for the wrong target is really not nice. (E.g. get an email with the subject "Go to Tommy\'s bar".)</li>
</ol>
<p>Esp #3 will occur if you escape data at the input layer (or you need to de-escape it again, etc).</p>
<p>PS: I'll second the advice for not using magic_quotes, those are pure evil!</p>
</div></text><author><a href="/users/13864/jilles">Jilles</a></author><comments><comment><text><span class="comment-copy">Bonus round: <a href="https://klikki.fi/adv/wordpress2.html" rel="nofollow noreferrer">WordPress got owned by XSS via MySQL column truncation in 2015</a> thanks to filtering on input, rather than output.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There are a lot of ways to do XSS (See <a href="http://ha.ckers.org/xss.html" rel="noreferrer">http://ha.ckers.org/xss.html</a>) and it's very hard to catch.</p>
<p>I personally delegate this to the current framework I'm using (Code Igniter for example). While not perfect, it might catch more than my hand made routines ever do.</p>
</div></text><author><a href="/users/6260/christian-studer">Christian Studer</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This is a great question.</p>
<p>First, don't escape text on input except to make it safe for storage (such as being put into a database). The reason for this is you want to keep what was input so you can contextually present it in different ways and places. Making changes here can compromise your later presentation.</p>
<p>When you go to present your data filter out what shouldn't be there. For example, if there isn't a reason for javascript to be there search for it and remove it. An easy way to do that is to use the <a href="http://us.php.net/strip_tags" rel="noreferrer">strip_tags</a> function and only present the html tags you are allowing.</p>
<p>Next, take what you have and pass it thought htmlentities or htmlspecialchars to change what's there to ascii characters. Do this based on context and what you want to get out.</p>
<p>I'd, also, suggest turning off Magic Quotes. It is has been removed from PHP 6 and is considered bad practice to use it. Details at <a href="http://us3.php.net/magic_quotes" rel="noreferrer">http://us3.php.net/magic_quotes</a></p>
<p>For more details check out <a href="http://ha.ckers.org/xss.html" rel="noreferrer">http://ha.ckers.org/xss.html</a></p>
<p>This isn't a complete answer but, hopefully enough to help you get started.</p>
</div></text><author><a href="/users/11910/matt-farina">Matt Farina</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>rikh Writes:</p>
<blockquote>
<p>I do my best to always call htmlentities() for anything I am outputing that is derived from user input.</p>
</blockquote>
</blockquote>
<p>See Joel's essay on <a href="http://www.joelonsoftware.com/articles/Wrong.html" rel="nofollow noreferrer">Making Code Look Wrong</a> for help with this </p>
</div></text><author><a href="/users/8973/mason">Mason</a></author><comments><comment><text><span class="comment-copy">+1 for a link to a great article</span></text><author><a class="comment-user" href="/users/64053/josiah" title="1,870 reputation">Josiah</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I rely on <a href="http://phptal.motion-twin.com/" rel="nofollow noreferrer">PHPTAL</a> for that.</p>
<p>Unlike Smarty and plain PHP, it escapes all output by default. This is a big win for security, because your site won't become vurnelable if you forget <code>htmlspecialchars()</code> or <code>|escape</code> somewhere.</p>
<p>XSS is HTML-specific attack, so HTML output is the right place to prevent it. You should not try pre-filtering data in the database, because you could need to output data to another medium which doesn't accept HTML, but has its own risks.</p>
</div></text><author><a href="/users/27009/kornel">Kornel</a></author><comments><comment><text><span class="comment-copy">Only solves the output to HTML, not output to SQL, Mail, XML, etc...</span></text><author><a class="comment-user" href="/users/13864/jilles" title="699 reputation">Jilles</a></author></comment><comment><text><span class="comment-copy">SQL does not execute JavaScript. Transforming data to a safe subset common to HTML, SQL, mail, etc. is too limiting and doesn't eliminate risk completely. Proper escaping of HTML output is bulletproof for HTML. For proper SQL escaping use SQL tools!</span></text><author><a class="comment-user" href="/users/27009/kornel" title="66,242 reputation">Kornel</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Template library.</strong> Or at least, that is what template libraries should do.
To prevent XSS <em>all</em> output should be encoded. This is not the task of the main application / control logic, it should solely be handled by the output methods.</p>
<p>If you sprinkle htmlentities() thorughout your code, the overall design is wrong. And as you suggest, you might miss one or two spots.
That's why the only solution is rigorous html encoding <em>-&gt; when</em> output vars get written into a html/xml stream.</p>
<p>Unfortunately, most php template libraries only add their own template syntax, but don't concern themselves with output encoding, or localization, or html validation, or anything important. Maybe someone else knows a proper template library for php?</p>
</div></text><author><a href="/users/319490/user319490">user319490</a></author><comments><comment><text><span class="comment-copy">I agree wholeheartedly, and I would say that the best template library is xsl.</span></text><author><a class="comment-user" href="/users/64053/josiah" title="1,870 reputation">Josiah</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Escaping all user input is enough for most sites. Also make sure that session IDs don't end up in the URL so they can't be stolen from the <code>Referer</code> link to another site. Additionally, if you allow your users to submit links, make sure no <code>javascript:</code> protocol links are allowed; these would execute a script as soon as the user clicks on the link.</p>
</div></text><author><a href="/users/1968/konrad-rudolph">Konrad Rudolph</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If you are concerned about XSS attacks, encoding your output strings to HTML is the solution. If you remember to encode every single output character to HTML format, there is no way to execute a successful XSS attack.</p>
<p>Read more:
<a href="http://www.diovo.com/2008/09/sanitizing-user-data-how-and-where-to-do-it/" rel="nofollow noreferrer">Sanitizing user data: How and where to do it</a></p>
</div></text><author><a href="/users/184/niyaz">Niyaz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Personally, I would disable magic_quotes. In PHP5+ it is disabled by default and it is better to code as if it is not there at all as it does not escape everything and it will be removed from PHP6.</p>
<p>Next, depending on what type of user data you are filtering will dictate what to do next e.g. if it is just text e.g. a name, then <code>strip_tags(trim(stripslashes()));</code> it or to check for ranges use regular expressions.</p>
<p>If you expect a certain range of values, create an array of the valid values and only allow those values through (<code>in_array($userData, array(...))</code>).</p>
<p>If you are checking numbers use is_numeric to enforce whole numbers or cast to a specific type, that should prevent people trying to send strings in stead.</p>
<p>If you have PHP5.2+ then consider looking at <a href="http://ca.php.net/filter" rel="nofollow noreferrer">filter()</a> and making use of that extension which can filter various data types including email addresses. Documentation is not particularly good, but is improving.</p>
<p>If you have to handle HTML then you should consider something like <a href="http://cyberai.users.phpclasses.org/browse/package/2189.html" rel="nofollow noreferrer">PHP Input Filter</a> or <a href="http://htmlpurifier.org/" rel="nofollow noreferrer">HTML Purifier</a>. HTML Purifier will also validate HTML for conformance. I am not sure if Input Filter is still being developed. Both will allow you to define a set of tags that can be used and what attributes are allowed.</p>
<p>Whatever you decide upon, always remember, never ever trust anything coming into your PHP script from a user (including yourself!).</p>
</div></text><author><a>NONE</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>All of these answers are great, but fundamentally, the solution to XSS will be to stop generating HTML documents by string manipulation.</p>
<p>Filtering input is always a good idea for any application.</p>
<p>Escaping your output using htmlentities() and friends should work as long as it's used properly, but this is the HTML equivalent of creating a SQL query by concatenating strings with mysql_real_escape_string($var) - it should work, but fewer things can validate your work, so to speak, compared to an approach like using parameterized queries.</p>
<p>The long-term solution should be for applications to construct the page internally, perhaps using a standard interface like the DOM, and then to use a library (like libxml) to handle the serialization to XHTML/HTML/etc.  Of course, we're a long ways away from that being popular and fast enough, but in the meantime we have to build our HTML documents via string operations, and that's inherently more risky.</p>
</div></text><author><a href="/users/7548/daniel-papasian">Daniel Papasian</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I find that using this function helps to strip out a lot of possible xss attacks:
<a href="http://www.codebelay.com/killxss.phps" rel="nofollow noreferrer">http://www.codebelay.com/killxss.phps</a></p>
</div></text><author><a href="/users/13518/barce">barce</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>“Magic quotes” is a palliative remedy for some of the worst XSS flaws which works by escaping everything on input, something that's wrong by design. The only case where one would want to use it is when you absolutely must use an existing PHP application known to be written carelessly with regard to XSS. (In this case you're in a serious trouble even with “magic quotes”.) When developing your own application, you should disable “magic quotes” and follow XSS-safe practices instead.</p>
<p>XSS, a cross-site scripting vulnerability, occurs when an application includes strings from external sources (user input, fetched from other websites, etc) in its [X]HTML, CSS, ECMAscript or other browser-parsed output without proper escaping, hoping that special characters like less-than (in [X]HTML), single or double quotes (ECMAscript) will never appear. The proper solution to it is to always escape strings according to the rules of the output language: using entities in [X]HTML, backslashes in ECMAscript etc.</p>
<p>Because it can be hard to keep track of what is untrusted and has to be escaped, it's a good idea to always escape everything that is a “text string” as opposed to “text with markup” in a language like HTML. Some programming environments make it easier by introducing several incompatible string types: “string” (normal text), “HTML string” (HTML markup) and so on. That way, a direct implicit conversion from “string” to “HTML string” would be impossible, and the only way a string could become HTML markup is by passing it through an escaping function.</p>
<p>“Register globals”, though disabling it is definitely a good idea, deals with a problem entirely different from XSS.</p>
</div></text><author><a href="/users/10682/alexey-feldgendler">Alexey Feldgendler</a></author><comments><comment><text><span class="comment-copy">Don't use register globals. They make it easy to write insecure code and have been depreciated in the time since this was posted.</span></text><author><a class="comment-user" href="/users/5625/james" title="1,407 reputation">James</a></author></comment><comment><text><span class="comment-copy">I meant disabling register globals, of course, not enabling. Typo.</span></text><author><a class="comment-user" href="/users/10682/alexey-feldgendler" title="1,589 reputation">Alexey Feldgendler</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Make you any session cookies (or all cookies) you use HttpOnly. Most browsers will hide the cookie value from JavaScript in that case. User could still manually copy cookies, but this helps prevent direct script access. StackOverflow had this problem durning beta. </p>
<p>This isn't a solution, just another brick in the wall </p>
</div></text><author><a href="/users/287/basszero">basszero</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<ul>
<li>Don't trust user input</li>
<li>Escape all free-text output</li>
<li>Don't use magic_quotes; see if there's a DBMS-specfic variant, or use PDO</li>
<li>Consider using HTTP-only cookies where possible to avoid any malicious script being able to hijack a session</li>
</ul>
</div></text><author><a href="/users/3542/rob">Rob</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You should at least validate all data going into the database. And try to validate all data leaving the database too.</p>
<p>mysql_real_escape_string is good to prevent SQL injection, but XSS is trickier.
You should preg_match, stip_tags, or htmlentities where possible!</p>
</div></text><author><a href="/users/320856/abeon">Abeon</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Use an existing user-input sanitization library to clean <em>all</em> user-input. Unless you put a <em>lot</em> of effort into it, implementing it yourself will never work as well.</p>
</div></text><author><a href="/users/745/dbr">dbr</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I find the best way is using a class that allows you to bind your code so you never have to worry about manually escaping your data.</p>
</div></text><author><a href="/users/13978/darren22">Darren22</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The best current method for preventing XSS in a PHP application is HTML Purifier (http://htmlpurifier.org/).  One minor drawback to it is that it's a rather large library and is best used with an op code cache like APC.  You would use this in any place where untrusted content is being outputted to the screen. It is much more thorough that htmlentities, htmlspecialchars, filter_input, filter_var, strip_tags, etc.</p>
</div></text><author><a href="/users/615686/night-owl">Night Owl</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>It is difficult to implement a thorough sql injection/xss injection prevention on a site that doesn't cause false alarms. In a CMS the end user might want to use <code>&lt;script&gt;</code> or <code>&lt;object&gt;</code> that links to items from another site. </p>
<p>I recommend having all users install FireFox with NoScript ;-)</p>
</div></text><author><a href="/users/13320/adam">Adam</a></author><comments/></answer></answers></post>