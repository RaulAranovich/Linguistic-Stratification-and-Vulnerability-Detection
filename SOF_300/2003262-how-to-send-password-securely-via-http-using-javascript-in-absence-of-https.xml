<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How to send password securely via HTTP using Javascript in absence of HTTPS? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>The very basic issue all developers face: Whenever user submits the form, the password is sent via network and it must be protected. The site I develop for doesn't have HTTPS. Neither does the owner want to buy a SSL certificate, nor is he interested in a self-signed one. So I want to protect the password sent via HTTP using Javascript when submitting form.</p>
<p>To eager downvoters: <a href="http://stackoverflow.com/questions/1582894/how-to-send-password-securely-over-http">How to send password securely over HTTP?</a> DOES NOT give any sensible solution and I am in another situation.</p>
<p>If I use MD5, one can reverse that password string. What about nonce/HMAC? Any available Javascript library for that? Or do you have any suggestion/hint to tackle? Thanks in advance!</p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>There is no way to send a password securely <strong>that the user can verify</strong> without SSL.</p>
<p>Sure, you can write some JavaScript that will make a password secure for over-the-wire transmission through hashing or public-key-encryption. But how can the user be sure that the JavaScript itself has not been tampered with by a man-in-the-middle before it reached them, to send the password to an attacker instead of the site, or even just compromise the security of the algorithm? The only way would be for them to be expert programmers and have them inspect every line of your page and script to ensure it was kosher before typing the password. That is not a realistic scenario.</p>
<p>If you want passwords to be safe from man-in-the-middle attacks, you must buy an SSL cert. There is no other way. Get used to it.</p>
<blockquote>
<p>If I use MD5, one can reverse that password string.</p>
</blockquote>
<p>No... not trivially at least. Whilst MD5 has attacks against it, it's a hashing algorithm and thus unreversable. You would have to brute-force it.</p>
<p>But again, a man-in-the-middle attacker doesn't need to look at your MD5s. He can simply sabotage the JavaScript you send the user to make the MD5s.</p>
</div></text><author><a href="/users/18936/bobince">bobince</a></author><comments><comment><text><span class="comment-copy">+1 thanks for your explanation.</span></text><author><a class="comment-user owner" href="/users/128028/viet" title="6,916 reputation">Viet</a></author></comment><comment><text><span class="comment-copy">Excellent post. I tried to make a secure password input with JavaScript, and realized it wasn't possible for these exact reasons. I wish I could have read this first.</span></text><author><a class="comment-user" href="/users/20760/ojrac" title="9,422 reputation">ojrac</a></author></comment><comment><text><span class="comment-copy">&lt;&lt;Whilst MD5 has attacks against it, it's a hashing algorithm and thus unreversable. You would have to brute-force it.&gt;&gt; You're forgetting that there are pre-calculated tables of MD5'd password hashes, which means that "Brute forcing" could well be fast and trivial.</span></text><author><a class="comment-user" href="/users/126229/ericlaw" title="45,302 reputation">EricLaw</a></author></comment><comment><text><span class="comment-copy">EricLaw: You're referring to Rainbow tables? They only contain hashes of text up to a certain length.</span></text><author><a class="comment-user" href="/users/154152/noon-silk" title="41,472 reputation">Noon Silk</a></author></comment><comment><text><span class="comment-copy">Anyway, before choosing a hashing function, everyone should check the latest details of the one they decide on: <a href="http://valerieaurora.org/hash.html" rel="nofollow noreferrer">valerieaurora.org/hash.html</a>, specifically, MD5, SHA0, SHA1, are all considered dead. Use only SHA-2 and up.</span></text><author><a class="comment-user" href="/users/154152/noon-silk" title="41,472 reputation">Noon Silk</a></author></comment><comment><text><span class="comment-copy">"If you want passwords to be safe from man-in-the-middle attacks, you must buy an SSL cert. There is no other way."  Nonsense. You just add a challenge for a second round of hashing.  See <a href="http://groups.google.com/group/comp.lang.php/browse_thread/thread/c5960aa0afac2621/ffd98ae87112ccc5" rel="nofollow noreferrer">groups.google.com/group/comp.lang.php/browse_thread/thread/â€¦</a>  C.</span></text><author><a class="comment-user" href="/users/223992/symcbean" title="35,653 reputation">symcbean</a></author></comment><comment><text><span class="comment-copy">As Jerry Stuckle says in that thread, it's still of no use. Adding more security on top makes no difference; the user would still have to read and verify that the client-side script sent to them was kosher before starting to type their credentials. That isn't going to happen. You need a secret of some sort to bootstrap a secure connection; SSL provides that in the form of shared CAs. Without it, you could be talking to any random active-MitM hacker pretending to be the target website. Password-hashing login schemes, although potentially useful for other reasons, can only defeat passive MitM.</span></text><author><a class="comment-user" href="/users/18936/bobince" title="387,718 reputation">bobince</a></author></comment><comment><text><span class="comment-copy">+1 Thanks for further explanation :)</span></text><author><a class="comment-user owner" href="/users/128028/viet" title="6,916 reputation">Viet</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The solution here is to not send the password at all.  Use challenge/response. </p>
<p>In the original form include a large block of random text along with a key.  Store the original random text in the session based on key on the server.  When the client submits the form, use JS to hash the random text and password together.  Then send the username, key, and hashed random text to the server. DO NOT send the password.  On the server, use the key to lookup the original random text, perform the same hashing operation with the stored password. If the server-hashed value matches the client hashed value, then you know the client entered the right password without ever sending the password to the server.</p>
<p>Whether the password is right or not, expire the key and random text so each are one-time-use. </p>
</div></text><author><a href="/users/118703/samuel-neff">Samuel Neff</a></author><comments><comment><text><span class="comment-copy">+1 Hi Sam, thanks. The concept you described is mentioned by "nonce" in my question. I'm not sure how to prove its reliability &amp; security yet.</span></text><author><a class="comment-user owner" href="/users/128028/viet" title="6,916 reputation">Viet</a></author></comment><comment><text><span class="comment-copy">You will still have to send the password at least once to the server for storing in database. What will you do in that case?</span></text><author><a class="comment-user" href="/users/1140783/sttaq" title="1,164 reputation">sttaq</a></author></comment><comment><text><span class="comment-copy">@sttaq, yes, if you're managing your own passwords then use you need to pass it when setting the password.  We authenticate against LDAP so we don't actually have the original password stored. Good point though.</span></text><author><a class="comment-user" href="/users/118703/samuel-neff" title="47,654 reputation">Samuel Neff</a></author></comment><comment><text><span class="comment-copy">@sttaq What I'd do is have the server create the password and email it to the owner</span></text><author><a class="comment-user" href="/users/293420/zloy-smiertniy" title="1,171 reputation">Zloy Smiertniy</a></author></comment><comment><text><span class="comment-copy">@ZloySmiertniy, when you need to provide password reset via e-mail, it's better to send a one-time link that resets the password and not send the actual password itself. This prevents security issues of the password being transmitted via e-mail and being stored in e-mail later.</span></text><author><a class="comment-user" href="/users/118703/samuel-neff" title="47,654 reputation">Samuel Neff</a></author></comment><comment><text><span class="comment-copy">And if I'm the "man in the middle" I would just catch that random hashed string, and use that to authenticate, so it wouldn't matter what you did in the browser. And by doing the same hashing on the client as on the server, you've just shown me how you authenticate on the serverside, what algorithm you're using, how many passes etc.</span></text><author><a class="comment-user" href="/users/965051/adeneo" title="224,423 reputation">adeneo</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you REALLY want to deep-dive into this, look at the <a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" rel="noreferrer">Diffie-Hellman key exchange</a> which was created to "allow two parties that have no prior knowledge of each other to jointly establish a shared secret key over an insecure communications channel"</p>
<p>I'm not a cryptography expert though, so I don't fully know if it's really secure if an attacker has both the Client (JavaScript source code) and the transport mechanism (Packet sniffer)</p>
</div></text><author><a href="/users/91/michael-stum">Michael Stum</a></author><comments><comment><text><span class="comment-copy">It's secure if you do it right... but doing it right is extremely hard.  SSL is way, way less work.</span></text><author><a class="comment-user" href="/users/241774/andrew-mcgregor" title="11,850 reputation">Andrew McGregor</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use a javascript RSA implementation to encrypt the password before sending. (Here is an example of <a href="http://ohdave.com/rsa/" rel="nofollow noreferrer">RSA In Javascript</a>.)</p>
<p>But I believe both this one and using a hash function will be vulnerable to <a href="http://en.wikipedia.org/wiki/Replay_attack" rel="nofollow noreferrer">replay attacks</a>. So, be careful.</p>
</div></text><author><a href="/users/33885/szere-dyeri">Szere Dyeri</a></author><comments><comment><text><span class="comment-copy">Shameless plug: I took that idea to the next level <a href="http://rsacpp.org/" rel="nofollow noreferrer">rsacpp.org</a></span></text><author><a class="comment-user" href="/users/195722/nathan-adams" title="769 reputation">Nathan Adams</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Unfortunately there will be no way to ensure security of a non-encrypted request. Anyone with access to your javascript will simply be able to reverse engineer it/tamper with it and anyone with a packet sniffer will be able to watch the unencrypted traffic. These two facts together mean:</p>
<p><strong>No SSL? No security.</strong></p>
</div></text><author><a href="/users/210/rfunduk">rfunduk</a></author><comments><comment><text><span class="comment-copy">I would also argue that SSL is as bad as no security as you can purchase a CA signed certificate for a domain that you don't own. Albeit it is becoming more rare, but I'm sure I can find a CA that will take my money and sign a certificate. With that - how do you know the chase.com you go to is actually chase's site and not an attackers? They both can have valid signed certificates.</span></text><author><a class="comment-user" href="/users/195722/nathan-adams" title="769 reputation">Nathan Adams</a></author></comment><comment><text><span class="comment-copy">The big ones wont do this and lots of the others are poorly supported in the browsers. The situation isn't perfect but I wouldn't call it 'as bad' as no security.</span></text><author><a class="comment-user" href="/users/210/rfunduk" title="22,465 reputation">rfunduk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Any transmission that you have will be in the clear; that is, without SSL your critical information will be exposed.  It is worth discussing that point with the site Owner.  In other words, it's best to take necessary measure to fortify your data transmission, and SSL is one the basic, cheap steps you can take.</p>
</div></text><author><a href="/users/19799/david-robbins">David Robbins</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>i don't think the issue here is the technology, but how you explain the importance of SSL. Provide them with reliable reading materials, i'm sure there are plenty over the web.</p>
</div></text><author><a href="/users/162381/martin-ongtangco">Martin Ongtangco</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The solution requires the client to be able to encrypt the password using a secret encryption key known <em>only</em> to the client <em>and</em> the server.</p>
<p>SSL accomplishes this by requiring both the server and the client web browser to have their own asymmetric public/private keypair, which they use to encrypt and transmit a random session key between them. The rest of the conversation then uses that secure session key.</p>
<p>So you're asking how to solve the same problem as SSL without the benefit of having a secret key that is known <em>only</em> to the client and server. I'm no expert, but it looks like this can't be done, or at least not easily.</p>
</div></text><author><a href="/users/170383/david-r-tribble">David R Tribble</a></author><comments><comment><text><span class="comment-copy">No it doesn't. Only one only end needs a certificate. The client does not generate the session key; does not encrypt it; and does not send it. It is negotiated via a key agreement protocol.</span></text><author><a class="comment-user" href="/users/207421/ejp" title="214,361 reputation">EJP</a></author></comment><comment><text><span class="comment-copy">@EJP - Yes, the server creates and encrypts the session key. But how is the key agreement protocol performed without the client having its own (asymmetric) encryption key?</span></text><author><a class="comment-user" href="/users/170383/david-r-tribble" title="7,108 reputation">David R Tribble</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you don't have access to SSL, MD5 should be adequate to prevent accidental discovery of passwords (such as in a network log file or something). Anything else would be a waste of time. Just make sure the app doesn't give access to sensitive information (ie, credit card numbers, medical history, etc).</p>
<p>Like others commenters have suggested, a serious attacker will be able to break any type of security on the page. Even SSL is a small barrier since most users use easy-to-guess passwords, re-use the same passwords everywhere, will give their password to anybody that asks, or can be tricked into giving up their password by a copied page or "tech support" phone call.</p>
</div></text><author><a href="/users/320/brian">Brian</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>-- English --
i think in something, but i don't know if it could be really secure. If you can put your form in a php file, then you can create an algoritm for create a string based in time or in something else, and then put this string in your html.</p>
<p>When the user type a password in a password input field, when you debug it you canot see the value typed by user, so before send the information via post or get, you can use the password user as a hint to encrypt the encrypted string previosly generated, and then, just sent it insted of the password typed by user.</p>
<p>In this way, the attackers dont have all inside the js code, so they will need discover the algoritm that you create to decrypt it.</p>
<p>This is just an idea, so if you can tell me how this can not be safe, I would appreciate it.</p>
<p>-- Spanish --
Se me acaba de ocurrir algo que puede servir, pero no se si realmente sea algo seguro. Por medio de php puedes generar un algoritmo que cree un string en base al timestamp o algo mÃ¡s, y despuÃ©s colocar esta cadena en el html.</p>
<p>Note que cuando alguien escribe una contraseÃ±a en un campo input tipo password, con un debug no se puede ver el valor que tecleo el usuario (no se si exista manera pero no quise investigar mÃ¡s), asi que podemos utilizar la contraseÃ±a que el usuario escribiÃ³ como palabra clave para encriptar la cadena de texto que previamente habiamos generado con php, por medio de un algoritmo en JS. SerÃ­a algo asÃ­ como encriptar lo encriptado. Posteriormente lo que estariamos enviado no serÃ­a la contraseÃ±a tecleada, si no esta Ãºltima cadena resultante.</p>
<p>Buscando un contra, lo Ãºnico que se me ocurra es que el atacante tendrÃ¡ que dedicarle mucho tiempo para tratar de encontrar el agoritmo que creamos por medio de php y poder decriptar la cadena final, o tendrÃ¡ que hackear el servidor para acceder al php y obtener el algoritmo.</p>
<p>Esto es solo una idea, por lo que si pueden decirme como esto puede no ser seguro, se los agradecerÃ­a.</p>
</div></text><author><a href="/users/2537169/eduardossmx">eduardossmx</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As mentioned, none of this is secure against <em>server</em> spoofing, as that requires an ability to trust the client-side Javascript. But if we're sure that the server can't be spoofed (signed cert, hash signing immune to length-extension, etc.) but <em>not</em> that the connection is immune to eavesdroppers, here's how I'd implement it.</p>
<p>I think the most secure way is, instead of storing H(<em>password</em>), where H is your hash function of choice, store g^H(<i>password</i>) i.e. use the password as the private key for Diffie-Hellman key exchange. (You should also probably use a random g for different users, too--it becomes your salt.) Then to verify, you generate a nonce b, send the user g^b, and compute (g^H(<i>password</i>))^b. The user does not need to know g--they need only compute (g^b)^H(<em>password</em>) = (g^H(<em>password</em>))^b. Now you have a number that both parties know <em>iff</em> the user entered the right password, and constructing a challenge-response zero-knowledge proof based on knowing the correct number is trivial, while the random number used as the server's "private key" makes the approach immune to replay attacks.</p>
</div></text><author><a href="/users/5602689/nxtangl">NXTangl</a></author><comments><comment><text><span class="comment-copy">Whatever the client can do, a MITM can do as well. You speak of a "signed cert", what's the difference to an installed SSL certificate? And what do you mean with "server can't be spoofed", does it mean the communication cannot be altered, only listened to?</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">What I meant was, basically, this solution is useless unless the server's identity is already validated to the client, which usually implies SSL certificates and end-to-end encryption in today's world. Yes, I meant a situation where eavesdropping is possible but impersonating the server or altering its output undetectably is not, e.g. the server's public key is known (validated by trusted sources) and it signs all its messages with a SHA3 hash encrypted with its private key.</span></text><author><a class="comment-user" href="/users/5602689/nxtangl" title="1 reputation">NXTangl</a></author></comment><comment><text><span class="comment-copy">Am I understanding right that you then mean that as long as the content is delivered securely this mechanism would be <i>somewhat</i> secure for a non-ssl api layer?  Not that I'm advocating, just curious.  I'm actually wanting to implement something in our internal stack like this.  We have a single authentication server that we want all of our apps to share.  Our individual apps don't need to know about the password, so this challenge response concept might answer that need, though we'd still serve everything SSL.</span></text><author><a class="comment-user" href="/users/740760/lassombra" title="333 reputation">lassombra</a></author></comment></comments></answer></answers></post>