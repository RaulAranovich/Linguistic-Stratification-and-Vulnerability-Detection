<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Google Authenticator implementation in Python - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am trying to use one-time passwords that can be generated using <a href="https://market.android.com/details?id=com.google.android.apps.authenticator" rel="noreferrer">Google Authenticator application</a>.</p>
<h2>What Google Authenticator does</h2>
<p>Basically, Google Authenticator implements two types of passwords:</p>
<ul>
<li><strong>HOTP</strong> - HMAC-based One-Time Password, which means the password is changed with each call, in compliance to <a href="http://tools.ietf.org/html/rfc4226" rel="noreferrer">RFC4226</a>, and</li>
<li><strong>TOTP</strong> - Time-based One-Time Password, which changes for every 30-seconds period (as far as I know).</li>
</ul>
<p>Google Authenticator is also available as Open Source here: <a href="http://code.google.com/p/google-authenticator/" rel="noreferrer">code.google.com/p/google-authenticator</a></p>
<h2>Current code</h2>
<p>I was looking for existing solutions to generate HOTP and TOTP passwords, but did not find much. The code I have is the following snippet responsible for generating HOTP:</p>
<pre class="lang-py prettyprint prettyprinted" style=""><code><span class="kwd">import</span><span class="pln"> hmac</span><span class="pun">,</span><span class="pln"> base64</span><span class="pun">,</span><span class="pln"> struct</span><span class="pun">,</span><span class="pln"> hashlib</span><span class="pun">,</span><span class="pln"> time

</span><span class="kwd">def</span><span class="pln"> get_token</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">,</span><span class="pln"> digest_mode</span><span class="pun">=</span><span class="pln">hashlib</span><span class="pun">.</span><span class="pln">sha1</span><span class="pun">,</span><span class="pln"> intervals_no</span><span class="pun">=</span><span class="kwd">None</span><span class="pun">):</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> intervals_no </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">None</span><span class="pun">:</span><span class="pln">
        intervals_no </span><span class="pun">=</span><span class="pln"> int</span><span class="pun">(</span><span class="pln">time</span><span class="pun">.</span><span class="pln">time</span><span class="pun">())</span><span class="pln"> </span><span class="pun">//</span><span class="pln"> </span><span class="lit">30</span><span class="pln">
    key </span><span class="pun">=</span><span class="pln"> base64</span><span class="pun">.</span><span class="pln">b32decode</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">)</span><span class="pln">
    msg </span><span class="pun">=</span><span class="pln"> struct</span><span class="pun">.</span><span class="pln">pack</span><span class="pun">(</span><span class="str">"&gt;Q"</span><span class="pun">,</span><span class="pln"> intervals_no</span><span class="pun">)</span><span class="pln">
    h </span><span class="pun">=</span><span class="pln"> hmac</span><span class="pun">.</span><span class="pln">new</span><span class="pun">(</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> msg</span><span class="pun">,</span><span class="pln"> digest_mode</span><span class="pun">).</span><span class="pln">digest</span><span class="pun">()</span><span class="pln">
    o </span><span class="pun">=</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">h</span><span class="pun">[</span><span class="lit">19</span><span class="pun">])</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">15</span><span class="pln">
    h </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">struct</span><span class="pun">.</span><span class="pln">unpack</span><span class="pun">(</span><span class="str">"&gt;I"</span><span class="pun">,</span><span class="pln"> h</span><span class="pun">[</span><span class="pln">o</span><span class="pun">:</span><span class="pln">o</span><span class="pun">+</span><span class="lit">4</span><span class="pun">])[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">0x7fffffff</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">1000000</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> h</span></code></pre>
<p>The problem I am facing is that the password I generate using the above code is not the same as generated using Google Authenticator app for Android. Even though I tried multiple <code>intervals_no</code> values (exactly first 10000, beginning with <code>intervals_no = 0</code>), with <code>secret</code> being equal to key provided within the GA app.</p>
<h2>Questions I have</h2>
<p>My questions are:</p>
<ol>
<li>What am I doing wrong?</li>
<li>How can I generate HOTP and/or TOTP in Python?</li>
<li>Are there any existing Python libraries for this?</li>
</ol>
<p>To sum up: please give me any clues that will help me implement Google Authenticator authentication within my Python code.</p>
</div></text><author><a href="/users/548696/tadeck">Tadeck</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I wanted to set a bounty on my question, but I have succeeded in creating solution. My problem seemed to be connected with incorrect value of <code>secret</code> key (it must be correct parameter for <code>base64.b32decode()</code> function).</p>
<p>Below I post full working solution with explanation on how to use it.</p>
<h2>Code</h2>
<p>The following code is enough. I have also uploaded it to GitHub as separate module called <em>onetimepass</em> (available here: <a href="https://github.com/tadeck/onetimepass">https://github.com/tadeck/onetimepass</a>).</p>
<pre class="lang-py prettyprint prettyprinted" style=""><code><span class="kwd">import</span><span class="pln"> hmac</span><span class="pun">,</span><span class="pln"> base64</span><span class="pun">,</span><span class="pln"> struct</span><span class="pun">,</span><span class="pln"> hashlib</span><span class="pun">,</span><span class="pln"> time

</span><span class="kwd">def</span><span class="pln"> get_hotp_token</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">,</span><span class="pln"> intervals_no</span><span class="pun">):</span><span class="pln">
    key </span><span class="pun">=</span><span class="pln"> base64</span><span class="pun">.</span><span class="pln">b32decode</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">True</span><span class="pun">)</span><span class="pln">
    msg </span><span class="pun">=</span><span class="pln"> struct</span><span class="pun">.</span><span class="pln">pack</span><span class="pun">(</span><span class="str">"&gt;Q"</span><span class="pun">,</span><span class="pln"> intervals_no</span><span class="pun">)</span><span class="pln">
    h </span><span class="pun">=</span><span class="pln"> hmac</span><span class="pun">.</span><span class="pln">new</span><span class="pun">(</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> msg</span><span class="pun">,</span><span class="pln"> hashlib</span><span class="pun">.</span><span class="pln">sha1</span><span class="pun">).</span><span class="pln">digest</span><span class="pun">()</span><span class="pln">
    o </span><span class="pun">=</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">h</span><span class="pun">[</span><span class="lit">19</span><span class="pun">])</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">15</span><span class="pln">
    h </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">struct</span><span class="pun">.</span><span class="pln">unpack</span><span class="pun">(</span><span class="str">"&gt;I"</span><span class="pun">,</span><span class="pln"> h</span><span class="pun">[</span><span class="pln">o</span><span class="pun">:</span><span class="pln">o</span><span class="pun">+</span><span class="lit">4</span><span class="pun">])[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">0x7fffffff</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">1000000</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> h

</span><span class="kwd">def</span><span class="pln"> get_totp_token</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">):</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> get_hotp_token</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">,</span><span class="pln"> intervals_no</span><span class="pun">=</span><span class="pln">int</span><span class="pun">(</span><span class="pln">time</span><span class="pun">.</span><span class="pln">time</span><span class="pun">())//</span><span class="lit">30</span><span class="pun">)</span></code></pre>
<p>It has two functions:</p>
<ul>
<li><code>get_hotp_token()</code> generates one-time token (that should invalidate after single use),</li>
<li><code>get_totp_token()</code> generates token based on time (changed in 30-second intervals),</li>
</ul>
<h2>Parameters</h2>
<p>When it comes to parameters:</p>
<ul>
<li><code>secret</code> is a secret value known to server (the above script) and client (Google Authenticator, by providing it as password within application),</li>
<li><code>intervals_no</code> is the number incremeneted after each generation of the token (this should be probably resolved on the server by checking some finite number of integers after last successful one checked in the past)</li>
</ul>
<h2>How to use it</h2>
<ol>
<li>Generate <code>secret</code> (it must be correct parameter for <code>base64.b32decode()</code>) - preferably 16-char (no <code>=</code> signs), as it surely worked for both script and Google Authenticator.</li>
<li>Use <code>get_hotp_token()</code> if you want one-time passwords invalidated after each use. In Google Authenticator this type of passwords i  mentioned as based on the counter. For checking it on the server you will need to check several values of <code>intervals_no</code> (as you have no quarantee that user did not generate the pass between the requests for some reason), but not less than the last working <code>intervals_no</code> value (thus you should probably store it somewhere).</li>
<li>Use <code>get_totp_token()</code>, if you want a token working in 30-second intervals. You have to make sure both systems have correct time set (meaning that they both generate the same Unix timestamp in any given moment in time).</li>
<li>Make sure to protect yourself from brute-force attack. If time-based password is used, then trying 1000000 values in less than 30 seconds gives 100% chance of guessing the password. In case of HMAC-based passowrds (HOTPs) it seems to be even worse.</li>
</ol>
<h2>Example</h2>
<p>When using the following code for one-time HMAC-based password:</p>
<pre class="lang-py prettyprint prettyprinted" style=""><code><span class="pln">secret </span><span class="pun">=</span><span class="pln"> </span><span class="str">'MZXW633PN5XW6MZX'</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> xrange</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">):</span><span class="pln">
    </span><span class="kwd">print</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> get_hotp_token</span><span class="pun">(</span><span class="pln">secret</span><span class="pun">,</span><span class="pln"> intervals_no</span><span class="pun">=</span><span class="pln">i</span><span class="pun">)</span></code></pre>
<p>you will get the following result:</p>
<pre class="lang-py prettyprint prettyprinted" style=""><code><span class="lit">1</span><span class="pln"> </span><span class="lit">448400</span><span class="pln">
</span><span class="lit">2</span><span class="pln"> </span><span class="lit">656122</span><span class="pln">
</span><span class="lit">3</span><span class="pln"> </span><span class="lit">457125</span><span class="pln">
</span><span class="lit">4</span><span class="pln"> </span><span class="lit">35022</span><span class="pln">
</span><span class="lit">5</span><span class="pln"> </span><span class="lit">401553</span><span class="pln">
</span><span class="lit">6</span><span class="pln"> </span><span class="lit">581333</span><span class="pln">
</span><span class="lit">7</span><span class="pln"> </span><span class="lit">16329</span><span class="pln">
</span><span class="lit">8</span><span class="pln"> </span><span class="lit">529359</span><span class="pln">
</span><span class="lit">9</span><span class="pln"> </span><span class="lit">171710</span></code></pre>
<p>which is corresponding to the tokens generated by the Google Authenticator app (except if shorter than 6 signs, app adds zeros to the beginning to reach a length of 6 chars).</p>
</div></text><author><a href="/users/548696/tadeck">Tadeck</a></author><comments><comment><text><span class="comment-copy">Excellent response. I have been wondering about this myself.</span></text><author><a class="comment-user" href="/users/790387/burhan-khalid" title="96,743 reputation">Burhan Khalid</a></author></comment><comment><text><span class="comment-copy">@burhan: If you need the code, I have uploaded it also to GitHub (here: <a href="https://github.com/tadeck/onetimepass" rel="nofollow noreferrer">https://github.com/tadeck/onetimepass</a>), so it should be quite easy to use it within projects as separate module. Enjoy!</span></text><author><a class="comment-user owner" href="/users/548696/tadeck" title="67,686 reputation">Tadeck</a></author></comment><comment><text><span class="comment-copy">I had a problem with this code because the 'secret' I was provided by the service I'm trying to log into was lowercase, not uppercase.  Changing line 4 to read "key = base64.b32decode(secret, True)" fixed the problem for me.</span></text><author><a class="comment-user" href="/users/1253362/chris-moore" title="121 reputation">Chris Moore</a></author></comment><comment><text><span class="comment-copy">@ChrisMoore: I have updated the code with <code>casefold=True</code> so people should not have similar problems now. Thanks for your input.</span></text><author><a class="comment-user owner" href="/users/548696/tadeck" title="67,686 reputation">Tadeck</a></author></comment><comment><text><span class="comment-copy">I was able to get the code pasted here to work for TOTP, but was not able to get the code on github to work for TOPT.</span></text><author><a class="comment-user" href="/users/1127047/osmosis" title="191 reputation">osmosis</a></author></comment><comment><text><span class="comment-copy">@osmosis: What do you meant by TOPT and how it differs from TOTP? The code here is almost identical to GitHub version - do you say the version here worked properly, but GitHub version used exactly the same way did not work?</span></text><author><a class="comment-user owner" href="/users/548696/tadeck" title="67,686 reputation">Tadeck</a></author></comment><comment><text><span class="comment-copy">I was just given a 23 character secret by a site.  Your code fails with a "TypeError: Incorrect padding" when I give it that secret.  Padding the secret, like this, fixed the problem:  key = base64.b32decode(secret + '===='[:3-((len(secret)-1)%4)], True)</span></text><author><a class="comment-user" href="/users/1253362/chris-moore" title="121 reputation">Chris Moore</a></author></comment><comment><text><span class="comment-copy">Just out of curiosity, is there a difference between the output of binascii.a2b_base64 and base64.b64decode? Is there a reason to choose one over the other?</span></text><author><a class="comment-user" href="/users/303169/musashixxx" title="1,000 reputation">musashiXXX</a></author></comment><comment><text><span class="comment-copy">@musashiXXX: According to <a href="http://docs.python.org/2/library/binascii.html" rel="nofollow noreferrer">docs.python.org/2/library/binascii.html</a>: "<i>The <code>binascii</code> module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like <code>uu</code>, <code>base64</code>, or <code>binhex</code> instead. The <code>binascii</code> module contains low-level functions written in C for greater speed that are used by the higher-level modules</i>".</span></text><author><a class="comment-user owner" href="/users/548696/tadeck" title="67,686 reputation">Tadeck</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I wanted a python script to generate TOTP password. So, I wrote the python script. This is my implementation. I have this <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm#Definition" rel="nofollow">info</a> on wikipedia and some knowledge about HOTP and TOTP to write this script.</p>
<pre class="lang-py prettyprint prettyprinted" style=""><code><span class="kwd">import</span><span class="pln"> hmac</span><span class="pun">,</span><span class="pln"> base64</span><span class="pun">,</span><span class="pln"> struct</span><span class="pun">,</span><span class="pln"> hashlib</span><span class="pun">,</span><span class="pln"> time</span><span class="pun">,</span><span class="pln"> array

</span><span class="kwd">def</span><span class="pln"> </span><span class="typ">Truncate</span><span class="pun">(</span><span class="pln">hmac_sha1</span><span class="pun">):</span><span class="pln">
    </span><span class="str">"""
    Truncate represents the function that converts an HMAC-SHA-1
    value into an HOTP value as defined in Section 5.3.

    http://tools.ietf.org/html/rfc4226#section-5.3

    """</span><span class="pln">
    offset </span><span class="pun">=</span><span class="pln"> int</span><span class="pun">(</span><span class="pln">hmac_sha1</span><span class="pun">[-</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">16</span><span class="pun">)</span><span class="pln">
    binary </span><span class="pun">=</span><span class="pln"> int</span><span class="pun">(</span><span class="pln">hmac_sha1</span><span class="pun">[(</span><span class="pln">offset </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pun">):((</span><span class="pln">offset </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">8</span><span class="pun">)],</span><span class="pln"> </span><span class="lit">16</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">0x7fffffff</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> str</span><span class="pun">(</span><span class="pln">binary</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">def</span><span class="pln"> _long_to_byte_array</span><span class="pun">(</span><span class="pln">long_num</span><span class="pun">):</span><span class="pln">
    </span><span class="str">"""
    helper function to convert a long number into a byte array
    """</span><span class="pln">
    byte_array </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">.</span><span class="pln">array</span><span class="pun">(</span><span class="str">'B'</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> reversed</span><span class="pun">(</span><span class="pln">range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8</span><span class="pun">)):</span><span class="pln">
        byte_array</span><span class="pun">.</span><span class="pln">insert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> long_num </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">0xff</span><span class="pun">)</span><span class="pln">
        long_num </span><span class="pun">&gt;&gt;=</span><span class="pln"> </span><span class="lit">8</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> byte_array

</span><span class="kwd">def</span><span class="pln"> HOTP</span><span class="pun">(</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> C</span><span class="pun">,</span><span class="pln"> digits</span><span class="pun">=</span><span class="lit">6</span><span class="pun">):</span><span class="pln">
    </span><span class="str">"""
    HOTP accepts key K and counter C
    optional digits parameter can control the response length

    returns the OATH integer code with {digits} length
    """</span><span class="pln">
    C_bytes </span><span class="pun">=</span><span class="pln"> _long_to_byte_array</span><span class="pun">(</span><span class="pln">C</span><span class="pun">)</span><span class="pln">
    hmac_sha1 </span><span class="pun">=</span><span class="pln"> hmac</span><span class="pun">.</span><span class="pln">new</span><span class="pun">(</span><span class="pln">key</span><span class="pun">=</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> msg</span><span class="pun">=</span><span class="pln">C_bytes</span><span class="pun">,</span><span class="pln"> digestmod</span><span class="pun">=</span><span class="pln">hashlib</span><span class="pun">.</span><span class="pln">sha1</span><span class="pun">).</span><span class="pln">hexdigest</span><span class="pun">()</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Truncate</span><span class="pun">(</span><span class="pln">hmac_sha1</span><span class="pun">)[-</span><span class="pln">digits</span><span class="pun">:]</span><span class="pln">

</span><span class="kwd">def</span><span class="pln"> TOTP</span><span class="pun">(</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> digits</span><span class="pun">=</span><span class="lit">6</span><span class="pun">,</span><span class="pln"> window</span><span class="pun">=</span><span class="lit">30</span><span class="pun">):</span><span class="pln">
    </span><span class="str">"""
    TOTP is a time-based variant of HOTP.
    It accepts only key K, since the counter is derived from the current time
    optional digits parameter can control the response length
    optional window parameter controls the time window in seconds

    returns the OATH integer code with {digits} length
    """</span><span class="pln">
    C </span><span class="pun">=</span><span class="pln"> long</span><span class="pun">(</span><span class="pln">time</span><span class="pun">.</span><span class="pln">time</span><span class="pun">()</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> window</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> HOTP</span><span class="pun">(</span><span class="pln">K</span><span class="pun">,</span><span class="pln"> C</span><span class="pun">,</span><span class="pln"> digits</span><span class="pun">=</span><span class="pln">digits</span><span class="pun">)</span></code></pre>
</div></text><author><a href="/users/3138699/anish-shah">Anish Shah</a></author><comments><comment><text><span class="comment-copy">Interesting, but you may wish to make it more understandable for the reader. Please make variable names more meaningful, or add docstrings. Also, following PEP8 may get you more support. Did you compare performance between these two solutions? Last question: is your solution compatible with Google Authenticator (as the question was about this specific solution)?</span></text><author><a class="comment-user owner" href="/users/548696/tadeck" title="67,686 reputation">Tadeck</a></author></comment><comment><text><span class="comment-copy">@Tadeck I have added some comments. And I got my things done using this script. so yeah, it should work perfectly.</span></text><author><a class="comment-user" href="/users/3138699/anish-shah" title="1,735 reputation">Anish Shah</a></author></comment></comments></answer></answers></post>