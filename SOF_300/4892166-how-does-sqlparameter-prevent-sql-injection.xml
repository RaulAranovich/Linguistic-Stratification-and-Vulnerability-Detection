<?xml version="1.0" encoding="utf-8"?>
<post><title>.net - How does SQLParameter prevent SQL Injection? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>What exactly is going on in the background that makes it so <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlparameter.aspx" rel="noreferrer">SQLParameter</a> prevents SQL Inection attacks in a .NET Parameterized query?  Is it just stripping out any suspect characters or is there something more to it?</p>
<p>Has anyone out there checked to see what actually gets to SQL Server when you pass malicious input?</p>
<p>Related: <a href="http://stackoverflow.com/questions/4892027/can-you-use-a-sqlparameter-in-the-sql-from-statement/4892060#4892060">Can you use a SQLParameter in the SQL FROM statement?</a></p>
</div></text><author><a href="/users/226897/abe-miessler">Abe Miessler</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Basically, when you perform a SQLCommand using SQLParameters, the parameters are never inserted directly into the statement. Instead, a system stored procedure called sp_executesql is called and given the SQL string and the array of parameters. When used as such, the parameters are isolated and treated as data, instead of having to be parsed out of the statement (and thus possibly changing it), so what the parameters contain can never be "executed". You'll just get a big fat error that the parameter value is invalid in some way.</p>
</div></text><author><a href="/users/436376/keiths">KeithS</a></author><comments><comment><text><span class="comment-copy">You'll also get an error for attempting to use variables in places where SQL (and TSQL in this case) doesn't support variables.  IE: <code>FROM</code> clause, a single parameter to represent a comma separated list in an <code>IN</code> clause, etc.</span></text><author><a class="comment-user" href="/users/135152/omg-ponies" title="213,534 reputation">OMG Ponies</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A easier-to-understand, and a more general answer goes like this:</p>
<p>Imagine a dynamic SQL query:</p>
<p><code>sqlQuery='SELECT * FROM custTable WHERE User=' + Username + ' AND Pass=' + password</code></p>
<p>A simple SQL injection would be just to put the Username in as <code>' OR 1=1--</code></p>
<p>This would effectively make the SQL query:</p>
<p><code>sqlQuery='SELECT * FROM custTable WHERE User='' OR 1=1-- ' AND PASS=' + password</code></p>
<p>This says select all customers where their username is blank (<code>''</code>) or <code>1=1</code>, which is a boolean, equating to true. It then uses <code>--</code> to comment out the rest of the query. So this will print out the <em>entire</em> customer table, or enable you to do whatever you want with it.</p>
<p>Now parameterized queries do it differently, with code like:</p>
<p><code>sqlQuery='SELECT * FROM custTable WHERE User=? AND Pass=?'
 parameters.add("User", username)
 parameters.add("Pass", password)</code></p>
<p>where username and password are variables pointing to the associated inputed username and password.</p>
<p>Now at this point, you may think, this doesn't change anything at all. Surely you could still just put into the username field something like Nobody OR 1=1'--, effectively making the query:</p>
<p><code>sqlQuery='SELECT * FROM custTable WHERE User=Nobody OR 1=1'-- AND Pass=?'</code></p>
<p>And this would seem like a valid argument. But, you would be wrong.</p>
<p>The way parameterized queries work, is that the SQL query is sent as a query, and the database knows exactly what this query will do, and only then will it insert the username and passwords merely as values. This means they cannot affect the query, because the database already knows what the query will do. So in this case it would look for a username of <code>Nobody OR 1=1'--</code> and a blank password, which should come up false.</p>
<p>This isn't a complete solution though, and input validation will still need to be done, since this won't affect other problems, such as <a class="post-tag" href="/questions/tagged/xss" rel="tag" title="show questions tagged 'xss'">xss</a> attacks, as you could still put javascript into the database. Then if this is read out onto a page, it would display it as normal javascript, depending on any output validation. So really the best thing to do is still use input validation, but using parameterized queries or stored procedures to stop any SQL attacks.</p>
<p>Source: <a href="http://www.lavamunky.com/2011/11/why-parameterized-queries-stop-sql.html" rel="nofollow noreferrer">http://www.lavamunky.com/2011/11/why-parameterized-queries-stop-sql.html</a></p>
</div></text><author><a href="/users/3284912/abhisheknaik96">abhisheknaik96</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>"Parameter collections such as SqlParameterCollection provide type checking and length validation. If you use a parameters collection, input is treated as a literal value, and SQL Server does not treat it as executable code. An additional benefit of using a parameters collection is that you can enforce type and length checks. Values outside of the range trigger an exception. This is a good example of defense in depth."</p>
<p><a href="http://msdn.microsoft.com/en-us/library/ff648339.aspx">http://msdn.microsoft.com/en-us/library/ff648339.aspx</a></p>
</div></text><author><a href="/users/153919/dave-brace">Dave Brace</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>When using parameterized queries, the attack surface is reduced to monkeying around with the parameters.</p>
<p>Do use <code>SqlParameters</code>, but don't forget about overflow, underflow and unvalidated parameters. For example, if the method is "proc <code>buy_book (@price money</code>)", a malicious attacker would attempt to trick the application to running with <code>@price</code> set to <code>0.01</code>, or attempting to get the application to do something interesting by submitting something that causes an overflow. Sql Overflows tend not to be interesting (i.e. they just cause exceptions, you are unlikely to be able to write to adjacent memory)</p>
</div></text><author><a href="/users/33264/matthewmartin">MatthewMartin</a></author><comments/></answer></answers></post>