<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Why Does OAuth v2 Have Both Access and Refresh Tokens? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Section 4.2 of the draft OAuth 2.0 protocol indicates that an authorization server can return both an <code>access_token</code> (which is used to authenticate oneself with a resource) as well as a <code>refresh_token</code>, which is used purely to create a new <code>access_token</code>:</p>
<p><a href="https://tools.ietf.org/html/rfc6749#section-4.2" rel="noreferrer">https://tools.ietf.org/html/rfc6749#section-4.2</a></p>
<p>Why have both? Why not just make the <code>access_token</code> last as long as the <code>refresh_token</code> and not have a <code>refresh_token</code>?</p>
</div></text><author><a href="/users/1697459/wilt">Wilt</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The idea of refresh tokens is that if an access token is compromised, because it is short-lived, the attacker has a limited window in which to abuse it.</p>
<p>Refresh tokens, if compromised, are useless because the attacker requires the client id and secret in addition to the refresh token in order to gain an access token.</p>
<p><strong>Having said that</strong>, because every call to both the authorization server and the resource server is done over SSL - including the original client id and secret when they request the access/refresh tokens - I am unsure as to how the access token is any more "compromisable" than the long-lived refresh token and clientid/secret combination.</p>
<p>This of course is different to implementations where you don't control both the authorization and resource servers.</p>
<p>Here is a good thread talking about uses of refresh tokens: <a href="http://www.ietf.org/mail-archive/web/oauth/current/msg06687.html">OAuth Archives</a>.</p>
<p>A quote from the above, talking about the security purposes of the refresh token:</p>
<blockquote>
<p>Refresh tokens... mitigates the risk of a long-lived access_token leaking (query param in a log file on an insecure resource server, beta or poorly coded resource server app, JS SDK client on a non https site that puts the access_token in a cookie, etc)</p>
</blockquote>
</div></text><author><a href="/users/49366/catchdave">catchdave</a></author><comments><comment><text><span class="comment-copy">Catchdave is right but thought I would add that things have evolved since his initial reply.  The use of SSL is now optional (this was probably still being debated when catchdave answered).  For example, MAC tokens (currently under development), provide the ability to sign the request with a private key so that SSL is not required.  Refresh tokens thus become very important since you want to have short-lived mac tokens.</span></text><author><a class="comment-user" href="/users/472765/alexgad" title="4,510 reputation">AlexGad</a></author></comment><comment><text><span class="comment-copy">"Refresh tokens, if compromised, are useless because the attacker requires the client id and secret in addition to the refresh token in order to gain an access token." But the client id and secret is also stored in the device, isn't it? So an attacker with access to the device can get them. Then why?  Here, <a href="https://github.com/auth0/lock/wiki/Using-a-Refresh-Token" rel="nofollow noreferrer">github.com/auth0/lock/wiki/Using-a-Refresh-Token</a> , It is written that loosing a Refresh token means, he can requests as many auth tokens as he want, may be not in the googles scenario, but what if I am implementing my own oauth2 server?</span></text><author><a class="comment-user" href="/users/2441077/jamsheed-kamarudeen" title="173 reputation">Jamsheed Kamarudeen</a></author></comment><comment><text><span class="comment-copy">I believe the idea behind renewing the access token is: it can be guessed by simply bombarding the host with random tokens. Assuming the attacker has no access to the device, but simply trying to hijack an active session by guessing the token. If somehow the attacker gains access to the other details (refresh token, ID, secret) then there is not much that can be done except relying on some heuristic approaches like collecting device fingerprints and storing for the user and thus enhance the <i>possibility</i> of discovering a possible intrusion attempt.</span></text><author><a class="comment-user" href="/users/602549/racs" title="961 reputation">racs</a></author></comment><comment><text><span class="comment-copy"><i>"The attacker requires the client id and secret in addition to the refresh token in order to gain an access token"</i>: then what's the difference between using a refresh token and simply resigning in?</span></text><author><a class="comment-user" href="/users/1225328/sp00m" title="31,748 reputation">sp00m</a></author></comment><comment><text><span class="comment-copy">Refresh token can be used by a third party that can renew the access token without any knowledge of user credentials.</span></text><author><a class="comment-user" href="/users/987856/marek-dec" title="884 reputation">Marek Dec</a></author></comment><comment><text><span class="comment-copy">@MarekDec I thought the client id+secret and users credentials were the same thing? Do you need the id+secret/user credentials to get a new access token or not?</span></text><author><a class="comment-user" href="/users/3470632/kevin-wheeler" title="532 reputation">Kevin Wheeler</a></author></comment><comment><text><span class="comment-copy">@KevinWheeler No, the client ID and secret are credentials for the OAuth client, not the user. When talking about OAuth the "client" is usually a server (for example the stackoverflow web server) which interfaces with an authorization or resource API server (for example the facebook auth provider). The user's credentials are only passed between the user and the OAuth API server, and never known to the client. The client secret is only passed from the client to the OAuth API server, and is never known to the user.</span></text><author><a class="comment-user" href="/users/798684/machine-yearning" title="4,898 reputation">machine yearning</a></author></comment><comment><text><span class="comment-copy">@machineyearning If my understanding is right, isn't knowing the shared secret all that's needed for the auth server to sign and give out a new, valid access token? If the client is already sending it's shared secret along with the refresh token, then what role does the refresh token play in the process? Is there any data inside a refresh token that becomes beneficial in the refresh step, other than I guess the auth server knowing if it's an expired token or not?</span></text><author><a class="comment-user" href="/users/1655666/georaldc" title="1,091 reputation">georaldc</a></author></comment><comment><text><span class="comment-copy">@georaldc You need to pass 2 challenges to be issued an access token. First you need to prove you're a registered client, which always happens by specifying your client ID and secret. Second you need to prove you have permission to access the user's resource on his behalf. This second part happens in 2 ways in the auth code flow. At first you get the user to log in directly to the auth provider, and you get back a code to your redirect URI. Subsequently you use the refresh token instead of the auth code, so the user doesn't have to login again once the original access token expires.</span></text><author><a class="comment-user" href="/users/798684/machine-yearning" title="4,898 reputation">machine yearning</a></author></comment><comment><text><span class="comment-copy">@machineyearning I kind of get the initial auth part that involves logins/credentials to retrieve access and refresh tokens. So the refresh token just doubles as your credentials, without actually requiring your credentials again but client id/secrets are still required? Does the refresh step usually involve dealing with state? Like checking if the refresh token is still valid/not revoked if you have such an option implemented?</span></text><author><a class="comment-user" href="/users/1655666/georaldc" title="1,091 reputation">georaldc</a></author></comment><comment><text><span class="comment-copy">@georaldc yeah you can kinda think of it as a reference to the previous user access grant, which would imply not only the user's credentials have been entered but also specifically which resources they granted you access to. I've seen the refresh token be issued along with some metadata before, such as TTL, if that's what you're wondering. But usually the auth server MUST give you a relevant error response when you try to use an expired, revoked, or otherwise invalid refresh token. Look at the oauth2 spec section 4.1 "authorization code grant". It's pretty readable as far as specs go</span></text><author><a class="comment-user" href="/users/798684/machine-yearning" title="4,898 reputation">machine yearning</a></author></comment><comment><text><span class="comment-copy">@georaldc and sections 5.2 and 6 contain details on errors for issuing access tokens and refresh tokens, respectively</span></text><author><a class="comment-user" href="/users/798684/machine-yearning" title="4,898 reputation">machine yearning</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The link to discussion, provided by Catchdave, has another <a href="http://www.ietf.org/mail-archive/web/oauth/current/msg07192.html">valid point</a> made by Dick Hardt, which I believe is worth to be mentioned here in addition to what's been written above:</p>
<blockquote>
<p>My recollection of refresh tokens was for security and revocation.
  &lt;...&gt;</p>
<p><strong>revocation:</strong> if the access token is self contained, authorization can be revoked by not issuing new access tokens. A resource does not need to query the authorization server to see if the access token is valid.This simplifies access token validation and makes it easier to scale and support multiple authorization servers.  There is a window of time when an access token is valid, but authorization is revoked. </p>
</blockquote>
<p>Indeed, in the situation where Resource Server and Authorization Server is the same entity, and where the connection between user and either of them is (usually) equally secure, there is not much sense to keep refresh token separate from the access token.</p>
<p>Although, as mentioned in the quote, another role of refresh tokens is to ensure the access token can be revoked at any time by the User (via the web-interface in their profiles, for example) while keeping the system scalable at the same time.</p>
<p>Generally, tokens can either be random identifiers pointing to the specific record in the Server's database, or they can contain all information in themselves (certainly, this information have to be signed, with <a href="http://en.wikipedia.org/wiki/Message_authentication_code">MAC</a>, for example).</p>
<p><strong>How the system with long-lived access tokens should work</strong></p>
<p>The server allows the Client to get access to User's data within a pre-defined set of scopes by issuing a token. As we want to keep the token revocable, we must store in the database the token along with the flag "revoked" being set or unset (otherwise, how would you do that with self-contained token?) Database can contain as much as <code>len(users) x len(registered clients) x len(scopes combination)</code> records. Every API request then must hit the database. Although it's quite trivial to make queries to such database performing O(1), the single point of failure itself can have negative impact on the scalability and performance of the system.</p>
<p><strong>How the system with long-lived refresh token and short-lived access token should work</strong></p>
<p>Here we issue two keys: random refresh token with the corresponding record in the database, and signed self-contained access token, containing among others the expiration timestamp field.</p>
<p>As the access token is self-contained, we don't have to hit the database at all to check its validity. All we have to do is to decode the token and to validate the signature and the timestamp.</p>
<p>Nonetheless, we still have to keep the database of refresh tokens, but the number of requests to this database is generally defined by the lifespan of the access token (the longer the lifespan, the lower the access rate).</p>
<p>In order to revoke the access of Client from a particular User, we should mark the corresponding refresh token as "revoked" (or remove it completely) and stop issuing new access tokens. It's obvious though that there is a window during which the refresh token has been revoked, but its access token may still be valid.</p>
<p><strong>Tradeoffs</strong></p>
<p>Refresh tokens partially eliminate the SPoF (Single Point of Failure) of Access Token database, yet they have some obvious drawbacks.</p>
<ol>
<li><p>The "window". A timeframe between events "user revokes the access" and "access is guaranteed to be revoked".</p></li>
<li><p>The complication of the Client logic.</p>
<p><strong>without</strong> refresh token</p>
<ul>
<li>send API request with access token</li>
<li>if access token is invalid, fail and ask user to re-authenticate</li>
</ul>
<p><strong>with</strong> refresh token</p>
<ul>
<li>send API request with access token</li>
<li>If access token is invalid, try to update it using refresh token</li>
<li>if refresh request passes, update the access token and re-send the initial API request</li>
<li>If refresh request fails, ask user to re-authenticate</li>
</ul></li>
</ol>
<p>I hope this answer does make sense and helps somebody to make more thoughtful decision. I'd like to note also that some well-known OAuth2 providers, including github and foursquare adopt protocol without refresh tokens, and seem happy with that.</p>
</div></text><author><a href="/users/848010/roman-imankulov">Roman Imankulov</a></author><comments><comment><text><span class="comment-copy">@RomannImankulov If I understand it correctly refreshe token we can save into db and delete them any time we want to revoke the access, so why don't save acces tokens it self ?</span></text><author><a class="comment-user" href="/users/428547/kosnkov" title="1,575 reputation">kosnkov</a></author></comment><comment><text><span class="comment-copy">@kosnkov the short version of my post is, if you save the access token in the database, you hit the database on every request to your API (which may or may not be a problem in your particular case). If you save refresh tokens and keep access tokens "self-contained", you hit the database only when the client decides to refresh the access token.</span></text><author><a class="comment-user" href="/users/848010/roman-imankulov" title="4,975 reputation">Roman Imankulov</a></author></comment><comment><text><span class="comment-copy">"self-contained" as there is no need to add an expiration date? My current implementation looks up the access token, and if the current date surpassed the expiry date, it is deleted and a refresh token is exchanged for a new access token...I wonder if this is normal.</span></text><author><a class="comment-user" href="/users/2898754/atieh" title="233 reputation">Atieh</a></author></comment><comment><text><span class="comment-copy">Personally I don't like this approach of not hitting the database to gain performance if it is going to compromise security (even if only for the timespan of the window). One should be able to revoke an access_token immediately if necessary as almost always we are dealing with sensitive user information (otherwise we would likely not be using OAuth in the first place). I wonder which approach bigger companies like Facebook and Google use.</span></text><author><a class="comment-user" href="/users/1369016/tiago" title="4,056 reputation">Tiago</a></author></comment><comment><text><span class="comment-copy">I don't  fully  understand why we have to have the "window open" for some time. Why can't  we just send a request to resource server to not accept access tokkens for this user? Also am I correct that  you cannot have refresh  token behavior when you don't  have client secret to sign tokkens with? So basically  you  cannot  use refresh  tokens  from software  on cliemts devices js,mobile desktop apps etc.</span></text><author><a class="comment-user" href="/users/2161029/psixo" title="1,987 reputation">PSIXO</a></author></comment><comment><text><span class="comment-copy">@PSIXO the resource server does not have any persistent store besides the database and maybe a local cache. Therefore, the only way it can check if a token is revoked is by hitting the database, which is what this whole process tries to avoid. As to your 2nd question, you are not correct. If you have a refresh token, you can request new access tokens.</span></text><author><a class="comment-user" href="/users/1030527/bernie" title="2,697 reputation">bernie</a></author></comment><comment><text><span class="comment-copy">A database, in the abstract, isn't a single point of failure. Modern (web) architecture styles, such as RESTful, assume a reliable (highly and widely available) persistency layer over which to scale stateless services. In the concrete, there are a good number high-availability databases to choose from.</span></text><author><a class="comment-user" href="/users/1194266/the-night-manager" title="505 reputation">The night manager</a></author></comment><comment><text><span class="comment-copy">+1, for as I think real argument in favor of refresh tokens - optimisation of access to token's database. (Can't see any real security advenatages)</span></text><author><a class="comment-user" href="/users/1321401/luten" title="3,205 reputation">Luten</a></author></comment><comment><text><span class="comment-copy">@RomanImankulov Correct me if I'm wrong, saying "If access token is invalid, try to update it using refresh token" means a user has to pass its credentials with refresh token? So it's similar to relogin</span></text><author><a class="comment-user" href="/users/1242831/long" title="128 reputation">long</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Neither of these answers get to the core reason refresh tokens exist. Obviously, you can always get a new access-token/refresh-token pair by sending your client credentials to the auth server - thats how you get them in the first place.</p>
<p>So the sole purpose of the refresh token is to limit the use of the client credentials being sent over the wire to the auth service. The shorter the ttl of the access-token, the more often the client credentials will have to be used to obtain a new access-token, and therefore the more opportunities attackers have to compromise the client credentials (although this may be super difficult anyway if asymmetric encryption is being used to send them). So if you have a single-use refresh-token, you can make the ttl of access-tokens arbitrarily small without compromising the client credentials.</p>
</div></text><author><a href="/users/122422/b-t">B T</a></author><comments><comment><text><span class="comment-copy">This is interesting as in Google's case when you ask for a refresh token, you also send over the client id and client secret. So you're compromising every hour anyway.</span></text><author><a class="comment-user" href="/users/455770/rots" title="4,443 reputation">Rots</a></author></comment><comment><text><span class="comment-copy">I want to edit, but confirming with you first:  "The shorter the ttl of the access-token, the more opportunities attackers have to compromise the client credentials..." you mean longer, right? Longer ttl = more opportunities to get compromised.</span></text><author><a class="comment-user" href="/users/1630889/alexander-pritchard" title="720 reputation">Alexander Pritchard</a></author></comment><comment><text><span class="comment-copy">Alexander, actually the shorter the ttl, the more often the client will have to get a new access-token (which requires using the client credentials). So I do in fact mean 'shorter' there. I'll add a note in to clarify.</span></text><author><a class="comment-user" href="/users/122422/b-t" title="18,135 reputation">B T</a></author></comment><comment><text><span class="comment-copy">"sole purpose" - doesn't wash. Making the TTL of the access-token as long as that of the imagined refresh-token will achieve just the same.</span></text><author><a class="comment-user" href="/users/20479/rhubarb" title="24,329 reputation">Rhubarb</a></author></comment><comment><text><span class="comment-copy">@Rhubarb You're right that what you suggest limits the use of the client credentials, however it also has the problem that the longer the ttl on the access-token means its more likely the token can be stolen and then used as credentials. You don't have this problem with the use of a long-lived refresh-token and short-lived access-token.</span></text><author><a class="comment-user" href="/users/122422/b-t" title="18,135 reputation">B T</a></author></comment><comment><text><span class="comment-copy">Refresh tokens also improve scalability and partially mitigate against a single point of failure, so "sole purpose" is not correct.</span></text><author><a class="comment-user" href="/users/289319/mike-chamberlain" title="9,736 reputation">Mike Chamberlain</a></author></comment><comment><text><span class="comment-copy">If you have a mobile application (iOS/Android), wouldn't it be pointless to have a refresh_token? I mean, both access_token and refresh_token would have to be stored in that app and then used. If one was compromised, the other would also be. So aren't refresh_tokens kind of pointless then in mobile?</span></text><author><a class="comment-user" href="/users/3075340/micror" title="3,218 reputation">MicroR</a></author></comment><comment><text><span class="comment-copy">If you are able to steal the users' credentials in transit, you're also able to steal the refresh token + client secret, which is arguably even worse. Getting hold of a refresh token by e.g. gaining access to the server DB on the other hand means nothing if you don't have the client secret. So that's why the refresh tokens are a secure way of allowing refreshes. The alternative is storing user passwords in that DB, which is obviously a big nono.</span></text><author><a class="comment-user" href="/users/678022/adversus" title="755 reputation">Adversus</a></author></comment><comment><text><span class="comment-copy">Since the standard <a href="https://tools.ietf.org/html/rfc6749#section-6" rel="nofollow noreferrer">requires</a> that the client credentials be sent along with the refresh token, the premise of this answer is simply false. "Because refresh tokens are typically long-lasting credentials used to request additional access tokens... the client MUST authenticate with the authorization server." Also see the comment by @Rots.</span></text><author><a class="comment-user" href="/users/2395796/kevin-christopher-henry" title="14,127 reputation">Kevin Christopher Henry</a></author></comment><comment><text><span class="comment-copy">A) I think you are mixing up client secrets and user secrets. The client secret is never sent from the user device, only from the accessing backend application to the data providing backend application. B) The oAuth server that allows for password grant for a Public Client (a client that cannot keep a client secret such as a native or javascript app) will also provide a refresh-token grant for that public client, thus you do not need to send a client secret when refreshing your token. C) The refresh-token provides the backend with a "hart-beat" when to check the validity of the user!</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment><comment><text><span class="comment-copy">@AndreasLundgren As the spec requires the auth server to authenticate the client on token refresh, it <a href="https://tools.ietf.org/html/rfc6749#section-4.2" rel="nofollow noreferrer">doesn't support</a> refresh tokens for implicit grant. Doesn't <a href="https://tools.ietf.org/html/rfc6749#section-4.3" rel="nofollow noreferrer">the password grant</a> seem such an edge-case...?</span></text><author><a class="comment-user" href="/users/1194266/the-night-manager" title="505 reputation">The night manager</a></author></comment><comment><text><span class="comment-copy">Not sure I follow you, can you please elaborate? (I agree what you say.) My main point may be that for password grant, refresh token provides a mechanism for a heart-beat, how often does the BE validates that the users account is not locked, the pw is not changed etc.</span></text><author><a class="comment-user" href="/users/2889165/andreas-lundgren" title="2,637 reputation">Andreas Lundgren</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Despite all the great answers above, I as a security master student and programmer who previously worked at eBay when I took a look into buyer protection and fraud, can say to separate access token and refresh token has its <strong>best balance</strong> between harassing user of <strong>frequent</strong> username/password input and keeping the authority in hand to revoke access to potential <strong><em>abuse</em></strong> of your service.</p>
<p>Think of a scenario like this. You issue user of an access token of 3600 seconds and refresh token much longer as one day.</p>
<ol>
<li><p>The user is a <strong>good</strong> user, he is at home and gets on/off your website shopping and searching on his iPhone. His IP address doesn't change and have a very low load on your server. Like 3-5 pages request every minute. When his 3600 seconds on the access token is over, he requires a new one with the refresh token. We, on the server side, check his activity history and IP address, think he is a human and behaves himself. We grant him a new access token to continue using our service. The user won't need to enter again the username/password until he has reached one day life-span of refresh token itself.</p></li>
<li><p>The user is a <strong>careless</strong> user. He lives in <strong>New York, USA</strong> and got his virus program shutdown and was hacked by a hacker in <strong>Poland</strong>. When the hacker got the access token and refresh token, he tries to impersonate the user and use our service. But after the short-live access token expires, when the hacker tries to refresh the access token, we, on the server, has noticed a dramatic IP change in user behavior history (hey, this guy logins in USA and now refresh access in Poland after just 3600s ???). We terminate the refresh process, invalidate the refresh token itself and prompt to enter username/password again.</p></li>
<li><p>The user is a <strong>malicious</strong> user. He is intended to abuse our service by calling 1000 times our API each minute using a robot. He can well doing so until 3600 seconds later, when he tries to refresh the access token, we noticed his behavior and think he might not be a human. We reject and terminate the refresh process and ask him to enter username/password again. This might potentially break his robot's automatic flow. At least makes him uncomfortable.</p></li>
</ol>
<p>You can see the refresh token has acted perfectly when we try to balance our work, user experience and potential risk of a stolen token. Your watch dog on the server side can check more than IP change, frequency of api calls to determine whether the user shall be a good user or not.</p>
<p>Another word is you can also try to limit the damage control of stolen token/abuse of service by implementing on each api call the basic IP watch dog or any other measures. But this is expensive as you have to read and write record about the user and will slow down your server response.</p>
</div></text><author><a href="/users/3399693/laalaguer">laalaguer</a></author><comments><comment><text><span class="comment-copy">Yeah, very cool. Didn't consider that you may not want to issue another token!</span></text><author><a class="comment-user" href="/users/61938/robert-grant" title="5,051 reputation">Robert Grant</a></author></comment><comment><text><span class="comment-copy">@laalaguer Do you have some more fine grained policies like for example: Don't revoke token when user IP address is changed (when mobile phone disconnects from WiFi and connect to 3G/4G network)?</span></text><author><a class="comment-user" href="/users/126414/svlada" title="1,564 reputation">svlada</a></author></comment><comment><text><span class="comment-copy">These are some great policies and ideas, but I don't see anything in your answer that inherently requires the use of refresh tokens. All of these features can be implemented with just the access token.</span></text><author><a class="comment-user" href="/users/80911/evert" title="29,350 reputation">Evert</a></author></comment><comment><text><span class="comment-copy">@Evert, one of the benefits of using both access and refresh tokens is that access tokens can be short-lived and therefore it is not too much of a security compromise to trust them unconditionally without checking with the server that originally issued them. This can allow you to scale your infrastructure so that non-critical parts of it can trust the information stored in the (signed) token without direct access to the user's account information.</span></text><author><a class="comment-user" href="/users/480176/avi-cherry" title="2,337 reputation">Avi Cherry</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>This answer is from Justin Richer via the OAuth 2 standard body email list. This is posted with his permission.</p>
<hr/>
<p>The lifetime of a refresh token is up to the (AS) authorization server — they can expire, be revoked, etc. The difference between a refresh token and an access token is the audience: the refresh token only goes back to the authorization server, the access token goes to the (RS) resource server. </p>
<p>Also, just getting an access token doesn’t mean the user’s logged in. In fact, the user might not even be there anymore, which is actually the intended use case of the refresh token. Refreshing the access token will give you access to an API on the user’s behalf, it will not tell you if the user’s there.</p>
<p>OpenID Connect doesn’t just give you user information from an access token, it also gives you an ID token. This is a separate piece of data that’s directed at the client itself, not the AS or the RS. In OIDC, you should only consider someone actually “logged in” by the protocol if you can get a fresh ID token. Refreshing it is not likely to be enough.</p>
<p>For more information please read <a href="http://oauth.net/articles/authentication/">http://oauth.net/articles/authentication/</a></p>
</div></text><author><a href="/users/814931/manicode">Manicode</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Clients can be compromised in many ways. For example a cell phone can be cloned.  Having an access token expire means that the client is forced to re-authenticate to the authorization server. During the re-authentication, the authorization server can check other characteristics (IOW perform adaptive access management).</p>
<p>Refresh tokens allow for a client only re-authentication, where as re-authorize forces a dialog with the user which many have indicated they would rather not do.</p>
<p>Refresh tokens fit in essentially in the same place where normal web sites might choose to periodically re-authenticate users after an hour or so (e.g. banking site). It isn't highly used at present since most social web sites don't re-authenticate web users, so why would they re-authenticate a client?</p>
</div></text><author><a href="/users/1609169/phil">Phil</a></author><comments><comment><text><span class="comment-copy">"Refresh tokens allow for a client only re-authentication..." is an important aspect here.</span></text><author><a class="comment-user" href="/users/285288/james" title="5,111 reputation">James</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To clear up some confusion you have to understand the roles of the <em><a href="https://salesforce.stackexchange.com/questions/14009/whats-the-benefit-of-the-client-secret-in-oauth2">client secret</a></em> and the <em>user password</em>, which are very different.</p>
<p>The <em>client</em> is an app/website/program/..., backed by a server, that wants to <em>authenticate</em> a <em>user</em> by using a third-party authentication service. The client secret is a (random) string that is known to both this client and the authentication server. Using this secret the client can identify itself with the authentication server, receiving <em>authorization</em> to request access tokens.</p>
<p>To get the initial access token and refresh token, what is required is:</p>
<ul>
<li>The user ID</li>
<li>The user password</li>
<li>The client ID</li>
<li>The client secret</li>
</ul>
<p>To get a refreshed access token however the <em>client</em> uses the following information:</p>
<ul>
<li>The client ID</li>
<li>The client secret</li>
<li>The refresh token</li>
</ul>
<p>This clearly shows the difference: when refreshing, the client receives authorization to refresh access tokens by using its client secret, and can thus re-authenticate the user using the refresh token <em>instead</em> of the user ID + password. This effectively prevents the user from having to re-enter his/her password.</p>
<p>This also shows that losing a refresh token is no problem because the client ID and secret are not known. It also shows that keeping the client ID and client secret secret is <em>vital</em>.</p>
</div></text><author><a href="/users/678022/adversus">Adversus</a></author><comments><comment><text><span class="comment-copy">"This also shows that losing a refresh token is no problem because the client ID and secret are not known". But I don't need them. If I got a refresh token then I can pass it to your application server. It adds client_id and secret and then pass all three to OAuth service. What's the point?</span></text><author><a class="comment-user" href="/users/1205788/3dface" title="56 reputation">3DFace</a></author></comment><comment><text><span class="comment-copy">The application server does not provide a way to supply a refresh token yourself, you cannot ask it to generate a new authentication token by giving it a refresh token. It renews the auth token itself when needed, "behind the scenes".</span></text><author><a class="comment-user" href="/users/678022/adversus" title="755 reputation">Adversus</a></author></comment><comment><text><span class="comment-copy">Got it. I mistakenly thought that the refresh token is stored on the user side.</span></text><author><a class="comment-user" href="/users/1205788/3dface" title="56 reputation">3DFace</a></author></comment><comment><text><span class="comment-copy">Note that you do in fact need the client secret to get the refresh token in the first place. You might be thinking of the implicit authentication flow, where you don't need a secret, but refresh tokens are not issued or used in that case.</span></text><author><a class="comment-user" href="/users/2395796/kevin-christopher-henry" title="14,127 reputation">Kevin Christopher Henry</a></author></comment><comment><text><span class="comment-copy">@KevinChristopherHenry I did not know, I edited the post, thanks.</span></text><author><a class="comment-user" href="/users/678022/adversus" title="755 reputation">Adversus</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To further simplify B T's answer: Use refresh tokens when you don't typically want the user to have to type in credentials again, but still want the power to be able to revoke the permissions (by revoking the refresh token) </p>
<p>You cannot revoke an access token, only a refresh token.</p>
</div></text><author><a href="/users/1991614/bitcoder">bitcoder</a></author><comments><comment><text><span class="comment-copy">You can revoke an access token, which will require either logging in again for another access token or using the refresh token to obtain another access token. If the refresh token was invalid, the user will have to re-authenticate to get a get a new access token along with a new refresh token.</span></text><author><a class="comment-user" href="/users/2898754/atieh" title="233 reputation">Atieh</a></author></comment><comment><text><span class="comment-copy">I disagree. An access token is issued by the auth server, signed with an expiry date, and sent to the client. When the client sends that token to the resource server, the resource server does not contact the auth server to verify the token; it just looks at the expiry date in the (signed and un-tampered) token. So no matter what you do at the auth server to try to 'revoke', the resource server doesn't care. Some people refer to the client logout as a revoke (ie client deletes its token) but imho this is misleading terminology - we want to 'revoke' a token at the server, not the client</span></text><author><a class="comment-user" href="/users/1991614/bitcoder" title="670 reputation">bitcoder</a></author></comment><comment><text><span class="comment-copy">Not saying that you couldn't write custom code to ignore certain tokens (like here <a href="http://stackoverflow.com/questions/22708046/access-token-revocation-implementation-in-oauth-2" title="access token revocation implementation in oauth 2">stackoverflow.com/questions/22708046/…</a>) but doing that  probably involves some network trips from the resource server to the oauth server/db each time the client makes a call. You avoid those calls by using refresh tokens instead, and I think is more in line with what the oauth authors intended.</span></text><author><a class="comment-user" href="/users/1991614/bitcoder" title="670 reputation">bitcoder</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>Why not just make the access_token last as long as the refresh_token
  and not have a refresh_token?</p>
</blockquote>
<p>In addition to great answers other people have provided there is another reason why would use refresh tokens and its to do with claims. </p>
<p>Each token contains claims which can include anything from the users name, their roles or the provider which created the claim. As a token is refreshed these claims are updated.</p>
<p>If we refresh the tokens more often we are obviously putting more strain on our identity services however we are getting more accurate and up-to-date claims.</p>
</div></text><author><a href="/users/1221847/heymega">heymega</a></author><comments><comment><text><span class="comment-copy">It would be an unusual bad practice to put such "claims" in the access token. As described in <a href="https://tools.ietf.org/html/rfc6749#section-1.4" rel="nofollow noreferrer">the specification</a>, the access token "is usually opaque to the client". Do you have examples of OAuth providers that do this?</span></text><author><a class="comment-user" href="/users/2395796/kevin-christopher-henry" title="14,127 reputation">Kevin Christopher Henry</a></author></comment><comment><text><span class="comment-copy">@heymega When user role is downgraded from ADMIN to REGULAR_USER expectation is that user role needs to be revoked immediately and not when access_token expires. So, it looks like hitting the database on each request is inevitable.</span></text><author><a class="comment-user" href="/users/126414/svlada" title="1,564 reputation">svlada</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Let's consider a system where each user is linked to one or more roles and each role is linked to one or more access privileges. This information can be cached for better API performance. But then, there may be changes in the user and role configurations (for e.g. new access may be granted or current access may be revoked) and these should be reflected in the cache.</p>
<p>We can use access and refresh tokens for such purpose. When an API is invoked with access token, the resource server checks the cache for access rights. IF there is any new access grants, it is not reflected immediately. Once the access token expires (say in 30 minutes) and the client uses the refresh token to generate a new access token, the cache can be updated with the updated user access right information from the DB. </p>
<p>In other words, we can move the expensive operations from every API call using access tokens to the event of access token generation using refresh token.</p>
</div></text><author><a href="/users/1235935/saptarshi">Saptarshi</a></author><comments/></answer></answers></post>