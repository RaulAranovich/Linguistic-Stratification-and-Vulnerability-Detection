<?xml version="1.0" encoding="utf-8"?>
<post><title>c - Why is this code vulnerable to buffer overflow attacks? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">int</span><span class="pln"> func</span><span class="pun">(</span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> str</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">char</span><span class="pln"> buffer</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln">
   </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">str</span><span class="pun">);</span><span class="pln">

   </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">len </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">100</span><span class="pun">)</span><span class="pln">
   </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">

   strncpy</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln">str</span><span class="pun">,</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">str</span><span class="pun">));</span><span class="pln">
   </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>This code is vulnerable to a buffer overflow attack, and I'm trying to figure out why. I'm thinking it has to do with <code>len</code> being declared a <code>short</code> instead of an <code>int</code>, but I'm not really sure.</p>
<p><strong>Any ideas?</strong></p>
</div></text><author><a href="/users/4761806/noam-m">Noam M</a></author><comments><comment><text><span class="comment-copy">There are multiple issues with this code. Recall that C strings are null-terminated.</span></text><author><a class="comment-user" href="/users/1328439/dmitri-chubarov" title="7,500 reputation">Dmitri Chubarov</a></author></comment><comment><text><span class="comment-copy">@DmitriChubarov, not null terminating the string will be a problem only if the string is used after the call to <code>strncpy</code>. In this case, it is not.</span></text><author><a class="comment-user" href="/users/434551/r-sahu" title="121,664 reputation">R Sahu</a></author></comment><comment><text><span class="comment-copy">The problems in this code flow directly from the fact that <code>strlen</code> is calculated, used for the validity check, <i>and then it is absurdly calculated again</i> -- it's a DRY failure. If the second <code>strlen(str)</code> were replaced with <code>len</code>, there would be no possibility of buffer overflow, regardless of the type of <code>len</code>. The answers don't address this point, they just manage to avoid it.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@RSahu What happens to <code>strlen</code> if the string is not NUL-terminated?</span></text><author><a class="comment-user" href="/users/733637/ciapan" title="5,353 reputation">CiaPan</a></author></comment><comment><text><span class="comment-copy">@CiaPan: Wenn passing a not null-terminated string to it, strlen will show undefined behavior.</span></text><author><a class="comment-user" href="/users/404734/kaiserludi" title="1,206 reputation">Kaiserludi</a></author></comment><comment><text><span class="comment-copy">It's weird that people get hung up on NUL termination here when that's completely irrelevant to this question about a buffer overflow attack. They might as well concern themselves with <code>str</code> being NULL.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@JimBalter Wouldn't the buffer overflow still occur if you used <code>len</code> in the <code>strncpy</code> and changed nothing else?</span></text><author><a class="comment-user" href="/users/1726343/asad-saeeduddin" title="32,606 reputation">Asad Saeeduddin</a></author></comment><comment><text><span class="comment-copy">@Asad Since I said it wouldn't (couldn't possibly), why are you asking me if it would, without giving some reason to think that I'm wrong? <code>len</code> is guaranteed to be &lt; 100 at the point of the <code>strncpy</code>, so how could it overflow <code>buffer</code> which is char[100]? It seems that you don't know the semantics of <code>strncpy</code>, or don't know what buffer overflow is, or something.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@JimBalter Yes, I'm very unfamiliar with C. The reason I thought an overflow would still occur is because of orlp's answer below, which indicates that if <code>strlen(str) &gt; 65535</code>, <code>len</code> will wrap around and the sentry if clause will pass, allowing strings that exceed the length of the buffer to be copied into the buffer.</span></text><author><a class="comment-user" href="/users/1726343/asad-saeeduddin" title="32,606 reputation">Asad Saeeduddin</a></author></comment><comment><text><span class="comment-copy">@JimBalter Ah, nevermind. Just looked at the strncpy docs and found out what the third arg is.</span></text><author><a class="comment-user" href="/users/1726343/asad-saeeduddin" title="32,606 reputation">Asad Saeeduddin</a></author></comment><comment><text><span class="comment-copy">@Asad You don't need knowledge of C, you just need to <i>think</i>. If strlen(str) is &gt; 65535, then len will either be &gt;= 100, in which case no copy is done, or it will be &lt; 100, in which case the copy only moves some of the bytes but is still safe. The function doesn't act as intended because <code>len</code> has the wrong type, but there's no way for overflow to happen because the guard clause isn't subverted.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@JimBalter Nah, I think I'll leave them there. Maybe someone else will have the same foolish misconception and learn from it. Feel free to flag them if they irk you, someone might come around and delete them.</span></text><author><a class="comment-user" href="/users/1726343/asad-saeeduddin" title="32,606 reputation">Asad Saeeduddin</a></author></comment><comment><text><span class="comment-copy">Also, it might address a <a href="http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use" rel="nofollow noreferrer">time of check to time of use</a> issue. If an attacker change the length of the sring in another thread, he might eventually change the content of <code>str</code> right after the check, but before the copy.</span></text><author><a class="comment-user" href="/users/1628038/leenevergup" title="883 reputation">LeeNeverGup</a></author></comment><comment><text><span class="comment-copy">Just curious how do you recognise that this code is "vulnerable to a buffer overflow attack"?</span></text><author><a class="comment-user" href="/users/1519939/dmitry-poroh" title="1,704 reputation">Dmitry Poroh</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>On most compilers the maximum value of an <code>unsigned short</code> is 65535.</p>
<p>Any value above that gets wrapped around, so 65536 becomes 0, and 65600 becomes 65.</p>
<p>This means that long strings of the right length (e.g. 65600) will pass the check, and overflow the buffer.</p>
<hr/>
<p>Use <code>size_t</code> to store the result of <code>strlen()</code>, not <code>unsigned short</code>, and compare <code>len</code> to an expression that directly encodes the size of <code>buffer</code>. So for example:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">char</span><span class="pln"> buffer</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln">
</span><span class="typ">size_t</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">str</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">len </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]))</span><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
memcpy</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">,</span><span class="pln"> len </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/565635/orlp">orlp</a></author><comments><comment><text><span class="comment-copy">If using <code>strnlen</code> guarantees it terminates before overflowing, then wouldn't it be safe (and faster) at that point to just use <code>strcpy</code> when you know the null terminator is less than 100 indices?</span></text><author><a class="comment-user" href="/users/1541563/patrick-roberts" title="6,446 reputation">Patrick Roberts</a></author></comment><comment><text><span class="comment-copy">@PatrickRoberts Theoretically, yes. But you have to keep in mind that 10% of the code is responsible for 90% of the runtime, so you shouldn't let performance go before security. And keep in mind that over time the code changes, which can suddenly mean that the previous check is gone.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">To prevent buffer overflow, simply use <code>len</code> as the third argument of strncpy. Using strlen again is dumb in any case.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">"<code>strncpy(buf, str, strlen(str))</code> does exactly the same as <code>strcpy(buf, str)</code>" -- no it doesn't; strncpy doesn't NUL-terminate (and does NUL-pad).</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@JimBalter Fair enough.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">And what about my other point? Using the sizeof(buffer) is excessive; <code>len</code> is always less and is sufficient. And it works regardless of the type of <code>len</code> -- the real problem here is that the test is done against <code>len</code> but the actual copy uses <code>strlen(str)</code> ... this violation of the DRY principle is bad practice in numerous ways, and here we see one of them.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy"><code>/ sizeof(buffer[0])</code> -- note that <code>sizeof(char)</code> in C is <i>always</i> 1 (even if a char contains a gazillion bits) so that's superfluous when there's no possibility of using a different data type. Still ... kudos for a complete answer (and thanks for being responsive to comments).</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">One last comment: since the copy always stops short of the NUL, <code>strncpy(buffer, str, len)</code> could be replaced with the equivalent but generally faster <code>memcpy(buffer, str, len)</code>.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">Why does <code>sizeof(buffer)</code> work? Wasn't it supposed to be the same as <code>sizeof(void*)</code> due to <code>const char[]</code> being just a <code>char*</code>?</span></text><author><a class="comment-user" href="/users/2016221/rr" title="6,919 reputation">rr-</a></author></comment><comment><text><span class="comment-copy">@rr-: <code>char[]</code> and <code>char*</code> are not the same thing.  There are <i>many</i> situations in which a <code>char[]</code> will get implicitly converted into a <code>char*</code>.  For example, <code>char[]</code> is exactly the same as <code>char*</code> when used as the type for function arguments.  However, the conversion does not happen for <code>sizeof()</code>.</span></text><author><a class="comment-user" href="/users/82294/dietrich-epp" title="123,983 reputation">Dietrich Epp</a></author></comment><comment><text><span class="comment-copy">@orlp I'm not agree with <code>len &gt;= sizeof(buffer) / sizeof(buffer[0])</code> because buffer is just a pointer and <code>sizeof(buffer)</code>  will return the size of a char pointer. You should use directly the size with which it was declared in <code>char buffer[100];</code> that is to say 100.</span></text><author><a class="comment-user" href="/users/2641719/watou" title="495 reputation">watou</a></author></comment><comment><text><span class="comment-copy">@watou You're wrong.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">@orlp: Could you please explain why comparing <code>len</code> to the expression is prefered to comparing the expression to <code>100</code>?</span></text><author><a class="comment-user" href="/users/2286508/sam-bruns" title="3,317 reputation">Sam Bruns</a></author></comment><comment><text><span class="comment-copy">@Controll Because if you change the size of <code>buffer</code> at some point the expression automatically updates. This is critical for security, because the declaration of <code>buffer</code> might be quite some lines away from  the check in actual code. So it's easy to change the size of buffer, but forget to update in every location where the size is used.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">Thanks! I understood.There is another point i'm missing. How the code you proposed is supposed to prevent the buffer overflow?  If it wasn't supposed to, then how can I prevent that?</span></text><author><a class="comment-user" href="/users/2286508/sam-bruns" title="3,317 reputation">Sam Bruns</a></author></comment><comment><text><span class="comment-copy">@Controll The code above is assumed to be inside a function. The buffer overflow is prevented because if the check fails the function returns before it writes to the buffer.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">Thanks for you answer! But how the fact of using <code>size_t</code> prevents <code>len</code> from being wrapped around, since afaik <code>size_t</code> is a <code>typedef</code> of an <code>unsigned</code> (perhaps <code>short</code>)?</span></text><author><a class="comment-user" href="/users/2286508/sam-bruns" title="3,317 reputation">Sam Bruns</a></author></comment><comment><text><span class="comment-copy">@Controll That's wrong. <a href="http://en.cppreference.com/w/c/string/byte/strlen" rel="nofollow noreferrer"><b><code>strlen</code></b></a> itself returns a <a href="http://en.cppreference.com/w/c/types/size_t" rel="nofollow noreferrer"><b><code>size_t</code></b></a>.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">Yes you're right. I understand now what I missed. Thanks! Btw great answer :)</span></text><author><a class="comment-user" href="/users/2286508/sam-bruns" title="3,317 reputation">Sam Bruns</a></author></comment><comment><text><span class="comment-copy">@JimBalter Because arrays in C(++) are confusing in that they decoy to pointers when passed into a function, even if the function argument looks like it's declared as an array. This confuses people into thinking that arrays are always just pointers, instead of only converting when passed into a function.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">@JimBalter It's not stupidity - it's a lack of knowledge. Knowledge that is counter-intuitive.</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">@Controll "size_t is a typedef of an unsigned (perhaps short)?" -- <code>size_t</code> is defined to be a type that is big enough to hold the length of <i>any</i> object, so it can only be <code>unsigned short</code> on machines with only 64K of memory.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@JimBalter: I've nothing more to say than: yes, you're right :) It's really not likely that <code>size_t</code> would be <code>unsigned short</code></span></text><author><a class="comment-user" href="/users/2286508/sam-bruns" title="3,317 reputation">Sam Bruns</a></author></comment><comment><text><span class="comment-copy">After 130+ upvotes I'm surprised no one found the <b>critical</b> bug in my original code. The string would never be null-terminated!</span></text><author><a class="comment-user" href="/users/565635/orlp" title="56,732 reputation">orlp</a></author></comment><comment><text><span class="comment-copy">@orip you are right, I missed the = in the &gt;=.</span></text><author><a class="comment-user" href="/users/97627/paul-wagland" title="14,760 reputation">Paul Wagland</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The problem is here:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">strncpy</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln">str</span><span class="pun">,</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">str</span><span class="pun">));</span><span class="pln">
                   </span><span class="pun">^^^^^^^^^^^</span></code></pre>
<p>If the string is greater than the length of the target buffer, strncpy will still copy it over.  You are basing the number of characters of the string as the number to copy instead of the size of the buffer.  The correct way to do this is as follows:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">strncpy</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln">str</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">buff</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
buffer</span><span class="pun">[</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">buff</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'\0'</span><span class="pun">;</span></code></pre>
<p>What this does is limit the amount of data copied to the actual size of the buffer minus one for the null terminating character.  Then we set the last byte in the buffer to the null character as an added safeguard.  The reason for this is because strncpy will copy upto n bytes, including the terminating null, if strlen(str) &lt; len - 1.  If not, then the null is not copied and you have a crash scenario because now your buffer has a unterminated string.</p>
<p>Hope this helps.</p>
<p>EDIT: Upon further examination and input from others, a possible coding for the function follows:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">int</span><span class="pln"> func </span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">str</span><span class="pun">)</span><span class="pln">
  </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">char</span><span class="pln"> buffer</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> size </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">str</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">len </span><span class="pun">&gt;</span><span class="pln"> size </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">(-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    memcpy</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">,</span><span class="pln"> len </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    buffer</span><span class="pun">[</span><span class="pln">size </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'\0'</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>
<p>Since we already know the length of the string, we can use memcpy to copy the string from the location that is referenced by str into the buffer.  Note that per the manual page for strlen(3) (on a FreeBSD 9.3 system), the following is stated:</p>
<blockquote>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln"> </span><span class="typ">The</span><span class="pln"> strlen</span><span class="pun">()</span><span class="pln"> function returns the number of characters that precede the
 terminating NUL character</span><span class="pun">.</span><span class="pln">  </span><span class="typ">The</span><span class="pln"> strnlen</span><span class="pun">()</span><span class="pln"> function returns either the
 same result as strlen</span><span class="pun">()</span><span class="pln"> or maxlen</span><span class="pun">,</span><span class="pln"> whichever is smaller</span><span class="pun">.</span></code></pre>
</blockquote>
<p>Which I interpret to be that the length of the string does not include the null.  That is why I copy len + 1 bytes to include the null, and the test checks to make sure that the length &lt; size of buffer - 2.  Minus one because the buffer starts at position 0, and minus another one to make sure there's room for the null.</p>
<p>EDIT: Turns out, the size of something starts with 1 while access starts with 0, so the -2 before was incorrect because it would return an error for anything &gt; 98 bytes but it should be &gt; 99 bytes.</p>
<p>EDIT: Although the answer about a unsigned short is generally correct as the maximum length that can be represented is 65,535 characters, it doesn't really matter because if the string is longer than that, the value will wrap around.  It's like taking 75,231 (which is 0x000125DF) and masking off the top 16 bits giving you 9695 (0x000025DF).  The only problem that I see with this is the first 100 chars past 65,535 as the length check will allow the copy, <strong>but it will only copy up to the first 100 characters of the string in all cases and null terminate the string</strong>.  So even with the wraparound issue, the buffer still will not be overflowed.</p>
<p>This may or may not in itself pose a security risk depending on the content of the string and what you are using it for.  If it's just straight text that is human readable, then there is generally no problem.  You just get a truncated string.  However, if it's something like a URL or even a SQL command sequence, you could have a problem.</p>
</div></text><author><a href="/users/1447013/daniel-rudy">Daniel Rudy</a></author><comments><comment><text><span class="comment-copy">True, but that is beyond of scope of the question.  The code clearly shows the function being passed a char pointer.  Outside of the scope of the function, we don't care.</span></text><author><a class="comment-user" href="/users/1447013/daniel-rudy" title="857 reputation">Daniel Rudy</a></author></comment><comment><text><span class="comment-copy">" the buffer in which str is stored" -- that's not a buffer <i>overflow</i>, which is the issue here. And <i>every</i> answer has that "problem", which is unavoidable given the signature of <code>func</code> ... and every <i>other</i> C function ever written that takes NUL-terminated strings as arguments. Bringing up the possibility of the input not being NUL-terminated is completely clueless.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">"that is beyond of scope of the question" -- which sadly is beyond the ability of some people to comprehend.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">"The problem is here" -- you're right, but you're still missing the key issue, which is that the test (<code>len &gt;= 100</code>) was done against one value but the length of the copy was given a different value ... this is a violation of the DRY principle. Simply calling <code>strncpy(buffer, str, len)</code> avoids the possibility of buffer overflow, and does less work than <code>strncpy(buffer,str,sizeof(buffer) - 1)</code> ... although here it is just a slower equivalent to <code>memcpy(buffer, str, len)</code>.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">@JimBalter It is beyond the scope of the question, but I digress. I understand that the values used by the test and what is used in strncpy are two different ones.  However, general coding practice says that the copy limit should be sizeof(buffer) - 1 so it doesn't matter what the length of str is on the copy. strncpy will stop copying bytes when it either hits a null or copies n bytes.  The next line guarantees that the last byte in the buffer is a null char.  The code is safe, I stand by my previous statement.</span></text><author><a class="comment-user" href="/users/1447013/daniel-rudy" title="857 reputation">Daniel Rudy</a></author></comment><comment><text><span class="comment-copy">"general coding practice says" -- no it doesn't; there are other cases and this is one of them. "The code is safe" -- I didn't say otherwise. "I stand by my previous statement" -- I didn't challenge any previous statement. You, OTOH, paid no attention to what I wrote.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">I will admit, I had no idea what the DRY or WET principles were. I had to look them up.  With that in mind, I can see why you were saying what you were saying.  I'm going to put some more code up to illustrate this.</span></text><author><a class="comment-user" href="/users/1447013/daniel-rudy" title="857 reputation">Daniel Rudy</a></author></comment><comment><text><span class="comment-copy">While this is safe, since a NUL character is explicitly added to the end, buffer overflow can still technically occur since <code>strlen</code> is being assigned to an <code>unsigned short</code>. I find it strange how this implementation arbitrarily allows strings of length <code>[N * 65536, N * 65536 + 98]</code> (N being any non-negative integer) and terminates them at <code>len - N * 65536</code>. That problem could be resolved by changing <code>unsigned short</code> to <code>unsigned size_t</code> or even just <code>size_t</code>.</span></text><author><a class="comment-user" href="/users/1541563/patrick-roberts" title="6,446 reputation">Patrick Roberts</a></author></comment><comment><text><span class="comment-copy">@PatrickRoberts "since a NUL character is explicitly added to the end" -- NUL termination is irrelevant; the issue is buffer overflow. "buffer overflow can still technically occur" -- <b>Wrong</b>. It is completely impossible for this code to store outside of <code>buffer</code> -- that's what "buffer overflow" means. This is true for <i>any</i> value of <code>len</code>; it doesn't matter whether <code>len</code> accurately reflects the length of the string -- that's an entirely different matter. (I don't endorse this code, which has several flaws, but it is safe.)</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Even though you're using <code>strncpy</code>, the length of the cutoff is still dependent on the passed string pointer. You have no idea how long that string is (the location of the null terminator relative to the pointer, that is). So calling <code>strlen</code> alone opens you up to vulnerability. If you want to be more secure, use <code>strnlen(str, 100)</code>.</p>
<p>Full code corrected would be:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">int</span><span class="pln"> func</span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">str</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">char</span><span class="pln"> buffer</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln">
   </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> strnlen</span><span class="pun">(</span><span class="pln">str</span><span class="pun">,</span><span class="pln"> </span><span class="lit">100</span><span class="pun">);</span><span class="pln"> </span><span class="com">// sizeof buffer</span><span class="pln">

   </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">len </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">100</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
     </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">

   strcpy</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">);</span><span class="pln"> </span><span class="com">// this is safe since null terminator is less than 100th index</span><span class="pln">
   </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/1541563/patrick-roberts">Patrick Roberts</a></author><comments><comment><text><span class="comment-copy">@user3386109 Wouldn't <code>strlen</code> also then access past the end of the buffer?</span></text><author><a class="comment-user" href="/users/1541563/patrick-roberts" title="6,446 reputation">Patrick Roberts</a></author></comment><comment><text><span class="comment-copy">orlp's answer is right.  I don't think this answer adds anything, and could be removed.  This answer overlooks the fact that the OP's code is attempting to check the length of the string.  A complete answer should explain why that check does not work.</span></text><author><a class="comment-user" href="/users/28128/david-grayson" title="45,045 reputation">David Grayson</a></author></comment><comment><text><span class="comment-copy">@user3386109 what you're pointing out makes orlp's answer just as invalid as mine. I fail to see why <code>strnlen</code> doesn't solve the problem if what orlp is suggesting is supposedly correct anyway.</span></text><author><a class="comment-user" href="/users/1541563/patrick-roberts" title="6,446 reputation">Patrick Roberts</a></author></comment><comment><text><span class="comment-copy">"I don't think strnlen solves anything here" -- of course it does; it prevents overflowing <code>buffer</code>. "since str could point to a buffer of 2 bytes, neither of which is NUL." -- that's irrelevant, as it is true of <i>any</i> implementation of <code>func</code>. The question here is about buffer overflow, not UB because the input isn't NUL-terminated.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">"The second parameter passed to strnlen must be the size of the object that the first parameter points to, or strnlen is worthless" -- this is complete and utter nonsense. If the second argument to strnlen is the length of the input string, then strnlen is equivalent to strlen. How would you even obtain that number, and if you had it, why would you need to call str[n]len? That's not what strnlen is for at all.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">+1 Although this answer is imperfect because it's not equivalent to the OP's code -- strncpy NUL-pads and doesn't NUL terminate, whereas strcpy NUL-terminates and doesn't NUL-pad, it <i>does</i> solve the problem, contrary to the ridiculous, ignorant comments above.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The answer with the wrapping is right. But there is a problem I think was not mentioned
if(len &gt;= 100)</p>
<p>Well if Len would be 100 we'd copy 100 elements an we'd not have trailing \0. That clearly would mean any other function depending on  proper ended string would walk way beyond the original array.</p>
<p>The string problematic from C is IMHO unsolvable. You'd alway better have some limits before the call, but even that won't help. There is no bounds checking and so buffer overflows always can and unfortunately will happen....</p>
</div></text><author><a href="/users/15068/friedrich">Friedrich</a></author><comments><comment><text><span class="comment-copy">The string problematic <b>is</b> solvable: just use the appropriate functions. I. e. <b>not</b> <code>strncpy()</code> and friends, but the memory allocating functions like <code>strdup()</code> and friends. They are in the POSIX-2008 standard, so they are fairly portable, though not available on some proprietary systems.</span></text><author><a class="comment-user" href="/users/2445184/cmaster" title="19,554 reputation">cmaster</a></author></comment><comment><text><span class="comment-copy">"any other function depending on proper ended string" -- <code>buffer</code> is local to this function and isn't used elsewhere. In a real program we would have to examine how it is used ... sometimes not NUL-terminating is correct (the original use of strncpy was to create UNIX's 14 byte directory entries -- NUL-padded and not NUL-terminated). "The string problematic from C is IMHO unsolvable" -- while C is a gawdawful language that has been surpassed by far better technology, safe code can be written in it if enough discipline is used.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">Your observation seems to me misguided. <code>if (len &gt;= 100)</code> is the condition for when the check <i>fails</i>, not when it passes, which means there is not a case where exactly 100 bytes with no NUL terminator is copied over, as that length is included in the fail condition.</span></text><author><a class="comment-user" href="/users/1541563/patrick-roberts" title="6,446 reputation">Patrick Roberts</a></author></comment><comment><text><span class="comment-copy">Patrick is right, I'm wrong.</span></text><author><a class="comment-user" href="/users/15068/friedrich" title="4,759 reputation">Friedrich</a></author></comment><comment><text><span class="comment-copy">@ cmaster. In this case you are wrong. It is not solvable, because one always can write beyoned the bounds. Yes it's undefiened behaviour but there is not way to prevent it completely.</span></text><author><a class="comment-user" href="/users/15068/friedrich" title="4,759 reputation">Friedrich</a></author></comment><comment><text><span class="comment-copy">@Jim Balter. It does not matter. I potentially can write over the bounds of this local buffer and so it always will be possible to corrupt some other datastructures.</span></text><author><a class="comment-user" href="/users/15068/friedrich" title="4,759 reputation">Friedrich</a></author></comment><comment><text><span class="comment-copy">Non sequitur. You seem to have forgotten what you wrote and what I was responding to.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment><comment><text><span class="comment-copy">I don't think so. Yes the buffer is local but it's still possible to write over the bounds and so we an invoke undefined behaviour. There might be some data which can be overwritten. You sometimes even can find out what is overwrittern, if e.g there would be another buffer this overwritting might take place...</span></text><author><a class="comment-user" href="/users/15068/friedrich" title="4,759 reputation">Friedrich</a></author></comment><comment><text><span class="comment-copy">You're just repeating yourself. Again, you have forgotten what you wrote and what I responded to ... it was about <code>strncpy</code> not NUL-terminating the data, which is a completely different subject from overflowing the buffer. Now go repeat yourself again ... I won't respond further.</span></text><author><a class="comment-user" href="/users/544557/jim-balter" title="12,206 reputation">Jim Balter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Beyond the security issues involved with calling <code>strlen</code> more than once, one should generally not use string methods on strings whose length is precisely known [for most string functions, there's only a really narrow case where they should be used--on strings for which a maximum length can be guaranteed, but the precise length isn't known].  Once the length of the input string is known and the length of the output buffer is known, one should figure out how big a region should be copied and then use <code>memcpy()</code> to actually perform the copy in question.  Although it's possible that <code>strcpy</code> might outperform <code>memcpy()</code> when copying a string of only 1-3 bytes or so, on many platforms <code>memcpy()</code> is likely to be more than twice as fast when dealing with larger strings.</p>
<p>Although there are some situations where security would come at the cost of performance, this is a situation where the secure approach is <em>also</em> the faster one.  In some cases, it may be reasonable to write code which is not secure against weirdly-behaving inputs, if code supplying the inputs can ensure they will be well-behaved, and if guarding against ill-behaved inputs would impede performance.  Ensuring that string lengths are only checked once improves <em>both</em> performance and security, though one extra thing can be done to help guard security even when tracking string length manually: for every string which is expected to have a trailing null, write the trailing null explicitly rather than expecting the source string to have it.  Thus, if one were writing an <code>strdup</code> equivalent:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">strdupe</span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">*</span><span class="pln">src</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  </span><span class="typ">size_t</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">src</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">dest </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="pln">len</span><span class="pun">+</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// Calculation can't wrap if string is in valid-size memory block</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">dest</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">OUT_OF_MEMORY</span><span class="pun">(),(</span><span class="kwd">char</span><span class="pun">*)</span><span class="lit">0</span><span class="pun">);</span><span class="pln"> 
  </span><span class="com">// OUT_OF_MEMORY is expected to halt; the return guards if it doesn't</span><span class="pln">
  memcpy</span><span class="pun">(</span><span class="pln">dest</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> len</span><span class="pun">);</span><span class="pln">      
  dest</span><span class="pun">[</span><span class="pln">len</span><span class="pun">]=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> dest</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Note that the last statement could generally be omitted if the memcpy had processed <code>len+1</code> bytes, but it another thread were to modify the source string the result could be a non-NUL-terminated destination string.</p>
</div></text><author><a href="/users/363751/supercat">supercat</a></author><comments><comment><text><span class="comment-copy">Can you please explain <i>the security issues involved with calling <code>strlen</code> more than once</i>?</span></text><author><a class="comment-user" href="/users/1646170/bogdan-alexandru" title="2,398 reputation">Bogdan Alexandru</a></author></comment><comment><text><span class="comment-copy">@BogdanAlexandru: Once one has called <code>strlen</code> and taken some action based upon the value returned (which was presumably the reason for calling it in the first place), then a repeated call either (1) will always yield the same answer as the first one, in which case it's simply wasted work, or (2) may sometimes (because something else--perhaps another thread--modified the string in the meantime) yield a different answer, in which case code which does some things with the length (e.g. allocating a buffer) may assume a different size than code which does other things (copying to the buffer).</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment></comments></answer></answers></post>