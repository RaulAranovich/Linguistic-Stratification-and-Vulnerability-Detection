<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Will HTML Encoding prevent all kinds of XSS attacks? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am not concerned about other kinds of attacks. Just want to know whether HTML Encode can prevent all kinds of XSS attacks.</p>
<p>Is there some way to do an XSS attack even if HTML Encode is used?</p>
</div></text><author><a href="/users/184/niyaz">Niyaz</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>No.</p>
<p>Putting aside the subject of allowing some tags (not really the point of the question), HtmlEncode simply does NOT cover all XSS attacks.</p>
<p>For instance, consider server-generated client-side javascript - the server dynamically outputs htmlencoded values directly into the client-side javascript, htmlencode will <strong>not stop</strong> injected script from executing.</p>
<p>Next, consider the following pseudocode:</p>
<pre><code>&lt;input value=&lt;%= HtmlEncode(somevar) %&gt; id=textbox&gt;
</code></pre>
<p>Now, in case its not immediately obvious, if somevar (sent by the user, of course) is set for example to</p>
<pre><code>a onclick=alert(document.cookie)
</code></pre>
<p>the resulting output is</p>
<pre><code>&lt;input value=a onclick=alert(document.cookie) id=textbox&gt;
</code></pre>
<p>which would clearly work. Obviously, this can be (almost) any other script... and HtmlEncode would not help much.</p>
<p>There are a few additional vectors to be considered... including the third flavor of XSS, called DOM-based XSS (wherein the malicious script is generated dynamically on the client, e.g. based on # values).</p>
<p>Also don't forget about UTF-7 type attacks - where the attack looks like </p>
<pre><code>+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-
</code></pre>
<p>Nothing much to encode there...</p>
<p>The solution, of course (in addition to proper and restrictive white-list input validation), is to perform <strong>context-sensitive</strong> encoding: HtmlEncoding is great IF you're output context IS HTML, or maybe you need JavaScriptEncoding, or VBScriptEncoding, or AttributeValueEncoding, or... etc.</p>
<p>If you're using MS ASP.NET, you can use their Anti-XSS Library, which provides all of the necessary context-encoding methods.</p>
<p>Note that all encoding should not be restricted to user input, but also stored values from the database, text files, etc.</p>
<p>Oh, and don't forget to explicitly set the charset, both in the HTTP header AND the META tag, otherwise you'll still have UTF-7 vulnerabilities...</p>
<p>Some more information, and a pretty definitive list (constantly updated), check out RSnake's Cheat Sheet: <a href="http://ha.ckers.org/xss.html" rel="noreferrer">http://ha.ckers.org/xss.html</a></p>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">It is of course wrong in the first place to write    &lt;input value=&lt;%= HtmlEncode(somevar) %&gt; id=textbox&gt;  and not    &lt;input value="&lt;%= HtmlEncode(somevar)" %&gt; id=textbox&gt;  if you do not know if the tekst contains e.g. a blank.</span></text><author><a class="comment-user" href="/users/6733/erik" title="3,098 reputation">Erik</a></author></comment><comment><text><span class="comment-copy">That's exactly the point - HTMLEncode does not protect you against mistakes. Of course, the programmer expected somevar to contain 23 - its just that nasty attacker that decided to shove a blank in...</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">It would not help to enclose it, image that SOMEVAR includes this text  |    " onclick="alert();" "   | it will then render like a valid tag.</span></text><author><a class="comment-user" href="/users/2257/espo" title="31,304 reputation">Espo</a></author></comment><comment><text><span class="comment-copy">Espo - Im late to the game on this - but it surely helps to enclose and encode - as in your example htmlencoding it (a quote) will yield: &amp;quot; and thus will be onclick=&amp;quot;alert()</span></text><author><a class="comment-user" href="/users/371637/adam-tuliper-msft" title="27,151 reputation">Adam Tuliper - MSFT</a></author></comment><comment><text><span class="comment-copy">@Adam, the proper solution here is to <i>attribute-encode</i> it (in addition to enclosing it), instead of html-encode. The context is different, so the encoding rules are different too - html encoding won't help you here.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD Given an HtmlEncode() function that <i>does</i> encode quote characters (as the ASP code in the example would), can you provide an example of an XSS value for <code>&lt;input value="&lt;%= HtmlEncode(value) %&gt;" id=textbox&gt;</code> ?</span></text><author><a class="comment-user" href="/users/54323/brianary" title="4,881 reputation">brianary</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you systematically encode all user input before displaying <s>then yes, you are safe</s> you are still not 100 % safe.<br/>
(See @Avid's post for more details)</p>
<p>In addition problems arise when you need to let <strong>some</strong> tags go unencoded so that you allow users to post images or bold text or any feature that requires user's input be processed as (or converted to) un-encoded markup.</p>
<p>You will have to set up a  decision making system to decide which tags are allowed and which are not, and it is always possible that someone will figure out a way to let a non allowed tag to pass through.</p>
<p>It helps if you follow Joel's advice of <a href="http://www.joelonsoftware.com/articles/Wrong.html" rel="nofollow noreferrer">Making Wrong Code Look Wrong</a> or if <a href="http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem" rel="nofollow noreferrer">your language helps you</a> by warning/not compiling when you are outputting unprocessed user data (static-typing).</p>
</div></text><author><a href="/users/238/pat">Pat</a></author><comments><comment><text><span class="comment-copy">While this includes a good point regarding bypassing some tags, the answer to the question is wrong. See my answer...</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">Added a comment to the OP so he accepts your answer instead. And added a link in my post to your answer, just in case.</span></text><author><a class="comment-user" href="/users/238/pat" title="25,631 reputation">Pat</a></author></comment><comment><text><span class="comment-copy">Thanks :) As a security guy, I just wanna make sure he gets it right...</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you encode everything it will. (depending on your platform and the implementation of htmlencode) But any usefull web application is so complex that it's easy to forget to check every part of it. Or maybe a 3rd party component isn't safe. Or maybe some code path that you though did encoding didn't do it so you forgot it somewhere else. </p>
<p>So you might want to check things on the input side too. And you might want to check stuff you read from the database.</p>
</div></text><author><a href="/users/3320/mendelt">Mendelt</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As mentioned by everyone else, you're safe as long as you encode <em>all</em> user input before displaying it. This includes all request parameters and data retrieved from the database that can be changed by user input.</p>
<p>As <a href="http://stackoverflow.com/questions/53728/will-html-encoding-prevent-all-kinds-of-xss-attacks#53755">mentioned by Pat</a> you'll sometimes want to display some tags, just not all tags. One common way to do this is to use a markup language like <a href="http://en.wikipedia.org/wiki/Textile_%28markup_language%29" rel="nofollow noreferrer">Textile</a>, <a href="http://en.wikipedia.org/wiki/Markdown" rel="nofollow noreferrer">Markdown</a>, or <a href="http://en.wikipedia.org/wiki/BBCode" rel="nofollow noreferrer">BBCode</a>. However, even markup languages can be vulnerable to XSS, just be aware.</p>
<pre><code># Markup example
[foo](javascript:alert\('bar'\);)
</code></pre>
<p>If you do decide to let "safe" tags through I would recommend finding some existing library to parse &amp; sanitize your code before output. There are <a href="http://ha.ckers.org/xss.html" rel="nofollow noreferrer">a lot of XSS vectors</a> out there that you would have to detect before your sanitizer is fairly safe.</p>
</div></text><author><a href="/users/5539/metavida">metavida</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I second metavida's advice to find a third-party library to handle output filtering. Neutralizing HTML characters is a good approach to stopping XSS attacks. However, the code you use to transform metacharacters can be vulnerable to evasion attacks; for instance, if it doesn't properly handle Unicode and internationalization.</p>
<p>A classic simple mistake homebrew output filters make is to catch only &lt; and &gt;, but miss things like ", which can break user-controlled output out into the attribute space of an HTML tag, where Javascript can be attached to the DOM.</p>
</div></text><author><a href="/users/5674/tqbf">tqbf</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>No, just encoding common HTML tokens DOES NOT completely protect your site from XSS attacks. See, for example, this XSS vulnerability found in google.com:</p>
<p><a href="http://www.securiteam.com/securitynews/6Z00L0AEUE.html" rel="nofollow noreferrer">http://www.securiteam.com/securitynews/6Z00L0AEUE.html</a></p>
<p>The important thing about this type of vulnerability is that the attacker is able to encode his XSS payload using UTF-7, and if you haven't specified a different character encoding on your page, a user's browser could interpret the UTF-7 payload and execute the attack script.</p>
</div></text><author><a href="/users/9573/chris-kite">Chris Kite</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>One other thing you need to check is where your input comes from. You can use the referrer string (most of the time) to check that it's from your own page, but putting in a hidden random number or something in your form and then checking it (with a session set variable maybe) also helps knowing that the input is coming from your own site and not some phishing site.</p>
</div></text><author><a href="/users/11421/mladen-mihajlovic">Mladen Mihajlovic</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'd like to suggest HTML Purifier (<a href="http://htmlpurifier.org/" rel="nofollow noreferrer">http://htmlpurifier.org/</a>) It doesn't just filter the html, it basically tokenizes and re-compiles it. It is truly industrial-strength. </p>
<p>It has the additional benefit of allowing you to ensure valid html/xhtml output. </p>
<p>Also n'thing textile, its a great tool and I use it all the time, but I'd run it though html purifier too. </p>
<p>I don't think you understood what I meant re tokens. HTML Purifier doesn't just 'filter', it actually reconstructs the html. <a href="http://htmlpurifier.org/comparison.html" rel="nofollow noreferrer">http://htmlpurifier.org/comparison.html</a></p>
</div></text><author><a href="/users/13113/buzz">Buzz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I don't believe so. Html Encode converts all functional characters (characters which could be interpreted by the browser as code) in to entity references which cannot be parsed by the browser and thus, cannot be executed.</p>
<pre><code>&amp;lt;script/&amp;gt;
</code></pre>
<p>There is no way that the above can be executed by the browser.</p>
<p>**Unless their is a bug in the browser ofcourse.*</p>
</div></text><author><a href="/users/383/gatekiller">GateKiller</a></author><comments><comment><text><span class="comment-copy">Or if Javascript is being used somehow to alter the user input for GUI purposes. I came across an XSS vulnerability that, at first, encoded &lt;&gt; to &lt; and &gt;... but when passed to this function, they were replaced again! So... there goes your XSS prevention, I guess. :)</span></text><author><a class="comment-user" href="/users/5342/verix" title="587 reputation">verix</a></author></comment></comments></answer></answers></post>