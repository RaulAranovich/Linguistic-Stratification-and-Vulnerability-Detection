<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Best way to store password in database - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am working on a project that has to have authentication  (user name/pass)</p>
<p>It also connects to a database so i figured i would store the user name and password there but it seems like not such a good idea to have passwords as just a text field in a table sitting on the db</p>
<p>I'm using C# and connecting to a 2008 express server. can anyone suggest ( with as many examples as possible) what is the best way to store this type of data?</p>
<p>(i am open to the idea that this info not be stored in the db if a good reason can be provided)</p>
</div></text><author><a href="/users/28004/balexandre">balexandre</a></author><comments><comment><text><span class="comment-copy">Whatever you do, if you go with encryption, don't store the key in the code as a previous poster mentioned. That's just poor practice.</span></text><author><a class="comment-user" href="/users/149020/woody" title="336 reputation">Woody</a></author></comment><comment><text><span class="comment-copy">'How to do passwords right?' is a vital question. It's a tough problem and mistakes have grave consequences (recall what happened to Tesco and LinkedIn). I think this question should be re-opened at <a href="http://programmers.stackexchange.com">programmers.stackexchange.com</a></span></text><author><a class="comment-user" href="/users/284795/colonel-panic" title="60,789 reputation">Colonel Panic</a></author></comment><comment><text><span class="comment-copy">It's better to stick to standards  - see <a href="http://en.wikipedia.org/wiki/PBKDF2" rel="nofollow noreferrer">en.wikipedia.org/wiki/PBKDF2</a> You only have to find an implementation in your language</span></text><author><a class="comment-user" href="/users/241986/boris-treukhov" title="10,294 reputation">Boris Treukhov</a></author></comment><comment><text><span class="comment-copy">This question is extensively answered in the security forum: <a href="http://security.stackexchange.com/questions/211/how-to-securely-hash-passwords" title="how to securely hash passwords">security.stackexchange.com/questions/211/…</a></span></text><author><a class="comment-user" href="/users/449288/gioele" title="4,654 reputation">gioele</a></author></comment><comment><text><span class="comment-copy">I wish we could down-vote those "closed as not constructive"... It looks like "a practical, answerable problem that is unique to software development" to me and as a programer (not a security expert), I'm glad to find this question here.</span></text><author><a class="comment-user" href="/users/287058/fabien" title="191 reputation">Fabien</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>You are correct that storing the password in a plain-text field is a <em>horrible</em> idea. However, <em>as far as location goes</em>, for most of the cases you're going to encounter (and I honestly can't think of any counter-examples) storing the <em>representation</em> of a password in the database is the proper thing to do. By representation I mean that you want to hash the password using a salt (which should be different for every user) and a secure 1-way algorithm and store <em>that</em>, throwing away the original password. Then, when you want to verify a password, you hash the value (using the same hashing algorithm and salt) and compare it to the hashed value in the database.</p>
<p>So, while it is a good thing you are thinking about this and it is a good question, this is actually a duplicate of these questions (at least):</p>
<ul>
<li><a href="http://stackoverflow.com/questions/947618/how-to-best-store-user-information-and-user-login-and-password">How to best store user information and user login and password</a></li>
<li><a href="http://stackoverflow.com/questions/258299/best-practices-for-storing-database-passwords">Best practices for storing database passwords</a></li>
<li><a href="http://stackoverflow.com/questions/674904/salting-your-password-best-practices">Salting Your Password: Best Practices?</a></li>
<li><a href="http://stackoverflow.com/questions/568657/is-it-ever-ok-to-store-password-in-plain-text-in-a-php-variable-or-php-constant">Is it ever ok to store password in plain text in a php variable or php constant?</a></li>
</ul>
<p>To clarify a bit further on the salting bit, the danger with simply hashing a password and storing that is that if a trespasser gets a hold of your database, they can still use what are known as <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="noreferrer">rainbow tables</a> to be able to "decrypt" the password (at least those that show up in the rainbow table). To get around this, developers add a <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noreferrer">salt</a> to passwords which, when properly done, makes rainbow attacks simply infeasible to do.  Do note that a common misconception is to simply add the same unique and long string to all passwords; while this is not <em>horrible</em>, it is best to add unique salts to every password. <a href="http://stackoverflow.com/questions/420843/need-some-help-understanding-password-salt">Read this for more.</a></p>
</div></text><author><a href="/users/16417/paolo-bergantino">Paolo Bergantino</a></author><comments><comment><text><span class="comment-copy">@Paolo Bergantino: "storing the password in the database is the proper thing to do" - I would disagree with that statement.</span></text><author><a class="comment-user" href="/users/16076/mitch-wheat" title="225,410 reputation">Mitch Wheat</a></author></comment><comment><text><span class="comment-copy">I meant storing the password in the database as opposed to storing it elsewhere. Taking that sentence out of context makes it seem like I am supporting storing plain passwords, if you read the rest I obviously don't.</span></text><author><a class="comment-user" href="/users/16417/paolo-bergantino" title="311,885 reputation">Paolo Bergantino</a></author></comment><comment><text><span class="comment-copy">@Paolo Bergantino: I understood what you meant perfectly. And I did not take it out of context. Best practice is not to store even the ecnrypted password, but to store a salted hash of the encrypted password.</span></text><author><a class="comment-user" href="/users/16076/mitch-wheat" title="225,410 reputation">Mitch Wheat</a></author></comment><comment><text><span class="comment-copy">Not only is that what I said, I directed him to a plethora of posts that discuss salts and such further...</span></text><author><a class="comment-user" href="/users/16417/paolo-bergantino" title="311,885 reputation">Paolo Bergantino</a></author></comment><comment><text><span class="comment-copy">@Paolo Bergantino: you sure there is not a typo in your post? It says "For most of the cases you are going to encounter (and I honestly can't think of any counter-examples) storing the password in the database is the proper thing to do." ??? It seems to contrdict your comments</span></text><author><a class="comment-user" href="/users/16076/mitch-wheat" title="225,410 reputation">Mitch Wheat</a></author></comment><comment><text><span class="comment-copy">What Paolo said directly contradicts itself.  A salted hash of a password is not a password.  Storing a salted hash of the password in the database is not storing the password in the database.  The body of the answer is perfectly appropriate, but its first sentence is extremely misleading.</span></text><author><a class="comment-user" href="/users/19403/robert-rossney" title="61,693 reputation">Robert Rossney</a></author></comment><comment><text><span class="comment-copy">@Robert: That's getting dangerously close to a petty semantics game, but I'll fix it nonetheless...</span></text><author><a class="comment-user" href="/users/16417/paolo-bergantino" title="311,885 reputation">Paolo Bergantino</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Background</strong>
You never ... really ... need to know the user's password. You just want to verify an incoming user knows the password for an account.</p>
<p><strong>Hash It:</strong>
Store user passwords hashed (one-way encryption) via a strong hash function. 
A search for "c# encrypt passwords" gives a load of examples.</p>
<p>See the <a href="http://sha1-hash-online.waraxe.us/" rel="nofollow noreferrer">online SHA1 hash creator</a> for an idea of what a hash function produces (But don't use SHA1 as a hash function, use something stronger such as SHA256).</p>
<p>Now, a hashed passwords means that you (and database thieves) shouldn't be able to reverse that hash back into the original password. </p>
<p><strong>How to use it:</strong>
But, you say, how do I use this mashed up password stored in the database?</p>
<p>When the user logs in, they'll hand you the username and the password (in its original text)
You just use the same hash code to hash that typed-in password to get the stored version.</p>
<p>So, compare the two hashed passwords (database hash for username and the typed-in &amp; hashed password). You can tell if "what they typed in" matched "what the original user entered for their password" by comparing their hashes.</p>
<p><strong>Extra credit:</strong></p>
<p><em>Question:</em> If I had your database, then couldn't I just take a cracker like John the Ripper and start making hashes until I find matches to your stored, hashed passwords?
(since users pick short, dictionary words anyway ... it should be easy)</p>
<p><em>Answer:</em> Yes ... yes they can.</p>
<p>So, you should 'salt' your passwords.
See the <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="nofollow noreferrer">Wikipedia article on salt</a></p>
<p>See <a href="http://www.obviex.com/samples/hash.aspx" rel="nofollow noreferrer">"How to hash data with salt" C# example</a></p>
</div></text><author><a href="/users/124739/joej">joej</a></author><comments><comment><text><span class="comment-copy">Nice post, except for one thing: md5 and sha1 have both been broken. You should probably go with a stronger algorithm, such as maybe the SHA2 family.</span></text><author><a class="comment-user" href="/users/16417/paolo-bergantino" title="311,885 reputation">Paolo Bergantino</a></author></comment><comment><text><span class="comment-copy">Thanks Paolo -- you are correct.  As the use of SHA2 is as easy as using MD5 &amp; SHA1, please use the stronger hash algorithm.</span></text><author><a class="comment-user" href="/users/124739/joej" title="694 reputation">joej</a></author></comment><comment><text><span class="comment-copy">SHA-1 hasn't been broken. But to paraphase Bruce Schneier: Walk, don't run, to SHA-2.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment><comment><text><span class="comment-copy">"So, you should 'salt' your passwords"... But the salt is usually stored in the database along with the password, so how does that help? Te attacker simply has to add the salt to the dictionary attack phrases he is testing against. How is that more secure other than it won't reveal duplicate passwords?</span></text><author><a class="comment-user" href="/users/454780/trusktr" title="12,788 reputation">trusktr</a></author></comment><comment><text><span class="comment-copy">@joej "You never ... really ... need to know the user's password" - that's a very short sighted assumption. There are many kind of applications where having a password stored in a way that can be retrieved is genuinely necessary. For example, an application that needs to frequently login to another system with stored credentials, supplied and updated by a user.</span></text><author><a class="comment-user" href="/users/2162673/francisco-zarabozo" title="1,505 reputation">Francisco Zarabozo</a></author></comment><comment><text><span class="comment-copy">@FranciscoZarabozo that's bad design of the both systems, because when my system is compromised, now my users on your system are too. oAuth and the like get around this, but you need the "other system" to support it. You should never reversibly encrypt a users password.</span></text><author><a class="comment-user" href="/users/1089267/thinkofanumber" title="572 reputation">thinkOfaNumber</a></author></comment><comment><text><span class="comment-copy">@thinkOfaNumber Again saying "you should never"... Tell me, how would you store the credentials to access an API like a REST API for PayPal or Twilio or any other system that provides you with a user and key (that acts as a password)? What if your system interfaces with those APIs not only for you but for several clients? You NEED to find a way to secure such data and that way exists. Two way encryption methods serve a purpose, they are not there as a "bad choice". Bad choices come from how you decide to implement it.</span></text><author><a class="comment-user" href="/users/2162673/francisco-zarabozo" title="1,505 reputation">Francisco Zarabozo</a></author></comment><comment><text><span class="comment-copy">@FranciscoZarabozo PayPal uses OAuth 2.0 as the auth mechanism. If PayPal allowed you to store my PayPal pwd in a 3rd party app, it would be a disaster, as they have little control over every unrelated app's security. An OAuth token gets around this, and is not the password, so it's ok to store in a reversibly encrypted form. Nor is my PayPal pwd <i>ever</i> made available to the third-party system,  as when I log into PayPal I'm on their website, not the third parties. That's how your system should interface with them. This discussion might warrant it's own question to ask if it's "ever OK"!</span></text><author><a class="comment-user" href="/users/1089267/thinkofanumber" title="572 reputation">thinkOfaNumber</a></author></comment><comment><text><span class="comment-copy">@thinkOfaNumber: you should have a look at POP and IMAP and come back with the right way to authenticate on these services. Also ping Google about that as they are storing these credentials in gmail (when you need to access mail systems via IMAP or POP). Seriously - saying this just shows that you have not worked about real life APIs.</span></text><author><a class="comment-user" href="/users/903011/woj" title="3,594 reputation">WoJ</a></author></comment><comment><text><span class="comment-copy">@WoJ Let's keep this technical and leave the guesses about my personal history for the pub. I admit that webmail is one case I never thought of, but POP and IMAP date back to the 80's when security was a different thing. Just because you can do it doesn't mean you should do it however, and I used to forward my POP mail to gMail so that I could avoid this very situation. PayPal would block your system from accessing them if you did the same, for good reason. A modern API developer should ensure that storing passwords is not necessary (or possible) by providing oAuth and other mechanisms.</span></text><author><a class="comment-user" href="/users/1089267/thinkofanumber" title="572 reputation">thinkOfaNumber</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As a key-hardened salted hash, using a secure algorithm such as sha-512.</p>
</div></text><author><a href="/users/19097/nilamo">nilamo</a></author><comments><comment><text><span class="comment-copy">In my opinion, you should always use slow algorithms (like Blowfish, for example) to store passwords. This writeup is a much better answer: <a href="https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords" title="how to securely hash passwords">security.stackexchange.com/questions/211/…</a>. Just putting it here, because this page still appears high in the search results.</span></text><author><a class="comment-user" href="/users/1061927/dynom" title="843 reputation">Dynom</a></author></comment><comment><text><span class="comment-copy">Following this advice for password storage would be doing it woefully wrong.</span></text><author><a class="comment-user" href="/users/64911/mlissner" title="4,832 reputation">mlissner</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The best security practice is not to store the password at all (not even encrypted), but to store the salted hash (with a unique salt per password) of the encrypted password.</p>
<p>That way it is (practically) impossible to retrieve a plaintext password.</p>
</div></text><author><a href="/users/16076/mitch-wheat">Mitch Wheat</a></author><comments><comment><text><span class="comment-copy">Wayne, by salting before computing the hash, the rainbow table is effectively defeated, provided the salt is of sufficient size.</span></text><author><a class="comment-user" href="/users/10429/mike-rosenblum" title="8,969 reputation">Mike Rosenblum</a></author></comment><comment><text><span class="comment-copy">@Wayne Hartman: Not so. If the salt value is exposed, then you must generate a new rainbow table for that specific salt value. The point of a rainbow table is to have hash values calculated beforehand. And nobody will have a rainbow table for his specific salt.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'd thoroughly recommend reading the articles <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</a> [dead link, <a href="http://web.archive.org/web/20120114184424/http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">copy at the Internet Archive</a>] and <a href="http://codahale.com/how-to-safely-store-a-password/" rel="nofollow noreferrer">How To Safely Store A Password</a>.</p>
<p>Lots of coders, myself included, think they understand security and hashing.   Sadly most of us just don't.</p>
</div></text><author><a href="/users/122755/zebrabox">zebrabox</a></author><comments><comment><text><span class="comment-copy">article gives a 404.</span></text><author><a class="comment-user" href="/users/650492/johan" title="52,571 reputation">Johan</a></author></comment><comment><text><span class="comment-copy">@Johan Looks like the link is now broken which is a shame. Here's an alternative <a href="http://codahale.com/how-to-safely-store-a-password/" rel="nofollow noreferrer">codahale.com/how-to-safely-store-a-password</a></span></text><author><a class="comment-user" href="/users/122755/zebrabox" title="4,701 reputation">zebrabox</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I may be slightly off-topic as you did mention the need for a username and password, and my understanding of the issue is admitedly not the best but is OpenID something worth considering?</p>
<p>If you use OpenID then you don't end up storing any credentials at all if I understand the  technology correctly and users can use credentials that they already have, avoiding the need to create a new identity that is specific to your application.</p>
<p>It may not be suitable if the application in question is purely for internal use though</p>
<p><a href="https://rpxnow.com/" rel="noreferrer">RPX</a> provides a nice easy way to intergrate OpenID support into an application.</p>
</div></text><author><a href="/users/35031/crippledsmurf">Crippledsmurf</a></author><comments><comment><text><span class="comment-copy">I agree that openID rocks peoples faces off but for this application it is a in house database for a company I doubt they would like any old person coming in to log on. also web access is not needed for this app to work correctly so i would hate to require it.</span></text><author><a class="comment-user owner" href="/users/72136/crash893" title="3,847 reputation">Crash893</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I would MD5/SHA1 the password if you don't need to be able to reverse the hash. When users login, you can just encrypt the password given and compare it to the hash. Hash collisions are  nearly impossible in this case, unless someone gains access to the database and sees a hash they already have a collision for.</p>
</div></text><author><a href="/users/89334/waiwai933">waiwai933</a></author><comments><comment><text><span class="comment-copy">I wouldn't use MD5 for hashing - it's basically broken   <a href="http://www.mscs.dal.ca/%7Eselinger/md5collision/" rel="nofollow noreferrer">mscs.dal.ca/~selinger/md5collision</a></span></text><author><a class="comment-user" href="/users/122755/zebrabox" title="4,701 reputation">zebrabox</a></author></comment><comment><text><span class="comment-copy">Actually, it's not that broken. What they can do is find the same hash value for two different files. What they can't do is reverse the MD5 and get a working password.</span></text><author><a class="comment-user" href="/users/89334/waiwai933" title="5,313 reputation">waiwai933</a></author></comment><comment><text><span class="comment-copy">Well, wouldn't that be broken too then?  You just enter the other password that generates the same hash, and you're in.  You don't need to know the original password.  The way to fix this is if you salt the password before hashing.</span></text><author><a class="comment-user" href="/users/236528/mjuarez" title="5,107 reputation">mjuarez</a></author></comment><comment><text><span class="comment-copy">@mjuarez if you add a salt to the password befor you use MD5 the collision doesn't matter because you can't use the other password</span></text><author><a class="comment-user" href="/users/1993545/wiimaxx" title="2,613 reputation">WiiMaxx</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In your scenario, you can have a look at asp.net membership, it is good practice to store user's password as hashed string in the database. you can authenticate the user by comparing the hashed incoming password with the one stored in the database.</p>
<p>Everything has been built for this purposes, check out <a href="http://msdn.microsoft.com/en-us/library/ms998347.aspx" rel="nofollow noreferrer">asp.net membership</a></p>
</div></text><author><a href="/users/11413/codemeit">codemeit</a></author><comments/></answer></answers></post>