<?xml version="1.0" encoding="utf-8"?>
<post><title>php - SQL injection that gets around mysql_real_escape_string() - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Is there an SQL injection possibility even when using <code>mysql_real_escape_string()</code> function?</p>
<p>Consider this sample situation. SQL is constructed in PHP like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$login </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="typ">GetFromPost</span><span class="pun">(</span><span class="str">'login'</span><span class="pun">));</span><span class="pln">
$password </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="typ">GetFromPost</span><span class="pun">(</span><span class="str">'password'</span><span class="pun">));</span><span class="pln">

$sql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM table WHERE login='$login' AND password='$password'"</span><span class="pun">;</span></code></pre>
<p>I have heard numerous people say to me that a code like that is still dangerous and possible to hack even with <code>mysql_real_escape_string()</code> function used. But I cannot think of any possible exploit?</p>
<p>Classic injections like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">aaa</span><span class="str">' OR 1=1 --</span></code></pre>
<p>do not work.</p>
<p>Do you know of any possible injection that would get through the PHP code above?</p>
</div></text><author><a href="/users/2754166/ram-sharma">Ram Sharma</a></author><comments><comment><text><span class="comment-copy">Usually it's better to do the password validation in the PHP code so you can display a more verbose error (invalid user / invalid password)</span></text><author><a class="comment-user" href="/users/298479/thiefmaster" title="201,303 reputation">ThiefMaster<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@ThiefMaster I know, the above is just a simple example to get my point across.</span></text><author><a class="comment-user owner" href="/users/95944/richard-knop" title="26,212 reputation">Richard Knop</a></author></comment><comment><text><span class="comment-copy">Always use prepared statements.  The security provision, performance benefits of statement re-use, standardised coding, and library maintainance always (in my opinion) out-weigh any other alternative 'short-cut' method.</span></text><author><a class="comment-user" href="/users/53341/matbailie" title="48,241 reputation">MatBailie</a></author></comment><comment><text><span class="comment-copy">@ThiefMaster - I prefer not to give verbose errors like invalid user / invalid password... it tells brute force merchants that they have a valid user ID, and it's just the password they need to guess</span></text><author><a class="comment-user" href="/users/324584/mark-baker" title="153,658 reputation">Mark Baker</a></author></comment><comment><text><span class="comment-copy">It's horrible from an usability point of view though. Sometimes you couldn't use your main nickname/username/email-address and forget this after some time or the site deleted your account for inactivity. Then it's extremely annoying if you continue trying passwords and maybe even get your IP blocked even though it's just your username that is invalid.</span></text><author><a class="comment-user" href="/users/298479/thiefmaster" title="201,303 reputation">ThiefMaster<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy"><a href="http://bit.ly/phpmsql" rel="nofollow noreferrer"><b>Please, don't use <code>mysql_*</code> functions in new code</b></a>. They are no longer maintained and the <a href="http://j.mp/Rj2iVR" rel="nofollow noreferrer">deprecation process</a> has begun on it. See the <a href="http://j.mp/Te9zIL" rel="nofollow noreferrer"><b>red box</b></a>? Learn about <a href="http://j.mp/T9hLWi" rel="nofollow noreferrer"><i>prepared statements</i></a> instead, and use <a href="http://php.net/pdo" rel="nofollow noreferrer">PDO</a> or <a href="http://php.net/mysqli" rel="nofollow noreferrer">MySQLi</a> - <a href="http://j.mp/QEx8IB" rel="nofollow noreferrer">this article</a> will help you decide which. If you choose PDO, <a href="http://j.mp/PoWehJ" rel="nofollow noreferrer">here is a good tutorial</a>.</span></text><author><a class="comment-user" href="/users/727208/tere%c5%a1ko" title="44,303 reputation">tereško</a></author></comment><comment><text><span class="comment-copy">@tereško: They will not remove the mysql_* function from php, at least not very soon. Maybe in 2050. Think about it, if they remove it, all the servers that are doing automatic update of php will have all the websites nonfunctional. That's just absurd.</span></text><author><a class="comment-user" href="/users/1057527/machineaddict" title="2,323 reputation">machineaddict</a></author></comment><comment><text><span class="comment-copy">@machineaddict, since 5.5 (which was released recently) the <code>mysql_*</code> functions already produce <code>E_DEPRECATED</code> warning. The <code>ext/mysql</code> extension has not been maintained for more then 10 years. Are you really so delusional?</span></text><author><a class="comment-user" href="/users/727208/tere%c5%a1ko" title="44,303 reputation">tereško</a></author></comment><comment><text><span class="comment-copy">As most production websites do not print errors, E_DEPRECATED is useless. Until "all" websites switch from mysql functions, it will not be removed. Even where I work, <b>I have to work</b> with mysql extension, because even they don't think it will be removed very soon. Maybe in php 6.0. Will see...</span></text><author><a class="comment-user" href="/users/1057527/machineaddict" title="2,323 reputation">machineaddict</a></author></comment><comment><text><span class="comment-copy">@machineaddict It will be removed eventually. Servers don't really do automatic updates as you claimed. Most servers are running LTS versions of Linux so they are still running relatively old PHP versions (lots of servers still on PHP 5.1 or 5.2). If they remove it in the next major release of PHP, there will be enough time to stop using mysql_* functions (and seriously nobody has been using it for years, it's only in legacy code) as it will take time (probably few years) until the new release is rolled into LTS releases.</span></text><author><a class="comment-user owner" href="/users/95944/richard-knop" title="26,212 reputation">Richard Knop</a></author></comment><comment><text><span class="comment-copy">There is only one ultimate way to protect you against SQL injection. Just check the variable contains what you are expecting for. If you are expecting an integer, use ctype_digit... IN most case you shoudl surround it with "" or ''. and escape in variable matching quotes...</span></text><author><a class="comment-user" href="/users/2610855/loenix" title="750 reputation">Loenix</a></author></comment><comment><text><span class="comment-copy">A [space] character after the two dashes ( -- ) in the last may make the query valid. <i>aaa' OR 1=1 --[SPACE_HERE]</i></span></text><author><a class="comment-user" href="/users/2156512/bimal-poudel" title="451 reputation">Bimal Poudel</a></author></comment><comment><text><span class="comment-copy">@Loenix: With ints there might be an even better way than that: rather than checking, simply turn it <i>into</i> what you're expecting. <code>$value = (int) $value;</code> or <code>$value = intval($value);</code>.  It handles things like negative signs, which <code>ctype_digit</code> won't.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@cHao I can't agree with you. The best way is always to check values cause is does not mean that all integers are expected, we don't want to insert a value that the user don't want too. If you are inserting data, you must : check the content you are expecting and format the value to be standardized or workable. Here, if you check it and you got a non-well formated user name, you could return "Hey your value is not valid, please fix it."</span></text><author><a class="comment-user" href="/users/2610855/loenix" title="750 reputation">Loenix</a></author></comment><comment><text><span class="comment-copy">@Loenix: If you're filtering for <i>business reasons</i> (eg: ensuring that a phone number looks like a phone number), that's one thing.  But filtering for technical reasons is wrongheaded. SQL injection isn't caused by bad data; it's caused by bad <i>code</i>.  One should be able to have a name of <code>&lt;script&gt;alert("①'ᆖ@\'½¶ഝ")</code>, if they really want to type it in.  If it would break your app, then your app is <i>already broken</i>.  At best, rejecting such a name for technical reasons is a band-aid; at worst, it's false security.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">mysqli_real_escape_string()</span></text><author><a class="comment-user" href="/users/4614305/dillon-burnett" title="99 reputation">Dillon Burnett</a></author></comment><comment><text><span class="comment-copy">@machineaddict They just removed that extension on PHP 7.0 and it is not 2050 yet.</span></text><author><a class="comment-user" href="/users/2671392/ggg" title="497 reputation">GGG</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Consider the following query:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$iId </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"1 OR 1=1"</span><span class="pun">);</span><span class="pln">    
$sSql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM table WHERE id = $iId"</span><span class="pun">;</span></code></pre>
<p><code>mysql_real_escape_string()</code> will not protect you against this.
The fact that you use single quotes (<code>' '</code>) around your variables inside your query is what protects you against this. The following is also an option:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$iId </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="str">"1 OR 1=1"</span><span class="pun">;</span><span class="pln">
$sSql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM table WHERE id = $iId"</span><span class="pun">;</span></code></pre>
</div></text><author><a href="/users/703808/wesley-van-opdorp">Wesley van Opdorp</a></author><comments><comment><text><span class="comment-copy">What if the users passes a single quote as part of the value: <code>1'; DROP TABLE --</code> the trailing comment will make the engine ignore the dangling other single quote from the statement</span></text><author><a class="comment-user" href="/users/330315/a-horse-with-no-name" title="212,445 reputation">a_horse_with_no_name</a></author></comment><comment><text><span class="comment-copy">+1 : Thus the value of paramaterised queries :)  I know so many people that try to take short-cuts to save on lines of code.  Much better, in my opinion, to be safer than you think you need to be, rather than find later that you were not safe enough...</span></text><author><a class="comment-user" href="/users/53341/matbailie" title="48,241 reputation">MatBailie</a></author></comment><comment><text><span class="comment-copy">@wesley <code>$iId = mysql_real_escape_string((int)"1; DROP table");</code> or `$dirty = "1; DROP table";$iId = mysql_real_escape_string((int)$dirty); would be a better example than what you have, I think.</span></text><author><a class="comment-user" href="/users/69993/kzqai" title="12,386 reputation">Kzqai</a></author></comment><comment><text><span class="comment-copy">But this wouldn't be a real problem, because <code>mysql_query()</code> doesn't execute multiple statements, no?</span></text><author><a class="comment-user" href="/users/187606/pekka-%ec%9b%83" title="317,852 reputation">Pekka 웃</a></author></comment><comment><text><span class="comment-copy">@Pekka, Although the usual example is <code>DROP TABLE</code>, in practice the attacker is more likely to <code>SELECT passwd FROM users</code>. In the latter case, the second query is usually executed by use of a <code>UNION</code> clause.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy"><code>(int)mysql_real_escape_string</code> - this makes no sense. It doesn't differ from <code>(int)</code> at all. And they will produce the same result for every input</span></text><author><a class="comment-user" href="/users/251311/zerkms" title="158,727 reputation">zerkms</a></author></comment><comment><text><span class="comment-copy">This is more of a misuse of the function than anything else. After all, it is named <code>mysql_real_escape_string</code>, not <code>mysql_real_escape_integer</code> . It's not mean to be used with integer fields.</span></text><author><a class="comment-user" href="/users/396458/nulluserexception" title="56,528 reputation">NullUserException</a></author></comment><comment><text><span class="comment-copy">To the people downvoting this answer: this answer is completely correct. This is <b>far</b> more likely to be the reason your use of <code>mysql_real_escape_string</code> is going to be compromised than my answer below. This belongs as the accepted answer (but both can live together)...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell, Yet the answer is totally misleading. Obviously the question is asking about the <b>contents</b> within the quotes. "Quotes are not there" is <b>not</b> the answer to this question.</span></text><author><a class="comment-user" href="/users/632951/pacerier" title="33,795 reputation">Pacerier</a></author></comment><comment><text><span class="comment-copy">Why did you remove the edit, @eggyal? Casting to int will produce a number, anyway. There can be nothing dangerous about numbers related to escaping, right? And Cast to integer itself does not care about any escaping.</span></text><author><a class="comment-user" href="/users/2157640/palec" title="5,595 reputation">Palec</a></author></comment><comment><text><span class="comment-copy">@Palec:  You're quite right.  I hadn't looked close enough, and thought that the edit had changed the meaning of the answer.  My bad.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">@wesley "The fact that you use single quotes (' ') around your variables inside your query is what protects you against this." Well but the single quotes were part of the example, the question asked for an attack for that situation, when you use single quotes.</span></text><author><a class="comment-user" href="/users/858981/eugenio" title="688 reputation">Eugenio</a></author></comment><comment><text><span class="comment-copy">@Wesley van Opdorp Why does single quoting protect from SQL injection? The query looks like this after expanding variables: SELECT * FROM table WHERE login='aaa' or 1=1 --' AND password='some_value' Why this is not a valid SQL statement?</span></text><author><a class="comment-user" href="/users/2350150/curiousguy" title="529 reputation">CuriousGuy</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The short answer is <strong>yes, yes there is a way to get around <code>mysql_real_escape_string()</code></strong>. </p>
<h1>For Very OBSCURE EDGE CASES!!!</h1>
<p>The long answer isn't so easy. It's based off an attack <a href="http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string" rel="noreferrer">demonstrated here</a>.</p>
<h1>The Attack</h1>
<p>So, let's start off by showing the attack...</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = '$var' LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>In certain circumstances, that will return more than 1 row. Let's dissect what's going on here:</p>
<ol>
<li><p><strong>Selecting a Character Set</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span></code></pre>
<p>For this attack to work, we need the encoding that the server's expecting on the connection both to encode <code>'</code> as in ASCII i.e. <code>0x27</code> <em>and</em> to have some character whose final byte is an ASCII <code>\</code> i.e. <code>0x5c</code>.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: <code>big5</code>, <code>cp932</code>, <code>gb2312</code>, <code>gbk</code> and <code>sjis</code>.  We'll select <code>gbk</code> here.</p>
<p>Now, it's very important to note the use of <code>SET NAMES</code> here. This sets the character set <strong>ON THE SERVER</strong>. If we used the call to the C API function <code>mysql_set_charset()</code>, we'd be fine (on MySQL releases since 2006). But more on why in a minute...</p></li>
<li><p><strong>The Payload</strong></p>
<p>The payload we're going to use for this injection starts with the byte sequence <code>0xbf27</code>.  In <code>gbk</code>, that's an invalid multibyte character; in <code>latin1</code>, it's the string <code>¿'</code>.  Note that in <code>latin1</code> <strong>and</strong> <code>gbk</code>, <code>0x27</code> on its own is a literal <code>'</code> character. </p>
<p>We have chosen this payload because, if we called <code>addslashes()</code> on it, we'd insert an ASCII <code>\</code> i.e. <code>0x5c</code>, before the <code>'</code> character. So we'd wind up with <code>0xbf5c27</code>, which in <code>gbk</code> is a two character sequence: <code>0xbf5c</code> followed by <code>0x27</code>. Or in other words, a <em>valid</em> character followed by an unescaped <code>'</code>. But we're not using <code>addslashes()</code>. So on to the next step...</p></li>
<li><p><strong>mysql_real_escape_string()</strong></p>
<p>The C API call to <code>mysql_real_escape_string()</code> differs from <code>addslashes()</code> in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we're still using <code>latin1</code> for the connection, because we never told it otherwise. We did tell the <em>server</em> we're using <code>gbk</code>, but the <em>client</em> still thinks it's <code>latin1</code>.</p>
<p>Therefore the call to <code>mysql_real_escape_string()</code> inserts the backslash, and we have a free hanging <code>'</code> character in our "escaped" content! In fact, if we were to look at <code>$var</code> in the <code>gbk</code> character set, we'd see:</p>
<pre>縗' OR 1=1 /*</pre>
<p>Which is <a href="https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;oq=%E7%B8%97%27%20OR&amp;aqs=chrome..69i57&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8" rel="noreferrer">exactly what</a> the attack requires.</p></li>
<li><p><strong>The Query</strong></p>
<p>This part is just a formality, but here's the rendered query:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">SELECT</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">FROM</span><span class="pln"> test </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'縗'</span><span class="pln"> </span><span class="kwd">OR</span><span class="pln"> </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> </span><span class="com">/*' LIMIT 1</span></code></pre></li>
</ol>
<p>Congratulations, you just successfully attacked a program using <code>mysql_real_escape_string()</code>...</p>
<h1>The Bad</h1>
<p>It gets worse. <code>PDO</code> defaults to <em>emulating</em> prepared statements with MySQL. That means that on the client side, it basically does a sprintf through <code>mysql_real_escape_string()</code> (in the C library), which means the following will result in a successful injection:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">));</span></code></pre>
<p>Now, it's worth noting that you can prevent this by disabling emulated prepared statements:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>
<p>This will <em>usually</em> result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently <a href="https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210" rel="noreferrer">fallback</a> to emulating statements that MySQL can't prepare natively: those that it can are <a href="http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html" rel="noreferrer">listed</a> in the manual, but beware to select the appropriate server version).</p>
<h1>The Ugly</h1>
<p>I said at the very beginning that we could have prevented all of this if we had used <code>mysql_set_charset('gbk')</code> instead of <code>SET NAMES gbk</code>. And that's true provided you are using a MySQL release since 2006.</p>
<p>If you're using an earlier MySQL release, then a <a href="http://bugs.mysql.com/bug.php?id=8378" rel="noreferrer">bug</a> in <code>mysql_real_escape_string()</code> meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes <em>even if the client had been correctly informed of the connection encoding</em> and so this attack would still succeed.  The bug was fixed in MySQL <a href="http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html" rel="noreferrer">4.1.20</a>, <a href="http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html" rel="noreferrer">5.0.22</a> and <a href="http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html" rel="noreferrer">5.1.11</a>.</p>
<p>But the worst part is that <code>PDO</code> didn't expose the C API for <code>mysql_set_charset()</code> until 5.3.6, so in prior versions it <strong>cannot</strong> prevent this attack for every possible command!
 It's now exposed as a <a href="http://www.php.net/manual/en/ref.pdo-mysql.connection.php" rel="noreferrer">DSN parameter</a>.</p>
<h1>The Saving Grace</h1>
<p>As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  <a href="http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html" rel="noreferrer"><code>utf8mb4</code></a> is <em>not vulnerable</em> and yet can support <em>every</em> Unicode character: so you could elect to use that instead—but it has only been available since MySQL 5.5.3.  An alternative is <a href="http://dev.mysql.com/doc/en/charset-unicode-utf8.html" rel="noreferrer"><code>utf8</code></a>, which is also <em>not vulnerable</em> and can support the whole of the Unicode <a href="http://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane" rel="noreferrer">Basic Multilingual Plane</a>.</p>
<p>Alternatively, you can enable the <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes" rel="noreferrer"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode, which (amongst other things) alters the operation of <code>mysql_real_escape_string()</code>.  With this mode enabled, <code>0x27</code> will be replaced with <code>0x2727</code> rather than <code>0x5c27</code> and thus the escaping process <em>cannot</em> create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. <code>0xbf27</code> is still <code>0xbf27</code> etc.)—so the server will still reject the string as invalid.  However, see <a href="http://stackoverflow.com/a/23277864/623041">@eggyal's answer</a> for a different vulnerability that can arise from using this SQL mode.</p>
<h1>Safe Examples</h1>
<p>The following examples are safe:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SET NAMES utf8'</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = '$var' LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>Because the server's expecting <code>utf8</code>...</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">mysql_set_charset</span><span class="pun">(</span><span class="str">'gbk'</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = '$var' LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>Because we've properly set the character set so the client and the server match.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
$pdo</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">));</span></code></pre>
<p>Because we've turned off emulated prepared statements.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">'mysql:host=localhost;dbname=testdb;charset=gbk'</span><span class="pun">,</span><span class="pln"> $user</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">));</span></code></pre>
<p>Because we've set the character set properly.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$mysqli</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$param </span><span class="pun">=</span><span class="pln"> </span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">;</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">'s'</span><span class="pun">,</span><span class="pln"> $param</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<p>Because MySQLi does true prepared statements all the time.</p>
<h1>Wrapping Up</h1>
<p>If you:</p>
<ul>
<li>Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) <strong>AND</strong> <code>mysql_set_charset()</code> / <code>$mysqli-&gt;set_charset()</code> / PDO's DSN charset parameter (in PHP ≥ 5.3.6)</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>Don't use a vulnerable character set for connection encoding (you only use <code>utf8</code> / <code>latin1</code> / <code>ascii</code> / etc)</li>
</ul>
<p>You're 100% safe.</p>
<p>Otherwise, you're vulnerable <strong>even though you're using <code>mysql_real_escape_string()</code></strong>...</p>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">PDO emulating prepare statements for MySQL, really? I don't see any reason why it would do that since the driver supports it natively. No?</span></text><author><a class="comment-user" href="/users/492901/netcoder" title="46,050 reputation">netcoder</a></author></comment><comment><text><span class="comment-copy">It does. They say in the documentation it doesn't. But in the source code, it's plainly visible and easy to fix. I chalk it up to incompetence of the devs.</span></text><author><a class="comment-user" href="/users/430062/theodore-r-smith" title="8,794 reputation">Theodore R. Smith</a></author></comment><comment><text><span class="comment-copy">@TheodoreR.Smith: It's not that easy to fix. I've been working on changing the default, but it fails a boat load of tests when switched. So it's a bigger change than it seems. I'm still hoping to have it finished by 5.5...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell There are few things: as stated in the article You link to, this vulnerability could be used only when using <code>addslashes()</code> and not <code>mysql_real_escape_string()</code> - that should be safe, as written in the article (read once more). Secondly I am very curious how could one PUT, GET or POST <code>char(0xBF)</code> followed by <code>char(0x27)</code>...Though it could be demonstrated with ourselves written PHP I doubt one could post such values from a form or an URL...</span></text><author><a class="comment-user" href="/users/598500/shadyyx" title="12,494 reputation">shadyyx</a></author></comment><comment><text><span class="comment-copy">@shadyyx: No, the vulnerability the article described was about <code>addslashes</code>. I <b>based</b> this vulnerability on that one. Try it yourself. Go get MySQL 5.0, and run this exploit and see for yourself. As far as how to put that into PUT/GET/POST, it's TRIVIAL. Input data are just byte streams. <code>char(0xBF)</code> is just a readable way of generating a byte. I've demoed this vulnerability live in front of multiple conferences. Trust me on this... But if you don't, try it yourself. It works...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@shadyyx: As for passing such funkiness in $_GET... <code>?var=%BF%27+OR+1=1+%2F%2A</code> in the URL, <code>$var = $_GET['var'];</code> in the code, and Bob's your uncle.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">+1 for spanking php devs</span></text><author><a class="comment-user" href="/users/193892/prof-falken" title="14,464 reputation">Prof. Falken</a></author></comment><comment><text><span class="comment-copy">@MarkAmery: On reflection, I think you're right.  If I want to send <code>0xbf27</code> i.e. <code>¿'</code> over a <code>latin1</code> connection then of course the client <b>must</b> still escape it as <code>¿\'</code> i.e. <code>0xbf5c27</code>. However, if the server is decoding received bytes using GBK (i.e. the client was mistaken about the connection's encoding) then it will perceive there to be an unescaped <code>'</code> and cannot have any way of knowing that wasn't the developer's intended SQL. I have updated this answer with what I think had been intended: prior to the bugfix, even correctly setting the client charset wouldn't help!</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">@eggyal I now understand the issue properly (and have reproduced it just for fun). Thank you for your awesome work here. Additional things that may be worth noting: 1. the same attack can be demonstrated against <code>mysqli_real_escape_string</code> (as one would expect); your brief note about MySQLi here could be interpreted by somebody foolish as meaning that MySQLi is immune to this attack, but that's only true if you use parametrized queries. 2. <a href="http://php.net/manual/en/mysqlinfo.concepts.charset.php" rel="nofollow noreferrer">php.net/manual/en/mysqlinfo.concepts.charset.php</a> hints at this attack's existence and describes proper ways to set connection charset for each API.</span></text><author><a class="comment-user" href="/users/1709587/mark-amery" title="32,062 reputation">Mark Amery</a></author></comment><comment><text><span class="comment-copy">I have a feeling that some emphasizings should be removed, and a cool headed TL;DR added, saying that as long as encoding is set properly and single quotes are used, there would be not a single problem.</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">@user1986811 no, other way around. That query is the source of the vulnerability... <b>Never</b> use <code>set names</code>. Instead, <b>always</b> call the proper API method (for mysql_*: <code>mysql_set_charset()</code>)...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">Okay, then I was confused...i´ll delete my stupid comment, thank you <b>very much</b>. one moment...why was that particular under <b>Safe Examples</b></span></text><author><a class="comment-user" href="/users/1986811/top-questions" title="1,092 reputation">Top Questions</a></author></comment><comment><text><span class="comment-copy">Is the charset still an issue? Because on the <code>php-5.6.1</code> tag, the description of <code>mysql_real_escape_strings</code> states that <code>Escape special characters in a string for use in a SQL statement, taking into account the current charset of the connection</code> so I suppose it depends how the "current charset of the connection" is determined.</span></text><author><a class="comment-user" href="/users/51760/aif" title="7,653 reputation">Aif</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<h1>TL;DR</h1>
<p><code>mysql_real_escape_string()</code> will <strong>provide no protection whatsoever</strong> (and could furthermore munge your data) if:</p>
<ul>
<li><p>MySQL's <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode is enabled (which it <em>might</em> be, unless you <em>explicitly</em> select another SQL mode <em>every time you connect</em>); and</p></li>
<li><p>your SQL string literals are quoted using double-quote <code>"</code> characters.</p></li>
</ul>
<p>This was filed as <a href="http://bugs.mysql.com/bug.php?id=72458">bug #72458</a> and has been fixed in MySQL v5.7.6 (see the section headed "<strong>The Saving Grace</strong>", below).</p>
</blockquote>
<h1>This is another, (perhaps less?) obscure EDGE CASE!!!</h1>
<p>In homage to <a href="http://stackoverflow.com/a/12118602">@ircmaxell's excellent answer</a> (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:</p>
<h2>The Attack</h2>
<p>Starting off with a demonstration...</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SET SQL_MODE="NO_BACKSLASH_ESCAPES"'</span><span class="pun">);</span><span class="pln"> </span><span class="com">// could already be set</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">'" OR 1=1 -- '</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = "'</span><span class="pun">.</span><span class="pln">$var</span><span class="pun">.</span><span class="str">'" LIMIT 1'</span><span class="pun">);</span></code></pre>
<p>This will return all records from the <code>test</code> table.  A dissection:</p>
<ol>
<li><p><strong>Selecting an SQL Mode</strong></p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SET SQL_MODE="NO_BACKSLASH_ESCAPES"'</span><span class="pun">);</span></code></pre>
<p>As documented under <a href="http://dev.mysql.com/doc/en/string-literals.html">String Literals</a>:</p>
<blockquote>
<p>There are several ways to include quote characters within a string:</p>
<ul>
<li><p>A “<code>'</code>” inside a string quoted with “<code>'</code>” may be written as “<code>''</code>”.</p></li>
<li><p>A “<code>"</code>” inside a string quoted with “<code>"</code>” may be written as “<code>""</code>”.</p></li>
<li><p>Precede the quote character by an escape character (“<code>\</code>”).</p></li>
<li><p>A “<code>'</code>” inside a string quoted with “<code>"</code>” needs no special treatment and need not be doubled or escaped. In the same way, “<code>"</code>” inside a string quoted with “<code>'</code>” needs no special treatment.</p></li>
</ul>
</blockquote>
<p>If the server's SQL mode includes <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes"><code>NO_BACKSLASH_ESCAPES</code></a>, then the third of these options—which is the usual approach adopted by <code>mysql_real_escape_string()</code>—is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one's data.</p></li>
<li><p><strong>The Payload</strong></p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="str">" OR 1=1 -- </span></code></pre>
<p>The payload initiates this injection quite literally with the <code>"</code> character.  No particular encoding.  No special characters.  No weird bytes.</p></li>
<li><p><strong>mysql_real_escape_string()</strong></p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">'" OR 1=1 -- '</span><span class="pun">);</span></code></pre>
<p>Fortunately, <code>mysql_real_escape_string()</code> does check the SQL mode and adjust its behaviour accordingly.  See <a href="http://bazaar.launchpad.net/%7Emysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267"><code>libmysql.c</code></a>:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">ulong STDCALL
mysql_real_escape_string</span><span class="pun">(</span><span class="pln">MYSQL </span><span class="pun">*</span><span class="pln">mysql</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">to</span><span class="pun">,</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">from</span><span class="pun">,</span><span class="pln">
             ulong length</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mysql</span><span class="pun">-&gt;</span><span class="pln">server_status </span><span class="pun">&amp;</span><span class="pln"> SERVER_STATUS_NO_BACKSLASH_ESCAPES</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> escape_quotes_for_mysql</span><span class="pun">(</span><span class="pln">mysql</span><span class="pun">-&gt;</span><span class="pln">charset</span><span class="pun">,</span><span class="pln"> to</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> from</span><span class="pun">,</span><span class="pln"> length</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> escape_string_for_mysql</span><span class="pun">(</span><span class="pln">mysql</span><span class="pun">-&gt;</span><span class="pln">charset</span><span class="pun">,</span><span class="pln"> to</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> from</span><span class="pun">,</span><span class="pln"> length</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Thus a different underlying function, <code>escape_quotes_for_mysql()</code>, is invoked if the <code>NO_BACKSLASH_ESCAPES</code> SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.</p>
<p>However, this function arbitrarily <em>assumes</em> that the string will be quoted using the single-quote <code>'</code> character.  See <a href="http://bazaar.launchpad.net/%7Emysql/libmysql/1.0/view/head:/mysys/charset.c#L836"><code>charset.c</code></a>:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="com">/*
  Escape apostrophes by doubling them up

// [ deletia 839-845 ]

  DESCRIPTION
    This escapes the contents of a string by doubling up any apostrophes that
    it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in
    effect on the server.

// [ deletia 852-858 ]
*/</span><span class="pln">

</span><span class="typ">size_t</span><span class="pln"> escape_quotes_for_mysql</span><span class="pun">(</span><span class="pln">CHARSET_INFO </span><span class="pun">*</span><span class="pln">charset_info</span><span class="pun">,</span><span class="pln">
                               </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">to</span><span class="pun">,</span><span class="pln"> </span><span class="typ">size_t</span><span class="pln"> to_length</span><span class="pun">,</span><span class="pln">
                               </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">from</span><span class="pun">,</span><span class="pln"> </span><span class="typ">size_t</span><span class="pln"> length</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
</span><span class="com">// [ deletia 865-892 ]</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">from </span><span class="pun">==</span><span class="pln"> </span><span class="str">'\''</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">to </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> to_end</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">{</span><span class="pln">
        overflow</span><span class="pun">=</span><span class="pln"> TRUE</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">*</span><span class="pln">to</span><span class="pun">++=</span><span class="pln"> </span><span class="str">'\''</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">*</span><span class="pln">to</span><span class="pun">++=</span><span class="pln"> </span><span class="str">'\''</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
<p>So, it leaves double-quote <code>"</code> characters untouched (and doubles all single-quote <code>'</code> characters) <em>irrespective of the actual character that is used to quote the literal</em>!  In our case <code>$var</code> remains exactly the same as the argument that was provided to <code>mysql_real_escape_string()</code>—it's as though no escaping has taken place <em>at all</em>.</p></li>
<li><p><strong>The Query</strong></p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = "'</span><span class="pun">.</span><span class="pln">$var</span><span class="pun">.</span><span class="str">'" LIMIT 1'</span><span class="pun">);</span></code></pre>
<p>Something of a formality, the rendered query is:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">SELECT</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">FROM</span><span class="pln"> test </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pln"> </span><span class="kwd">OR</span><span class="pln"> </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> </span><span class="com">-- " LIMIT 1</span></code></pre></li>
</ol>
<p>As my learned friend put it: congratulations, you just successfully attacked a program using <code>mysql_real_escape_string()</code>...</p>
<h2>The Bad</h2>
<p><a href="http://www.php.net/manual/en/function.mysql-set-charset.php"><code>mysql_set_charset()</code></a> cannot help, as this has nothing to do with character sets; nor can <a href="http://www.php.net/manual/en/mysqli.real-escape-string.php"><code>mysqli::real_escape_string()</code></a>, since that's just a different wrapper around this same function.</p>
<p>The problem, if not already obvious, is that the call to <code>mysql_real_escape_string()</code> <strong>cannot know</strong> with which character the literal will be quoted, as that's left to the developer to decide at a later time.  So, in <code>NO_BACKSLASH_ESCAPES</code> mode, there is literally <em>no way</em> that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).</p>
<h2>The Ugly</h2>
<p>It gets worse.  <code>NO_BACKSLASH_ESCAPES</code> may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the <a href="http://www.contrib.andrew.cmu.edu/%7Eshadow/sql/sql1992.txt">SQL-92 specification</a>, namely the <code>&lt;quote symbol&gt; ::= &lt;quote&gt;&lt;quote&gt;</code> grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly <a href="http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html">recommended as a workaround</a> to the (long since fixed) <a href="http://bugs.mysql.com/bug.php?id=8378">bug</a> that ircmaxell's post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like <a href="http://www.php.net/manual/en/function.addslashes.php"><code>addslashes()</code></a>.</p>
<p>Also, the <a href="http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting">SQL mode of a new connection</a> is set by the server according to its configuration (which a <code>SUPER</code> user can change at any time); thus, to be certain of the server's behaviour, you must <em>always</em> explicitly specify your desired mode after connecting.</p>
<h2>The Saving Grace</h2>
<p>So long as you always <em>explicitly</em> set the SQL mode not to include <code>NO_BACKSLASH_ESCAPES</code>, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively <code>escape_quotes_for_mysql()</code> will not be used, or its assumption about which quote characters require repeating will be correct.</p>
<p>For this reason, I recommend that anyone using <code>NO_BACKSLASH_ESCAPES</code> also enables <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes"><code>ANSI_QUOTES</code></a> mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be used—it merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).</p>
<p>In PDO, both its equivalent function <a href="http://www.php.net/manual/en/pdo.quote.php"><code>PDO::quote()</code></a> and its prepared statement emulator call upon <a href="https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302"><code>mysql_handle_quoter()</code></a>—which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.</p>
<p>As of MySQL v5.7.6, this bug has been fixed.  See <a href="http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html">change log</a>:</p>
<blockquote>
<h3>Functionality Added or Changed</h3>
<ul>
<li><p><strong><em>Incompatible Change:</em></strong> A new C API function, <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html"><code>mysql_real_escape_string_quote()</code></a>, has been implemented as a replacement for <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html"><code>mysql_real_escape_string()</code></a> because the latter function can fail to properly encode characters when the <a href="http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode is enabled. In this case, <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html"><code>mysql_real_escape_string()</code></a> cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html"><code>mysql_real_escape_string_quote()</code></a> takes an extra argument for specifying the quoting context. For usage details, see <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html">mysql_real_escape_string_quote()</a>.</p>
<blockquote>
<h3> Note</h3>
<p>Applications should be modified to use <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html"><code>mysql_real_escape_string_quote()</code></a>, instead of <a href="http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html"><code>mysql_real_escape_string()</code></a>, which now fails and produces an <a href="http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err"><code>CR_INSECURE_API_ERR</code></a> error if <a href="http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes"><code>NO_BACKSLASH_ESCAPES</code></a> is enabled.</p>
</blockquote>
<p>References: See also Bug #19211994.</p></li>
</ul>
</blockquote>
<h2>Safe Examples</h2>
<p>Taken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_set_charset</span><span class="pun">(</span><span class="pln">$charset</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SET SQL_MODE=''"</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">'" OR 1=1 /*'</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = "'</span><span class="pun">.</span><span class="pln">$var</span><span class="pun">.</span><span class="str">'" LIMIT 1'</span><span class="pun">);</span></code></pre>
<p>...because we've explicitly selected an SQL mode that doesn't include <code>NO_BACKSLASH_ESCAPES</code>.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_set_charset</span><span class="pun">(</span><span class="pln">$charset</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"' OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = '$var' LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>...because we're quoting our string literal with single-quotes.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">([</span><span class="str">"' OR 1=1 /*"</span><span class="pun">]);</span></code></pre>
<p>...because PDO prepared statements are immune from this vulnerability (and ircmaxell's too, provided either that you're using PHP≥5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$var  </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">quote</span><span class="pun">(</span><span class="str">"' OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = $var LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>...because PDO's <code>quote()</code> function not only escapes the literal, but also quotes it (in single-quote <code>'</code> characters); note that to avoid ircmaxell's bug in this case, you <em>must</em> be using PHP≥5.3.6 <em>and</em> have correctly set the character set in the DSN.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$param </span><span class="pun">=</span><span class="pln"> </span><span class="str">"' OR 1=1 /*"</span><span class="pun">;</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">'s'</span><span class="pun">,</span><span class="pln"> $param</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<p>...because MySQLi prepared statements are safe.</p>
<h2>Wrapping Up</h2>
<p>Thus, if you:</p>
<ul>
<li>use native prepared statements</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>use MySQL v5.7.6 or later</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li><p>in <em>addition</em> to employing one of the solutions in ircmaxell's summary, use at least one of:</p>
<ul>
<li>PDO;</li>
<li>single-quoted string literals; or</li>
<li>an explicitly set SQL mode that does not include <code>NO_BACKSLASH_ESCAPES</code></li>
</ul></li>
</ul>
<p>...then you <em>should</em> be completely safe (vulnerabilities outside the scope of string escaping aside).</p>
</div></text><author><a href="/users/623041/eggyal">eggyal</a></author><comments><comment><text><span class="comment-copy">So, TL;DR would be like "there is a NO_BACKSLASH_ESCAPES mysql server mode which can cause an injection if you aren't using single quotes.</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense: Yes, thank you!  I will add that.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">I'm not able to access <a href="http://bugs.mysql.com/bug.php?id=72458" rel="nofollow noreferrer">bugs.mysql.com/bug.php?id=72458</a>; I just get an access denied page. Is it being hidden from the public due to being a security issue? Also, do I understand correctly from this answer that you are the discoverer of the vulnerability? If so, congratulations.</span></text><author><a class="comment-user" href="/users/1709587/mark-amery" title="32,062 reputation">Mark Amery</a></author></comment><comment><text><span class="comment-copy">@MarkAmery: Er, I think the answer to both of those questions is "yes" - although I suspect many won't consider this to be a vulnerability <i>per se</i>, but rather a design flaw in separating escaping from quoting.  In the bug report I have proposed a fix, but as it changes the protocol (albeit in a safe way) I don't know whether the fix will be adopted.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">People shouldn't be using <code>"</code> for strings in the first place.  SQL says that's for identifiers.  But eh...just another example of MySQL saying "screw standards, i'll do whatever i want".  (Fortunately, you can include <code>ANSI_QUOTES</code> in the mode to fix the quoting brokenness.  The open disregard of standards, though, is a bigger issue that might require more severe measures.)</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@eggyal, is using PDO sufficient, or is it necessary to use PDO prepared statements?  Consider this in php/PDO: $sql="select * from product_master where abbr='".$_GET['prod']."'";// order by skey limit ".mt_rand(1,10).", 10"; $stmt = $pdo-&gt;query($sql);  That would be wide open to injection, with no protection on the $_GET. No?  Also, use of single quotes needs to be supported with mysqli_real_escape_string, is that right? If these questions seem too obvious, my problem is that I am reading the answer and I am not certain it says these things flat out. I can see the examples show this.</span></text><author><a class="comment-user" href="/users/1569275/danallen" title="81 reputation">DanAllen</a></author></comment><comment><text><span class="comment-copy">@DanAllen: my answer was a little broader, in that you <i>can</i> avoid <i>this particular</i> bug through PDO's <code>quote()</code> function—but prepared statements are a much safer and more appropriate way to avoid injection generally.  Of course, if you have directly concatenated unescaped variables into your SQL then you are most certainly vulnerable to injection no matter what methods you use thereafter.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">@eggyall: Our system relies on the 2nd safe example above. There are errors, where mysql_real_escape_string has been omitted. Fixing those in an emergency mode seems to be the prudent path, hoping we don't get nuked before the corrections.  My rationale is converting to prepared statements will be a much longer process that will have to come after. Is the reason prepared statements is safer the fact that errors don't create vulnerabilities? In other words, is correctly implemented 2nd example above is  just as safe as prepared statements?</span></text><author><a class="comment-user" href="/users/1569275/danallen" title="81 reputation">DanAllen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Well, there's nothing really that can pass through that, other than <code>%</code> wildcard. It could be dangerous if you were using <code>LIKE</code> statement as attacker could put just <code>%</code> as login if you don't filter that out, and would have to just bruteforce a password of any of your users.
People often suggest using prepared statements to make it 100% safe, as data can't interfere with the query itself that way.
But for such simple queries it probably would be more efficient to do something like <code>$login = preg_replace('/[^a-zA-Z0-9_]/', '', $login);</code></p>
</div></text><author><a href="/users/598472/slava">Slava</a></author><comments><comment><text><span class="comment-copy">+1, but the wildcards are for LIKE clause, not simple equality.</span></text><author><a class="comment-user" href="/users/207812/dor" title="4,749 reputation">Dor</a></author></comment><comment><text><span class="comment-copy">By what measure do you consider a simple replacement <code>more efficient</code> than using prepared statements?  (Prepared statements always work, the library can be quickly corrected in case of attacks, doesn't expose human error [such as mis-typing the complete replace string], and have significant performance benefits if the statement is re-used.)</span></text><author><a class="comment-user" href="/users/53341/matbailie" title="48,241 reputation">MatBailie</a></author></comment><comment><text><span class="comment-copy">@Slava: You're effectively limiting usernames and passwords to word chars only.  Most people who know anything about security would consider that a bad idea, as it shrinks the search space considerably.  Course they'd also consider it a bad idea to store cleartext passwords in the database, but we don't need to be compounding the problem.  :)</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@cHao, my suggestion concerns only logins. Obviously you don't need to filter passwords, sorry it isn't clearly stated in my answer. But actually that might be good idea. Using "stone ignorant tree space" instead of hard-to-remember-and-type "a4üua3!@v\"ä90;8f" would be much harder to bruteforce. Even using a dictionary of, say 3000 words to help you, knowing you used exactly 4 words - that would still be roughly 3.3*10^12 combinations. :)</span></text><author><a class="comment-user" href="/users/598472/slava" title="1,711 reputation">Slava</a></author></comment><comment><text><span class="comment-copy">@Slava: I've seen that idea before; see <a href="http://xkcd.com/936/" rel="nofollow noreferrer">xkcd.com/936</a> .  Problem is, the math doesn't quite bear it out.  Your example 17-char password would have like 96^17 possibilities, and that's if you forgot the umlauts and limited yourself to printable ASCII.  That's about 4.5x10^33.  We're talking literally <i>a billion trillion times</i> more work to brute force.  Even an 8-char ASCII password would have 7.2x10^15 possibilities -- 3 thousand times more.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@cHao, sorry to go on with this holy war here, but still... Let's say you're pretty good on resources and can try 100 million passwords/sec. Using 3k-words dictionary and knowing there are 4 words trying 3.3 trillion passwords would take you about 23 days. That will be enough for host to notice stolen DB and change your password. Safe enough. You can make that many times harder by alternating lower/upper-case letters. And all this assuming attacker knows there are exactly 4 words, which is unlikely.</span></text><author><a class="comment-user" href="/users/598472/slava" title="1,711 reputation">Slava</a></author></comment><comment><text><span class="comment-copy">And if you use self-made words, leaving attacker with need to try by char... 22 chars with 6 bits/char (lower-upper case, dashes, etc. = roughly 64) ~= 5.4 duodecillion = years</span></text><author><a class="comment-user" href="/users/598472/slava" title="1,711 reputation">Slava</a></author></comment><comment><text><span class="comment-copy">@Slava: Most site owners hardly even realize there are server logs, much less read through them. And a non-idiot attacker wouldn't <i>steal</i> the data, but simply <i>copy</i> it...leaving the site functional and your average owner not even realizing there was an intrusion (and thus, not knowing to reset passwords), giving the attacker lots of time to crack the easy phrases. Human nature effectively guarantees there will be easy phrases, especially if dictionary words are allowed. And without dictionary words, all you've done is require a 20+-character password, which the users would hate you for.  :)</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">Users just want to get shit done.  Security directly opposes that in most cases, and you can safely assume it will be avoided or subverted by any means possible.  People aren't going to pick a half dozen random imaginary words; they're going to pick a short line/sentence/catchphrase from their favorite book or movie or whatever, making the phrase much, much more predictable.  In order to prevent them from doing such things, you'd basically have to make the server understand English and/or search a database of most known artistic works for the phrase used.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment></comments></answer></answers></post>