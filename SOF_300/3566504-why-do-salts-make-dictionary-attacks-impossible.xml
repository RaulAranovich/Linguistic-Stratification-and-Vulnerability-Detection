<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Why do salts make dictionary attacks 'impossible'? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="http://stackoverflow.com/questions/420843/need-some-help-understanding-password-salt">Need some help understanding password salt</a> </p>
</blockquote>
<p><strong>Update: Please note I am not asking what a salt is, what a rainbow table is, what a dictionary attack is, or what the purpose of a salt is. I am querying: If you know the users salt and hash, isn't it quite easy to calculate their password?</strong></p>
<p>I understand the process, and implement it myself in some of my projects.</p>
<pre><code>s =  random salt
storedPassword = sha1(password + s)
</code></pre>
<p>In the database you store:</p>
<pre><code>username | hashed_password | salt
</code></pre>
<p>Every implementation of salting I have seen adds the salt either at the end of the password, or beginning:</p>
<pre><code>hashed_Password = sha1(s + password )
hashed_Password = sha1(password + s)
</code></pre>
<p>Therfore, a dictionary attack from a hacker who is worth his salt (ha ha) would simply run each keyword against the stored salts in the common combinations listed above.</p>
<p>Surely the implementation described above simply adds another step for the hacker, without actually solving the underlying issue?  What alternatives are there to step around this issue, or am I misunderstanding the problem?</p>
<p>The only thing I can think to do is have a secret blending algorithm that laces the salt and password together in a random pattern, or adds other user fields to the hashing process meaning the hacker would have to have access to the database AND code to lace them for a dictionary attack to prove fruitful. (Update, as pointed out in comments it's best to assume the hacker has access to all your information so this probably isn't best).</p>
<p>Let me give an example of how I propose a hacker would hack a user database with a list of passwords and hashes:</p>
<p>Data from our hacked database:</p>
<pre><code>RawPassword (not stored)  |  Hashed   |     Salt
--------------------------------------------------------
letmein                       WEFLS...       WEFOJFOFO...
</code></pre>
<p>Common password dictionary:</p>
<pre><code>   Common Password
   --------------
   letmein
   12345
   ...
</code></pre>
<p>For each user record, loop the common passwords and hash them:</p>
<pre><code>for each user in hacked_DB

    salt = users_salt
    hashed_pw = users_hashed_password

    for each common_password

        testhash = sha1(common_password + salt)
        if testhash = hashed_pw then
           //Match!  Users password = common_password
           //Lets visit the webpage and login now.
        end if

    next

next
</code></pre>
<p>I hope this illustrates my point a lot better.</p>
<p>Given 10,000 common passwords, and 10,000 user records, we would need to calculate 100,000,000 hashes to discover as many user passwords as possible.  It might take a few hours, but it's not really an issue.</p>
<p><strong>Update on Cracking Theory</strong></p>
<p>We will assume we are a corrupt webhost, that has access to a database of SHA1 hashes and salts, along with your algorithm to blend them.  The database has 10,000 user records.</p>
<p><a href="http://www.golubev.com/hashgpu.htm" rel="nofollow noreferrer">This site</a> claims to be able to calculate 2,300,000,000 SHA1 hashes per second using the GPU.  (In real world situation probably will be slower, but for now we will use that quoted figure).</p>
<blockquote>
<p>(((95^4)/2300000000)/2)*10000 = 177
  seconds</p>
</blockquote>
<p>Given a full range of 95 printable ASCII characters, with a maximum length of 4 characters, divided by the rate of calculation (variable), divided by 2 (assuming the average time to discover password will on average require 50% of permutations) for 10,000 users it would take 177 seconds to work out all users passwords where the length is &lt;= 4.</p>
<p>Let's adjust it a bit for realism.</p>
<blockquote>
<p>(((36^7)/1000000000)/2)*10000 = 2 days</p>
</blockquote>
<p>Assuming non case sensitivity, with a password length &lt;= 7, only alphanumeric chars, it would take 4 days to solve for 10,000 user records, and I've halved the speed of the algorithm to reflect overhead and non ideal circumstance.</p>
<p>It is important to recognise that this is a linear brute force attack, all calculations are independant of one another, therfore it's a perfect task for multiple systems to solve.  (IE easy to set up 2 computers running attack from different ends that would half the exectution time).</p>
<p>Given the case of recursively hashing a password 1,000 times to make this task more computationally expensive:</p>
<blockquote>
<p>(((36^7) / 1 000 000 000) / 2) * 1000
  seconds = 10.8839117 hours</p>
</blockquote>
<p>This represents a maximum length of 7 alpha-numeric characters, at a less than half speed execution from quoted figure for <em>one user</em>.</p>
<p>Recursively hashing 1,000 times effectively blocks a blanket attack, but targetted attacks on user data are still vulnerable.</p>
</div></text><author><a href="/users/2246344/sam">Sam</a></author><comments><comment><text><span class="comment-copy">The whole point in salting is to prevent you from being able to look at the hashed password and see that multiple users have the same hash (and thus the same password). Without salting you could just use the hashing algorithm and generate every possible hash and then do a brute search for that hash. Since the algorithm never changes it makes it predictable for attackers, salting just makes it that much more difficult.</span></text><author><a class="comment-user" href="/users/405906/berecursive" title="5,160 reputation">BeRecursive</a></author></comment><comment><text><span class="comment-copy">here it is discussed in detail : <a href="http://stackoverflow.com/questions/420843/need-some-help-understanding-password-salt" title="need some help understanding password salt">stackoverflow.com/questions/420843/…</a></span></text><author><a class="comment-user" href="/users/419497/tarrasch" title="633 reputation">tarrasch</a></author></comment><comment><text><span class="comment-copy">Thanks @be, I suppose the point I am trying to make is that it is presented as an extremely secure method when actually it isn't, it just obscures the data enough to make the hackers job a little more irritating</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Yes but if you use a complicated enough hashing algorithm with a good pseudo random salt then you can push the complexity of solving the problem into the realms of physical impossibility on any modern/future hardware. 2^128 is a really big number!</span></text><author><a class="comment-user" href="/users/405906/berecursive" title="5,160 reputation">BeRecursive</a></author></comment><comment><text><span class="comment-copy">If a hacker has access to the salt + the hashed password, they simply run all the salt + dictionary password combinations, for n dictionary passwords you need to perform n hashing calculations per user account, a lot more computationally expensive, but perfectly easy for a laptop to perform over a few hours or so.  I'm not sure if my question is clear enough?</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Because crackers are like slugs, and the salt dries up the mucous on their skin and kills them.</span></text><author><a class="comment-user" href="/users/29639/t-e-d" title="32,560 reputation">T.E.D.</a></author></comment><comment><text><span class="comment-copy">@T.E.D.: I rather like salted crackers. Salted slugs, not so much.</span></text><author><a class="comment-user" href="/users/192801/frustratedwithformsdesigner" title="18,935 reputation">FrustratedWithFormsDesigner</a></author></comment><comment><text><span class="comment-copy">@Tom - in your example attack. If there isn't salt, then the attacker can do "for each common password, hash the password. Does this match one or more users? Yes, I have their password" - the attacker is able to attack all passwords "in parallel", at no extra cost.</span></text><author><a class="comment-user" href="/users/15498/damien-the-unbeliever" title="157,270 reputation">Damien_The_Unbeliever</a></author></comment><comment><text><span class="comment-copy">@Tom Gullen - you only have half the picture. Without salt, an attacker wouldn't use the method you demonstrate in "Update 2". He'd simply do a lookup in a table and get the password in O(1) or O(log n) time (n being the number of candidate passwords). <i>Salt</i> is what prevents that and forces him to use the O(n) approach you demonstrate. Another technique (key-strengthening) can cause each attempt in your loop to take a full second, meaning that it will take 3 <b>years</b> to perform those tests... and with only 10k passwords, you're likely to crack zero passwords in that time.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">I didn't realize you were assuming the salt had been compromised as well. Whilst technically you are correct the real issue is that the hacker has compromised the entire database before we begin. This is a much larger issue than the fact he can crack common passwords in 3 days ;) Salting is not meant to prevent what you are talking about, but instead to prevent the hacker from gaining access to every password in your database in one go. It is - as is every form of encryption - merely a method to INCONVENIENCE the attacker</span></text><author><a class="comment-user" href="/users/405906/berecursive" title="5,160 reputation">BeRecursive</a></author></comment><comment><text><span class="comment-copy">@erickson key stengthening is another good point. Make the hashing algorithm computationally expensive and you again make cracking less likely.</span></text><author><a class="comment-user" href="/users/405906/berecursive" title="5,160 reputation">BeRecursive</a></author></comment><comment><text><span class="comment-copy">Thank you, when in the real world has a list of passwords been hacked without having access to the salt values?  It might be more common than I assume, just wondering.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Thank you also erickson, do you mean rehashing the result say 100 times to make it computationally expensive?  Or using a heavier hash algorithm?  I could see that working well, but no article or guide I have read online has ever suggested that.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@Tom Gullen - I mean re-hashing the result say 2000 times (you have to consider that an attacker is going to use something fast, not PHP), so that it takes a good fraction of a second to compute the hash for a single password. This is found in the standard key derivation algorithms PBKDF1 and PBKDF2, from PKCS #5, which make great password obfuscation algorithms (the "derived key" is the "hash"). A lot of users on SO refer to <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">this article</a> because it was a response to Jeff Atwood.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">@Tom: Generally, always assume that both your code and your database may become public knowledge. This means that having a secret way of blending the salt with the password, as you mention, is a bad idea, in essence being security by obscurity. Not that I see you advertising for it, but I would just mention it for clarification.</span></text><author><a class="comment-user" href="/users/96061/boris" title="3,224 reputation">Boris</a></author></comment><comment><text><span class="comment-copy">BTW, of course you assume the attacker has everything. Assume the attacker is a corrupt hosting company employee who dumped the user table on your myprettypony.com fansite so that he can recover passwords and see if they work on people's citibank.com accounts. With a well-designed password scheme, it will be <i>impossible</i> for this guy to recover any passwords.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">Thanks Boris, but lots of security is security through obscurity isn't it?  That's essentially what a hash is?</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@Erickson thanks for clarification, you should put it in an answer it's exactly what I was after.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@Erickson, excellent article thanks for the link</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">See also: <a href="http://stackoverflow.com/questions/213380/the-necessity-of-hiding-the-salt-for-a-hash" title="the necessity of hiding the salt for a hash">stackoverflow.com/questions/213380/…</a> and <a href="http://stackoverflow.com/questions/1645161/salt-generation-and-open-source-software/1645190#1645190" title="salt generation and open source software">stackoverflow.com/questions/1645161/…</a> and <a href="http://stackoverflow.com/questions/536584/non-random-salt-for-password-hashes/536756#536756" title="non random salt for password hashes">stackoverflow.com/questions/536584/…</a></span></text><author><span class="comment-user">user195488</span></author></comment><comment><text><span class="comment-copy">@Tom: Concerning security through obscurity: No, it's not. Security Through Obscurity is using a weak method and assuming you can prevent people from learning what that method <i>is</i>. The point of salt is to drive the mean cost (in time, processing power, disk space, electric bills, whatever) of the attack higher than the expected value to be gained by success or to push the expected time to success far enough into the future that it does not matter (say, beyond the next mandatory password change).</span></text><author><a class="comment-user" href="/users/2509/dmckee" title="69,581 reputation">dmckee</a></author></comment><comment><text><span class="comment-copy">@dmckee, thanks but I was under the impression the definition of security through obscurity doesn't cover the 'weakness' of the solution?  IE, it's not by definition necesserially weak.  Your point about it meaning  a secret method is correct though, my point is for example, is public key encryption STO because you method is combining a 'secret key'?</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">I've updated the question with some figures on crack times for various scenarios, so far I have learnt that recursive hashing protects about blanket cracks and I hope I have proved that, but the interesting question now is how can we protect from targetted attacks?  This comes down to the user, and if you require a 9 character password with a special char, and case sensitivity you will be looking at (((95^9) / 1000000000) / 2) * 1000 seconds in years = 10,000 years to crack.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Sorry, but this question is not a duplicate, so I've voted to reopen.  A lot of the responses seem to describe what a salt is, why it's there, which doesn't address the question.  This question is more specific than that.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Plus we are generating interesting discussion so it would be nice to keep it open!</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy"><i>"Avoid asking questions that [...] require extended discussion."</i> -- <a href="http://stackoverflow.com/faq">The FAQ</a></span></text><author><a class="comment-user" href="/users/2509/dmckee" title="69,581 reputation">dmckee</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Yes, you need just 3 days for sha1(salt | password). That's why good password storage algorithms use 1000-iteration hashing: you will need 8 years.</p>
</div></text><author><a href="/users/417166/blaze">blaze</a></author><comments><comment><text><span class="comment-copy">+1, most concise and to the point answer so far, I wasn't aware this was an option.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Apparently you've never done a hash benchmark on your system.  You can do <b>MANY MILLIONS</b> of sha1 calculations per seconds.  A 1,000 rounds is meaningless to an attacker.  Also -1  because sha1 is a broken hash function.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Apparently I'm using names and numbers from question. If you ever heard about such thing as topic and clarity... oh, it's Rook. Never mind.</span></text><author><a class="comment-user" href="/users/417166/blaze" title="3,324 reputation">blaze</a></author></comment><comment><text><span class="comment-copy">@Rook, 1,000 rounds means it will take 1,000 times longer to brute force.  Seems like a good feature to me.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">if an attacker can guess a password, is this the same for login (or something escaped to me ? lol)</span></text><author><a class="comment-user" href="/users/1376051/khaled-webdev" title="1,202 reputation">khaled_webdev</a></author></comment><comment><text><span class="comment-copy">Note that in the 2013/2014 timeframe, PBKDF2 iteration counts should be in the tens of thousands to hundreds of thousands, not just 1000 (WPA2 itself is merely 4096 iterations of PBKDF2-HMAC-SHA-1).</span></text><author><a class="comment-user" href="/users/1967612/anti-weakpasswords" title="1,725 reputation">Anti-weakpasswords</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It doesn't stop dictionary attacks.</p>
<p>What it does is stop someone who manages to get a copy of your password file from using a <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="noreferrer">rainbow table</a> to figure out what the passwords are from the hashes.</p>
<p>Eventually, it can be brute-forced, though.  The answer to that part is to force your users to not use dictionary words as passwords (minimum requirements of at least one number or special character, for example).</p>
<p><strong>Update</strong>:</p>
<p>I should have mentioned this earlier, but some (most?) password systems use a different salt for each password, likely stored with the password itself.  This makes a single rainbow table useless.  This is how the UNIX <a href="http://en.wikipedia.org/wiki/Crypt_%28Unix%29" rel="noreferrer">crypt</a> library works, and modern UNIX-like OSes have extended this library with new hash algorithms.</p>
<p>I know for a fact that support for SHA-256 and SHA-512 were added in newer versions of GNU crypt.</p>
</div></text><author><a href="/users/15880/powerlord">Powerlord</a></author><comments><comment><text><span class="comment-copy">+1 Salt prevents pre-computed lists of hashes (rainbow tables) from being useful. The attacker must start all over again.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment><comment><text><span class="comment-copy">@Tom: then it's not a rainbow table anymore, it's just a password list.  the entire value of a rainbow table is that someone spent a lot of computation time calculating the hashes, so you can reverse them instantly.</span></text><author><a class="comment-user" href="/users/10861/rmeador" title="18,301 reputation">rmeador</a></author></comment><comment><text><span class="comment-copy">@rmeador thanks, but my point is that the salt doesn't really solve anything because using a password list is perfectly feasable</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@Tom: the point is brute forcing isn't feasible if you use a good hash algorithm and reasonably complex passwords.  SHA1 may not be a good choice for a password hash algorithm because it is designed to be fast.  You want something designed to be slow.  Sadly, I can't find the article I read recently on this, but I believe blowfish was one of the recommended algorithms.</span></text><author><a class="comment-user" href="/users/10861/rmeador" title="18,301 reputation">rmeador</a></author></comment><comment><text><span class="comment-copy">Thanks for your comments, it's an interesting topic.  Every article and guide I have read suggests to just md5/sha the salt + password, and leave it at that consider it secure.  Are these articles just out of date or not written by people thinking about the problem enough?</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">In PHP, you can use the mcrypt or bcrypt libraries for better encryption than md5 or sha1. If you're stuck with md5 or sha1 you should to 'stretching', where you hash the password 1000's of times before you arrive at whatever is stored in the database. This keeps the entropy the same, but increases the time to compute the hash.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Tom Gullen, what articles are you reading? Self-professed experts or peer reviewed articles in a scientific journal?</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">No, but your average Joe developer is just going to read a tutorial from any of the thousands of developer help guides out there.  I think it's unfair to expect people to read scientific journals on network security when writing a login script for their blog or whatever small site they are developing.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">And it's your average Joe developer making those blog/help posts on how to write a "secure" system. Security isn't something you can pick up on the side, it requires extensive knowledge. Is it unfair? Probably. Is it safe? To a degree. There are reasons there are security experts. But then again, not everything has to be as secure as Fort Knox. The best policy here is to use a prebuilt system designed by those experts, and modify it to meet your needs.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@rmeador: This is why GNU crypt makes multiple passes with it.  I know it was 1000 for MD5, I'm not sure how many it is for newer algorithms.</span></text><author><a class="comment-user" href="/users/15880/powerlord" title="63,907 reputation">Powerlord</a></author></comment><comment><text><span class="comment-copy">@R. Bemrose: exactly, you can use that technique for key strengthening, or you can use an algorithm that is inherently slow.  I found an article (not the one I read originally) on how blowfish is used this way, since it has a peculiar property that changing keys is very slow.  <a href="http://www.openwall.com/crypt/" rel="nofollow noreferrer">openwall.com/crypt</a></span></text><author><a class="comment-user" href="/users/10861/rmeador" title="18,301 reputation">rmeador</a></author></comment><comment><text><span class="comment-copy">I think it's important to note that prebuilt systems are exposed on-mass to discovered flaws in their architecture or supporting architecture, although I completely agree that they are highly advisable.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Why does a salt make rainbow tables useless?</span></text><author><a class="comment-user" href="/users/20471/joe-phillips" title="23,899 reputation">Joe Phillips</a></author></comment><comment><text><span class="comment-copy">@Joe: rainbow tables are precompiled tables.  If you use a salt, generally there won't be a rainbow table with that particular salt value.</span></text><author><a class="comment-user" href="/users/15880/powerlord" title="63,907 reputation">Powerlord</a></author></comment><comment><text><span class="comment-copy">@R. Bemrose Why wouldn't there be a rainbow table with that particular salt value? Doesn't that completely rely on what you use as a salt? The current explanation is not sitting well with me because I feel like there are a LOT of assumptions</span></text><author><a class="comment-user" href="/users/20471/joe-phillips" title="23,899 reputation">Joe Phillips</a></author></comment><comment><text><span class="comment-copy">@Joe: Because a salt can be practically anything.  Jeff Atwood talks about it a bit on his blog: <a href="http://www.codinghorror.com/blog/2007/09/rainbow-hash-cracking.html" rel="nofollow noreferrer">codinghorror.com/blog/2007/09/rainbow-hash-cracking.html</a></span></text><author><a class="comment-user" href="/users/15880/powerlord" title="63,907 reputation">Powerlord</a></author></comment><comment><text><span class="comment-copy">@R. Bemrose So I believe what you're saying is that the benefit that a salt provides is simply to lengthen the password. In which case, having a salt of 'a' is going to be nearly useless?</span></text><author><a class="comment-user" href="/users/20471/joe-phillips" title="23,899 reputation">Joe Phillips</a></author></comment><comment><text><span class="comment-copy">Ok, I see now. If a password is salted and you don't know the salt, then you would have to do a lot of educated guessing to figure out what the password is because SHA1(stored salt + user entered password) == stored hash. But I would think that if you're able to get the stored hash then you could also easily get the salt. This just doesn't seem anywhere close to impossible to me. And what's to stop you from generating rainbow tables for large strings?</span></text><author><a class="comment-user" href="/users/20471/joe-phillips" title="23,899 reputation">Joe Phillips</a></author></comment><comment><text><span class="comment-copy">@Joe: With large enough salts, the size of the rainbow tables makes it infeasible to use them for current or future hardware.</span></text><author><a class="comment-user" href="/users/374341/colin-declue" title="1,143 reputation">Colin DeClue</a></author></comment><comment><text><span class="comment-copy">@Colin In that case I think it is an important distinction to make. Size plays an important part (depending on your salting algorithm)</span></text><author><a class="comment-user" href="/users/20471/joe-phillips" title="23,899 reputation">Joe Phillips</a></author></comment><comment><text><span class="comment-copy">Salt size has absolutely nothing to do with it. The point is to modify the user's password to be something that won't show up in a rainbow table. The rainbow table might have every dictionary word in it. If the user uses the password "apple", it's going to show up in the table. If you salt with "a" to make their password "aapple", now it doesn't show up in the table. It's not any more difficult to make a custom table for the salt "a" than it is for a 30-character salt</span></text><author><a class="comment-user" href="/users/309308/michael-mrozek" title="80,637 reputation">Michael Mrozek</a></author></comment><comment><text><span class="comment-copy">@Michael: With a longer salt, you need to precompute all possible salt values, for it to show up in the rainbow table. The point is you don't keep the same salt for all passwords, you choose it randomly for each password, and store it in the database next to the stored hashed-salted password. So, a hacker would need an entry in the rainbow table for each possible large-valued salt, causing the table to be too large to be feasible, which is the point.</span></text><author><a class="comment-user" href="/users/374341/colin-declue" title="1,143 reputation">Colin DeClue</a></author></comment><comment><text><span class="comment-copy">@Michael: It is enormously more difficult to make a table for all 30 character salts than it is for all single character salts. Salt size is critical.</span></text><author><a class="comment-user" href="/users/238704/james-k-polk" title="22,870 reputation">James K Polk</a></author></comment><comment><text><span class="comment-copy">@GregS: Just as a real-world example, PCI does not require a salt length only that there is a salt. It can be generated with <code>srand (time(NULL));</code> for instance.</span></text><author><span class="comment-user">user195488</span></author></comment><comment><text><span class="comment-copy">@0A0D: So? I certainly don't consider PCI to be the first or final word in security.</span></text><author><a class="comment-user" href="/users/238704/james-k-polk" title="22,870 reputation">James K Polk</a></author></comment><comment><text><span class="comment-copy">@GregS: My point is that significant enforcers of security do not consider salt length to be important, just that it is added.</span></text><author><span class="comment-user">user195488</span></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To be more precise, a <a href="http://en.wikipedia.org/wiki/Dictionary_attack" rel="nofollow noreferrer">dictionary attack</a>, i.e. an attack where all words in an exhaustive list are tried, gets not "impossible", but it gets <strong>impractical</strong>: <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="nofollow noreferrer">each bit of salt doubles the amount of storage and computation required</a>. </p>
<p>This is different from pre-computed dictionary attacks like attacks involving rainbow tables where it does not matter whether the salt is secret or not.</p>
<p>Example: With a 64-bit salt (i.e. 8 bytes) you need to check 2<sup>64</sup> additional password combinations in your dictionary attack. With a dictionary containing 200,000 words you will have to make</p>
<blockquote>
<p>200,000 * 2<sup>64</sup> = 3.69 * 10<sup>24</sup></p>
</blockquote>
<p>tests in the worst case - instead of 200,000 tests without salt.</p>
<p>An additional benefit of using salt is that an attacker cannot pre-compute the password hashes from his dictionary. It would simply take too much time and/or space.</p>
<p><strong>Update</strong></p>
<p>Your update assumes that an attacker already knows the salt (or has stolen it). This is of course a different situation. Still it is not possible for the attacker to use a pre-computed rainbow table. What matters here a lot is the speed of the hashing function. To make an attack impractical, the hashing function needs to be slow. MD5 or SHA are not good candidates here because they are designed to be fast, better candidates for hashing algorithms are Blowfish or some variations of it.</p>
<p><strong>Update 2</strong></p>
<p>A good read on the matter of securing your password hashes in general (going much beyond the original question but still interesting):</p>
<blockquote>
<p><strong><a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</a></strong></p>
</blockquote>
<p>Corollary of the article: Use salted hashes created with <strong>bcrypt</strong> (based on Blowfish) or <strong>Eksblowfish</strong> that allows you to use a configurable setup time to make hashing slow.</p>
</div></text><author><a href="/users/40347/dirk-vollmar">Dirk Vollmar</a></author><comments><comment><text><span class="comment-copy">I would argue that it doesn't become impractical, only trivially more difficult, as a dictionary of a size of thousands of passwords against tens of thousands user records is perfectly calculable on a normal desktop computer.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@Tom Gullen - With proper password choice policies (at least nine characters, including numbers, mixed case, and symbols), you won't crack many accounts by trying a few thousand passwords.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">With proper password choice policies you don't need a salt at all would we?  Maybe I misunderstand the problem.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Please refer to my 2nd update example, is this relevant?</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@Tom Gullen - even with reasonable strong password policies, a dictionary of hundreds of millions or a few billion candidates is likely to get some hits, because all passwords are not equally likely (because people use mnemonics, rather than RNGs, to choose them). A dictionary of that size <i>is</i> precomputable on commodity systems if salt is not used. If salt is used, the attacker has to recompute hashes every time, and if enough iterations of the hash are performed, the attacker's rate of attack can be slowed to a few attempts per second.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">Downvoter, could you explain? Especially if there is something incorrect it would be good to know.</span></text><author><a class="comment-user" href="/users/40347/dirk-vollmar" title="116,079 reputation">Dirk Vollmar</a></author></comment><comment><text><span class="comment-copy">I was the downvoter, I misread it though so I removed my downvote. However, I would like to point out that if they user has access to the database storing the password (as you seem to assume), the salt is probably known (they are typically stored in plaintext alongside the hashed password). If they are attacking it from the front-end, bruteforce or dictionary attacks will not be affected by the presence of the salt (unless the salt is computationally expensive). The goal on the front end should be delay and/or prevent blind guessing, and the backend to salt securely.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">-1 from me: being kept secret is totally not the point of salts. You need them accessible for checking passwords anyway, so any attempt to keep them secret is likely to make the system more vulnerable through added complexity rather than actually succeed.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@Michael Borgwart: You probably misread my answer. I was referring to the fact that the computational amount for checking the items in your word list is actually increased if the salt is unknown to the attacker, namely doubled for each bit of salt. And you want the computation to be expensive.</span></text><author><a class="comment-user" href="/users/40347/dirk-vollmar" title="116,079 reputation">Dirk Vollmar</a></author></comment><comment><text><span class="comment-copy">Great answer and discussion.  Thanks to all answers I have learnt a lot.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">@0xA3: again: being unknown to an attacker <i>is not the point of a salt</i>. Your machine needs to access it in some way, so an attacker who breaks into the machine can get it too. Any scenario where the attacker does not know the salt is a red herring.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">Salt does not need to be secret. <a href="http://stackoverflow.com/questions/3347035/salting-is-it-reasonable-to-use-the-user-name" title="salting is it reasonable to use the user name">stackoverflow.com/questions/3347035/…</a></span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment><comment><text><span class="comment-copy">I think it's worth mentioning that the linked article mis-describes rainbow tables. What he describes is a simple dictionary attach. Rainbow tables are really quite different (and somewhat more complex). There's a pretty decent explanation of how rainbow tables <i>really</i> work at: <a href="http://kestas.kuliukas.com/RainbowTables/" rel="nofollow noreferrer">kestas.kuliukas.com/RainbowTables</a></span></text><author><a class="comment-user" href="/users/179910/jerry-coffin" title="336,847 reputation">Jerry Coffin</a></author></comment><comment><text><span class="comment-copy">-1 for "Of course the salt needs to be kept secret". If an attacker has access to your password hashes, he will have your salts as well - what you need are <b>per-user</b> salts, not the security through obscurity of a "hidden" salt.</span></text><author><a class="comment-user" href="/users/430360/snemarch" title="3,987 reputation">snemarch</a></author></comment><comment><text><span class="comment-copy">I'm asking about guessing login too, is it easy than password or it's not a problem for attacker from the beginning?</span></text><author><a class="comment-user" href="/users/1376051/khaled-webdev" title="1,202 reputation">khaled_webdev</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A dictionary is a structure where values are indexed by keys. In the case of a pre-computed dictionary attack, each key is a hash, and the corresponding value is a password that results in the hash. With a pre-computed dictionary in hand, an attacker can "instantly" lookup a password that will produce the necessary hash to log in.</p>
<p>With salt, the space required to store the dictionary grows rapidly… so rapidly, that trying to pre-compute a password dictionary soon becomes pointless.</p>
<p>The best salts are randomly chosen from a cryptographic random number generator. Eight bytes is a practical size, and more than 16 bytes serves no purpose.</p>
<hr/>
<p>Salt does much more than just "make an attacker's job more irritating." It eliminates an entire class of attack—the use of precomputed dictionaries.</p>
<p>Another element is necessary to completely secure passwords, and that is "key-strengthening." <em>One round of SHA-1 is not good enough:</em> a safe password hashing algorithm should be <em>very</em> slow computationally. </p>
<p>Many people use PBKDF2, a key derivation function, that feeds back results to the hash function <em>thousands</em> of times. The "bcrypt" algorithm is similar, using an iterative key derivation that is slow.</p>
<p>When the hashing operation is very slow, a precomputed table becomes more and more desirable to an attacker. But proper salt defeats that approach.</p>
<hr/>
<h2>Comments</h2>
<p>Below are the comments I made on the question.</p>
<hr/>
<p>Without salt, an attacker wouldn't use the method demonstrated in "Update 2". He'd simply do a lookup in a pre-computed table and get the password in O(1) or O(log n) time (n being the number of candidate passwords). Salt is what prevents that and forces him to use the O(n) approach shown in "Update 2". </p>
<p>Once reduced to an O(n) attack, we have to consider how long each attempt takes. Key-strengthening can cause each attempt in the loop to take a full second, meaning that the time needed to test 10k passwords on 10k users will stretch from 3 days to 3 <em>years</em>… and with only 10k passwords, you're likely to crack zero passwords in that time. </p>
<p>You have to consider that an attacker is going to use the fastest tools he can, not PHP, so thousands of iterations, rather than 100, would be a good parameter for key-strengthening. It should take a large fraction of a second to compute the hash for a single password. </p>
<p>Key-strengthening is part of the standard key derivation algorithms PBKDF1 and PBKDF2, from PKCS #5, which make great password obfuscation algorithms (the "derived key" is the "hash").</p>
<p>A lot of users on StackOverflow refer to <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="noreferrer">this article</a> because it was a response to Jeff Atwood's post about the dangers of rainbow tables. It's not my favorite article, but it does discuss these concepts in more detail.</p>
<hr/>
<p>Of course you assume the attacker has everything: salt, hash, user name. Assume the attacker is a corrupt hosting company employee who dumped the user table on your myprettypony.com fansite. He's trying recover these passwords because he's going to turn around and see if your pony fans used the same password on their citibank.com accounts. </p>
<p>With a well-designed password scheme, it will be <em>impossible</em> for this guy to recover any passwords.</p>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">+1 great answer thank you.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">I think that by "dictionary attack", Tom refers to trying out known weak passwords (i.e. straight out of a human language dictionary), not precomputed hash-plaintext tables - this is also what I first think of when I read "dictionary" in this context.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@Michael Borgwardt: I agree, @erickson refers to pre-computed dictionary attacks.</span></text><author><a class="comment-user" href="/users/40347/dirk-vollmar" title="116,079 reputation">Dirk Vollmar</a></author></comment><comment><text><span class="comment-copy">Salt stops pre-computed dictionary attacks. Key-strengthening stops dictionary attacks. Both must be used together for secure password authentication.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">I do mean plain english tables yes.  The question aims to tackle the problem of how to stop a hacker working out all possible combinations of hashes for each user account</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The point of salting is to prevent the amortization of the attacker's effort.</p>
<p>With no salt, a single table of precomputed hash-password entries (e.g. MD5 of all alphanumeric 5 character strings, easy to find online) can be used on every user in every database in the world.</p>
<p>With a site-specific salt, the attacker has to compute the table himself and can then use it on all users of the site.</p>
<p>With a per-user salt, the attacker has to expend this effort for every user separately.</p>
<p>Of course, this doesn't do much to protect really weak passwords straight out of a dictionary, but it protects reasonably strong passwords against this amortization.</p>
</div></text><author><a href="/users/16883/michael-borgwardt">Michael Borgwardt</a></author><comments><comment><text><span class="comment-copy">Short and precise answer - worth adding that without salt or with site-wide salt, you can easily spot users with the same password, and will only need to brute-force one. With per-user salts, you can't do that.</span></text><author><a class="comment-user" href="/users/430360/snemarch" title="3,987 reputation">snemarch</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Also - one more imporatant point - using a USER-specific salt prevents the detection of two users with the SAME password - their hashes would match. That's why many times the hash is hash(salt + username + password) </p>
<p>If you try and keep the hash secret the attacker also can not verify the hashes. </p>
<p>Edit- just noticed the main point was made in a comment above.</p>
</div></text><author><a href="/users/428708/dominik-weber">Dominik Weber</a></author><comments><comment><text><span class="comment-copy">+1 I missed this point, but it is an excellent consideration</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">You should edit to specify per-user salt; sites using a site-wide salt will still allow you to detect identical passwords.</span></text><author><a class="comment-user" href="/users/430360/snemarch" title="3,987 reputation">snemarch</a></author></comment><comment><text><span class="comment-copy">@snemarch - Yes- thank you very much for this important distinction!</span></text><author><a class="comment-user" href="/users/428708/dominik-weber" title="541 reputation">Dominik Weber</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Salts are implemented to prevent rainbow table attacks. A rainbow table is a list of pre-calculated hashes, which makes translating a hash into it's phrase much more simple. You need to understand that salting isn't effective as a modern prevention to cracking a password unless we have a modern hashing algo. </p>
<p>So lets say we're working with SHA1, taking advantage of recent exploits discovered with this algo, and lets say we have a computer running at 1,000,000 hashes/second, <a href="http://www.schneier.com/blog/archives/2007/01/sha1_cracked.html" rel="nofollow noreferrer">it would take 5.3 million million million years to find a collision</a>, so yeah php can work 300 a second, big woop, doesn't really matter. The reason we salt is because if someone did bother to generate all common dictionary phrases,  (2^160 people, welcome to 2007 era exploits).</p>
<p>So here's an actual database, with 2 users I use for testing and admin purposes.</p>
<pre><code>RegistrationTime        UserName        UserPass    
1280185359.365591       briang      a50b63e927b3aebfc20cd783e0fc5321b0e5e8b5
1281546174.065087       test        5872548f2abfef8cb729cac14bc979462798d023
</code></pre>
<p>In fact, the salting scheme is your sha1(registration time + user name). Go ahead, tell me my password, these are real passwords in production. You can even sit there and hash out a word list in php. Go wild.</p>
<p>I'm not crazy, I just know that this is secure. For fun sake, test's password is <code>test</code>. 
<code>sha1(sha1(1281546174.065087 + test) + test) = 5872548f2abfef8cb729cac14bc979462798d023</code></p>
<p>You would need to generate an entire rainbow table perpended with <code>27662aee8eee1cb5ab4917b09bdba31d091ab732</code> for <em>just</em> this user. That means I can actually allow my passwords to not all be compromised by a single rainbow table, the hacker needs to generate an entire rainbow table for 27662aee8eee1cb5ab4917b09bdba31d091ab732 for test, and again f3f7735311217529f2e020468004a2aa5b3dee7f for briang. Think back to the 5.3 million million million years for all hashes. Think of the size of storing just the 2^80 hashes (that's well over 20 <a href="http://en.wikipedia.org/wiki/Yottabyte" rel="nofollow noreferrer">yottabytes</a>), it's not going to happen. </p>
<p>Don't confuse salting as a means of making a hash something you can't ever decode, it's a means of preventing a rainbow table from translating <strong>all</strong> your user passwords. It's imposable at this level of technology.</p>
</div></text><author><a href="/users/257493/incognito">Incognito</a></author><comments><comment><text><span class="comment-copy">I understand what a rainbow table is, but you are missing the point of my question.  If you provided me with your salting algorithm, a hashed password and the salt, then yes I probably could tell you what your password was within a few minutes.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Put your money where your mouth is?</span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment><comment><text><span class="comment-copy">Sure, but you just told me what the password is in your example, give me a salt, hashed password and how you combine the salt + password (non recursive) and as long as the password &lt;= 5 lowercase alphanumeric chars (no whitespace/special chars) I'll let you know what it is in this box.  If you want me to put money on it as you suggest, let me know, although my comment of a few minutes is probably a gross underestimation, but within hours yes.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Maybe seconds actually, see <a href="http://www.golubev.com/hashgpu.htm" rel="nofollow noreferrer">golubev.com/hashgpu.htm</a> which uses GPU to calculate as quoted "2300M/s SHA1 hashes per second".  With a full range of 95 ASCII characters ranging from 1-6 chars we can crack it in &lt;6 minutes.  If we have only lowercase alphanumeric chars, up to 8 chars in length &lt;25 minutes.  With a database of 10,000 user records, we could find all 4 char full ASCII passwords in &lt;200 seconds ((((95^4)/2300000000)/2)*10000).  (More overhead than quoted, and quoted GPU speeds are probably ideal situations).</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Yes, salting doesn't prevent you from being able to brute force that password. It makes it harder for you to generate the ((10^5)*(94^10))=10^24 if users have around 10-character passwords, which is much harder than the 10^19 without hashes. Again, it's not to make breaking one password hard, it's to make breaking all the passwords unfeasible with a pre-processed rainbow table.  (and check my math here, but I believe 10^25/2300000000/60/60/24/365/1000 = 137 869~ milinea for everyone's password). If we want stronger passwords we don't salt them, we use things like Diffie–Hellman key exchange.</span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment><comment><text><span class="comment-copy">Breaking 4-character passwords is nothing new. Salting doesn't make them harder to crack, it makes the database harder to crack.</span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment><comment><text><span class="comment-copy">So, did anyone ever crack his password?</span></text><author><a class="comment-user" href="/users/361460/andy" title="538 reputation">Andy</a></author></comment><comment><text><span class="comment-copy">To be fair, I've actually learned more, and standard PKCS #5 section 4.2 says I should have run at least 1000 iterations of my hash function, not one. There's other considerations I neglected since then also. <a href="https://docs.google.com/viewer?url=http%3A%2F%2Fwww.truecrypt.org%2Fdocs%2Fpkcs5v2-0.pdf" rel="nofollow noreferrer">docs.google.com/…</a></span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The idea behind dictionary attack is that you take a hash and find the password, from which this hash was calculated, <em>without</em> hash calculation. Now do the same with salted password - you can't. </p>
<p>Not using a salt makes password search as easy as lookup in the database. Adding a salt make attacker perform hash calculation of all possible passwords (even for dictionary attach this significantly increases time of attack). </p>
</div></text><author><a href="/users/47961/eugene-mayevski-eldos">Eugene Mayevski 'EldoS</a></author><comments><comment><text><span class="comment-copy">In the OP's scenario, the attacker <i>has</i> the salts from the database, and will have to try every salt with every entry in the "dictionary". ...I think.</span></text><author><a class="comment-user" href="/users/192801/frustratedwithformsdesigner" title="18,935 reputation">FrustratedWithFormsDesigner</a></author></comment><comment><text><span class="comment-copy">See my updated answer.</span></text><author><a class="comment-user" href="/users/47961/eugene-mayevski-eldos" title="36,320 reputation">Eugene Mayevski 'EldoS</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In simplest terms: without salting, each candidate password need only be hashed once to check it against every user, anywhere in the "known universe" (collection of compromised databases), whose password is hashed via the same algorithm.  With salting, if the number of possible salt values substantially exceeds the number of users in the "known universe", each candidate password must be hashed separately for each user against whom it will be tested.</p>
</div></text><author><a href="/users/363751/supercat">supercat</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Simply put salting does not prevent a hash from attack (bruteforce or dictionary), it only makes it harder; the attacker will either need to find the salting algorithm (which if implemented properly will make use of more iterations) or bruteforce the algo, which unless very simple, is nearly impossible. Salting also almost completely discards the option of rainbow table lookups...</p>
</div></text><author><a href="/users/508817/cyber-guard">cyber-guard</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Salt makes <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="nofollow noreferrer">Rainbow table</a> attacks much more difficult since it makes a single password hash much harder to crack. Imagine you have a horrid password of just the number 1. A rainbow table attack would crack this immediately. </p>
<p>Now imagine each password in the db is salted with a long random value of many random characters. Now your lousy password of "1" is stored in the db as a hash of 1 plus a bunch of random characters (the salt), so in this example the rainbow table needs to have the hash for something like: 1. </p>
<p>So assuming your salt is something secure and random, say <em>()%ISLDGHASKLU(</em>%#%#, the hacker's rainbow table would need to have an entry for 1*()%ISLDGHASKLU(*%#%#. Now using a rainbow table on even this simple password is no longer practical. </p>
</div></text><author><a href="/users/26180/cory-house">Cory House</a></author><comments><comment><text><span class="comment-copy">Please see update #2, you would simply have raw passwords and calculate all hashes against the salts for each user record.</span></text><author><a class="comment-user owner" href="/users/356635/tom-gullen" title="28,900 reputation">Tom Gullen</a></author></comment><comment><text><span class="comment-copy">Sure Tom, I agree, but the point is the hacker has to do that ugly time-consuming process once <i>for</i> <i>each</i> password if salt is used. Thus, salt does make using a rainbow table harder.</span></text><author><a class="comment-user" href="/users/26180/cory-house" title="6,912 reputation">Cory House</a></author></comment><comment><text><span class="comment-copy">@Tom Gullen: generating salted rainbow tables is only feasible if site-wide salts are used; per-user salting makes rainbow table attacks pretty much useless.</span></text><author><a class="comment-user" href="/users/430360/snemarch" title="3,987 reputation">snemarch</a></author></comment></comments></answer></answers></post>