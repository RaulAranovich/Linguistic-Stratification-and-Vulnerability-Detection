<?xml version="1.0" encoding="utf-8"?>
<post><title>ios - How To Secure Web Service Without Login - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I have a mobile app (currently IOS and soon Android) which talks to a web service. There is no login and the data is not private. Basically, the app POSTs a marker (lon, lat) and GETs the nearest 25 markers to display on a map.</p>
<p>It's a very trivial app and I cannot imagine anyone putting great effort into abusing the web service. However, I can see there is fun for someone in POSTing many markers. What most concerns me is someone running a script that pushes many requests (using expensive bandwidth and making nonsense of my app data).</p>
<p>I am slowly reaching the conclusion this cannot be secure. The best answer is "do not do this". Do not provide a web service without authentication. Not many services are so open. Google's You Tube API is open but most are not. Unfortunately, I have no choice. So after days of looking at this here's my thinking. Be aware I am very far from a security expert and I am confident my approach could be improved upon. But it might point you in the right direction. Hopefully, someone more experienced might chime in and correct/improve upon this. I found <a href="http://www.thebuzzmedia.com/designing-a-secure-rest-api-without-oauth-authentication/">this article</a> and comments particularly helpful.</p>
<p><strong>Message Level Security</strong></p>
<p>I will secure the msgs with a hash encryption. The clients and web service all retain a copy of a shared secret which is used as a salt to create a hash from the URL and all the POST arguments. The hash is passed as an additional argument and the hash is rebuilt and compared at the other end (using the shared key as a salt). This is pretty good until you understand that any mobile client code can be reverse engineered in minutes. At which point this line of defense is utterly useless.</p>
<p><strong>Client Measures</strong></p>
<p>The client includes rate limiting of messages as a measure to restrict the number of messages sent by honest users. Yet again this is useless against an attacker who jailbreaks the mobile device.</p>
<p><strong>Server Side Security</strong></p>
<p>So the server side must have as much additional security measures as possible, to stand alone on the assumption that your client (and shared secret) is compromised. Here is what I have:</p>
<p>One msg arg is a UTC time which is used to limit replay attacks. This should prevent an attacker from firing the same msg at the server repeatedly.</p>
<p>The server performs rate limiting by IP. Yes, IPs are easily spoofed and proxy switching is childs play but everything helps when you have so little.</p>
<p>Of course, the server strictly validates all arguments, uses parametised queries and doesn't return exceptions.</p>
<p><strong>Transport Level Security</strong></p>
<p>Unfortunately, I am fairly confident that issuing individual client SSL certs is not possible without a registration process. And because I am using the msg hash check (and my data is not private) I am not entirely sure what SSL brings to the table. However, I will probably use SSL (with one app wide cert) because it adds another level of security that is easily and cheaply deployed (albeit at a cost of additional connection time for every msg).</p>
<p><strong>The Gaping Great Big Hole In My Approach</strong></p>
<p>I am warned that should the app become popular that someone will compromise the shared secret on the client. Just because they can and they will probably post it on the internet. So really it all comes down to the server side. Unfortunately, <em>I have no way to identify and block an attacker</em>. This I would dearly love. </p>
<p><strong>A Final Plea</strong></p>
<p>After days of research this is all I have. But I want more. I would particularly appreciate any ideas to beef up the server side. So, I have put all my SO points up as a bounty. Yes sir, all 97 points! </p>
</div></text><author><a href="/users/781200/polly">Polly</a></author><comments><comment><text><span class="comment-copy">It might just be worth adding rate limiting? That could be a simpler solution.</span></text><author><a class="comment-user" href="/users/1178052/velox" title="1,469 reputation">Velox</a></author></comment><comment><text><span class="comment-copy">@Velox Do you mean limiting the number of requests per client (per day)? If so, yes I am doing that on the app. But I do not see how I can do that server side beyond by IP (which is better than nothing but I am hoping something better is available).</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">Do you maintain a list of registered devices or users who can push that data to you. If not do you expect it in the message .. or can anybody just push the data and you consume it ?</span></text><author><a class="comment-user" href="/users/1583851/vamsi-mohan-jayanti" title="563 reputation">Vamsi Mohan Jayanti</a></author></comment><comment><text><span class="comment-copy">@VamsiMohanJayanti: There is no registration process. The app is downloaded and you're off. A requirement is no login. I can sort of imagine a device registration behind the scenes on first load - but that seems no more secure, and more load on the server, than a secret key solution. Please tell me if I am missing your point.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">@Polly - Just want to mention that faking IP address is not possible if the attacker wants to read the response. So, rate limiting by IP address is a good start.</span></text><author><a class="comment-user" href="/users/242940/sripathi-krishnan" title="22,613 reputation">Sripathi Krishnan</a></author></comment><comment><text><span class="comment-copy">I like @kuba's solution, but want to warn against perhaps premature optimization. If you really do create an application that is popular and you really are acquiring spam, wouldn't you then also really redesign your API (if only to handle scaling issues)? You're attacker can hack your client easily, but you can also update your client/server and invalidate their hack...</span></text><author><a class="comment-user" href="/users/214890/dsummersl" title="4,004 reputation">dsummersl</a></author></comment><comment><text><span class="comment-copy">@dsummersl: That is an excellent point and a strategy I will definitely employ.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">@SripathiKrishnan: True. Thanks. Unfortunately I anticipate any <i>cheating</i> will be in POSTing rogue location markers which requires no knowedge of the response. And there are always proxys for an attacker to bounce around.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Actually in your particular case, since it is currently an iOS only app, there is a solution.</p>
<ol>
<li><p>After the user downloads and runs the app for the first time, the app hits a <code>/access_token/create</code> API that comes up with a GUID and relays it back to the Application via Apple's Push Notifications.</p></li>
<li><p>App stores this access_token, and uses it on all subsequent requests. Your actual API's can rate limit on the basis of the access_token.</p></li>
</ol>
<p>Basically, you let Apple do all the hard work of ensuring that the initial request came from an actual iOS device. </p>
<p>Extending this to Desktop clients is possible, but somewhat ruins the UX. Just change step 1 to allow <code>/access_token/create</code> to accept arbitrary requests, and if the request is not from a iOS device, then force the user to verify their email address/solve a captcha etc before issuing them an access_token.</p>
<p>Android devices (not really familiar with them) may have a similar Push Notification mechanism, in which case you can use that, or may not have a Push Notification mechanism, in which case you can subject your Android users to the inconvenience listed above.</p>
</div></text><author><a href="/users/141220/manav">Manav</a></author><comments><comment><text><span class="comment-copy">this is very interesting. Could you elaborate on it a little more because now it's quite unclear (at least for me)? What is this <code>/access_token/create</code> API you talk about? Is it some Apple service? How does it ensure coming from iOS device? How does server know that specific GUID was generated this way? What if iOS device was jailbroken?</span></text><author><a class="comment-user" href="/users/1486834/kuba-wyrostek" title="4,694 reputation">Kuba Wyrostek</a></author></comment><comment><text><span class="comment-copy">the <code>/access_token/create</code> API is just any arbitrary URL that you yourself provide on your server. When the application first starts, it makes a call to this URL alongwith a device token that one can get by registering for push notifications. (The entire flow is documented by Apple at <a href="http://developer.apple.com/library/mac/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html" rel="nofollow noreferrer">developer.apple.com/library/mac/#documentation/â€¦</a>). The server knows that the specific GUID was generated this way because the server itself generated it, and keep a list of the access_tokens that it has handed out.</span></text><author><a class="comment-user" href="/users/141220/manav" title="6,087 reputation">Manav</a></author></comment><comment><text><span class="comment-copy">For the last part of your question, I refer you to <a href="http://apple.stackexchange.com/questions/57225/does-push-notification-work-on-a-jailbroken-device" title="does push notification work on a jailbroken device">apple.stackexchange.com/questions/57225/â€¦</a></span></text><author><a class="comment-user" href="/users/141220/manav" title="6,087 reputation">Manav</a></author></comment><comment><text><span class="comment-copy">Very Nice. I had not even heard of APN. Google do have a <a href="http://developer.android.com/guide/google/gcm/index.html" rel="nofollow noreferrer">push service</a>. I am not qualified to say if this provides a similar level of security as APN. I am going to read further about these services. Thank you very much.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">As long as this solution really works on iOS and Android, and there are no jailbreak-related flaws or other "catches" - I really like it as possibly the easiest to implement. It should be the winner here.</span></text><author><a class="comment-user" href="/users/1486834/kuba-wyrostek" title="4,694 reputation">Kuba Wyrostek</a></author></comment><comment><text><span class="comment-copy">This solution would be fantastic <i>if</i> I knew that the Android push service provided the same level of security as Apple's APN appears to. Unfortunately I am nowhere near being able to evaluate that myself. And as the question says any user interaction is not acceptable. Would you have the time and inclination to take a look and assess Google's GCM? I ask because perhaps you are interested in the bounty which I must award today. Or perhaps you are just a good citizen. Sorry if this comment is cheeky and thanks very much for this great answer anyway.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">Really sorry, but any Android related answer I can give you will probably be second hand and possibly incorrect, so it is better that I not spread ignorance :)</span></text><author><a class="comment-user" href="/users/141220/manav" title="6,087 reputation">Manav</a></author></comment><comment><text><span class="comment-copy">I think if you ask a targeted new question on Stackoverflow itself about Android Push you should get relevant info. Or we could just wait for some Good Samaritan to waltz in here and dispel our ignorance.</span></text><author><a class="comment-user" href="/users/141220/manav" title="6,087 reputation">Manav</a></author></comment><comment><text><span class="comment-copy"><a href="http://stackoverflow.com/q/12089600/781200">Question</a> asked!</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">Guess people just didn't bother reading it through. Perhaps you could have made it simpler (and independent of this question), something like, "yo, bros! is Google Push dependable?" :)</span></text><author><a class="comment-user" href="/users/141220/manav" title="6,087 reputation">Manav</a></author></comment><comment><text><span class="comment-copy">I have improved the question. I can't disagree with @KubaWyrostek and accept your answer. Thanks to all for the great answers here.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">Sounds like a great solution indeed. Much easier than many of the other ones. Does this solution require the user to accept the "Enable Push Notifications" popup, or will the token part work regardless (they just won't get push notifications)?</span></text><author><a class="comment-user" href="/users/1580216/adam-b" title="2,758 reputation">Adam B</a></author></comment><comment><text><span class="comment-copy">AFAIK, the user will have to accept the "Enable Push Notifications" popup for this to work.</span></text><author><a class="comment-user" href="/users/141220/manav" title="6,087 reputation">Manav</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I've heard about this idea once, when talking about finding a global solution to SPAM problem: force your client to perform some time-taking computation.</p>
<p>To be precise: find some computational algorithm, that can compute some <code>z</code> for a pair of <code>x</code> and <code>y</code> in a blink of an eye, but it takes some considerable amount of time to compute <code>z</code> being given only <code>x</code>. I can not provide actual algorithm but I am sure that there are plenty of them that would much this criteria.</p>
<p>Now the whole procedure should look as follows:</p>
<ol>
<li>Upon first client request generate some <code>session_id</code> and for this <code>session_id</code> a pair of <code>x</code> and <code>y</code>.</li>
<li>Provide your client with <code>session_id</code> and <code>x</code>.</li>
<li>Client can start calculations as soon as it receives data (in some background thread not related to user interactions).</li>
<li>To request markers, client must provide <code>session_id</code> and calculated <code>z</code>.</li>
<li>You can quickly verify if client's <code>z</code> is all right, for you already have <code>x</code> and <code>y</code> that let you easily do it.</li>
<li>(option 1) For each <code>session_id</code> store how much/often it is being requested. The moment you suspect it is being abused - force regenerating <code>x</code> and <code>y</code>.</li>
<li>(option 2) Force new <code>x</code> and <code>y</code> upon each consecutive request for a <code>session_id</code>.</li>
</ol>
<p>Choosing between 6 and 7 is actually tweaking that depends on the complexity of algorithm vs. expected 'fair' use of marker database. If your estimates are good - the evil client should never obtain too much data or overload your server.</p>
<p>Hope it helps.</p>
</div></text><author><a href="/users/1486834/kuba-wyrostek">Kuba Wyrostek</a></author><comments><comment><text><span class="comment-copy">Interesting. I will need to spend time next week looking into this. I am keeping the question open until the last day of the bounty but I like that this is a fresh idea. Thank you.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">A possible candidate problem is the <a href="https://en.wikipedia.org/wiki/Discrete_logarithm" rel="nofollow noreferrer">discrete logarithm problem</a>: for the equation <code>g^x = h (mod p)</code> [where <code>p</code> is a prime and <code>g</code> is a generator for the multiplicative group modulo <code>p</code>], solve for the power <code>x</code> given the base <code>g</code> and solution <code>h</code>. It is easy to compute <code>g^x (mod p)</code> but difficult to compute <code>log_g(h) (mod p)</code>.</span></text><author><a class="comment-user" href="/users/710446/apsillers" title="63,441 reputation">apsillers</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There is nothing really you can do on the client side. You have to give the whole app (including any keys or any other protection mechanism) to your user. If a malicious user wants to play mischief with your web service he will have to do some reverse engineering to get to your web service. You can make this harder, but you cannot prevent this, no matter how hard you try.</p>
<p>Iâ€™d just implement some server-side rate limiting (per IP address) and not worry any more about this. This is a battle you cannot win. If someone really wants to hurt your server he could just DDOS it without knowing anything about your web service protocol.</p>
<p>Also, generating an unique key or certificate per user automatically on first connect does not help at all. After an attacker reverse-engineered your protocol he knows how to handle all this and doesn't have to play by your rules. Nothing would stop him from requesting a new key from your server every time he runs into the rate limiting.</p>
<p>The approach Kuba Wyrostek described could work - make the client perform some time-consuming computation you can quickly check before you allow the request to be processed. But this can't take too long or your users will complain about the reduced battery life. Also an attacker will probably use more powerful desktop hardware instead of another iPhone.</p>
<p>And a last point - do you really think this is necessary? You donâ€™t want your users to have to register, so your data or service canâ€™t be too important. So what would anyone have to gain from reverse-engineering your app and flooding your server with requests? </p>
</div></text><author><a href="/users/431526/sven">Sven</a></author><comments><comment><text><span class="comment-copy">Great points, especially the last. The data is entirely unimportant (except for the value in cheating the <i>game</i>). However, I will, at least (as well as server side rate limiting), secure msgs with a hash to force reverse engineering - this seems like a small cost for a large obstacle. Thank you.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I've actually been looking for a reason to implement a few of these ideas. Great question and answers so far.</p>
<p>I agree with @Kuba Wyrostek regarding treating it like a spam problem is part of the solution. Especially if your app will have textual messages (adding a store, service, or message), you may find that a common reason to spam your app would be to advertise something. That would lead to my first recommendation:</p>
<blockquote>
<p><strong>1) Treat each message's validity as a percentage from 0% to 100% valid</strong>. Develop a process on the server side to with heurestics to mark the message as more or less valid. This will allow you to target some of the additional methods (such as forcing a client to calculate a complex value) to only those requests where it is needed. You can also more easily log and review possible abuse (and more easily clean out that abuse after it is targeted).</p>
</blockquote>
<p>Your apps do have a strong advantage over email servers in the spam war, however - you control both sides of the conversation. This situation actually reminds me of two other related situations that you might find helpful: the satellite Pay-TV "wars" and Instant Messenger clone "wars". (Reference Jeff Atwoods post on the <a href="http://www.codinghorror.com/blog/2008/05/revisiting-the-black-sunday-hack.html" rel="nofollow">Black Sunday hack</a>, for example). Here are a few ideas from those standoffs that might help you get a little ahead of the game of cat and mouse:</p>
<blockquote>
<p><strong>2) Require the client to send extra data</strong> - as much data about the request as makes sense. On iOS, send the accuracy metrics for the location. On Android, you can actually get raw GPS data such as ephemeris information. You can then (maybe not right away, but later), start checking this data for validity. This forces someone reverse engineering the requests to work that much harder. If they send the GPS satellites in view, for example, you could check that against publicly known data to confirm.</p>
<p><strong>3) Force your adversary onto the mobile device</strong> - As @Sven notes, your attacker might use a desktop PC, which means a "computationally expensive" request might become trivial. Don't let them do this (or at least make them work harder). You can, for example, have the client compute some mathematical function (sent by the server), and see, based on the phone model, if it takes the correct number of milliseconds to complete. Or do a small 3D rendering task with data from the server, that relies on hardware clipping behavior. Hash the result and send it back. All of these would be within a range - it is a multitasking OS. But it would help tremendously.</p>
<p><strong>4) Go dynamic on them</strong> - Send along bits of algorithm that need to be computed in the client's context. Apple gets a little funny about remote code to be interpreted, but something like sending a bit of javascript that does not render to the user might work. That code could ask all sorts of unique questions (screen resolution, browser version, WebKit quirks) that would be hard to anticipate up front. As they catch up, you can get more creative with these.</p>
<p><strong>5) CAPTCHA</strong> - If your heuristics start seeing suspect data, force them to authenticate. If you have a multilingual app, it could be as simple as matching a picture or unicode character to another one. Render it in a way that you can update it later.</p>
</blockquote>
<p>Anyhow - a few additional ideas. Good luck!</p>
</div></text><author><a href="/users/1580216/adam-b">Adam B</a></author><comments><comment><text><span class="comment-copy">Great ideas. I do appreciate this whole spam approach from @Kuba and yourself. When I have some time I will need to evaluate how far I implement them. I am not sure my app warrants too much extra cpu work. But will be great for other apps with more important data. In my case I have no user text input and any text responses are passed as ints and switched on the client. I like the idea of a simple captacha for suspicious requests to thwart script. I have choices now. I just need to decide the balance which is a far better place than before these responses. Thank you.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The simplest way to implement rate limiting on the server side is to just use a web server plugin/module.  For example, if your service is running on apache, install and configure mod_evasive.  This will allow you to rate limit based on IP address, service/URL, etc.  Mod Evasive will be more effective than what you can implement on your own.</p>
<p>If you use keys, you need to have some kind of captcha based way for the client to get the keys upon signup.  You could have it drop accounts for abusive users.  Right, of course one parameter would be the timestamp which would be verified as recent and in the past on the server side.  The key would encrypt the entire payload along with the timestamp, and be added as an additional parameter.  Storing frequency of requests on a per-key basis ends up requiring some kind of round-robin database, unless you only check recency of last request.</p>
<p>No purely client-side rate limit will make any difference.  Someone could discover your API on the web without ever even having seen your client.  I doubt that a shared secret would be effective for long.</p>
<p>You will find plenty of web services that don't require a password and are merely rate limited... for example, the twitter API offers many rate-limited unauthenticated API services.</p>
</div></text><author><a href="/users/621233/brian">Brian</a></author><comments><comment><text><span class="comment-copy">Great tip about the web server plugin/module. And I stand corrected regarding the number of open web services. So much is new! Thank you.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Here is another "solution":</p>
<ul>
<li>don't waste time on this issue.</li>
</ul>
<p>because:</p>
<ul>
<li>you don't expose a public interface to the world, so you are free to change your webservice interface at any time via update of webservice and an update to your app.</li>
<li>the app is "very trivial" (as you called it) and probably isn't used much at the moment</li>
<li>you probably have better things to do right now and are just consuming time</li>
</ul>
<p>if there are suspicious performance or query spikes go for the least time consuming solution:</p>
<ul>
<li>introduce a password (clientid) saved in your app (blocks 95% of these users) this clientid can later be used to identify different clients if other programmers want to legally access your service</li>
<li>introduce rate limiting (as mentioned above)</li>
</ul>
<p>this will in 99,99% solve your problems and you can get to work right now and write awesome new features.</p>
</div></text><author><a href="/users/315331/stephan-schinkel">Stephan Schinkel</a></author><comments><comment><text><span class="comment-copy">Fair point and possible what I would do where it not that the client is absolutely insistent upon no user registration/password now or in the future. She is convinced that uptake will rely on this. May I ask if you speak from experience? I would love to hear from a developer who put an API into the wild with no security.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">And as suggested by @dsummersl in a comment below the question I will be introducing any security measures incrementally.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">there is no registration going on. the clientid is hardcoded in your app. if other developers want to access your webservice just let them send an email to you and you send them a clientid. i had an webservice in the "wild" that just had this clientid. but fairly enough the android app wasn't something like popular. i used the same technique as jeff atwood in his blog and just used an static captcha. no spam was seen afterwards.</span></text><author><a class="comment-user" href="/users/315331/stephan-schinkel" title="2,622 reputation">Stephan Schinkel</a></author></comment><comment><text><span class="comment-copy">Ah, sorry I misunderstood. There is no plan to give API access to other devs - so this would only possibly be a consideration for future versions. And any client side hard coded key must be assumed as compromised - maybe only upon wide uptake but to plan for little uptake is no plan at all.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It is tricky, you don't expect anybody to tamper the data ... so your concern is not about integrity. 
And since you do not maintain any list of clients ... there cannot be any concern about Authenticity? </p>
<p>And for all the well know Webservice attacks (like DoS or replay attacks) you get firewalls that can prevent them. So I don't think you need to bother about them much.</p>
<p>But then you you don't want to send plain text data and want to make sure that your download app is what is pushing the data. </p>
<p>If you look at the approaches you are evaluating :</p>
<p><strong>Secured Key</strong> : As I understand the server and the App are going to share the same Key and if I am correct all the apps on all the devices will share the same Key. And when the app pushes the data it hashes the Actual feed and sends across  Actual feed + the hashed feed. On the server side you would use the Key and hash the actual feed and verify if it is matching with the hashed feed. And in my opinion this solution is mainly addresses the Data integrity aspect which is not a major concern for you. rgt!
(And yes it will probably be easy to reverse engineer.)</p>
<p>In the above approaches server would need to store the Key So if your Key is compromised your whole service will be and it will be difficult to update all the apps with new key.
Or else if the app generates a Key it will have to send the key on the wire along with the message as digest or something(like timestamp + some random number). Not so difficult to break.</p>
<p><strong>Certificate:</strong> Even with certificates you get the same security .. but it is difficult to break but easy to steel :). If you are keeping a private Key with device (ofcourse then you will have to maintain a public key at the server). You will have to assign a private key per client and then the server needs to maintain the public key for all private keys assigned. If a private key is compromized only that single app can be red flaged and requested for an update.</p>
<p>So what is left is from an application development perspective you want to avoid fabricated data. For sake of preventing mischief 
The the only point to check such things is in the application logic. You will need to cache the last ten(or what even the optimum number is) feeds (comming from same IP)and have some sort of logic verify if there is a flaw. </p>
</div></text><author><a href="/users/1583851/vamsi-mohan-jayanti">Vamsi Mohan Jayanti</a></author><comments><comment><text><span class="comment-copy">RE:Certificate - Wouldn't issuing each device a cert require a CA? I think the cost of using a CA is too much for this project. Assuming that to be the case, then are you saying what I proposed (secret key on the client and watching IPs on the server) is about as good as I can do?</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">Yes if you go for CAs it will cost you. But I thing you can go for self signed certificates.Create your own CA and generate certificates using openssl. And since your App is the consumer (consumes the service) and you are the service provider I don't think you should have any problem with self signed certificates, you can always override the "Not a Trusted CA issue". IF you are planning for secret key .. are you going to maintain a key per IP or  just a single key across?</span></text><author><a class="comment-user" href="/users/1583851/vamsi-mohan-jayanti" title="563 reputation">Vamsi Mohan Jayanti</a></author></comment><comment><text><span class="comment-copy">RE:Secured Key - Are you suggesting a unique salt for each device (so I can red flag any abuser)? So, on first use the server sends a unique salt which it associates with the IP. It seems to me that this would be easily compromised by reverse engineering - the attacker would simply repeatedly reregister. Or am I misunderstanding your suggestion?</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">RE:Certs - OK I had no idea I could be a CA with self signed certs. This would seem like an excellent solution. I have no idea how to implement and need to spend time looking at openssl. However, I have one question at this stage- Would any user interaction be required to create/download a unique cert or can this be done behind the scenes by my app alone?</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You could use rate limit + client 'soft' registration.</p>
<p>Basically you would generate a device ID that you could store in the user defaults upon the first request.
For every request you track how many request have been sent to the server and limit it server side.
This can be achieved really quickly.</p>
<p>You can also have some kind of shared secret used to sign your request with the generated device id + post/get parameters</p>
</div></text><author><a href="/users/743337/flovilmart">flovilmart</a></author><comments><comment><text><span class="comment-copy">Thanks but if I understand correctly, this adds nothing against attackers who reverse engineer the code (at the expense of extra work server side for everyone). An attacker could simply repeatedly re-register. And I already have a shared secret signature. Have I have misunderstood your suggestion?</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">If inside a mobile app, it would require some exploit to extract your shared secret. If you consider that, it's good enough to sign your request and apply an API Rate limitation. Tracking the clients (IP...) is also a good idea. When you generate the device ID, you can make it follow a pattern you and only you know as well...</span></text><author><a class="comment-user" href="/users/743337/flovilmart" title="589 reputation">flovilmart</a></author></comment><comment><text><span class="comment-copy">Yes I would rest easy if decompiling an app wasn't possible. But it appears <a href="http://stackoverflow.com/a/6809770/781200">possible</a>. I have no idea about how easy or how likely this is but if done my ws is wide open. Perhaps I am worrying too much.</span></text><author><a class="comment-user owner" href="/users/781200/polly" title="395 reputation">Polly</a></author></comment><comment><text><span class="comment-copy">Look at all the app that embed Facebook and Twitter API_KEY and API_SECRET and that usually, have them in a #define API_KEK. With accessing such parameters, you'd be able to impersonate a developer's app, and it looks like they don't worry that much! :)</span></text><author><a class="comment-user" href="/users/743337/flovilmart" title="589 reputation">flovilmart</a></author></comment></comments></answer></answers></post>