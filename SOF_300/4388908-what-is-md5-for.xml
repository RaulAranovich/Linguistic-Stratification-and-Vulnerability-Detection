<?xml version="1.0" encoding="utf-8"?>
<post><title>php - What is md5() for? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I was reading this tutorial for a <a href="http://www.phpeasystep.com/workshopview.php?id=6" rel="noreferrer">simple PHP login system</a>.</p>
<p>In the end it recommends that you should <a href="http://www.phpeasystep.com/workshopview.php?id=26" rel="noreferrer">encrypt your password using md5()</a>.</p>
<p>Though I know this is a beginners' tutorial, and you shouldn't put bank statements behind this login system, this got me thinking about encryption.</p>
<p>So I went ahead and went to (one of the most useful questions this site has for newbies): <a href="http://stackoverflow.com/questions/72394/what-should-a-developer-know-before-building-a-public-web-site">What should a developer know before building a public web site?</a></p>
<p>There it says (under security) you should: </p>
<blockquote>
<p><strike>Encrypt</strike> Hash and salt passwords rather
  than storing them plain-text.</p>
</blockquote>
<p>It doesn't say much more about it, no references.</p>
<p>So I went ahead and tried it myself:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$pass </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Trufa"</span><span class="pun">;</span><span class="pln">
$enc </span><span class="pun">=</span><span class="pln"> md5</span><span class="pun">(</span><span class="pln">$pass</span><span class="pun">);</span><span class="pln">

echo $enc</span><span class="pun">;</span><span class="pln"> </span><span class="com">#will echo 06cb51ce0a9893ec1d2dce07ba5ba710</span></code></pre>
<p>And this is what got me thinking, that although I know md5() might not the strongest way to encrypt, anything that always produces the same result can be reverse engineered.</p>
<p>So what is the sense of encrypting something with md5() or any other method?</p>
<p>If a hacker gets to a password encrypted with md5(), <a href="http://md5.rednoize.com/" rel="noreferrer">he would just use this page!</a>.</p>
<p>So now the actual questions:</p>
<ol>
<li><strong>How does password encryption work?</strong></li>
</ol>
<p>I know I have not discovered a huge web vulnerability here! :) I just want to understand the logic behind password encryption.</p>
<p>I'm sure I'm understanding something wrong, and would appreciate if you could help me set my though and other's (I hope) straight.</p>
<p><strong>How would you have to apply password encryption so that it is actually useful?</strong></p>
<ol start="2">
<li>What about this idea?</li>
</ol>
<p>As I said, I may/am getting the whole idea wrong, but, would this method add any security in security to a real environment?</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$reenc </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">
 </span><span class="str">"h38an"</span><span class="pun">,</span><span class="pln">
 </span><span class="str">"n28nu"</span><span class="pun">,</span><span class="pln">
 </span><span class="str">"fw08d"</span><span class="pln">
 </span><span class="pun">);</span><span class="pln">

$pass </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Trufa"</span><span class="pun">;</span><span class="pln">

$enc </span><span class="pun">=</span><span class="pln"> chunk_split</span><span class="pun">(</span><span class="pln">md5</span><span class="pun">(</span><span class="pln">$pass</span><span class="pun">),</span><span class="lit">5</span><span class="pun">,</span><span class="pln">$reenc</span><span class="pun">[</span><span class="pln">mt_rand</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln">count</span><span class="pun">(</span><span class="pln">$reenc</span><span class="pun">)-</span><span class="lit">1</span><span class="pun">)]);</span><span class="pln">

echo $enc</span><span class="pun">;</span></code></pre>
<p>As you see, I randomly added arbitrary strings (<code>$reenc = array()</code>) to my md5() password "making it unique". This of course is just a silly example.</p>
<p>I may be wrong but unless you "seed the encryption yourself" it will always be easily reversible. </p>
<p>The above would be my idea of "password protecting" and encrypted password, If a hacker gets to it he wont be able to decrypt it unless he gets access to the raw .php</p>
<p>I know this might not even make sense, but I can't figure out why this is a bad idea!</p>
<hr/>
<p>I hope I've made myself clear enough, but this is a very long question so, <strong>please ask for any clarification needed!</strong></p>
<p>Thanks in advance!!</p>
</div></text><author><a href="/users/463065/trufa">Trufa</a></author><comments><comment><text><span class="comment-copy">+1 For not just asking “Whats is md5() for?”</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,781 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">what you "invented" already exists. it's called SALT. "salting" a hash results in higher security, yes. but md5() is kinda deprecated. it has too many collisions and is outdated. use sha1() instead</span></text><author><a class="comment-user" href="/users/461173/mark" title="19,632 reputation">mark</a></author></comment><comment><text><span class="comment-copy">@Gumbo I've been amazed with the good will and effort that people put to answer when you put a little effort in your questions!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy"><i>(suggested alternative)</i> <a href="http://de2.php.net/manual/en/function.hash-hmac.php" rel="nofollow noreferrer"><code>hash_hmac</code> — Generate a keyed hash value using the HMAC method</a></span></text><author><a class="comment-user" href="/users/208809/gordon" title="228,088 reputation">Gordon</a></author></comment><comment><text><span class="comment-copy">@Gordon I'll take a look thank you, it seems good!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">I removed the encryption tag because md5 is a message digest function not an encryption function.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook Agreed, That was seems ages ago now ;) Thanks <a href="http://stackoverflow.com/questions/4388908/what-is-md5-for/4389047#4389047" title="what is md5 for">stackoverflow.com/questions/4388908/what-is-md5-for/…</a></span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">FYI, MD5 is not secure. It should only be used to maybe ensure data integrity, not passwords! It's been broken for years. With the right tools you can easily create a collision that will give you access as long as you know what to compute. MD5 doesn't give you the benefit of securely storing passwords. Please be adviced and use SHA-1 or preferably SHA2/256 which are (S)ecure (H)ash (A)lgorithms. <a href="http://en.wikipedia.org/wiki/MD5#Security" rel="nofollow noreferrer">en.wikipedia.org/wiki/MD5#Security</a></span></text><author><a class="comment-user" href="/users/58961/john-leidegren" title="31,516 reputation">John Leidegren</a></author></comment><comment><text><span class="comment-copy">@John thanks for the advice, related question to that subject: <a href="http://stackoverflow.com/questions/2768248/is-md5-really-that-bad" title="is md5 really that bad">stackoverflow.com/questions/2768248/is-md5-really-that-bad</a></span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@John  The relevant section is "Preimage vulnerability" which is currently only theoretical, with a prohibitive computational complexity. Looks like MD5 is good for password protection for the time being.</span></text><author><a class="comment-user" href="/users/497358/axn" title="306 reputation">Axn</a></author></comment><comment><text><span class="comment-copy">@Akinator - use <code>SHA512</code>, if you're truly L33T. You don't even need salt then.</span></text><author><a class="comment-user" href="/users/128463/orokusaki" title="18,730 reputation">orokusaki</a></author></comment><comment><text><span class="comment-copy">@Axn - I don't know what rock you live under but you clearily haven't been paying attention these past years. MD5 is in fact broken, I also happen to have been using tools that create collisions in time which is computationally feasible (1-2 hours).</span></text><author><a class="comment-user" href="/users/58961/john-leidegren" title="31,516 reputation">John Leidegren</a></author></comment><comment><text><span class="comment-copy">@orokusaki a stronger hash function is not a reason to not use a salt. A salt makes it impossible to use large dictionaries of precomputed hashes, prevents a lot of the guess work that goes into password breaking. This has nothing to do with the algorithm in question.</span></text><author><a class="comment-user" href="/users/58961/john-leidegren" title="31,516 reputation">John Leidegren</a></author></comment><comment><text><span class="comment-copy">@John - Interesting. When you say "creating collisions", are you able to generate a collision for a pre-specified hash?</span></text><author><a class="comment-user" href="/users/497358/axn" title="306 reputation">Axn</a></author></comment><comment><text><span class="comment-copy">@Axn - Yes? <a href="http://www.mscs.dal.ca/%7Eselinger/md5collision/" rel="nofollow noreferrer">mscs.dal.ca/~selinger/md5collision</a> I not sure what your trying to get at, MD5 is in now way secure.</span></text><author><a class="comment-user" href="/users/58961/john-leidegren" title="31,516 reputation">John Leidegren</a></author></comment><comment><text><span class="comment-copy">@John - That page shows that MD5 is broken for digital signature purpose -- where you are free to generate both the messages that produces a collision. But, in password protection, one message (the password) is already specified, and unknown. The task is to generate another message that yields the same hash as the (unknown) password. That is the "preimage vulnerability" -- and currently that is <i>not</i> broken. For instance, if I give you the hash of a secret password , would you be able to generate the password or another text with the same hash using your collision tools?</span></text><author><a class="comment-user" href="/users/497358/axn" title="306 reputation">Axn</a></author></comment><comment><text><span class="comment-copy">Gawker Media was compromised. They weren't salting, they only md5ed the passwords. See it here: <a href="http://thepiratebay.org/torrent/6036819/Gawker_Sites_Hacked_Databases__amp__More" rel="nofollow noreferrer">thepiratebay.org/torrent/6036819/…</a></span></text><author><a class="comment-user" href="/users/233286/ilhan" title="2,996 reputation">ilhan</a></author></comment><comment><text><span class="comment-copy">@ilhan I've heard of course :) but the most worrying thing IMO is the amount passwords: "password", "123456" etc etc! you might like this: <a href="http://www.codinghorror.com/blog/2010/12/the-dirty-truth-about-web-passwords.html" rel="nofollow noreferrer">codinghorror.com/blog/2010/12/…</a></span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Axn - You might be limited to alpha numerics but these characters are still enough to generate a collision. A collision is all it takes to gain access. I don't need to know what the password was, I just need to find a collision. This question makes it sort of obvious why MD5 really is that bad. Which by the way references the same source <a href="http://stackoverflow.com/questions/2768248/is-md5-really-that-bad" title="is md5 really that bad">stackoverflow.com/questions/2768248/is-md5-really-that-bad</a></span></text><author><a class="comment-user" href="/users/58961/john-leidegren" title="31,516 reputation">John Leidegren</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>You should have an <code>encryption</code> like <code>md5</code> or <code>sha512</code>. You should also have two different salts, a <code>static salt</code> (written by you) and then also a <code>unique salt</code> for that specific password.</p>
<p>Some sample code (e.g. registration.php):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$unique_salt </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="str">'md5'</span><span class="pun">,</span><span class="pln"> microtime</span><span class="pun">());</span><span class="pln"> 
$password </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="str">'md5'</span><span class="pun">,</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">'password'</span><span class="pun">].</span><span class="str">'raNdoMStAticSaltHere'</span><span class="pun">.</span><span class="pln">$unique_salt</span><span class="pun">);</span></code></pre>
<p>Now you have a <code>static salt</code>, which is valid for all your passwords, that is stored in the .php file. Then, at registration execution, you generate a <code>unique hash</code> for that specific password.</p>
<p>This all ends up with: two passwords that are spelled exactly the same, will have two different <code>hashes</code>. The <code>unique hash</code> is stored in the <code>database</code> along with the current id. If someone grab the <code>database</code>, they will have every single <code>unique salt</code> for every specific password. But what they don't have is your <code>static salt</code>, which make things a lot harder for every "hacker" out there.</p>
<p>This is how you check the validity of your password on login.php for example:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$user </span><span class="pun">=</span><span class="pln"> </span><span class="com">//random username;</span><span class="pln">
$querysalt </span><span class="pun">=</span><span class="pln"> mysql_query</span><span class="pun">(</span><span class="str">"SELECT salt FROM password WHERE username='$user'"</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">while</span><span class="pun">(</span><span class="pln">$salt </span><span class="pun">=</span><span class="pln"> mysql_fetch_array</span><span class="pun">(</span><span class="pln">$querysalt</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $password </span><span class="pun">=</span><span class="pln"> hash</span><span class="pun">(</span><span class="str">'md5'</span><span class="pun">,</span><span class="pln">
          $_POST</span><span class="pun">[</span><span class="str">'userpassword'</span><span class="pun">].</span><span class="str">'raNdoMStAticSaltHere'</span><span class="pun">.</span><span class="pln">$salt</span><span class="pun">[</span><span class="pln">salt</span><span class="pun">]);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>This is what I've used in the past. It's very powerful and secure. Myself prefer the <code>sha512</code> encryption. It's actually just to put that inside the hash function instead of <code>md5</code> in my example.</p>
<p>If you wanna be even more secure, you can store the <code>unique salt</code> in a completely different database.</p>
</div></text><author><a href="/users/426429/wroclai">Wroclai</a></author><comments><comment><text><span class="comment-copy">One important point about this is that if the attacker learns the static-salt it's still at least as secure as if you hadn't used a static salt at all.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment><comment><text><span class="comment-copy">@CodelnChaos: Yes. Stick with this solution I've made have helped me; since hackers don't wanna use decryptors to find out just one unique salt (it will take weeks). Imagine that you have a big database with a lot of users.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy">@Charlie Ok as soon as I will give it a try, this is making much more sense now! Thank you!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator: No problems. Just ask if it's unclear.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy">You might also want to add something about how md5 is not secure because it's too fast, I would recommend using b_crypt, or if that's not available, looping the md5 hashing thousands of times. Remember, users won't care if it takes 2 seconds to login instead of 1, but people trying to guess the password will. You've doubled the time it takes to check a password, and lengthened the cracking time considerably.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Malfist: That's just what my solution pointing out. Even if the database gets in wrong hands, they gonna spend a LOT of more time to decrypt the password (and they will never succeed without the static salt). I've also added that I recommendsíng <code>sha512</code>.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy">sha and md5 are both designed to be <i>fast</i>, not secure. If someone is able to get access to your database, they probably have more than enough access to also dump your files, i.e. securing the static salt and any other method of security by obscurity. Hashing thousands of times, or using a more time intensive hash will significantly increase time to crack.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Malfist: Even then it's very hard. The hacker would be spending months on just about ten people's password because every single user have an unique salt. However, we can still looping through <code>sha512</code> thousands of times (like your mentioned) but there's up to yourself to choose which type of flexibility/speed you want.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy">Yes, that is the purpose of a unique salt. But the hacker could be after only one person's password (such as the admin's). If you hash the password 1000 times with md5, the hacker has to also. This increases the time to crack that one user's password 1000 times also (or nearly), which may push the time to crack one user's password into the years category.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Malfist: Of course. This was an example of my sort (since my websites are not the most popular ;)), where I simplified it. There isn't much to do to add your part into my example.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy"><b>gah!</b> You're not understanding. There is a significant difference between just hashing it once with md5 or sha512 or any other hash algorithm designed to be <b>fast.</b> Because they're fast they are <b>not strong enough</b> to be used in the real world. b_crypt or m_crypt is designed to <b>be slow</b> and because it's slow it is hard for to bruteforce and therefor <b>more secure</b>. Hashing the same password 1000's of times is a compromise in order to make it take longer. To crack a common password secured with single pass md5 would only take <b>a few weeks</b>, with b_crypt, <b>years</b>.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">And no, storing the salt in another database isn't any more secure. That's just another example of security by obscurity. <b>It does not work!</b> If the have enough access to dump one database they probably have enough to dump both.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Malfist: I'm understanding what your wanted to say since your first comment. That said; storing in another database is more secure than have it in a table along with your user information. The hacker MAY not have access to the whole system (like you wrote), he could just drop the database via SQL injection, and THAT makes sense - if we have stored our unique salt in another database.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy">There is a significant difference between what I'm suggesting and what you have written. As to the point you just made, if your site if vulnerable to sql injection you have more problems. The vast majority of information leaks is from the inside. I.E. a new admin grabs the entire database, or a worker who just got fired steals it, or someone puts it on a CD and loses it (happened with the IRS a few years ago). Just look at wikileaks, they didn't hack the us government, the was given or bought that information from the inside.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Malfist: If there is a significant difference between my answer from what you're suggesting, make another answer. Should we as programmers really care about if there's any leaks inside? That's a problem of its own.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment><comment><text><span class="comment-copy">@Charlie Sheen sorry for the delay but I cant get you recommendations to work (because I cannot understand the code). So yo do to hashes (one is unique to as the user becuase you multiply by microtime I guess) but i cannot understand how is your second piece of code checking the validity of the password, are you cheking one hash against another? Shouldn't they be different? I am quite confused, if by any chance you would happen to know a link to point me to a "working example" I would appreciate it, if not, whenever you can I would thank you if you could help me out a little bit Thank you!!!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator: You compare the hash that was generated in registration exactly the same in login page, therefore the login should match.</span></text><author><a class="comment-user" href="/users/426429/wroclai" title="22,205 reputation">Wroclai</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Firstly, "hashing" (using a cryptographic one way function) is not "encrypting". In encryption, you can reverse the process (decryption). In hashing, there is (theoretically) no feasible way of reversing the process.</p>
<p>A hash is some function f such that v cannot be determined from f(v) easily.</p>
<p>The point of using hashing for authentication is that you (or someone seeing the hash value) do not have any feasible way (again, theoretically) of knowing the password. However, you can still verify that the user knows his password. (Basically, the user proves that he knows v such that f(v) is the stored hash).</p>
<p>The weakness of simply hashing (aside from weak hash functions) is that people can compile tables of passwords and their corresponding hash and use them to (effectively) get the inverse of the hash function. Salting prevents this because then a part of the input value to the hash is controlled and so tables have to be compiled for that particular salt.</p>
<p>So practically, you store a salt and a hash value, and authenticate by hashing a combination of the salt and the password and comparing that with your hash value.</p>
</div></text><author><a href="/users/288222/lijie">lijie</a></author><comments><comment><text><span class="comment-copy">that helps! nice and simple explanation, thank you!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">+1 for proper usage of terms.</span></text><author><a class="comment-user" href="/users/497358/axn" title="306 reputation">Axn</a></author></comment><comment><text><span class="comment-copy">+1 Thankful to find at least a couple of posters saying that hashes are not a form of encryption.</span></text><author><a class="comment-user" href="/users/438971/orbling" title="16,343 reputation">Orbling</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>MD5 is a one way hashing function which will guard your original password more or less safely. </p>
<p>So, let's say your password is "Trufa", and its hashed version is <code>06cb51ce0a9893ec1d2dce07ba5ba710</code>.</p>
<p>For example, when you sign in to a new webpage, they ask you for your username and password. When you write "Trufa" as your password, the value <code>06cb51ce0a9893ec1d2dce07ba5ba710</code> is stored in the database because it is hashed.</p>
<p>The next time you log in, and you write "Trufa", the hashed value will be compared to the one in the database. If they are the same, you are authenticated! Providing you entered the right username, of course.</p>
<p>If your password wasn't stored in its hashed form in database, some malicious person might run a query somehow on that database and see all real passwords. And that would be compromising. </p>
<p>Also, since MD5 is a 128 bit cryptographic function, there are 2^128-1 = 340282366920938463463374607431768211455 possible combinations.</p>
<p>Since there are more possible strings than this, it is possible that 2 strings will generate the same hash value. This is called a collision. And it makes sure that a hashed password cannot be uniquely reverse engineered.</p>
</div></text><author><a href="/users/489261/darioo">darioo</a></author><comments><comment><text><span class="comment-copy">I get you point, now that I've read some good answers, this one gives me a good idea of what md5() is though it still puzzles me that (if you don't SALT you password) why would md5() be more secure than an unencrypted password. Lets say you want to protect against a dictionary attack, what good would it be, if the hacker, knows you passwords are hashed, he would just hash his dictionary and continue trying, the collisions would just slow him down a little bit. see my point? BTW do you happen to know how high this collision rate is? Thanks for your answer!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator - this does not provide any protection against a dictionary style attack (the attacker does not need to hash his attempts, he just peppers your site with requests).  This is where you combine this with a count of the number of tries to login someone gets (e.g. 5) before they are either locked out, or temporarily unable to login for a set period (say 30 mins).</span></text><author><a class="comment-user" href="/users/117215/paddy" title="24,145 reputation">Paddy</a></author></comment><comment><text><span class="comment-copy">@Paddy ok got it, but probably explained myself wrong though.</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">Salts are normally just a concatenation of a (random or not) string to the password.  If someone gets access to the database the passwords are still visible by plain text, and it's possible to determine which part of the string is the salt and which part is the password.  MD5-ing the result means that there is no way to figure the password out without attempting every string combination, and in the unlikely event they succeed they still will have a hard time determining which part is the salt based on one decoded password.</span></text><author><a class="comment-user" href="/users/231002/kalldrexx" title="14,548 reputation">KallDrexx</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The only vulnerability with salting is that you need to know what the salt is in order to reconstruct the hash for testing the password. This is gotten around by storing the entry in the authdb in the form <code>&lt;algorithm&gt;$&lt;salt&gt;$&lt;hash&gt;</code>. This way the authdb entry can be used by <em>any</em> code that has access to it.</p>
</div></text><author><a href="/users/20862/ignacio-vazquez-abrams">Ignacio Vazquez-Abrams</a></author><comments><comment><text><span class="comment-copy">I'm a little bit lost! I could follow your line of reasoning! Sorry! could could make it a little more newbie friendly?</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">If you store a password of "hello" with a salt of "12345", your code (and all code that wants to use the authdb) needs to have the salt of "12345" hardcoded in order to verify the password, since you have to hash the password and compare it to the stored hash. If you store the salt along with the hash then you don't need to have it hardcoded, and you can in fact use random salts instead, from any code that uses it. <code>sha1$12345$bighashgoeshere</code></span></text><author><a class="comment-user" href="/users/20862/ignacio-vazquez-abrams" title="478,668 reputation">Ignacio Vazquez-Abrams</a></author></comment><comment><text><span class="comment-copy">ok I think I see your point now! Thanks!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You're missing the important step - the salt. This is a unique (per user, ideally) bit of extra data that you add to the password before hashing it.</p>
<p><a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="nofollow">http://en.wikipedia.org/wiki/Salt_%28cryptography%29</a></p>
</div></text><author><a href="/users/71399/pauljwilliams">PaulJWilliams</a></author><comments><comment><text><span class="comment-copy">No, the salting is there.</span></text><author><a class="comment-user" href="/users/20862/ignacio-vazquez-abrams" title="478,668 reputation">Ignacio Vazquez-Abrams</a></author></comment><comment><text><span class="comment-copy">@Ignacio are you talking about my "invention" or when you do md5()?</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator: Your "invention" is called "salting the hash".</span></text><author><a class="comment-user" href="/users/20862/ignacio-vazquez-abrams" title="478,668 reputation">Ignacio Vazquez-Abrams</a></author></comment><comment><text><span class="comment-copy">@Ignacio, so it wasn't a bad idea after all? :)</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator: It's an excellent idea. See my answer for a caveat.</span></text><author><a class="comment-user" href="/users/20862/ignacio-vazquez-abrams" title="478,668 reputation">Ignacio Vazquez-Abrams</a></author></comment><comment><text><span class="comment-copy">The basic idea was good, but how you did it wasn't. You need to use <code>md5($pass.$salt)</code> or something similar where you mix the password with the salt before hashing.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Your idea (salting) is well known and is actually well-implemented in the PHP language. If you use <a href="http://php.net/manual/en/function.crypt.php" rel="nofollow">the <code>crypt()</code> function</a> it allows you to specify a string to hash, a method to encrypt (in some cases), and a salt. For example, </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$x </span><span class="pun">=</span><span class="pln"> crypt</span><span class="pun">(</span><span class="str">'insecure_password'</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">);</span></code></pre>
<p>Returns a hashed and salted password ready for storage. Passwords get cracked the same way that we check if they're right: we check the hash of what the user inputs against the hash of their password in the database. If they match, they're authenticated (AFAIK this is the most common way to do this, if not the only). <em>Insecure</em> passwords (like <code>password</code>) that use dictionary words can be cracked by comparing their hash to hashes of common passwords. <em>Secure</em> passwords cannot be cracked this way, but can still be cracked. Adding a salt to the password makes it much more difficult to crack: since the hacker most likely doesn't know what the salt is, his dictionary attack won't work.</p>
</div></text><author><a href="/users/399815/rafe-kettler">Rafe Kettler</a></author><comments><comment><text><span class="comment-copy">Ok now I'm starting to understand. Very clear explanation IMO. Thanks.</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>For a decent hash the attacker won't be reversing the hash, they'll be using a rainbow table, which is essentially a brute-force method made useful if everyone uses the same hash function.</p>
<p>The idea of a rainbow table is that since hashing is fast I can hash every possible value you could use as a password, store the result, and have a map of which hash connects to which password.  If everyone just takes their passwords and hashes them with MD5 then my hash table is good for any set of password hashes I can get my hands on!</p>
<p>This is where salting comes in.  If I take the password the user enters and add some data which is different for every user, then that list of pre-determined hashes is useless since the hash is of both the password and some random data.  The data for the salt could be stored right beside the password and even if I get both it doesn't help me get the password back since I still have to essentially brute force the hash separately for every single user - I can't form a single rainbow table to attack all the hashes at once.</p>
<p>Of course, ideally an attacker won't get the list of hashed passwords in the first place, but some employees will have access so it's not possible to secure the password database entirely.  </p>
</div></text><author><a href="/users/14092/tloach">tloach</a></author><comments><comment><text><span class="comment-copy">if you use <code>password</code> + <code>salt</code> you get 'hash', if your rainbow table is big enough, it will have <code>passAsaltA</code> and maybe <code>passBsaltB</code> as matches for that <code>hash</code>, you now some idea's on what the password maybe. if the site uses the same has for all, you'll be able to see it present in all the match results. The real problem is is your rainbow table big enough.</span></text><author><a class="comment-user" href="/users/43992/simeon-pilgrim" title="4,932 reputation">Simeon Pilgrim</a></author></comment><comment><text><span class="comment-copy">That's why I mentioned that the salt should be different for every user.  In the case that you're salting the password directly then the salt should also have a length and complexity greater than the average password, to prevent pass+salt from being hit by a standard rainbow table.  It's probably better to hash the password, add the salt to the hash, then rehash and store the result.</span></text><author><a class="comment-user" href="/users/14092/tloach" title="7,312 reputation">tloach</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In addition to providing salt (or seed), the md5 is a complex hashing algorithm which uses mathematical rules to produce a result that is specifically not reversable because of the mathematical changes and dataloss in throughput.</p>
<p><a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="nofollow">http://en.wikipedia.org/wiki/Cryptographic_hash_function</a></p>
</div></text><author><a href="/users/250832/joel-etherton">Joel Etherton</a></author><comments><comment><text><span class="comment-copy">Did you see my link? <a href="http://md5.rednoize.com/" rel="nofollow noreferrer">md5.rednoize.com</a></span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator - Sorry, that link is blocked my company's firewall.</span></text><author><a class="comment-user" href="/users/250832/joel-etherton" title="30,643 reputation">Joel Etherton</a></author></comment><comment><text><span class="comment-copy">@Joel no problem, it just reverses md5 hashes instantly.</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">@Akinator - that's just it, it doesn't. It makes a GUESS at what the original message is, but it won't always get it right. As someone else said, md5 is not strong because there are too many collisions (different messages with identical hashes). The inherent problem is that these collisions do create vulnerabilities because it becomes easier to find a match than it should be.</span></text><author><a class="comment-user" href="/users/250832/joel-etherton" title="30,643 reputation">Joel Etherton</a></author></comment><comment><text><span class="comment-copy">@Joel thanks for the clarification! it makes more sense now! thanks!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">MD5 isn't insecure because of the collisions, it's insecure because it was designed for speed. A fast hashing algorithm means it's easier to check for collisions, or for the original message. My computer can generate and check thousands of md5 passwords per second. That's the real problem.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">@Malfist - I didn't say that was the only problem, only one of the problems. You even mention that it's easier to check for collisions because of the nature of the algorithm.</span></text><author><a class="comment-user" href="/users/250832/joel-etherton" title="30,643 reputation">Joel Etherton</a></author></comment><comment><text><span class="comment-copy">Yes that's a problem, but not the primary problem. SHA doesn't have the same problems with collisions, but it's also considered insecure for the same reason md5 is, it's designed for speed.</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><code>md5</code> (or better put: hash algorithms in general) are used to safely store passwords in database. The most important thing to know about hashes is: <strong>Hashes are not encryptions per se.</strong> (they are one-way-encryptions at most). If you encrypt something, you can get the data back with the key you used. A hash generates a fixed-length value from an arbitrary input (like a string), which can be used to see if the same input was used.</p>
<p>Hashes are used to store sensitive, repeatly entered data in a storage device. Doing this, nobody can recreate the original input from the hash data, but you can hash an incoming password and compare it to the value in the database, and see if both are the same, if so, the password was correct.</p>
<p>You already pointed out, that there possibilites to break the algorithm, either by using a database of value/hash pairs or producing collisions (different values resulting in the hash value). You can obscure this a bit by using a salt, thus modifying the algorithm. But if the salt is known, it can be used to break the algorithm again.</p>
</div></text><author><a href="/users/127059/femaref">Femaref</a></author><comments><comment><text><span class="comment-copy">Thanks I get your point regarding the SALT part, now what I dont get is why is exactly what you say about md5, this is exactly what triggered my question, why compare "jfnvsv123" (hashed password) against "jfnvsv123" when you could just compare "123" agaist "123" beacuse the hashed one is easily reversible.</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">The point is - it is not. The reason why it is easily reversible lies in the fact of <code>md5</code> (and also recently, <code>sha1</code>) being quite old, and the only reason it wasn't cracked (as in: producing enough collisions) was that the computers weren't fast enough. The page you linked doesn't "crack" the password, it uses a simple database to look it up. If no one else supplied the original input before, you won't get something back.</span></text><author><a class="comment-user" href="/users/127059/femaref" title="49,922 reputation">Femaref</a></author></comment><comment><text><span class="comment-copy">@Ok that makes sense that it doesn't "crack" the hash. It actually doesn't work por loger "passwords"</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment><comment><text><span class="comment-copy">well, it works after you put the clear text into it ;)</span></text><author><a class="comment-user" href="/users/127059/femaref" title="49,922 reputation">Femaref</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I like this question. But I think you've really answered yourself.  </p>
<p>The site you referenced uses dictionary lookups of known, unsalted, md5's - it doesn't "crack" anything.  </p>
<p>Your example is almost good, except your application needs to be able to regenerate the md5 using the same salt every time.  </p>
<p>Your example appears to use one of the random salts, which will fail 2 of 3 times if you try to compare a users password hash to something input. </p>
<p>People will tell you to also use SHA1 or SHA256 to be have a 'stronger' hash - but people will also argue that they're all 'broken.'</p>
</div></text><author><a href="/users/89208/darryl-e-clarke">Darryl E. Clarke</a></author><comments><comment><text><span class="comment-copy">I see that now, you explained it very clearly thank you, but I can't see why NOT using random salts will help, lets say I get the whole array out of the hash, wouldn't that be enough?</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>That documentation is misleading -- it teaches a "vulnerable" concept and presents it as somehow being "secure" because it (the saved password) looks like gibberish. Just internet junk that won't die. The following link should clear things up (you have already found a good bit of it though, it seems. Good work.)</p>
<p><a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow">Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</a> talks about MD5 (and why it should not be used) along with salt (e.g. how to thwart rainbow attacks) as well as provides useful insights (such as "Use someone else’s password system. Don’t build your own"). It is a fairly good overview.</p>
</div></text><author><a>NONE</a></author><comments><comment><text><span class="comment-copy">+1 for sharing an example, thank you! I will give it a look! I found this one <a href="http://tinsology.net/2009/06/creating-a-secure-login-system-the-right-way/" rel="nofollow noreferrer">tinsology.net/2009/06/…</a> which seems promising too I guess, still haven't found time. Thanks again!!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>This is my question about the aspects of md5 collision, slightly related to your question:</p>
<p><a href="http://stackoverflow.com/questions/2942671/is-there-any-difference-between-md5-and-sha1-in-this-situation">Is there any difference between md5 and sha1 in this situation?</a></p>
<p>The important part is in the first 3 rows, that is: you <strong>must put</strong> your salt <strong>before</strong> the password, if you want to achieve stronger protection, <strong>not after</strong>.</p>
</div></text><author><a href="/users/89364/vili">Vili</a></author><comments><comment><text><span class="comment-copy">to be honest, I couldn't fully understand whats going on there :) but i'll take your advice!</span></text><author><a class="comment-user owner" href="/users/463065/trufa" title="15,625 reputation">Trufa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To simply answer the title of your question, md5's only real use nowadays is for hashing large strings (such as files) to produce checksums. These are typically used to see if both strings are identical (in terms of files, checksums are frequently used for security purposes to ensure a file being distributed hasn't been tampered with, for example).</p>
<p>To address each of your inline questions:</p>
<blockquote>
<p>How does password encryption work?
  How would you have to apply password encryption so that it is actually useful?</p>
</blockquote>
<p>Secure password <em>hashing</em> works by taking the password in plain text form, and then applying a costly hashing function to it, salted with a <strong>cryptographically secure</strong> random salt to it. See the <a href="http://stackoverflow.com/questions/401656/secure-hash-and-salt-for-php-passwords?rq=1">Secure hash and salt for PHP passwords</a> question for more detail on this.</p>
<blockquote>
<p>What about this idea?</p>
</blockquote>
<p>Password hashing does not need to be complicated like that, and nor should it be. Avoid thinking up your own algorithms and stick with the tried and tested hashing algorithms already out there. As the question linked above mentions, <code>md5()</code> for password hashing has been obsolete for many years now, and so it should be avoided.</p>
<p>Your method of generating a "random" salt from an array of three different salts is not the randomness you're looking for. You need unique randomness that is suitable for cryptographically secure (i.e. using a cryptically secure pseudo-random number generator (CSPRNG)). If you're using PHP 7 and above, then the <a href="http://php.net/random_bytes" rel="nofollow">random_bytes</a> function can be used to generate a cryptographically secure salt (for PHP 5 users, the <a href="https://github.com/paragonie/random_compat" rel="nofollow">random_compat</a> library can be used).</p>
</div></text><author><a href="/users/4530326/tpunt">tpunt</a></author><comments/></answer></answers></post>