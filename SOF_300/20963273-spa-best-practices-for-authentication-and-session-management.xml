<?xml version="1.0" encoding="utf-8"?>
<post><title>security - SPA best practices for authentication and session management - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>When building SPA style applications using frameworks like Angular, Ember, React, etc. what do people believe to be some best practices for authentication and session management? I can think of a couple of ways of considering approaching the problem.</p>
<ol>
<li><p>Treat it no differently than authentication with a regular web application assuming the API and and UI have the same origin domain. </p>
<p>This would likely involve having a session cookie, server side session storage and probably some session API endpoint that the authenticated web UI can hit to get current user information to help with personalization or possibly even determining roles/abilities on the client side. The server would still enforce rules protecting access to data of course, the UI would just use this information to customize the experience.</p></li>
<li><p>Treat it like any third-party client using a public API and authenticate with some sort of token system similar to OAuth. This token mechanism would used by the client UI to authenticate each and every request made to the server API.</p></li>
</ol>
<p>I'm not really much of an expert here but #1 seems to be completely sufficient for the vast majority of cases, but I'd really like to hear some more experienced opinions.</p>
</div></text><author><a href="/users/75642/robert-koritnik">Robert Koritnik</a></author><comments><comment><text><span class="comment-copy">I perfer this way, <a href="http://stackoverflow.com/a/19820685/454252">stackoverflow.com/a/19820685/454252</a></span></text><author><a class="comment-user" href="/users/454252/allenhwkim" title="16,415 reputation">allenhwkim</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>This question has been addressed, in a slightly different form, at length, here: </p>
<p><a href="http://stackoverflow.com/questions/319530/restful-authentication">RESTful Authentication</a></p>
<p>But this addresses it from the server-side. Let's look at this from the client-side. Before we do that, though, there's an important prelude:</p>
<h2>Javascript Crypto is Hopeless</h2>
<p>Matasano's article on this is famous, but the lessons contained therein are pretty important:</p>
<p><a href="http://www.matasano.com/articles/javascript-cryptography/">http://www.matasano.com/articles/javascript-cryptography/</a></p>
<p>To summarize: </p>
<ul>
<li>A man-in-the-middle attack can trivially replace your crypto code with <code>&lt;script&gt;
function hash_algorithm(password){ lol_nope_send_it_to_me_instead(password); }&lt;/script&gt;</code></li>
<li>A man-in-the-middle attack is trivial against a page that serves any resource over a non-SSL connection.</li>
<li>Once you have SSL, you're using real crypto anyways.</li>
</ul>
<p>And to add a corollary of my own:</p>
<ul>
<li>A successful XSS attack can result in an attacker executing code on your client's browser, even if you're using SSL - so even if you've got every hatch battened down, your browser crypto can still fail if your attacker finds a way to execute any javascript code on someone else's browser. </li>
</ul>
<p>This renders a lot of RESTful authentication schemes impossible or silly if you're intending to use a JavaScript client. Let's look! </p>
<h2>HTTP Basic Auth</h2>
<p>First and foremost, HTTP Basic Auth. The simplest of schemes: simply pass a name and password with every request.</p>
<p>This, of course, absolutely requires SSL, because you're passing a Base64 (reversibly) encoded name and password with every request. Anybody listening on the line could extract username and password trivially. Most of the "Basic Auth is insecure" arguments come from a place of "Basic Auth over HTTP" which is an awful idea. </p>
<p>The browser provides baked-in HTTP Basic Auth support, but it is ugly as sin and you probably shouldn't use it for your app. The alternative, though, is to stash username and password in JavaScript.</p>
<p>This is the most RESTful solution. The server requires no knowledge of state whatsoever and authenticates every individual interaction with the user. Some REST enthusiasts (mostly strawmen) insist that maintaining any sort of state is heresy and will froth at the mouth if you think of any other authentication method. There are theoretical benefits to this sort of standards-compliance - it's supported by Apache out of the box - you could store your objects as files in folders protected by .htaccess files if your heart desired!</p>
<p>The <strong>problem</strong>? You are caching on the client-side a username and password. This gives evil.ru a better crack at it - even the most basic of XSS vulnerabilities could result in the client beaming his username and password to an evil server. You could try to alleviate this risk by hashing and salting the password, but remember: <strong>JavaScript Crypto is Hopeless</strong>. You could alleviate this risk by leaving it up to the Browser's Basic Auth support, but.. ugly as sin, as mentioned earlier. </p>
<h2>HTTP Digest Auth</h2>
<p><a href="http://stackoverflow.com/questions/5288150/digest-authentication-w-jquery-is-it-possible">Digest Authentication w/ Jquery, is it possible?</a></p>
<p>A more "secure" auth, this is a request/response hash challenge. Except <strong>JavaScript Crypto is Hopeless</strong>, so it only works over SSL and you still have to cache the username and password on the client side, making it more complicated than HTTP Basic Auth but <em>no more secure</em>.</p>
<h2>Query Authentication with Additional Signature Parameters.</h2>
<p>Another more "secure" auth, where you encrypt your parameters with nonce and timing data (to protect against repeat and timing attacks) and send the. One of the best examples of this is the OAuth 1.0 protocol, which is, as far as I know, a pretty stonking way to implement authentication on a REST server. </p>
<p><a href="http://tools.ietf.org/html/rfc5849">http://tools.ietf.org/html/rfc5849</a></p>
<p>Oh, but there aren't any OAuth 1.0 clients for JavaScript. Why?  </p>
<p><strong>JavaScript Crypto is Hopeless</strong>, remember. JavaScript can't participate in OAuth 1.0 without SSL, and you still have to store the client's username and password locally - which puts this in the same category as Digest Auth - it's more complicated than HTTP Basic Auth but it's <em>no more secure</em>. </p>
<h2>Token</h2>
<p>The user sends a username and password, and in exchange gets a token that can be used to authenticate requests. </p>
<p>This is marginally more secure than HTTP Basic Auth, because as soon as the username/password transaction is complete you can discard the sensitive data. It's also less RESTful, as tokens constitute "state" and make the server implementation more complicated. </p>
<h3>SSL Still</h3>
<p>The rub though, is that you still have to send that initial username and password to get a token. Sensitive information still touches your compromisable JavaScript. </p>
<p>To protect your user's credentials, you still need to keep attackers out of your JavaScript, and you still need to send a username and password over the wire. SSL Required.</p>
<h3>Token Expiry</h3>
<p>It's common to enforce token policies like "hey, when this token has been around too long, discard it and make the user authenticate again." or "I'm pretty sure that the only IP address allowed to use this token is <code>XXX.XXX.XXX.XXX</code>". Many of these policies are pretty good ideas.</p>
<h3>Firesheeping</h3>
<p>However, using a token Without SSL is still vulnerable to an attack called 'sidejacking': <a href="http://codebutler.com/firesheep/">http://codebutler.com/firesheep/</a></p>
<p>The attacker doesn't get your user's credentials, but they can still pretend to be your user, which can be pretty bad. </p>
<p>tl;dr: Sending unencrypted tokens over the wire means that attackers can easily nab those tokens and pretend to be your user. FireSheep is a program that makes this very easy. </p>
<h3>A Separate, More Secure Zone</h3>
<p>The larger the application that you're running, the harder it is to absolutely ensure that they won't be able to inject some code that changes how you process sensitive data. Do you absolutely trust your CDN? Your advertisers? Your own code base? </p>
<p>Common for credit card details and less common for username and password - some implementers keep 'sensitive data entry' on a separate page from the rest of their application, a page that can be tightly controlled and locked down as best as possible, preferably one that is difficult to phish users with. </p>
<h2>Cookie (just means Token)</h2>
<p>It is possible (and common) to put the authentication token in a cookie. This doesn't change any of the properties of auth with the token, it's more of a convenience thing. All of the previous arguments still apply. </p>
<h2>Session (still just means Token)</h2>
<p>Session Auth is just Token authentication, but with a few differences that make it seem like a slightly different thing: </p>
<ul>
<li>Users start with an unauthenticated token.</li>
<li>The backend maintains a 'state' object that is tied to a user's token.</li>
<li>The token is provided in a cookie.</li>
<li>The application environment abstracts the details away from you.</li>
</ul>
<p>Aside from that, though, it's no different from Token Auth, really.</p>
<p>This wanders even further from a RESTful implementation - with state objects you're going further and further down the path of plain ol' RPC on a stateful server.  </p>
<h2>OAuth 2.0</h2>
<p>OAuth 2.0 looks at the problem of "How does Software A give Software B access to User X's data without Software B having access to User X's login credentials."</p>
<p>The implementation is very much just a standard way for a user to get a token, and then for a third party service to go "yep, this user and this token match, and you can get some of their data from us now." </p>
<p>Fundamentally, though, OAuth 2.0 is just a token protocol. It exhibits the same properties as other token protocols - you still need SSL to protect those tokens - it just changes up how those tokens are generated.</p>
<p>There are two ways that OAuth 2.0 can help you: </p>
<ul>
<li>Providing Authentication/Information to Others </li>
<li>Getting Authentication/Information from Others</li>
</ul>
<p>But when it comes down to it, you're just... using tokens. </p>
<h2>Back to your question</h2>
<p>So, the question that you're asking is "should I store my token in a cookie and have my environment's automatic session management take care of the details, or should I store my token in Javascript and handle those details myself?" </p>
<p>And the answer is: <em>do whatever makes you happy</em>. </p>
<p>The thing about automatic session management, though, is that there's a lot of magic happening behind the scenes for you. Often it's nicer to be in control of those details yourself. </p>
<h2>I am 21 so SSL is yes</h2>
<p>The other answer is: Use https for everything or brigands will steal your users' passwords and tokens.</p>
</div></text><author><a href="/users/464436/curtis-lassam">Curtis Lassam</a></author><comments><comment><text><span class="comment-copy">Great answer. I appreciate the equivalence between token auth systems and basic cookie auth (which is often built into the web framework). That's sort of what I was looking for. I appreciate you covering so many potential issues for consideration too. Cheers!</span></text><author><a class="comment-user owner" href="/users/235243/chris-nicola" title="6,900 reputation">Chris Nicola</a></author></comment><comment><text><span class="comment-copy">I know it's been a while but I'm wondering if this should be expanded to include JWT? <a href="https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/" rel="nofollow noreferrer">auth0.com/blog/2014/01/07/…</a></span></text><author><a class="comment-user owner" href="/users/235243/chris-nicola" title="6,900 reputation">Chris Nicola</a></author></comment><comment><text><span class="comment-copy">finally found a person that really understand security, by reading the way he explain it, well done Curtis.</span></text><author><a class="comment-user" href="/users/241004/jawad-al-shaikh" title="758 reputation">Jawad Al Shaikh</a></author></comment><comment><text><span class="comment-copy"><b>Token</b> <code>It's also less RESTful, as tokens constitute "state and make the server implementation more complicated."</code> (1) REST requires the <i>server</i> to be stateless. A token stored <i>client-side</i> doesn't represent state in any meaningful way for the server. (2) Marginally more complicated server-side code has nothing to do with RESTfulness.</span></text><author><a class="comment-user" href="/users/183840/soupdog" title="302 reputation">soupdog</a></author></comment><comment><text><span class="comment-copy">@ChrisNicola JWT is basically one implementation of the <b>Token</b> method above. Same implications.</span></text><author><a class="comment-user" href="/users/183840/soupdog" title="302 reputation">soupdog</a></author></comment><comment><text><span class="comment-copy">Best answer in the entire stackoverflow!</span></text><author><a class="comment-user" href="/users/5018962/eddyp23" title="387 reputation">eddyP23</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can increase security in authentication process by using JWT <em>(JSON Web Tokens)</em> and SSL/HTTPS.</p>
<p>The Basic Auth / Session ID can be stolen via:</p>
<ul>
<li>MITM attack (Man-In-The-Middle) - <em>without SSL/HTTPS</em></li>
<li>An intruder gaining access to a user's computer</li>
<li>XSS</li>
</ul>
<p>By using JWT you're encrypting the user's authentication details and storing in the client, and sending it along with every request to the API, where the server/API validates the token. <strike>It can't be decrypted/read without the private key (which the server/API stores secretly)</strike> <strong>Read update</strong>.</p>
<p><strong>The new (more secure) flow would be:</strong></p>
<h3>Login</h3>
<ul>
<li>User logs in and sends login credentials to API <em>(over SSL/HTTPS)</em></li>
<li>API receives login credentials</li>
<li>If valid:

<ul>
<li>Register a new session in the database <strong>Read update</strong></li>
<li>Encrypt User ID, Session ID, IP address, timestamp, etc. in a JWT with a private key.</li>
</ul></li>
<li>API sends the JWT token back to the client <em>(over SSL/HTTPS)</em></li>
<li>Client receives the JWT token and stores in localStorage/cookie</li>
</ul>
<h3>Every request to API</h3>
<ul>
<li>User sends a HTTP request to API <em>(over SSL/HTTPS)</em> with the stored JWT token in the HTTP header</li>
<li>API reads HTTP header and decrypts JWT token with its private key</li>
<li>API validates the JWT token, matches the IP address from the HTTP request with the one in the JWT token and checks if session has expired</li>
<li>If valid:

<ul>
<li>Return response with requested content</li>
</ul></li>
<li>If invalid:

<ul>
<li>Throw exception (403 / 401)</li>
<li>Flag intrusion in the system</li>
<li>Send a warning email to the user.</li>
</ul></li>
</ul>
<p><strong>Updated 30.07.15:</strong></p>
<p>JWT payload/claims can actually be read without the private key (secret) and it's not secure to store it in localStorage. I'm sorry about these false statements. However they seem to be working on a <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-40" rel="noreferrer">JWE standard <em>(JSON Web Encryption)</em></a>.</p>
<p>I implemented this by storing claims (userID, exp) in a JWT, signed it with a private key (secret) the API/backend only knows about and stored it as a secure HttpOnly cookie on the client. That way it cannot be read via XSS and cannot be manipulated, otherwise the JWT fails signature verification. Also by using a <em>secure HttpOnly</em> cookie, you're making sure that the cookie is sent only via HTTP requests (not accessible to script) and only sent via secure connection (HTTPS).</p>
<p><strong>Updated 17.07.16:</strong></p>
<p>JWTs are by nature stateless. That means they invalidate/expire themselves. By adding the SessionID in the token's claims you're making it stateful, because its validity doesn't now only depend on signature verification and expiry date, it also depends on the session state on the server. However the upside is you can invalidate tokens/sessions easily, which you couldn't before with stateless JWTs.</p>
</div></text><author><a href="/users/1053611/gaui">Gaui</a></author><comments><comment><text><span class="comment-copy">In the end a JWT is still 'just a token' from a security standpoint I think. The server could still associate the user id, IP address, timestamp etc. with an opaque session token and it would be no more or less secure than a JWT. However, the stateless nature of JWT does make the implementation easier.</span></text><author><a class="comment-user" href="/users/165783/james" title="1,713 reputation">James</a></author></comment><comment><text><span class="comment-copy">@James the JWT has the advantage of being verifiable and capable of carrying key details. This is pretty useful for various API scenarios, like where cross-domain auth is required. Something a session won't be as good for. It is also a defined (or at least in progress) spec, which is useful for implementations. That isn't to say it's any better than any other good token implementation, but it is well defined and convenient.</span></text><author><a class="comment-user owner" href="/users/235243/chris-nicola" title="6,900 reputation">Chris Nicola</a></author></comment><comment><text><span class="comment-copy">@Chris Yes I agree with all of your points. However, the flow described in the answer above is not inherently a more secure flow as claimed due to the use of a JWT. Furthermore, the JWT is not revocable in the scheme described above unless you associate an identifier with JWT and store state on the server. Otherwise you either need to regularly get a new JWT by requesting username/password (poor user experience) or issue a JWT with a very long expiry time (bad if the token gets stolen).</span></text><author><a class="comment-user" href="/users/165783/james" title="1,713 reputation">James</a></author></comment><comment><text><span class="comment-copy">OP and @ChrisNicola - I love JWT but only find it particularly useful when the token is only signed/encoded (not encrypted) so that the client actually gains some value from using it and not using a backed session database.  What would be less secure about taking the verifiable details that we want to keep private on the client (IP Address, etc.), encrypting them, and storing the hashed value in a claim on the token.  Then on the server undergo the standard JWT validation on each request with an additional check that decrypts the private details claim to test if it matches the request details?</span></text><author><a class="comment-user" href="/users/769871/cchamberlain" title="5,640 reputation">cchamberlain</a></author></comment><comment><text><span class="comment-copy">My answer is not 100% correct, because JWT can actually be decrypted/read without the private key (secret) and it's not secure to store it in localStorage. I implemented this by storing claims (userID, exp) in a JWT, signed it with a private key (secret) the API/backend only knows about and stored it as a HttpOnly cookie on the client. That way it cannot be read by XSS. But you have to use HTTPS because the token could be stolen with MITM attack. I will update my answer to reflect on this.</span></text><author><a class="comment-user" href="/users/1053611/gaui" title="2,595 reputation">Gaui</a></author></comment><comment><text><span class="comment-copy">As a rule I would suggest never communicating anything remotely comprising in a JWT token. Usually just a user ID and the token details. Perhaps some of the permissions or roles allowed for by the token if you are using it in some sort of federated system.</span></text><author><a class="comment-user owner" href="/users/235243/chris-nicola" title="6,900 reputation">Chris Nicola</a></author></comment><comment><text><span class="comment-copy">@James, yes I wouldn't call JWT "more" secure than other <i>well implemented</i> token strategies. It is however both simple and well defined by it it's RFC, which I do think are very useful properties.</span></text><author><a class="comment-user owner" href="/users/235243/chris-nicola" title="6,900 reputation">Chris Nicola</a></author></comment><comment><text><span class="comment-copy">Sounds a bit like "OpenID Connect" what you're describing.</span></text><author><a class="comment-user" href="/users/470517/aydin-k" title="717 reputation">Aydin K.</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I would go for the second, the token system.</p>
<p>Did you know about <a href="https://github.com/heartsentwined/ember-auth">ember-auth</a> or <a href="https://github.com/simplabs/ember-simple-auth">ember-simple-auth</a>? They both use the token based system, like ember-simple-auth states:</p>
<blockquote>
<p>A lightweight and unobtrusive library for implementing token based
  authentication in Ember.js applications.
  <a href="http://ember-simple-auth.simplabs.com">http://ember-simple-auth.simplabs.com</a></p>
</blockquote>
<p>They have session management, and are easy to plug into existing projects too.</p>
<p>There is also an Ember App Kit example version of ember-simple-auth: <a href="https://github.com/erkarl/ember-app-kit-simple-auth/">Working example of ember-app-kit using ember-simple-auth for OAuth2 authentication.</a></p>
</div></text><author><a href="/users/1153884/delphilynx">DelphiLynx</a></author><comments/></answer></answers></post>