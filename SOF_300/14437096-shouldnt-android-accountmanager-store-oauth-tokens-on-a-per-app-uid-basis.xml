<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Shouldn't Android AccountManager Store OAuth Tokens on a Per-App/UID Basis? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Android's AccountManager appears to fetch the same cached auth token for apps with different UIDs - is this secure? It does not seem compatible with OAuth2, since access tokens are not supposed to be shared between different clients.</p>
<h2>Background/Context</h2>
<p>I am building an Android app which uses OAuth2 for authentication/authorization of REST API requests to my server, which is an OAuth2 provider. Since the app is the "official" app (as opposed to a 3rd-party app), it is considered a trusted OAuth2 client, so I am using the resource owner password flow for obtaining an OAuth2 token: the user (the resource owner) enters his username/password into the app, which then sends its client ID and client secret along with the user credentials to my server's OAuth2 token endpoint in exchange for an access token that can be used to make API calls, as well as a long-lived refresh token used to get new access tokens when they expire. The rationale is that it is more secure to store the refresh token on the device than the user's password.</p>
<p>I am utilizing <a href="http://developer.android.com/reference/android/accounts/AccountManager.html" rel="noreferrer">AccountManager</a> for managing the account and associated access token on the device. Since I am providing my own OAuth2 provider, I have created my own custom account type by extending <a href="http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html" rel="noreferrer">AbstractAccountAuthenticator</a> and other required components, as explained <a href="http://developer.android.com/training/id-auth/custom_auth.html" rel="noreferrer">in this Android Dev Guide</a> and demonstrated in the SampleSyncAdapter sample project. I am able to successfully add accounts of my custom type from within my app and manage them from the "Accounts and sync" Android settings screen.</p>
<h2>The Issue</h2>
<p>However, I am concerned with the way the AccountManager caches and issues auth tokens - specifically, that <strong>the same auth token for a given account type and token type seems to be accessible by any app to which the user has granted access.</strong> </p>
<p>To obtain an auth token through the AccountManager, one must invoke <a href="http://developer.android.com/reference/android/accounts/AccountManager.html#getAuthToken%28android.accounts.Account,%20java.lang.String,%20android.os.Bundle,%20android.app.Activity,%20android.accounts.AccountManagerCallback%3Candroid.os.Bundle%3E,%20android.os.Handler%29" rel="noreferrer">AccountManager.getAuthToken()</a>, passing, among other things, the <a href="http://developer.android.com/reference/android/accounts/Account.html" rel="noreferrer">Account</a> instance for which to obtain the auth token and the desired <code>authTokenType</code>. If an auth token exists for the specified account and authTokenType, and if the user grants access (via the grant <a href="http://1.bp.blogspot.com/-2H_e7jCKEyQ/UJdvyERleHI/AAAAAAAAJiE/3ce0q6Mguyk/s400/gls-gb-gant-screen.png" rel="noreferrer">"Access Request"</a> screen) to the app which has made the auth token request (in such cases where the requesting app's UID does not match the authenticator's UID), then the token is returned. In case my explanation is lacking, <a href="http://nelenkov.blogspot.com/2012/11/android-online-account-management.html" rel="noreferrer">this helpful blog entry</a> explains it very clearly. Based on that post, and after examining the source of <a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/accounts/AccountManager.java" rel="noreferrer">AccountManager</a> and <a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/accounts/AccountManagerService.java" rel="noreferrer">AccountManagerService</a> (an internal class which does the heavy lifting for AccountManager) for myself, it appears that <strong>only 1 auth token is stored per authTokenType/account combo.</strong> </p>
<p>So, it seems feasible that <strong>if a malicious app knew the account type and authTokenType(s) used by my authenticator, it could invoke AccountManager.getAuthToken() to obtain access my app's stored OAuth2 token,</strong> assuming that the user grants access to the malicious app.</p>
<p>To me, the problem is that AccountManager's default caching implementation is built on a paradigm on which, if we were to layer an OAuth2 authentication/authorization context, it would consider the phone/device to be a single OAuth2 client for a service/resource provider. <strong>Whereas, the paradigm that makes sense to me is that each app/UID should be considered as its own OAuth2 client.</strong> When my OAuth2 provider issues an access token, it is issuing an access token for that particular app which has sent the correct client ID and client secret, not all apps on the device. For instance, the user might have both my official app (call it app Client A), and a "licensed" third-party app which uses my API (call it app Client B) installed. For the official Client A, my OAuth2 provider may issue a "super" type/scope token which grants access to both public and private pieces of my API, whereas for the third-party Client B, my provider may issue a "restricted" type/scope token which only grants access to the the public API calls. <strong>It should not be possible for app Client B to obtain app Client A's access token, which the current AccountManager/AccountManagerService implementation seems to allow.</strong> For, even if the user grants authorization to Client B for Client A's super token, the fact remains that my OAuth2 provider only intended to grant that token to Client A.</p>
<p>Am I overlooking something here? Is my belief that auth tokens to should be issued on a per-app/UID basis  (each app being a distinct client) rational/practical, or are auth-tokens-per-device (each device being a client) the standard/accepted practice?</p>
<p>Or is there some flaw in my understanding of the code/security restrictions around <code>AccountManager</code>/<code>AccountManagerService</code>, such that this vulnerability does not actually exist? I've tested the above Client A/Client B scenario with the <code>AccountManager</code> and my custom authenticator, and my test client app B, which has a different package scope and UID, was able to obtain the auth token that my server had issued for my test client app A by passing-in the same <code>authTokenType</code> (during which I was prompted with "Access Request" grant screen, which I approved since I'm a user and therefore clueless)...</p>
<h2>Possible Solutions</h2>
<p><strong>a. "Secret" authTokenType</strong><br/>
In order to obtain the auth token, the <a href="http://stackoverflow.com/a/4774158/1429387"><code>authTokenType</code></a> must be known; should the <code>authTokenType</code> be treated as a type of client secret, such that a token issued for a given secret token type may be obtained by only those "authorized" client apps which know the secret token type? This does  not seem very secure; on a rooted device, it would be possible to examine the <code>auth_token_type</code> column of <code>authtokens</code> table in the system's <code>accounts</code> database and examine authTokenType values that are stored with my tokens. Thus, the "secret" auth token types used across all installations of my app (and any authorized third-party apps used on the device) will have been exposed in one central location. At least with OAuth2 client IDs/secrets, even if they must be packaged with the app, they are spread out among different client apps, and some attempt may be made to obfuscate them (which is better than nothing) to help discourage those who would unpackage/decompile the app.</p>
<p><strong>b. Custom Auth Tokens</strong><br/>
According to the docs for <a href="http://developer.android.com/reference/android/accounts/AccountManager.html#KEY_CALLER_UID" rel="noreferrer">AccountManager.KEY_CALLER_UID</a> and <a href="http://developer.android.com/reference/android/accounts/AuthenticatorDescription.html#customTokens" rel="noreferrer">AuthenticatorDescription.customTokens</a>, and the <code>AccountManagerService</code> source code I referenced earlier, I should be able to specify that my custom account type uses "custom tokens" and spin my own token caching/storage implementation within my custom authenticator, wherein I can obtain the UID of the calling app in order store/fetch auth tokens on a per-UID basis. Basically, I would have an <code>authtokens</code> table like the default implementation, except there would be an added <code>uid</code> column so that tokens are uniquely indexed on U̲I̲D̲, a̲c̲c̲o̲u̲n̲t̲, and A̲u̲t̲h̲ ̲T̲o̲k̲e̲n̲ ̲T̲y̲p̲e̲ (as opposed to just a̲c̲c̲o̲u̲n̲t̲ and A̲u̲t̲h̲ ̲T̲o̲k̲e̲n̲ ̲T̲y̲p̲e̲). This seems like a more secure solution than using "secret" authTokenTypes, since that would involve using the same <code>authTokenTypes</code> across all installations of my app/authenticator, whereas UIDs vary from system-to-system, and cannot be easily spoofed. Aside from the joyful overhead of getting to write and manage my own token caching mechanism, what downsides are there to this approach in terms of security? Is it overkill? Am I really protecting anything, or am I missing something such that even with such an implementation in place, it would still be easy enough for one malicious app client to obtain another app client's auth token using the <code>AccountManager</code> and <code>authTokenType</code>(s) which are not guaranteed to be secret (assuming that said malicious app does not know the OAuth2 client secret, and therefore cannot directly get a fresh token but could only hope to get one that was already cached in the <code>AccountManager</code> on behalf of the authorized app client)? </p>
<p><strong>c. Send client ID/secret w/ OAuth2 token</strong><br/>
I could stick with the <code>AccountManagerService</code>'s default token storage implementation and accept the possibility of unauthorized access to my app's auth token, but I could force API requests to always include the OAuth2 client ID and client secret, in addition to the access token, and verify server-side that the app is the authorized client for which the token was issued in the first place. However, I would like to avoid this because <strong>A)</strong> AFAIK, the OAuth2 spec does not require client authentication for protected resource requests - only the access token is required, and <strong>B)</strong> I would like to avoid the additional overhead of authenticating the client on each request.</p>
<blockquote>
<p>This isn't possible in the general case (all the server gets is a series of messages in a protocol - the code that generated those messages can't be determined). --<a href="http://stackoverflow.com/questions/14437096/shouldnt-android-accountmanager-store-oauth-tokens-on-a-per-app-uid-basis/14468836#14468836">Michael</a></p>
</blockquote>
<p>But the same could be said of the initial client authentication in the OAuth2 flow during which the client is first issued the access token. The only difference is that instead of authenticating on just the token request, requests for protected resources would also be authenticated in the same way. (Note that the client app would be able to pass in its c̲l̲i̲e̲n̲t̲ ̲i̲d̲ and c̲l̲i̲e̲n̲t̲ ̲s̲e̲c̲r̲e̲t̲ through the <code>loginOptions</code> parameter of <code>AccountManager.getAuthToken()</code>, which my custom authenticator would just pass to my resource provider, per the OAuth2 protocol).</p>
<hr/>
<h1>Key Questions</h1>
<ol>
<li><strong>Is it indeed possible for one app to obtain another app's authToken</strong> for an account by invoking AccountManager.getAuthToken() with the same authTokenType? </li>
<li><p>If this is possible, <strong>is this a valid/practical security concern within an OAuth2 context?</strong> </p>
<blockquote>
<p>You could never rely on an auth token given to a user remaining secret from that user...so it's reasonable for Android to ignore this security by obscurity goal in its design --<a href="http://stackoverflow.com/questions/14437096/shouldnt-android-accountmanager-store-oauth-tokens-on-a-per-app-uid-basis/14468836#14468836">Michael</a></p>
</blockquote>
<p><strong>BUT</strong> - I'm not concerned about the user (the resource owner) getting the auth token without my consent; I'm concerned about <em>unauthorized clients</em> (apps). If the user wants to be an attacker of his own protected resources, then he can knock himself out. I'm saying it should not be possible that a user installs my client app and, unwittingly, an "imposter" client app that is able to gain access to my app's auth token simply because it passed-in the correct authTokenType and the user was too lazy/unaware/rushed to examine the access request screen. This analogy may be a bit oversimplified, but I don't consider it "security by obscurity" that my installed Facebook app cannot read emails cached by my Gmail app, which is different from me (the user) rooting my phone and examining the cache contents myself.</p>
<blockquote>
<p>The user needed to accept an (Android system provided) access request for the app to use your token... Given that, the Android solution seems OK - apps can't silently use a user's authentication without asking --<a href="http://stackoverflow.com/questions/14437096/shouldnt-android-accountmanager-store-oauth-tokens-on-a-per-app-uid-basis/14468836#14468836">Michael</a></p>
</blockquote>
<p><strong>BUT</strong> - This is also a problem of <em>authorization</em> - the auth token issued for my "official" client is the key to a set of protected resources for which that client and <em>only that client</em> is authorized. I suppose one could argue that since the user is the owner of those protected resources, if he accepts the access request from a third party client (be it a "sactioned" partner app or some phisher), then he is effectively authorizing the third-party client that made the request to access those resources. But I have issues with this: </p>
<ul>
<li>The average user is not security-conscious enough to be able to competently make this decision. I don't believe we should depend solely on the user's judgment to tap "Deny" on Android's access request screen to prevent even a crude phishing attempt. When the user is presented with the access request, my authenticator could be super-detailed and enumerate all the types of sensitive protected resources (that only my client should be able to access) for which the user will be granting should he accept the request, and in most cases, the user will still be too unaware and is going to accept. And in other, more sophisticated phishing attempts, the "imposter" app is just going to look too "official" for the user to even raise an eyebrow at the access request screen. Or, here's a more blunt example - on the access request screen, my authenticator could simply say, <em>"Do not accept this request! If you are seeing this screen, a malicious app is trying to gain access to your account!"</em> Hopefully, in such a case, most users would deny the request. But - why should it even get that far? If Android simply kept auth tokens isolated to the scope of each app/UID for which they were issued, then this would be a non-issue. Let's simplify - even in the case where I have just one "official" client app, and therefore my resource provider does not even worry about issuing tokens to other, third-party clients, as a developer I should have the option of saying to the AccountManager, "No! Lock-down this auth token so that only my app has access." I can do this if I go along the "custom tokens" route, but even in that case, I would not be able to prevent the user from first being presented with the access request screen. At the very least, it should be better-documented that the default implementation of AccountManager.getAuthToken() will return the same auth token for all requesting apps/UIDs.</li>
<li>Even the Android docs recognize OAuth2 as the "<a href="http://developer.android.com/training/id-auth/authenticate.html" rel="noreferrer">industry standard</a>" for authentication (and presumably authorization). The OAuth2 spec clearly states that access tokens are not to be shared between clients or divulged in any way. Why, then, does the default AccountManager implemenation/configuration make it so easy for a client to obtain the same cached auth token that was originally obtained from the service by another client? A simple fix within the AccountManager would be to only re-use cached tokens for the same app/UID under which the they were originally obtained from the service. If there is no locally cached auth token available for a given UID, then it should be obtained from the service. Or at least make this a configurable option for the developer.</li>
<li>In the OAuth 3-legged flow (which involves the user granting access to the client), isn't it supposed to be the service/resource provider (and not, say, the OS) which gets to <strong>A)</strong> authenticate the client and <strong>B) <em>if</em></strong> the client is valid, present the user with the grant access request? Seems like Android is (incorrectly) usurping this role in the flow.</li>
</ul>
<blockquote>
<p>But the user can explicitly allow apps to re-use a previous authentication to a service, which is convenient for the user.--<a href="http://stackoverflow.com/questions/14437096/shouldnt-android-accountmanager-store-oauth-tokens-on-a-per-app-uid-basis/14468836#14468836">Michael</a></p>
</blockquote>
<p><strong>BUT</strong> - I don't think the ROI in convenience warrants the security risk. In cases where the user's password is being stored in the user's account, then really, the only convenience that is being bought for the user is that instead of sending a web request to my service to get a new, distinct token that is actually authorized for the requesting client, a locally cached token that is not authorized for the client is returned. So the user gains the slight convenience of seeing a "Signing In..." progress dialog for a couple of seconds fewer, at the risk of the user being majorly  inconvenienced by having his resources stolen/misused.</p></li>
<li><p>Keeping in mind that I am committed to <strong>A)</strong> using the OAuth2 protocol for securing my API requests, <strong>B)</strong> providing my own OAuth2 resource/authentication provider (as opposed to authenticating with say, Google or Facebook), and <strong>C)</strong> utilizing Android's AccountManager to manage my custom account type and its token(s), are <strong>any of my proposed solutions valid?</strong> Which makes the most sense? Am I overlooking any of the pros/cons? Are there worthwhile alternatives that I have not thought of?</p>
<blockquote>
<p><strong>[Use] Alternative clients</strong> Don't have a secret API that attempts to only be accessible to an official client; people will get around this. Ensure all your public facing APIs are secure no matter what (future) client the user is using --<a href="http://stackoverflow.com/questions/14437096/shouldnt-android-accountmanager-store-oauth-tokens-on-a-per-app-uid-basis/14468836#14468836">Michael</a></p>
</blockquote>
<p><strong>BUT</strong> - Doesn't this defeat one of the key purposes of using OAuth2 in the first place? What good is authorization if all potential authorizees would be authorized to the same scope of protected resources?</p></li>
<li><p><strong>Has anyone else felt this was an issue, and how did your work around it?</strong> I've done some extensive Googling to try to find if others have felt this to be a security issue/concern, but it seems that most posts/questions involving Android's AccountManager and auth tokens are about how to authenticate with a Google account, and not with a custom account type and OAuth2 provider. Moreover, I could not find anyone that was concerend about the possibility of the same auth token being used by different apps, which makes me wonder whether this is indeed a possibility/worthy of concern in the first place (see my first 2 "Key Questions" listed above).</p></li>
</ol>
<p>I appreciate your input/guidance!</p>
<hr/>
<h2>In Response to...</h2>
<p><strong><a href="http://stackoverflow.com/questions/14437096/shouldnt-android-accountmanager-store-oauth-tokens-on-a-per-app-uid-basis/14468836#14468836">Michael's Answer</a></strong> - I think the major difficulties I have with your answer are: </p>
<ol>
<li><p>I am still inclined to think of apps as being separate, distinct clients of a service, as opposed to the user/phone/device itself being one "big" client, and therefore a token that has been authorized for one app should not, by default, be transferable to one that has not. It seems like you may be hinting that it is moot to consider each app as a distinct client because of the possibility that,</p>
<blockquote>
<p>the user could be running a rooted phone, and read off the token, gaining access to your private API... [or] if the user's system was compromised (the attacker could read off the token in this case) </p>
</blockquote>
<p>and that therefore, in the grand scheme of things, we should consider the device to be a client of the service since we cannot guarantee security between apps on the device itself. It's true if the system itself has been compromised, then there can be no guarantee of authenticating/authorizing requests being sent from that device to a service. But the same could be said, of say, TLS; transport security is irrelevant if the endpoints themselves cannot be secured. And for the vast majority of Android devices, which are not compromised, I believe it is more secure to consider each app client as a distinct endpoint, instead of lumping them all into one by sharing the same auth token.</p></li>
<li>When presented with the "access request" screen (akin to the software user license agreement that we always read thoroughly before consenting and installing), I don't trust the user's judgment to distinguish a malicious/unauthorized client app from one that is not.</li>
</ol>
</div></text><author><a href="/users/1995666">perfhacktionist</a></author><comments><comment><text><span class="comment-copy">+1 This is one of the best questions I've seen recently on SO.</span></text><author><a class="comment-user" href="/users/124538/wesley-wiser" title="5,214 reputation">Wesley Wiser</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<h2>Is this a valid/practical security concern?</h2>
<blockquote>
<p>For the official Client A, my OAuth2 provider may issue a "super" type/scope token which grants access to both public and private pieces of my API</p>
</blockquote>
<p>In the general case, you could never rely on an auth token given to a user remaining secret <em>from that user</em>. For example - the user could be running a rooted phone, and read off the token, gaining access to your private API. Ditto if the user's system was compromised (the attacker could read off the token in this case).</p>
<p>Put another way, there's no such thing as a "private" API that is at the same time accessible to any authenticated user, so it's reasonable for Android to ignore this security by obscurity goal in its design.</p>
<blockquote>
<p>a malicious app ... could obtain access to my app's stored OAuth2 token</p>
</blockquote>
<p>For the malicious app case, it begins to sound more reasonable that a malicious app shouldn't be able to use the client's token, as we expect Android's permission system to provide isolation of malicious apps (provided the user read / cared about the permissions they accepted when they installed it). However, as you say the user needed to accept an (Android system provided) access request for the app to use your token.</p>
<p>Given that, the Android solution seems OK - apps can't silently use a user's authentication without asking, but the user can explicitly allow apps to re-use a previous authentication to a service, which is convenient for the user.</p>
<h2>Possible Solutions Review</h2>
<blockquote>
<p>"Secret" authTokenType ... does not seem very secure</p>
</blockquote>
<p>Agreed - it's just another layer of security through obscurity; it sounds like any app wishing to share your authentication would have had to look up what the authTokenType was anyway, so adopting this approach just makes it a bit more awkward for this hypothetical app developer.</p>
<blockquote>
<p>Send client ID/secret w/ OAuth2 token ... [to] verify server-side that the app is the authorized client</p>
</blockquote>
<p>This isn't possible in the general case (all the server gets is a series of messages in a protocol - the code that generated those messages can't be determined). In this specific instance, it might protect against the more limited threat of a  (non-root) alternative client / malicious app - I'm not familiar enough with the AccountManager to comment (ditto for your custom auth tokens solutions).</p>
<h2>Suggestion</h2>
<p>You described two threats - malicious apps that a user doesn't want to have access to their account, and alternative clients that you (the developer) doesn't want using parts of the API.</p>
<ul>
<li><p>Malicious apps: Consider how sensitive the service you are providing is, and if it's not more sensitive than e.g. Google / twitter accounts, just rely on Android's protections (permissions on install, Access Request screen). If it <em>is</em> more sensitive, consider whether your constraint of utilizing Android's AccountManager is appropriate. To strongly protect the user against malicious use of their account, try two factor authentication for dangerous actions (c.f. adding a new recipient's account details in online banking).</p></li>
<li><p>Alternative clients: don't have a secret API that attempts to only be accessible to an official client; people will get around this. Ensure all your public facing APIs are secure no matter what (future) client the user is using.</p></li>
</ul>
</div></text><author><a href="/users/515412/michael">Michael</a></author><comments><comment><text><span class="comment-copy">Michael - Thank you for your answer! To help others who may be following/coming accross this question, and because comments do not support blockquotes and lengthy replies, I've edited my post to reflect your thoughts and suggestions, as well as my responses. Also, if I've misunderstood any part of your answer, of if you feel that I'm reading/taking something out of context, please don't hesitate to let me know. Thanks again for taking the time, thought and effor to respond to my question!</span></text><author><a class="comment-user owner" href="/users/1995666/perfhacktionist" title="51 reputation">perfhacktionist</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Your observation is correct. Authenticator will run with same UID as the installing app. When another app connects to Account manager and get token for this authenticator, it will bind to your provided authenticator service. It will run as your UID, so new accounts will be related to this Authenticator. When app calls for getAuthToken, binding will happen and Authenticator will still run in same UId. Default built in permissions check for account's UID, so that different Authenticator could not access another account from different Authenticator.</p>
<p>You can solve this issue with using "Calling UID" for addAccount and GetAuthToken since account manager service adds that to bundle. Your authenticator implementation can check that.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">   </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Bundle</span><span class="pln"> getAuthToken</span><span class="pun">(</span><span class="typ">AccountAuthenticatorResponse</span><span class="pln"> response</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Account</span><span class="pln"> account</span><span class="pun">,</span><span class="pln">
            </span><span class="typ">String</span><span class="pln"> authTokenType</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Bundle</span><span class="pln"> loginOptions</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">NetworkErrorException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">Log</span><span class="pun">.</span><span class="pln">v</span><span class="pun">(</span><span class="pln">
                TAG</span><span class="pun">,</span><span class="pln">
                </span><span class="str">"getAuthToken() for accountType:"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> authTokenType </span><span class="pun">+</span><span class="pln"> </span><span class="str">" package:"</span><span class="pln">
                        </span><span class="pun">+</span><span class="pln"> mContext</span><span class="pun">.</span><span class="pln">getPackageName</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"running pid:"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">Binder</span><span class="pun">.</span><span class="pln">getCallingPid</span><span class="pun">()</span><span class="pln">
                        </span><span class="pun">+</span><span class="pln"> </span><span class="str">" running uid:"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">Binder</span><span class="pun">.</span><span class="pln">getCallingUid</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">" caller uid:"</span><span class="pln">
                        </span><span class="pun">+</span><span class="pln"> loginOptions</span><span class="pun">.</span><span class="pln">getInt</span><span class="pun">(</span><span class="typ">AccountManager</span><span class="pun">.</span><span class="pln">KEY_CALLER_UID</span><span class="pun">));</span><span class="pln">
          </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>I suggest to follow authorization flow instead of storing client secret in your native app, because other developers can extract that secret. Your app is not a web app and should not have secrets.</p>
<p>When you are adding an account, you can query the callingUId as well. You need to <strong>setUserData</strong> at your <strong>addAccount</strong> related activity which will be running as your app's UID, so it can call <strong>setUserData</strong>. </p>
<p><strong>getUserData</strong> and <strong>setUserData</strong> uses built in sqllite database, so you don't need to build cache by yourself. You can only store string type, but you can parse json and store extra info per account.</p>
<p>When different third party app queries account and calls for getAuthtoken with your account, you can check UID in the account' userdata. If calling UID is not listed, you can do the prompt and/or other things to get permission. If it is permitted, you can add new UID to the account.</p>
<p><strong>Sharing tokens between apps</strong>:
Each app is normally registered with different clientid and they should not share token. Token is for a client app.</p>
<p><strong>Storage</strong>:
AccountManager is not encrypting your data. If you need more secure solution, you should encrypt the tokens and then store it.</p>
</div></text><author><a href="/posts/22399108/revisions" id="history-22399108" title="show revision history for this post">
        Omer Cansizoglu
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm facing the same architectural problem for an app.</p>
<p>The solution that I got is to associate/hash the oauth token, with the app vendor token (ex. the token that facebook give to an app), and to device id (<code>android_id</code>). So only the app authorized, for the device is able to use the token from account manager.</p>
<p>Of course, it's just a new layer of security, but no bullet proof.</p>
</div></text><author><a href="/users/3454585">user3454585</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I reckon @Michael answered the question perfectly; however, to make the answer more sensible and short to those looking for a quick answer I am writing this.</p>
<p>Your concern about the security of android <code>AccountManager</code> is correct, but this is what OAuth is meant to be, upon which android <code>AccountManager</code> relies.</p>
<p>In other words, if you are looking for a very secure authentication mechanism this would not be a good option for you. You should not rely on any cached tokens for authentication, since they can be easily revealed to the intruder in case there is any security vulnerability on the user's device such as inadvertently granting access permission to the intruder, running a rooted device, etc.</p>
<p>The better alternative to OAuth in more secure authentication systems, e.g. online banking apps, is using asymmetric encryption using public and private keys, in which the user is required to enter their password every time for using the services. The password is then encrypted using the public key on the device and sent to the server. Here, even if the intruder gets known of the encrypted password, he cannot do anything with that because he cannot decrypt it with that public key and needs only the private key of the server.</p>
<p>Anyway, if one wants to make use of the <code>AccountManager</code> system of the android as well as maintain high level of security, it would be possible by not saving any tokens on the device. The <code>getAuthToken</code> method from <code>AbstractAccountAuthenticator</code> can then be overriden like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="lit">@Override</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Bundle</span><span class="pln"> getAuthToken</span><span class="pun">(</span><span class="typ">AccountAuthenticatorResponse</span><span class="pln"> response</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Account</span><span class="pln"> account</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pln">
        authTokenType</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Bundle</span><span class="pln"> options</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">NetworkErrorException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">AuthenticatorManager</span><span class="pln"> authenticatorManager </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AuthenticatorManager</span><span class="pun">.</span><span class="pln">authenticatorManager</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">Bundle</span><span class="pln"> result</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">AccountManager</span><span class="pln"> accountManager </span><span class="pun">=</span><span class="pln"> </span><span class="typ">AccountManager</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">context</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// case 1: access token is available</span><span class="pln">
    result </span><span class="pun">=</span><span class="pln"> authenticatorManager</span><span class="pun">.</span><span class="pln">getAccessTokenFromCache</span><span class="pun">(</span><span class="pln">account</span><span class="pun">,</span><span class="pln"> authTokenType</span><span class="pun">,</span><span class="pln">
            accountManager</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">result </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> refreshToken </span><span class="pun">=</span><span class="pln"> accountManager</span><span class="pun">.</span><span class="pln">getPassword</span><span class="pun">(</span><span class="pln">account</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// case 2: access token is not available but refresh token is</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">refreshToken </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        result </span><span class="pun">=</span><span class="pln"> authenticatorManager</span><span class="pun">.</span><span class="pln">makeResultBundle</span><span class="pun">(</span><span class="pln">account</span><span class="pun">,</span><span class="pln"> refreshToken</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// case 3: neither tokens is available but the account exists</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isAccountAvailable</span><span class="pun">(</span><span class="pln">account</span><span class="pun">,</span><span class="pln"> accountManager</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        result </span><span class="pun">=</span><span class="pln"> authenticatorManager</span><span class="pun">.</span><span class="pln">makeResultBundle</span><span class="pun">(</span><span class="pln">account</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// case 4: account does not exist</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Bundle</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>In this method, neither case 1, case 2 nor case 4 holds true because there is no saved token, even though the <code>account</code> is there. Therefore, only case 3 will be returned which can then be set in the relevant callback to open an <code>Activity</code> in which the user enters username and password for authentication.</p>
<p>I am not sure of being on the right track in further describing this here, but <a href="http://www.digigene.com/category/android/accounts-in-android/" rel="nofollow noreferrer">my website posts on <code>AccountManager</code></a> may help just in case.</p>
</div></text><author><a href="/posts/41075149/revisions" id="history-41075149" title="show revision history for this post">
        Ali Nemati Hayati
        </a></author><comments/></answer></answers></post>