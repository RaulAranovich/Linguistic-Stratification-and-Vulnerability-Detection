<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Non-random salt for password hashes - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>UPDATE: I recently learned from <a href="https://security.stackexchange.com/q/379/33">this question</a> that in the entire discussion below, I (and I am sure others did too) was a bit confusing: What I keep calling a rainbow table, is in fact called a hash table. Rainbow tables are more complex creatures, and are actually a variant of Hellman Hash Chains. Though I believe the answer is still the same (since it doesnt come down to cryptanalysis), some of the discussion might be a bit skewed.<br/>
The question: "<a href="https://security.stackexchange.com/q/379/33">What are rainbow tables and how are they used?</a>"</p>
<hr/>
<p>Typically, I always recommend using a cryptographically-strong random value as salt, to be used with hash functions (e.g. for passwords), such as to protect against Rainbow Table attacks.  </p>
<p>But is it actually cryptographically necessary for the salt to be random? Would any unique value (unique per user, e.g. userId) suffice in this regard? It would in fact prevent using a single Rainbow Table to crack all (or most) passwords in the system...<br/>
But does lack of entropy really weaken the cryptographic strength of the hash functions?  </p>
<hr/>
<p>Note, I am not asking about why to use salt, how to protect it (it doesnt need to be), using a single constant hash (don't), or what kind of hash function to use.<br/>
Just whether salt needs entropy or not.</p>
<hr/>
<p>Thanks all for the answers so far, but I'd like to focus on the areas I'm (a little) less familiar with. Mainly implications for cryptanalysis - I'd appreciate most if anyone has some input from the crypto-mathematical PoV.<br/>
Also, if there are additional vectors that hadn't been considered, thats great input too (see @Dave Sherohman point on multiple systems).<br/>
Beyond that, if you have any theory, idea or best practice - please back this up either with proof, attack scenario, or empirical evidence. Or even valid considerations for acceptable trade-offs... I'm familiar with Best Practice (capital B capital P) on the subject, I'd like to prove what value this actually provides.</p>
<hr/>
<p>EDIT: Some really good answers here, but I think as @Dave says, it comes down to Rainbow Tables for common user names... and possible less common names too. However, what if my usernames are globally unique? Not necessarily unique for my system, but per each user - e.g. email address.<br/>
There would be no incentive to build a RT for a single user (as @Dave emphasized, the salt is not kept secret), and this would still prevent clustering. Only issue would be that I might have the same email and password on a different site - but salt wouldnt prevent that anyway.<br/>
So, it comes back down to cryptanalysis - IS the entropy necessary, or not? (My current thinking is it's not necessary from a cryptanalysis point of view, but it is from other practical reasons.)</p>
</div></text><author><a href="/users/-1/community">Community</a></author><comments><comment><text><span class="comment-copy">I must say I'm confused by many of the answers below. The main point of using salt is simply to prevent rainbow table attack so anything unique to user should do as it forces the attacker to recreate a rainbow table for each salt. my 2c.</span></text><author><a class="comment-user" href="/users/23164/goran" title="5,058 reputation">Goran</a></author></comment><comment><text><span class="comment-copy">If salt is needed for eg. site, you often have ids in urls. If attacker knows (and we assume he does) that password salt is userid+username it's fairly easy to modify attack to avoid salt value.</span></text><author><a class="comment-user" href="/users/39233/dmajkic" title="2,928 reputation">dmajkic</a></author></comment><comment><text><span class="comment-copy">@dmajkic, salt is intended to prevent RT attacks and differentiate same passwords for different users. This is a given, even with usernames.</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD: That's true. But if I know my hash for my pass, and I know that salt is my username then I can easly create hashed pass value for any dictionary word, and compare it to someone else pass hash. That is why time is better than username.</span></text><author><a class="comment-user" href="/users/39233/dmajkic" title="2,928 reputation">dmajkic</a></author></comment><comment><text><span class="comment-copy">( not trained ) - Traditionally, trying to better what has been achieved is error prone - at a minimum such may distract from other issues. From what I see, the only issue is to insure the salt is of sufficient length to get things going - then it's pretty much algorithm strength from there on, no?</span></text><author><a class="comment-user" href="/users/177505/nicholas-jordan" title="540 reputation">Nicholas Jordan</a></author></comment><comment><text><span class="comment-copy">See also: <a href="http://stackoverflow.com/questions/1645161/salt-generation-and-open-source-software/1645190#1645190" title="salt generation and open source software">stackoverflow.com/questions/1645161/â€¦</a></span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">Just found an article on the PHP Security Consortium website that in its example uses a md5 hashed <i>random</i> number as the salt  <a href="http://phpsec.org/articles/2005/password-hashing.html" rel="nofollow noreferrer">phpsec.org/articles/2005/password-hashing.html</a></span></text><author><a class="comment-user" href="/users/219416/helloworlder" title="1,100 reputation">helloworlder</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Salt is traditionally stored as a prefix to the hashed password.  This already makes it known to any attacker with access to the password hash.  Using the username as salt or not does not affect that knowledge and, therefore, it would have no effect on single-system security.</p>
<p>However, using the username or any other user-controlled value as salt would reduce cross-system security, as a user who had the same username and password on multiple systems which use the same password hashing algorithm would end up with the same password hash on each of those systems.  I do not consider this a significant liability because I, as an attacker, would try passwords that a target account is known to have used on other systems first before attempting any other means of compromising the account.  Identical hashes would only tell me in advance that the known password would work, they would not make the actual attack any easier.  (Note, though, that a quick comparison of the account databases would provide a list of higher-priority targets, since it would tell me who is and who isn't reusing passwords.)</p>
<p>The greater danger from this idea is that usernames are commonly reused - just about any site you care to visit will have a user account named "Dave", for example, and "admin" or "root" are even more common - which would make construction of rainbow tables targeting users with those common names much easier and more effective.</p>
<p>Both of these flaws could be effectively addressed by adding a second salt value (either fixed and hidden or exposed like standard salt) to the password before hashing it, but, at that point, you may as well just be using standard entropic salt anyhow instead of working the username into it.</p>
<p><strong>Edited to Add:</strong>  A lot of people are talking about entropy and whether entropy in salt is important.  It is, but not for the reason most of the comments on it seem to think.</p>
<p>The general thought seems to be that entropy is important so that the salt will be difficult for an attacker to guess.  This is incorrect and, in fact, completely irrelevant.  As has been pointed out a few times by various people, attacks which will be affected by salt can only be made by someone with the password database and someone with the password database can just look to see what each account's salt is.  Whether it's guessable or not doesn't matter when you can trivially look it up.</p>
<p>The reason that entropy is important is to avoid clustering of salt values.  If the salt is based on username and you know that most systems will have an account named either "root" or "admin", then you can make a rainbow table for those two salts and it will crack most systems.  If, on the other hand, a random 16-bit salt is used and the random values have roughly even distribution, then you need a rainbow table for all 2^16 possible salts.</p>
<p>It's not about preventing the attacker from knowing what an individual account's salt is, it's about not giving them the big, fat target of a single salt that will be used on a substantial proportion of potential targets.</p>
</div></text><author><a href="/users/18914/dave-sherohman">Dave Sherohman</a></author><comments><comment><text><span class="comment-copy">Agreed. I'd put more emphasis on re-use of usernames, since I think that's the attack most likely to be successful against hypothetical systems using the username as a salt, that would have failed against a system using random salt.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">I appreciate your point on cross-system security. Also, I guess that in the future its not unlikely to see user-specific rainbow tables...</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD: You think so?  That's quite a specific attack vector.</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">No, if for example you want to have compromised accounts to send spam you don't mind what the account name is.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">@gs: I meant that using the username as salt is quite a specific vector.</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">@MrPotatoHead, its not a vector, thats the question that I'm asking - is it good enough? Cross-system security is one point to consider.</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">In this case, is it worthwhile to invest in the additional time of a cryptographically secure random number generator? Any RNG will prevent user login collisions.</span></text><author><a class="comment-user" href="/users/135056/nona-urbiz" title="1,977 reputation">Nona Urbiz</a></author></comment><comment><text><span class="comment-copy">Not for generating salts, no.  The only attacks which are affected by salt are those made directly against the hashed passwords.  An attack can't make this sort of attack unless they have a copy of your password database, which will also contain the salts.  Since the attacker will already have the salts in his possession, they only require sufficient entropy to avoid having multiple passwords hashed with the same salt, which any basic (P)RNG will provide.</span></text><author><a class="comment-user" href="/users/18914/dave-sherohman" title="32,498 reputation">Dave Sherohman</a></author></comment><comment><text><span class="comment-copy">Third sentence should start "An attack<b>er</b> can't make...".</span></text><author><a class="comment-user" href="/users/18914/dave-sherohman" title="32,498 reputation">Dave Sherohman</a></author></comment><comment><text><span class="comment-copy">So is salt prefixed to a password secure? for example if i store the password as <code>passhash = md5("urhu2389udfcbdvalk" + UserPassword)</code> would that be secure?</span></text><author><a class="comment-user" href="/users/34537/acidzombie24" title="46,604 reputation">acidzombie24</a></author></comment><comment><text><span class="comment-copy">@acidzombie24: Using a single fixed salt (usually called a "nonce" in my experience) for all passwords is less secure than using a unique random salt for each password, as it still allows an attacker to trivially determine whether two or more accounts share the same password. On the other hand, the nonce would likely be stored in your code rather than in the database, so an attacker who <i>only</i> has your database won't have access to it; because of this, the most secure option is to use both a system-wide nonce (stored in the code) and a per-password salt (stored in the database).</span></text><author><a class="comment-user" href="/users/18914/dave-sherohman" title="32,498 reputation">Dave Sherohman</a></author></comment><comment><text><span class="comment-copy">+1 for the last paragraph. It made me understand needing salt-per-user rather than single-use-salt.</span></text><author><a class="comment-user" href="/users/510175/yoshiyahu" title="938 reputation">Yoshiyahu</a></author></comment><comment><text><span class="comment-copy">@DaveSherohman very informative, based on this advice, I found a very nice Java library that does what you've suggested: <a href="http://www.jasypt.org/encrypting-passwords.html" rel="nofollow noreferrer">jasypt.org/encrypting-passwords.html</a></span></text><author><a class="comment-user" href="/users/1198517/jmac" title="155 reputation">JMac</a></author></comment><comment><text><span class="comment-copy">Using usernames also creates an unnecessary coupling with the password so you cannot create a feature of "change username" without asking for password anymore.</span></text><author><a class="comment-user" href="/users/54937/sedat-kapanoglu" title="29,543 reputation">Sedat Kapanoglu</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Using a high-entropy salt is absolutely necessary to store passwords securely.</strong></p>
<p>Take my username 'gs' and add it to my password 'MyPassword' gives gsMyPassword. This is easily broken using a rainbow-table because if the username hasn't got enough entropy it could be that this value is already stored in the rainbow-table, especially if the username is short.</p>
<p>Another problem are attacks where you know that a user participates in two or more services. There are lots of common usernames, probably the most important ones are admin and root. If somebody created a rainbow-table that have salts with the most common usernames, he could use them to compromise accounts.</p>
<p><a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noreferrer">They used to have a 12-bit salt</a>. 12 bit are 4096 different combinations. That was not secure enough because <a href="http://en.wikipedia.org/wiki/Password_cracking#Early_Unix_password_vulnerability" rel="noreferrer">that much information can be easily stored nowadays</a>. The same applies for the 4096 most used usernames. It's likely that a few of your users will be choosing a username that belongs to the most common usernames.</p>
<p>I've found this <a href="http://rumkin.com/tools/password/passchk.php" rel="noreferrer">password checker</a> which works out the entropy of your password. Having smaller entropy in passwords (like by using usernames) makes it much easier for rainbowtables as they try to cover at least all passwords with low entropy, because they are more likely to occur.</p>
</div></text><author><a href="/users/24587/georg-sch%c3%b6lly">Georg SchÃ¶lly</a></author><comments><comment><text><span class="comment-copy">+1 for common sense</span></text><author><a class="comment-user" href="/users/23164/goran" title="5,058 reputation">Goran</a></author></comment><comment><text><span class="comment-copy">+1 for a good point, however, you <i>are</i> talking about a potentially <i>massive</i> rainbow table.  To cover off all values of gsMyPassword length (assuming mixed-case alphanumeric) requires 36^12 rows in the table!</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">As a follow up: the distributed rainbow table project has 63,970 cracked hashes, but 36^12 is 4,738,381,338,321,616,896!</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">Thanks, and this does make sense - but as Mr.PotatoHead pointed out, you're still expanding your space beyond reasonable possiblity of cracking with RT. Also, assuming my usernames are at least 6-8 characters - what additional necessary value does entropy provide?</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@Potato: you assume a rainbow table containing all possible combinations of alphanumeric characters. This doesnt need to be the case, an effective rainbow table will contain hashes for common passwords/hashes. Salt is there to protect against dictionary attacks or combined rainbowtable/dictionary.</span></text><author><a class="comment-user" href="/users/23704/guillaume" title="12,161 reputation">Guillaume</a></author></comment><comment><text><span class="comment-copy">@Guillaume: Thanks - I hadn't considered that. :)</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">@ Mr Potate Head: My computer can generate 1000 hashes per second, 63,970 hashes doesn't say how many hashes the distributed rainbow table has stored.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">@gs:  Since I would imagine the project has more than one minute's CPU time, I guess my figure is wrong. :P</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">@ Mr Potate Head: It says something about "10181 million chains completed", how many hashes might that be?</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">@gs: Not sure - I've seen something about chains, but more interesting are the databases - they go up to 8 mixed-alphanumeric characters!</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">Using the username as the salt is also a bad idea for systems where there is a predictably-named high-privilege account: "Administrator" on Windows, "root" on *nix, "sa" in MSSQL, etc.</span></text><author><a class="comment-user" href="/users/19405/andrew-medico" title="16,276 reputation">Andrew Medico</a></author></comment><comment><text><span class="comment-copy">However, in most applications / business systems, there is no builtin "Administrator", "root", etc.</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">"High entropy salt" isn't bigger search space because "the salt part" is always known. Let's say you have 4096-bit salt and 8-bit password. As long as you know the salt, your search space is just 256.</span></text><author><a class="comment-user" href="/users/54937/sedat-kapanoglu" title="29,543 reputation">Sedat Kapanoglu</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It is true that the username alone may be problematic since people may share usernames among different website. But it should be rather unproblematic if the users had a different name on each website. So why not just make it unique on each website. Hash the password somewhat like this</p>
<p>hashfunction("www.yourpage.com/"+username+"/"+password)</p>
<p>This should solve the problem. I'm not a master of cryptanalysis, but I sure doubt that the fact that we don't use high entropy would make the hash any weaker.</p>
</div></text><author><a href="/users/487905/konne">konne</a></author><comments><comment><text><span class="comment-copy">I believe you're right that this is sufficient. However, given that hashes are a complicated mathematical field and it's very well possible that low entropy salts make the hashes more easily to guess in the future, (especially as hashes get broken), I wouldn't bet on the security, when the proven more secure solution is not much more expensive.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I like to use both: a high-entropy random per-record salt, plus the unique ID of the record itself.</p>
<p>Though this doesn't add much to security against dictionary attacks, etc., it does remove the fringe case where someone copies their salt and hash to another record with the intention of replacing the password with their own.</p>
<p>(Admittedly it's hard to think of a circumstance where this applies, but I can see no harm in belts and braces when it comes to security.)</p>
</div></text><author><a href="/users/15825/teedyay">teedyay</a></author><comments><comment><text><span class="comment-copy">I like the idea of binding the password to the user. But if the attacker can change the password he can surely also change the id.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">Depends on what the ID is: I use the primary key of the table, which you can't really change at will.  TBH, if the hacker's writing to your database, you're in some pretty big trouble already...</span></text><author><a class="comment-user" href="/users/15825/teedyay" title="16,445 reputation">teedyay</a></author></comment><comment><text><span class="comment-copy">Nah, I like it. An attacker is often an "insider". I could dream up scenarios where what he's after isn't in the database, but if he can overwrite the credentials in the database, he can authenticate himself to do what he wants.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">Good point. We do find it makes it increasingly difficult to add the first user to a new database: we've effectively made our applications so secure we can barely hack them ourselves.  [Also, use an application-specific salt so you can't copy credentials from one database to another.]</span></text><author><a class="comment-user" href="/users/15825/teedyay" title="16,445 reputation">teedyay</a></author></comment><comment><text><span class="comment-copy">Finally I found someone saying this: adding something user-specific to the salt. That avoids an intruder to copy some credentials to another user, and also prevents a hacker to guess any password if he manages to reach your hash and salt field in the table. One thing more I like to do: not using a round number of iterations in the hashing. Don't go for 10k or 20k, but rather something like 19835.</span></text><author><a class="comment-user" href="/users/2321042/andrew" title="3,536 reputation">Andrew</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If the salt is known or easily guessable, you have not increased the difficulty of a dictionary attack.  It even may be possible to create a modified rainbow table that takes a "constant" salt into account.</p>
<p>Using unique salts increases the difficulty of BULK dictionary attacks.</p>
<p>Having unique, cryptographically strong salt value would be ideal.</p>
</div></text><author><a href="/users/27233/huaghaguah">HUAGHAGUAH</a></author><comments><comment><text><span class="comment-copy">The whole point of the rainbow table is that the values are pre-generated, and that if you're generating the table for a value (e.g. password) PLUS a given constant, that is a entirely different table, and you might as well just try the hash outcome directly. :)</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">A constant hash is worth nothing. All passwords can be cracked using a single rainbow-table. The purpose of the salt is that it's impossible to create a rainbow-table.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">@gs - I don't see why you can't construct a rainbow table that "includes" the effects of a constant salt.  The attack space (the password) won't have changed, so the table won't need to grow, just be recalculated.</span></text><author><a class="comment-user" href="/users/27233/huaghaguah" title="853 reputation">HUAGHAGUAH</a></author></comment><comment><text><span class="comment-copy">@Potato - depends on the tradeoff.  If your company's 20k logins were all hashed with the same constant salt, it may be cheaper to compute a fresh rainbow table than to dictionary attack them all individually.  Hence my emphasis of "BULK".</span></text><author><a class="comment-user" href="/users/27233/huaghaguah" title="853 reputation">HUAGHAGUAH</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I would say that as long as the salt is different for each password, you will probably be ok.  The point of the salt, is so that you can't use standard rainbow table to solve every password in the database.  So if you apply a different salt to every password (even if it isn't random), the attacker would basically have to compute a new rainbow table for each password, since each password uses a different salt.  </p>
<p>Using a salt with more entropy doesn't help a whole lot, because the attacker in this case is assumed to already have the database. Since you need to be able to recreate the hash, you have to already know what the salt is.  So you have to store the salt, or the values that make up the salt in your file anyway.  In systems like Linux, the method for getting the salt is known, so there is no use in having a secret salt.  You have to assume that the attacker who has your hash values, probably knows your salt values as well.</p>
</div></text><author><a href="/users/1862/kibbee">Kibbee</a></author><comments><comment><text><span class="comment-copy">"The point of the salt, is so that you can't use standard rainbow table to solve every password in the database". I disagree. The point is so that you can't use a standard rainbow table to solve <i>any</i> password. If the salt is the username, then the rainbow table for "root" could crack root's pw.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">That's probably about the only rule that really matters.  Basically you want the password to be something that's unique on your system, but it doesn't matter what it is.  It could still be something simple though. You don't need a whole lot of entropy.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment><comment><text><span class="comment-copy">This was my thinking too - but I got stuck at the "probably okay". I still don't see this theory being proved - or at least verified that there are no cryptanalysis implications.</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@onebyone: If the salt consists of username + constant local value (I often use ':'), then that still ruins standardized RTs, unless there are a variety of them that include common usernames and common static salt values. I rather suspect that's not the case.</span></text><author><a class="comment-user" href="/users/13757/nsayer" title="9,724 reputation">nsayer</a></author></comment><comment><text><span class="comment-copy">Along with nsayer.  You could use a system-wide constant string, that there wouldn't be a pregenerated RT for, like #(D83d8, along with the user name as the salt, and that would probalby prevent any rainbow table attacks.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The strength of a hash function is not determined by its input!</p>
<p>Using a salt that is known to the attacker obviously makes constructing a rainbow table (particularly for hard-coded usernames like <strong>root</strong>) more attractive, but it doesn't weaken the <em>hash</em>.  Using a salt which is unknown to the attacker will make the system harder to attack.</p>
<p>The concatenation of a username and password might still provide an entry for an intelligent rainbow table, so using a salt of a series pseudo-random characters, stored with the hashed password is probably a better idea.  As an illustration, if I had username "potato" and password "beer", the concatenated input for your hash is "potatobeer", which is a reasonable entry for a rainbow table.</p>
<p>Changing the salt each time the user changes their password might help to defeat prolonged attacks, as would the enforcement of a reasonable password policy, e.g. mixed case, punctuation, min length, change after <em>n</em> weeks.</p>
<p>However, I would say your choice of digest algorithm is more important.  Use of SHA-512 is going to prove to be more of a pain for someone generating a rainbow table than MD5, for example.</p>
</div></text><author><a href="/users/40581">David Grant</a></author><comments><comment><text><span class="comment-copy">The strength of the function does not change, but the output definitely changes. If the input can be influenced or known, then perhaps something can be deduced about the hash value. That's the risk.</span></text><author><a class="comment-user" href="/users/39443/martin-carpenter" title="5,103 reputation">Martin Carpenter</a></author></comment><comment><text><span class="comment-copy">@Martin: The only thing you should be able to deduce from the hash value if whether or not you have a match!  Putting "roota" or "rootb" (where "a" and "b" represent the password) into a hash function will give you radically different output.</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">The salts are known to an attacker using rainbow-tables.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">@gs: Can you expand on that?</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">The server has to know the unencrypted salt (to check the password against the hash), thus one can take for granted that an attacker has access to the salt, or can get it very easily.</span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">@gs: Thanks for clarifying.</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">Right, right, thats a given - to be more specific I meant the strength of the overall cryptosystem (or -subsystem, wrt hashes).</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD: Since you a username + password concatenation might still give you an entry from a intelligent rainbow table, I would say it was better to use a random series of characters as your salt, and store the salt in the same place.  If you like, you could change the salt each time the user logs in.</span></text><author><a class="comment-user" href="/users/40581/david-grant" title="10,496 reputation">David Grant</a></author></comment><comment><text><span class="comment-copy">Potatobeer! I luv that!</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Salt should have as much entropy as possible to ensure that should a given input value be hashed multiple times, the resulting hash value will be, as close as can be achieved, always different.</p>
<p>Using ever-changing salt values with as much entropy as possible in the salt will ensure that the likelihood of hashing (say, password + salt) will produce entirely different hash values.</p>
<p>The less entropy in the salt, the more chance you have of generating the same salt value, as thus the more chance you have of generating the same hash value.</p>
<p>It is the nature of the hash value being "constant" when the input is known and "constant" that allow dictionary attacks or rainbow tables to be so effective.  By varying the resulting hash value as much as possible (by using high entropy salt values) ensures that hashing the same input+random-salt will produce many different hash value results, thereby defeating (or at least greatly reducing the effectiveness of) rainbow table attacks.</p>
</div></text><author><a href="/users/57477/craigtp">CraigTP</a></author><comments><comment><text><span class="comment-copy">Again, I'm not referring to using a single constant salt - rather a non-random, but user-unique value. E.g. userId.</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">The whole point is that your salt value should never be constant.  Every single thing you hash, whether the same "input" value or not should have a different salt.  Dave Sherohman explains the downsides of using even user-unique values that essentially stay the same with each hash computation.</span></text><author><a class="comment-user" href="/users/57477/craigtp" title="29,796 reputation">CraigTP</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Entropy is the point of Salt value.  </p>
<p>If there is some simple and reproducible "math" behind salt, than it's the same as the salt is not there. Just adding time value should be fine. </p>
</div></text><author><a href="/users/39233/dmajkic">dmajkic</a></author><comments><comment><text><span class="comment-copy">I don't understand this comment. You say "use entropy", and then: "use time"??</span></text><author><a class="comment-user" href="/users/39443/martin-carpenter" title="5,103 reputation">Martin Carpenter</a></author></comment><comment><text><span class="comment-copy">if Username is used for salt, it' not entropic enough. But if you use username+current dateime - it is, since it's hard to guess when exactly salt was created.</span></text><author><a class="comment-user" href="/users/39233/dmajkic" title="2,928 reputation">dmajkic</a></author></comment><comment><text><span class="comment-copy">"entropic enough" is subjective; it's your standard. Basing this value on time may not be adequate.</span></text><author><a class="comment-user" href="/users/39443/martin-carpenter" title="5,103 reputation">Martin Carpenter</a></author></comment><comment><text><span class="comment-copy">There is no such a thing as "absolute true randomness". It's on us to say when it's "good enough". If you think that in this case time is not good enough, use something else.   <a href="http://stackoverflow.com/questions/84556/whats-your-favorite-programmer-cartoon/90391#90391" title="whats your favorite programmer cartoon">stackoverflow.com/questions/84556/â€¦</a></span></text><author><a class="comment-user" href="/users/39233/dmajkic" title="2,928 reputation">dmajkic</a></author></comment><comment><text><span class="comment-copy">True randomness: <a href="http://random.org/" rel="nofollow noreferrer">random.org</a></span></text><author><a class="comment-user" href="/users/24587/georg-sch%c3%b6lly" title="86,894 reputation">Georg SchÃ¶lly</a></author></comment><comment><text><span class="comment-copy">Actually, the point of salt is to cause each hash result to be unique - in order to prevent (a) rainbow table attacks, and (b) identical password identification. The question is, what else is entropy needed for, if at all?</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">Imagine a system that creates batches of accounts (random passwords) on the first day of each month. Imagine it uses a low granularity time for salt (or is a really fast system that creates hundreds of accounts per time unit). Now we're vulnerable to both AviD's (a) and (b).</span></text><author><a class="comment-user" href="/users/39443/martin-carpenter" title="5,103 reputation">Martin Carpenter</a></author></comment><comment><text><span class="comment-copy">@AviD: and if we turn your question around: When is it bad to use high-entropy salt? Extra CPU cycles? Predictable PRNG?</span></text><author><a class="comment-user" href="/users/39443/martin-carpenter" title="5,103 reputation">Martin Carpenter</a></author></comment><comment><text><span class="comment-copy">@Martin, the problem isnt actually one of high-entropy - rather the "complexity" of <i>any</i> additional information, seeing as how we already have a unique username its a hard to convince them of the necessity...</span></text><author><a class="comment-user owner" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment></comments></answer></answers></post>