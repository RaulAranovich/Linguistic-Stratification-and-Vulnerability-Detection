<?xml version="1.0" encoding="utf-8"?>
<post><title>How to secure database passwords in PHP? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>When a PHP application makes a database connection it of course generally needs to pass a login and password. If I'm using a single, minimum-permission login for my application, then the PHP needs to know that login and password somewhere. What is the best way to secure that password? It seems like just writing it in the PHP code isn't a good idea.</p>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">To be totally secure, you'll need to set up an ssl connection, otherwise anyone on your network can still sniff the password you type.</span></text><author><a class="comment-user" href="/users/11708/charles-ma" title="21,566 reputation">Charles Ma</a></author></comment><comment><text><span class="comment-copy">Do you mean the user passwords or the database password used in the connection string?</span></text><author><a class="comment-user" href="/users/976/ozgur-ozcitak" title="6,088 reputation">Ozgur Ozcitak</a></author></comment><comment><text><span class="comment-copy">Database password used in the connection string. Thanks!</span></text><author><a class="comment-user owner" href="/users/18359/user18359" title="1,688 reputation">user18359</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Several people misread this as a question about how to <strong>store</strong> passwords in a database.  That is wrong.  It is about how to store the password that lets you get <strong>to</strong> the database.</p>
<p>The usual solution is to move the password out of source-code into a configuration file.  Then leave administration and securing that configuration file up to your system administrators.  That way developers do not need to know anything about the production passwords, and there is no record of the password in your source-control.</p>
</div></text><author><a href="/users/11318/user11318">user11318</a></author><comments><comment><text><span class="comment-copy">Thanks. If I understand this correctly, the php file will then have an include to the config file, allowing it to use the password. e.g. I create a file called 'app1_db_cfg.php' that stores the login, pword, &amp; db name. Then my application.php page includes 'app1_db_cfg.php' and I'm in business!</span></text><author><a class="comment-user owner" href="/users/18359/user18359" title="1,688 reputation">user18359</a></author></comment><comment><text><span class="comment-copy">yep, I usually do DEFINE("DB_NAME","mydb"); etc it is also handy to define anything you'll be using on more then page, that you might want to change later</span></text><author><a class="comment-user" href="/users/15000/matthew-rapati" title="4,712 reputation">Matthew Rapati</a></author></comment><comment><text><span class="comment-copy">Just saving the password in a config file is not much more secure. It needs to be properly protected, using strong ACLs and strong encryption with properly protected keys... See my post below.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">I agree that the config needs to be properly protected.  However knowing how to do that is the business of system administrators, not developers.  I disagree on the value of strong encryption in this case.  If you can't protect your config file, what makes you think you can protect your keys?</span></text><author><a class="comment-user" href="/users/11318/user11318" title="6,983 reputation">user11318</a></author></comment><comment><text><span class="comment-copy">I prefer using a database account that is only allowed to acces the database from the web server. And then I don't bother encrypting the configuration, I just store it outside the web root.</span></text><author><a class="comment-user" href="/users/27204/gnud" title="46,520 reputation">gnud</a></author></comment><comment><text><span class="comment-copy">@bentilly, that's where strong Key Management comes in, and this should definitely be the developer's responsibility, not the admin's - though the admins also have some tasks here too.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@bentilly so when you dont expose sensitive data theres no need for encryption at all? Not encrypting because you dont think anyone unprivileged would get access sounds odd for me - it makes the PIN on my VISA useless, since nobody should get access to it.  edit: sorry, someone dug out an old thread</span></text><author><a class="comment-user" href="/users/366299/atamanroman" title="6,582 reputation">atamanroman</a></author></comment><comment><text><span class="comment-copy">@gnut: " I just store it outside the web root. ". How string it outside webroot would help? I am asking this as I have seen in even modern open source scripts that the config file which contains the db password is in root. I dont prefer this and I wanna know if I sould bother.</span></text><author><a class="comment-user" href="/users/699559/c-graphics" title="2,003 reputation">C graphics</a></author></comment><comment><text><span class="comment-copy">@MatthewRapati ... I'm actually solving problem with password in constants, because other developers can simple do <code>get_defined_constants()</code>.</span></text><author><a class="comment-user" href="/users/904846/dmnc" title="516 reputation">dmnc</a></author></comment><comment><text><span class="comment-copy">I use an apache environment variable to set the path so that even the path to the file is unknown in the source code. This also nicely allows having a different password for development and production based on what Apache settings are on the serverm</span></text><author><a class="comment-user" href="/users/1725471/geedew" title="892 reputation">geedew</a></author></comment><comment><text><span class="comment-copy">Please keep in mind that even files stored outside of the web accessible directory must be read by the script that uses them. If someone includes that file, then dumps the data from the file, they will see the password.</span></text><author><a class="comment-user" href="/users/3421575/rick-mac-gillis" title="148 reputation">Rick Mac Gillis</a></author></comment><comment><text><span class="comment-copy">For all the people who are asking how to protect from all other than me, the answer is either manage the whole company by yourself, otherwise you have to trust at least someone.</span></text><author><a class="comment-user" href="/users/1447576/ankit" title="113 reputation">Ankit</a></author></comment><comment><text><span class="comment-copy">@henk There is no solution for this. You have to trust or be careful about the contents of all the scripts that are going to the production server.</span></text><author><a class="comment-user" href="/users/1447576/ankit" title="113 reputation">Ankit</a></author></comment><comment><text><span class="comment-copy">@RickMacGillis <code>If someone includes that file, then dumps the data from the file, they will see the password</code> how do you deal with this?</span></text><author><a class="comment-user" href="/users/3019105/tonix" title="1,928 reputation">tonix</a></author></comment><comment><text><span class="comment-copy">@tonix The issue is more of an issue with open source software, as you'll have knowledge of the variables or layout of that file. For that reason, <code>define</code> is a bad idea for setting those variables. (Ex. WordPress uses that insecure method and it has it inside of the web-accessible directory.)  The issue I was pointing out is that if someone is able to upload a file, they can discover the passwords in that file. However, even though someone can easily dump the password created with define, Laravel's .env or array-based config files are only mildly better. Every file is susceptible to attack.</span></text><author><a class="comment-user" href="/users/3421575/rick-mac-gillis" title="148 reputation">Rick Mac Gillis</a></author></comment><comment><text><span class="comment-copy">To avoid this issue in the first place, use a password server and query the server for the information you need. AWS KMS could be used to help secure your passwords further by keeping them encrypted in the file-system, and only decrypt them in memory with Redis.  <a href="https://aws.amazon.com/kms/" rel="nofollow noreferrer">aws.amazon.com/kms</a></span></text><author><a class="comment-user" href="/users/3421575/rick-mac-gillis" title="148 reputation">Rick Mac Gillis</a></author></comment><comment><text><span class="comment-copy">Then again, if someone can place a file on your site and run it, you have bigger issues than just losing your passwords. That file can do anything.</span></text><author><a class="comment-user" href="/users/3421575/rick-mac-gillis" title="148 reputation">Rick Mac Gillis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you're hosting on someone else's server and don't have access outside your webroot, you can always put your password and/or database connection in a file and then lock the file using a .htaccess:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="tag">&lt;files</span><span class="pln"> </span><span class="atn">mypasswdfile</span><span class="tag">&gt;</span><span class="pln">
order allow,deny
deny from all
</span><span class="tag">&lt;/files&gt;</span></code></pre>
</div></text><author><a href="/users/94671/kellen">kellen</a></author><comments><comment><text><span class="comment-copy">Thanks, that was exactly what I was looking for.</span></text><author><a class="comment-user" href="/users/70068/david-gladfelter" title="3,397 reputation">David Gladfelter</a></author></comment><comment><text><span class="comment-copy">Useful, if it's truly secure, though it seems like a shell login would   still have access.</span></text><author><a class="comment-user" href="/users/69993/kzqai" title="12,386 reputation">Kzqai</a></author></comment><comment><text><span class="comment-copy">Definitely, but if someone has shell access, your entire account has been compromised anyway.</span></text><author><a class="comment-user" href="/users/94671/kellen" title="4,215 reputation">kellen</a></author></comment><comment><text><span class="comment-copy">There is no real solution for this. Anyone can use dump functions in file, upload the file to production server and execute it. Yayy you got all the secrets of production server !</span></text><author><a class="comment-user" href="/users/1447576/ankit" title="113 reputation">Ankit</a></author></comment><comment><text><span class="comment-copy">This is bad practice because you might accidentally commit your credentials to a repository.</span></text><author><a class="comment-user" href="/users/3736937/porlune" title="423 reputation">Porlune</a></author></comment><comment><text><span class="comment-copy">@Ankit: If it's possible for a non-friendly to upload a file to the server and execute it, then the server is not properly configured.</span></text><author><a class="comment-user" href="/users/94671/kellen" title="4,215 reputation">kellen</a></author></comment><comment><text><span class="comment-copy">@Porlune: Developers should make their version control system ignore the password file, i.e. by using a .gitignore. But yes, care should be taken with files that contain sensitive data.</span></text><author><a class="comment-user" href="/users/94671/kellen" title="4,215 reputation">kellen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Store them in a file outside web root.</p>
</div></text><author><a href="/users/14979/da5id">da5id</a></author><comments><comment><text><span class="comment-copy">And also, as mentioned elsewhere, outside of source control.</span></text><author><a class="comment-user" href="/users/82769/frank-farmer" title="23,963 reputation">Frank Farmer</a></author></comment><comment><text><span class="comment-copy">we would be able to include it? e.g. in PHP can we then do <code>include('../otherDirectory/configfile.conf')</code> ?</span></text><author><a class="comment-user" href="/users/1135954/mtk" title="6,233 reputation">mtk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>For extremely secure systems we encrypt the database password in a configuration file (which itself is secured by the system administrator). On application/server startup the application then prompts the system administrator for the decryption key. The database password is then read from the config file, decrypted, and stored in memory for future use. Still not 100% secure since it is stored in memory decrypted, but you have to call it 'secure enough' at some point!</p>
</div></text><author><a href="/users/7819/pdavis">pdavis</a></author><comments><comment><text><span class="comment-copy">what if the admin dies ?</span></text><author><a class="comment-user" href="/users/995822/radu-murzea" title="7,011 reputation">Radu Murzea</a></author></comment><comment><text><span class="comment-copy">@RaduMurzea that's ridiculous. When have you heard of Sys Admins dying? They're like McDonalds, they just appear/disappear out of nowhere!</span></text><author><a class="comment-user" href="/users/1315565/ilikebeanstacos" title="3,216 reputation">ILikeBeansTacos</a></author></comment><comment><text><span class="comment-copy">@Radu Murzea Just have 2 or more admins, then you have parity like a raid array. Chances of more than one drive failing at a time is much lower.</span></text><author><a class="comment-user" href="/users/1034876/element11" title="1,240 reputation">element11</a></author></comment><comment><text><span class="comment-copy">what about when the servers restart? What about the time it takes to wake the admin up to get them to type the password in..etc.etc. lol</span></text><author><a class="comment-user" href="/users/421398/john-hunt" title="1,392 reputation">John Hunt</a></author></comment><comment><text><span class="comment-copy">iam 100% agreed, that was oracle weblogic done with boot.properties</span></text><author><a class="comment-user" href="/users/2622017/nurulhudamustaqim" title="305 reputation">nurulhudamustaqim</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The most secure way is to not have the information specified in your PHP code at all.</p>
<p>If you're using Apache that means to set the connection details in your httpd.conf or virtual hosts file file. If you do that you can call mysql_connect() with no parameters, which means PHP will never ever output your information.</p>
<p>This is how you specify these values in those files:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">php_value mysql</span><span class="pun">.</span><span class="kwd">default</span><span class="pun">.</span><span class="pln">user      myusername
php_value mysql</span><span class="pun">.</span><span class="kwd">default</span><span class="pun">.</span><span class="pln">password  mypassword
php_value mysql</span><span class="pun">.</span><span class="kwd">default</span><span class="pun">.</span><span class="pln">host      server</span></code></pre>
<p>Then you open your mysql connection like this:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
$db </span><span class="pun">=</span><span class="pln"> mysqli_connect</span><span class="pun">();</span></code></pre>
<p>Or like this:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
$db </span><span class="pun">=</span><span class="pln"> mysqli_connect</span><span class="pun">(</span><span class="pln">ini_get</span><span class="pun">(</span><span class="str">"mysql.default.user"</span><span class="pun">),</span><span class="pln">
                     ini_get</span><span class="pun">(</span><span class="str">"mysql.default.password"</span><span class="pun">),</span><span class="pln">
                     ini_get</span><span class="pun">(</span><span class="str">"mysql.default.host"</span><span class="pun">));</span></code></pre>
</div></text><author><a href="/users/1227116/lars-nystr%c3%b6m">Lars Nyström</a></author><comments><comment><text><span class="comment-copy">Please check the proper values of ini_get('default values') <a href="http://www.php.net/manual/en/class.mysqli.php" rel="nofollow noreferrer">php.net/manual/en/class.mysqli.php</a></span></text><author><a class="comment-user" href="/users/240215/val" title="9,899 reputation">Val</a></author></comment><comment><text><span class="comment-copy">Could one use this in their .htaccess file?</span></text><author><span class="comment-user">user1193509</span></author></comment><comment><text><span class="comment-copy">@user1193509 Yes.</span></text><author><a class="comment-user" href="/users/2408964/untill" title="560 reputation">untill</a></author></comment><comment><text><span class="comment-copy">yes, but any user (or a hacker abusing badly written php script) can read the password via <code>ini_get()</code>.</span></text><author><a class="comment-user" href="/users/1129642/marki555" title="3,352 reputation">Marki555</a></author></comment><comment><text><span class="comment-copy">@Marki555 <code>but any user (or a hacker abusing badly written php script) can read the password via ini_get()</code> How do you deal with this?</span></text><author><a class="comment-user" href="/users/3019105/tonix" title="1,928 reputation">tonix</a></author></comment><comment><text><span class="comment-copy">Marki555 is saying that an attacker who can run PHP code can also call PHP functions, which is obviously true and impossible to do something about. I would also like to add that I no longer follow the advice I give in this answer myself, but instead use environment variables. The concept is similar though: Don't store your credentials in the code, but inject them somehow. It doesn't really matter if you use <code>ini_get()</code> or <code>getenv()</code>.</span></text><author><a class="comment-user" href="/users/1227116/lars-nystr%c3%b6m" title="1,858 reputation">Lars Nyström</a></author></comment><comment><text><span class="comment-copy">@tonix as already written, if "good" script has access to db password, then also "bad" script does. So your only option is to detect such scripts and don't allow them to run, for example using <code>mod_security</code> apache module, although it is not trivial to fine-tune the rules correctly.</span></text><author><a class="comment-user" href="/users/1129642/marki555" title="3,352 reputation">Marki555</a></author></comment><comment><text><span class="comment-copy">@Marki555 I can think of using a single DB connection entry point where I read the password and the username of the database and pass them to the connection engine in order to get the database connection and then unset those variables. At this point I need to beware everyone's push to the codebase and assure that there are no changes to that entry point file and no one is trying to dump the password of the database somehow. Could it be enough?</span></text><author><a class="comment-user" href="/users/3019105/tonix" title="1,928 reputation">tonix</a></author></comment><comment><text><span class="comment-copy">Having the pass in config file outside root, is safer that exposing it to ini_get() or getenv() that could be injected and executed from anywhere in the website.</span></text><author><a class="comment-user" href="/users/2007059/deepblue" title="327 reputation">DeepBlue</a></author></comment><comment><text><span class="comment-copy">@DeepBlue If you can inject ini_get() you can inject file_get_contents(anypath) as well. As long as php has a way to get to the password, so will any malicious code.</span></text><author><a class="comment-user" href="/users/966508/varesa" title="1,162 reputation">varesa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>This solution is general, in that it is useful for both open and closed source applications.</p>
<ol>
<li>Create an OS user for your application. See <a href="http://en.wikipedia.org/wiki/Principle_of_least_privilege" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Principle_of_least_privilege</a> </li>
<li>Create a (non-session) OS environment variable for that user, with the password</li>
<li>Run the application as that user</li>
</ol>
<p>Advantages:</p>
<ol>
<li>You won't check your passwords into source control by accident, because you can't</li>
<li>You won't accidentally screw up file permissions. Well, you might, but it won't affect this.</li>
<li>Can only be read by root or that user. Root can read all your files and encryption keys anyways.</li>
<li>If you use encryption, how are you storing the key securely?</li>
<li>Works x-platform</li>
<li>Be sure to not pass the envvar to untrusted child processes</li>
</ol>
<p>This method is suggested by Heroku, who are very successful. </p>
</div></text><author><a href="/users/223478/neil-mcguigan">Neil McGuigan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Your choices are kind of limited as as you say you need the password to access the database. One general approach is to store the username and password in a seperate configuration file rather than the main script. Then be sure to store that outside the main web tree. That was if there is a web configuration problem that leaves your php files being simply displayed as text rather than being executed you haven't exposed the password.</p>
<p>Other than that you are on the right lines with minimal access for the account being used. Add to that</p>
<ul>
<li>Don't use the combination of username/password for anything else</li>
<li>Configure the database server to only accept connections from the web host for that user (localhost is even better if the DB is on the same machine) That way even if the credentials are exposed they are no use to anyone unless they have other access to the machine.</li>
<li>Obfuscate the password (even ROT13 will do) it won't put up much defense if some does get access to the file, but at least it will prevent casual viewing of it.</li>
</ul>
<p>Peter </p>
</div></text><author><a href="/users/3720/vagnerr">Vagnerr</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>if it is possible to create the database connection in the same file where the credentials are stored. Inline the credentials in the connect statement.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_connect</span><span class="pun">(</span><span class="str">"localhost"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"me"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"mypass"</span><span class="pun">);</span></code></pre>
<p>Otherwise it is best to unset the credentials after the connect statement, because credentials that are not in memory, can't be read from memory ;)</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">include</span><span class="pun">(</span><span class="str">"/outside-webroot/db_settings.php"</span><span class="pun">);</span><span class="pln">  
mysql_connect</span><span class="pun">(</span><span class="str">"localhost"</span><span class="pun">,</span><span class="pln"> $db_user</span><span class="pun">,</span><span class="pln"> $db_pass</span><span class="pun">);</span><span class="pln">  
unset </span><span class="pun">(</span><span class="pln">$db_user</span><span class="pun">,</span><span class="pln"> $db_pass</span><span class="pun">);</span><span class="pln">  </span></code></pre>
</div></text><author><a href="/users/19165/bob-fanger">Bob Fanger</a></author><comments><comment><text><span class="comment-copy">If someone has access to the memory, you're screwed anyway. This is pointless fake-security. Outside the webroot (or at the least protected by a .htaccess if you don't have access above your webroot) is the only safe option.</span></text><author><a class="comment-user" href="/users/242278/uliwitness" title="4,826 reputation">uliwitness</a></author></comment><comment><text><span class="comment-copy">@uliwitness - That's like saying that just because someone can cut through your network operation center's lock with an acetylene torch means that the door is also fake security.  Keeping sensitive information bound to the tightest possible scope always makes sense.</span></text><author><a class="comment-user" href="/users/1476330/luke-a-leber" title="401 reputation">Luke A. Leber</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you are using PostgreSQL, then it looks in <code>~/.pgpass</code> for passwords automatically.  See <a href="http://www.postgresql.org/docs/8.3/interactive/libpq-pgpass.html" rel="nofollow noreferrer">the manual</a> for more information.</p>
</div></text><author><a href="/users/8427/jim">Jim</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Put the database password in a file, make it read-only to the user serving the files.</p>
<p>Unless you have some means of only allowing the php server process to access the database, this is pretty much all you can do.</p>
</div></text><author><a href="/users/15578/chris">Chris</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If you're talking about the database password, as opposed to the password coming from a browser, the standard practice seems to be to put the database password in a PHP config file on the server.</p>
<p>You just need to be sure that the php file containing the password has appropriate permissions on it. I.e. it should be readable only by the web server and by your user account.</p>
</div></text><author><a href="/users/11078/jason-wadsworth">Jason Wadsworth</a></author><comments><comment><text><span class="comment-copy">Unfortunately the PHP config file can be read by phpinfo() and if someone happens to leave some test script behind a lucky attacker would be able to read the password.  It's probably best to leave the connection password in a file outside the web server root instead. Then the only way to access it is either with a shell or by executing arbitrary code, but in that scenario all security is lost anyway.</span></text><author><a class="comment-user" href="/users/426293/mariovilas" title="751 reputation">MarioVilas</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I think the OP means the database password.</p>
<p>Unless someone gains access to your server via FTP or SSH (in which case you're already buggered), I wouldn't worry about storing passwords in plaintext in PHP files. Most PHP applications I've seen do it that way, for example phpbb.</p>
</div></text><author><a href="/users/15245/ryan-bigg">Ryan Bigg</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Best way is to not store the password at all!<br/>
For instance, if you're on a Windows system, and connecting to SQL Server, you can use Integrated Authentication to connect to the database without a password, using the current process's identity.</p>
<p>If you do need to connect with a password, first <strong>encrypt</strong> it, using strong encryption (e.g. using AES-256, and then protect the encryption key, or using asymmetric encryption and have the OS protect the cert), and then store it in a configuration file (outside of the web directory) with <strong>strong ACLs</strong>.</p>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">No point in encrypting the password <i>again</i>. Someone who could get at the unencrypted password can also get at whatever passphrase is needed to decrypt the password. However, using ACLs &amp; .htaccess is a good idea.</span></text><author><a class="comment-user" href="/users/242278/uliwitness" title="4,826 reputation">uliwitness</a></author></comment><comment><text><span class="comment-copy">@uliwitness I think you may have misunderstood - what do you mean by "encrypt <i>again</i>"? It's just the one encryption. And you don't want to be using passphrases (intended for human use) to encrypt it, rather strong key management, e.g. protected by the OS, in such a way that simply accessing the file system will not grant access to the key.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">Encryption is not magic - instead of protecting the AES key with ACLs you could just store the password there. There is no difference between accessing the AES key or the decrypted password, encryption in this context is just snake oil.</span></text><author><a class="comment-user" href="/users/426293/mariovilas" title="751 reputation">MarioVilas</a></author></comment><comment><text><span class="comment-copy">@MarioVilas whaat? If the password is encrypted, with the encryption key protected by the OS, how is there no difference? Encryption is not magic - it just compacts all the secrecy into the smaller encryption key. Hardly snakeoil, in this context it is just <i>moving</i> all that secrecy into the OS.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD how come the OS can protect the key but not the data itself? Answer: it can protect both, so encryption doesn't really help. It'd be different if only the data was stored and the encryption key was derived, for example, from a password that had to be <i>typed</i> by a user.</span></text><author><a class="comment-user" href="/users/426293/mariovilas" title="751 reputation">MarioVilas</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>An additional trick is to use a PHP separate configuration file that looks like that :</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php </span><span class="kwd">exit</span><span class="pun">()</span><span class="pln"> </span><span class="pun">?&gt;</span><span class="pln">

[...]

Plain text data including password</span></code></pre>
<p>This does not prevent you from setting access rules properly. But in the case your web site is hacked, a "require" or an "include" will just exit the script at the first line so it's even harder to get the data.</p>
<p>Nevertheless, do not ever let configuration files in a directory that can be accessed through the web. You should have a "Web" folder containing your controler code, css, pictures and js. That's all. Anything else goes in offline folders.</p>
</div></text><author><a href="/users/9951/e-satis">e-satis</a></author><comments><comment><text><span class="comment-copy">but then how does the php script read the credentials stored in the file?</span></text><author><a class="comment-user" href="/users/479/christopher-mahan" title="5,072 reputation">Christopher Mahan</a></author></comment><comment><text><span class="comment-copy">You use fopen(), like for a regular text file.</span></text><author><a class="comment-user" href="/users/9951/e-satis" title="275,732 reputation">e-satis</a></author></comment><comment><text><span class="comment-copy">@e-satis ok it will prevent hacker to do <code>require</code>/<code>include</code> but how to prevent to do <code>fopen</code>?</span></text><author><a class="comment-user" href="/users/904846/dmnc" title="516 reputation">dmnc</a></author></comment><comment><text><span class="comment-copy">"this does not prevent you from setting access rules properly"</span></text><author><a class="comment-user" href="/users/9951/e-satis" title="275,732 reputation">e-satis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Just putting it into a config file somewhere is the way it's usually done. Just make sure you:</p>
<ol>
<li>disallow database access from any servers outside your network, </li>
<li>take care not to accidentally show the password to users (in an error message, or through PHP files accidentally being served as HTML, etcetera.)</li>
</ol>
</div></text><author><a href="/users/12038/marijn">Marijn</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Previously we stored DB user/pass in a configuration file, but have since hit paranoid mode -- adopting a policy of <em>Defence in Depth</em>.</p>
<p>If your application is compromised, the user will have read access to your configuration file and so there is potential for a cracker to read this information.  Configuration files can also get caught up in version control, or copied around servers.</p>
<p>We have switched to storing user/pass in environment variables set in the Apache VirtualHost. This configuration is only readable by root -- hopefully your Apache user is not running as root.</p>
<p>The con with this is that now the password is in a Global PHP variable.</p>
<p>To mitigate this risk we have the following precautions:</p>
<ul>
<li><strong>The password is encrypted.</strong> We extend the PDO class to include logic for decrypting the password. If someone reads the code where we establish a connection, it won't be obvious that the connection is being established with an encrypted password and not the password itself.</li>
<li><strong>The encrypted password is moved from the global variables into a private variable</strong> The application does this immediately to reduce the window that the value is available in the global space.</li>
<li><strong><code>phpinfo()</code> is disabled.</strong> PHPInfo is an easy target to get an overview of everything, including environment variables.</li>
</ul>
</div></text><author><a href="/users/2045006/user2045006">user2045006</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>We have solved it in this way:</p>
<ol>
<li>Use memcache on server, with open connection from other password server.</li>
<li>Save to memcache the password (or even all the password.php file encrypted) plus the decrypt key.</li>
<li>The web site, calls the memcache key holding the password file passphrase and decrypt in memory all the passwords.</li>
<li>The password server send a new encrypted password file every 5 minutes.</li>
<li>If you using encrypted password.php on your project, you put an audit, that check if this file was touched externally - or viewed. When this happens, you automatically can clean the memory, as well as close the server for access.</li>
</ol>
</div></text><author><a href="/users/2511995/asi-azulay">Asi Azulay</a></author><comments/></answer></answers></post>