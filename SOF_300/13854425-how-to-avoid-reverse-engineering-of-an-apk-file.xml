<?xml version="1.0" encoding="utf-8"?>
<post><title>android - How to avoid reverse engineering of an APK file? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am developing a <strong>payment processing app</strong> for Android, and I want to prevent a hacker from accessing any resources, assets or source code from the <a href="http://en.wikipedia.org/wiki/APK_%28file_format%29" rel="noreferrer">APK</a> file.</p>
<p>If someone changes the .apk extension to .zip then they can unzip it and easily access all the app's resources and assets, and using <a href="http://code.google.com/p/dex2jar/wiki/Faq" rel="noreferrer">dex2jar</a> and a Java decompiler, they can also access the source code. It's very easy to reverse engineer an Android APK file - for more details see Stack Overflow question <em><a href="http://stackoverflow.com/questions/12732882/reverse-engineering-from-apk-to-project">Reverse engineering from an APK file to a project</a></em>.</p>
<p>I have used the Proguard tool provided with the Android SDK. When I reverse engineer an APK file generated using a signed keystore and Proguard, I get obfuscated code. However, the names of Android components remain unchanged and some code, like key-values used in the app, remains unchanged. As per Proguard documentation the tool can't obfuscate components mentioned in the Manifest file.</p>
<p>Now my questions are:</p>
<ol>
<li>How can I <strong>completely avoid</strong> reverse engineering of an Android APK? Is this possible?</li>
<li>How can I protect all the app's resources, assets and source code so that hackers can't hack the APK file in any way?</li>
<li><strong>Is there a way to make hacking more tough or even impossible?</strong> What more can I do to protect the source code in my APK file?</li>
</ol>
</div></text><author><a href="/users/3366929/astrocb">AstroCB</a></author><comments><comment><text><span class="comment-copy">It sounds like you may be using "security by obscurity" if your payment processing scheme relies on the operation of the client remaining secret.</span></text><author><a class="comment-user" href="/users/1599751/peterj" title="2,250 reputation">PeterJ</a></author></comment><comment><text><span class="comment-copy">@PeterJ thanks for your reply, I am using Proguard tool to provide security to my app. <a href="http://developer.android.com/tools/help/proguard.html" rel="nofollow noreferrer">developer.android.com/tools/help/proguard.html</a></span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy">Have you considered writing the important parts of the code in C/C++ and add them as a compiled library? They can be disassembled into assembly code, but reverse-engineering a large library from assembly is extremely timeconsuming.</span></text><author><a class="comment-user" href="/users/713554/leo" title="1,401 reputation">Leo</a></author></comment><comment><text><span class="comment-copy">@Leo I will try your suggestion to write important code in C/C++.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy"><a href="http://boomerang.sourceforge.net" rel="nofollow noreferrer">Yes, nobody can decompile C code</a> ...</span></text><author><a class="comment-user" href="/users/1244588/dualed" title="6,116 reputation">dualed</a></author></comment><comment><text><span class="comment-copy">Welcome to the fundamental issue of creating any digital asset. Hackers can get down to the machine instruction level, so if a computer can read the file then it can be hacked open/copied, an no amount of obfuscation or DRM can ever completely stop a determined hacker. If you need security then make sure that the private keys are never in source, and know at the design stage that only isolation (remote and/or dedicated hardware) can ever protect them.</span></text><author><a class="comment-user" href="/users/905/keith" title="73,049 reputation">Keith</a></author></comment><comment><text><span class="comment-copy">I don't know why you want to obfuscate your code but I hope it's not necessary for the core security (for the user) of your payment processing app, because you should never design or even implement any cryptography parts yourself and instead use openly available standards. Hopefully this wasn't relevant.</span></text><author><a class="comment-user" href="/users/1734730/nathan-cooper" title="2,784 reputation">Nathan Cooper</a></author></comment><comment><text><span class="comment-copy">@NathanCooper By reading all these reply I decided to move core coding in java to Native code - C/C++ &amp; for rest java code proguard + DexGuard is okay. Other better solutions are always welcome.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy">@dualed:  Have you seen the output that Boomerang gives?  It's so terrible it's completely useless for anything but the most trivial programs.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">@BlueRaja-DannyPflughoeft The "fanciness" of the generated code does not really matter. Of course it can not infer the original function and variable names because that information is simply not in the file. But any string in the executable is in there as plain text and any nifty algorithm you may want to protect will work just as well as generated code or assembly no matter how bad it looks. On top of that you lose compatibility, as native code for ARM will certainly not run on Atom, etc.</span></text><author><a class="comment-user" href="/users/1244588/dualed" title="6,116 reputation">dualed</a></author></comment><comment><text><span class="comment-copy">Note that depending on what your payment processing app does, there may be regulatory and legal policy that affects your app and could potetially expose you to severe penalties: see PCI compliance, starting with <a href="http://www.pcicomplianceguide.org/pcifaqs.php#11" rel="nofollow noreferrer">pcicomplianceguide.org/pcifaqs.php#11</a>.</span></text><author><a class="comment-user" href="/users/14819/bloopletech" title="902 reputation">bloopletech</a></author></comment><comment><text><span class="comment-copy">@dualed: Sure it can be decompiled. Anything can be reverse-engineered, the question is at what cost (in time or money). I haven't  looked at the output from Boomerang or Dedexer, but I would assume that the output from Boomerang would be significantly harder to interpret which is what the OP asked for. If you want to take it one level further, write directly in assembly. As for the algorithm working just as well in assembly or generated code, well that is sort of the point. If you just want to use the algorithm directly, why reverse-engineer it?</span></text><author><a class="comment-user" href="/users/713554/leo" title="1,401 reputation">Leo</a></author></comment><comment><text><span class="comment-copy">Oh, and Boomerang does not support ARM apparently.</span></text><author><a class="comment-user" href="/users/713554/leo" title="1,401 reputation">Leo</a></author></comment><comment><text><span class="comment-copy">@Leo That is the point. The cost is the same for the attacker. They just use a different tool. On the other hand the OP may now have the false security that their native code is not (easily) readable. And since DexGuard can obfuscate string constants, it is probably more effective.</span></text><author><a class="comment-user" href="/users/1244588/dualed" title="6,116 reputation">dualed</a></author></comment><comment><text><span class="comment-copy">@dualed sorry, but decompiled Java or C# is far more readable than decompiled/disassembled native code, so the cost for the attacker is not the same, not even close. Even on logarithmic scale ))</span></text><author><a class="comment-user" href="/users/913845/zar-shardan" title="3,136 reputation">Zar Shardan</a></author></comment><comment><text><span class="comment-copy">@ZarShardan Oh yes, and you make it so much harder for an attacker to find sensitive sections of code by moving them to a separate file ...</span></text><author><a class="comment-user" href="/users/1244588/dualed" title="6,116 reputation">dualed</a></author></comment><comment><text><span class="comment-copy">Google itself tried to tackle on piracy by saving encrypted apks in <code>/mnt/asec</code>, starting in JB. I think the whole thing was disabled due to bugs. I don't know what is the current state of this mechanism, but even if it were in place it would only make things harder for JB+ non-rooted devices.</span></text><author><a class="comment-user" href="/users/813951/mister-smith" title="13,798 reputation">Mister Smith</a></author></comment><comment><text><span class="comment-copy">@dualed: <code>The "fanciness" of the generated code does not really matter.</code> Er, yes it does, especially when the output-C is essentially the same as the input-assembly.  Not only are the function names not there, but I've found that most of the time, it can't even <i>recognize</i> a function call, or basic combinations of arithmetic, or anything else that would make the C easier to read than the assembly.  The output is basically useless.  And that's when Boomerang <i>can</i> actually decompile a program without crashing or erroring out, which is also pretty rare.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">Even assuming an equivalently high level of competence in interpreting both native assembly and, say, Java bytecode, it's clearly going to be quicker to make something out of the Java because of the extra information in bytecode and slightly higher level instructions.</span></text><author><a class="comment-user" href="/users/1208271/elliott" title="507 reputation">Elliott</a></author></comment><comment><text><span class="comment-copy">Are you sure you should be coding security sensitve applications, if you think that programs can be absolutely protected against reverse engineering and tampering, without tamper-resistant hardware? (Or even with?)</span></text><author><a class="comment-user" href="/users/1250772/kaz" title="31,980 reputation">Kaz</a></author></comment><comment><text><span class="comment-copy">I don't believe in security by obscurity - Everybody knows how common encryption algorithms work, but it doesn't make them less secure. As long as the keys are well protected. I don't see how this payment processing application is any different. Knowing its internals won't help the attacker to break into the payment system if the design is solid and keys/password remain secret and different for every client.</span></text><author><a class="comment-user" href="/users/913845/zar-shardan" title="3,136 reputation">Zar Shardan</a></author></comment><comment><text><span class="comment-copy">Possible Duplicate of This [Link][1] !         [1]: <a href="http://stackoverflow.com/questions/3593420/android-getting-source-code-from-an-apk-file" title="android getting source code from an apk file">stackoverflow.com/questions/3593420/…</a></span></text><author><a class="comment-user" href="/users/1635859/hardik-thaker" title="2,281 reputation">Hardik Thaker</a></author></comment><comment><text><span class="comment-copy">What is the name of this payment app so I know not to use it? The OP seems to miss the point that security through obscurity is not security at all...</span></text><author><a class="comment-user" href="/users/152580/eloff" title="8,722 reputation">Eloff</a></author></comment><comment><text><span class="comment-copy">@HardikThaker This is not duplicate question like you mentioned in that link, read my questions again.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy">See also <a href="http://stackoverflow.com/questions/5600143/android-game-keeps-getting-hacked">Android Game Keeps Getting Hacked</a></span></text><author><a class="comment-user" href="/users/94363/rds" title="12,792 reputation">rds</a></author></comment><comment><text><span class="comment-copy">you can use <a href="http://www.saikoa.com/dexguard" rel="nofollow noreferrer">dexGuard</a>, it's not 100% secure, but it's the most secure, and it's not free!</span></text><author><a class="comment-user" href="/users/2855059/m-d-p" title="685 reputation">M D P</a></author></comment><comment><text><span class="comment-copy">Check this <a href="https://1belong2jesus.wordpress.com/2014/07/29/configure-proguard/" rel="nofollow noreferrer">1belong2jesus.wordpress.com/2014/07/29/configure-proguard</a></span></text><author><a class="comment-user" href="/users/3020568/deniz" title="6,784 reputation">deniz</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p> 1. How can I completely avoid reverse engineering of an Android APK? Is this possible?</p>
</blockquote>
<p>AFAIK, there is not any trick for complete avoidance of reverse engineering.</p>
<p>And also very well said by @inazaruk: <em>Whatever you do to your code, a potential attacker is able to change it in any way she or he finds it feasible</em>. You basically can't protect your application from being modified. And any protection you put in there can be disabled/removed.</p>
<blockquote>
<p> 2. How can I protect all the app's resources, assets and source code so that hackers can't hack the APK file in any way?</p>
</blockquote>
<p>You can do different tricks to make hacking harder though. For example, use obfuscation (if it's Java code). This usually slows down reverse engineering significantly.</p>
<blockquote>
<p> 3. Is there a way to make hacking more tough or even impossible? What more can I do to protect the source code in my APK file?</p>
</blockquote>
<p>As everyone says, and as you probably know, there's no 100% security. But the place to start for Android, that Google has built in, is ProGuard. If you have the option of including <strong>shared libraries</strong>, you can include the needed code in C++ to verify file sizes, integration,
etc. If you need to add an external native library to your APK's library folder on every build,
then you can use it by the below suggestion.</p>
<p>Put the library in the native library path which defaults to "libs" in
your project folder. If you built the native code for the <strong>'armeabi'</strong> target then put it
under <strong>libs/armeabi</strong>. If it was built with <strong>armeabi-v7a</strong> then put it under
<strong>libs/armeabi-v7a.</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;project&gt;</span><span class="pln">/libs/armeabi/libstuff.so</span></code></pre>
</div></text><author><a href="/users/1297214/bhavesh-patadiya">Bhavesh Patadiya</a></author><comments><comment><text><span class="comment-copy">For Payment transaction I've used ISO 8585 standard, right now  schema for this standard is in key-value pair using HashMap collection of Java &amp; when I do reverse engineering on apk I'll get all schema.Is it possible to avoid schema get exposed via reverse engineering.? Can your last suggestion of Share libraries useful in this case? Doy you have any links so that I can get exposure to the share libraries in android.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy">how about encrypting your strings in the code and decrypting them at runtime? If you do the decryption on a remote server, like other people suggested, you don't get the problem that the decryption key is in the sources.</span></text><author><a class="comment-user" href="/users/1319284/kutschkem" title="1,823 reputation">kutschkem</a></author></comment><comment><text><span class="comment-copy">yes, encryption is way, but it is not sure to be notHacked. If i  am encrypting String in order to decrypt them, i need one unique id in the code. and if anyone able to decompile it then it will be very easy to get the Unique id.</span></text><author><a class="comment-user" href="/users/1297214/bhavesh-patadiya" title="17,552 reputation">Bhavesh Patadiya</a></author></comment><comment><text><span class="comment-copy">why you added <i>Edited</i> stuff? its all regular.</span></text><author><a class="comment-user" href="/users/739270/azhar-shaikh" title="29,566 reputation">Azhar Shaikh</a></author></comment><comment><text><span class="comment-copy">@hotveryspicy: yes i have now removed the "edited" mark from answer.i have edited my answer beacause he wanted to know more about how Share libraries useful in this case.</span></text><author><a class="comment-user" href="/users/1297214/bhavesh-patadiya" title="17,552 reputation">Bhavesh Patadiya</a></author></comment><comment><text><span class="comment-copy">@Bhavesh yes your correct, I was looking for shared libaries, I'm still working on it, anyways thanks for reply.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy">how to hide string inside " " i use proguard but it's not hide or convert value inside " " is there anyway to hide that?</span></text><author><a class="comment-user" href="/users/6333971/b-devloper" title="130 reputation">b devloper</a></author></comment><comment><text><span class="comment-copy">this is old. but for someone looking for extra information. you don't have to  use one unique key. see this: <a href="http://www.androidauthority.com/how-to-hide-your-api-key-in-android-600583/" rel="nofollow noreferrer">androidauthority.com/how-to-hide-your-api-key-in-android-600‌​583</a></span></text><author><a class="comment-user" href="/users/766985/dreaded-semicolon" title="1,717 reputation">Dreaded semicolon</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>AFAIK, you cannot protect the files in the /res directory anymore than they are protected right now.</p>
<p>However, there are steps you can take to protect your source code, or at least what it does if not everything.</p>
<ol>
<li>Use tools like ProGuard. These will obfuscate your code, and make it harder to read when decompiled, if not impossible.</li>
<li>Move the most critical parts of the service out of the app, and into a webservice, hidden behind a server side language like PHP. For example, if you have an algorithm that's taken you a million dollars to write. You obviously don't want people stealing it out of your app. Move the algorithm and have it process the data on a remote server, and use the app to simply provide it with the data. Or use the NDK to write them natively into .so files, which are much less likely to be decompiled than apks. I don't think a decompiler for .so files even exists as of now (and even if it did, it wouldn't be as good as the Java decompilers). Additionally, as @nikolay mentioned in the comments, you should use SSL when interacting between the server and device.</li>
<li>When storing values on the device, don't store them in a raw format. For example, if you have a game, and you're storing the amount of in game currency the user has in SharedPreferences. Let's assume it's <code>10000</code> coins. Instead of saving <code>10000</code> directly, save it using an algorithm like <code>((currency*2)+1)/13</code>. So instead of <code>10000</code>, you save <code>1538.53846154</code> into the SharedPreferences. However, the above example isn't perfect, and you'll have to work to come up with an equation that won't lose currency to rounding errors etc.</li>
<li>You can do a similar thing for server side tasks. Now for an example, let's actually take your payment processing app. Let's say the user has to make a payment of <code>$200</code>. Instead of sending a raw <code>$200</code> value to the server, send a series of smaller, predefined, values that add up to <code>$200</code>. For example, have a file or table on your server that equates words with values. So let's say that <code>Charlie</code> corresponds to <code>$47</code>, and <code>John</code> to <code>$3</code>. So instead of sending <code>$200</code>, you can send <code>Charlie</code> four times and <code>John</code> four times. On the server, interpret what they mean and add it up. This prevents a hacker from sending arbitrary values to your server, as they do not know what word corresponds to what value. As an added measure of security, you could have an equation similar to point 3 for this as well, and change the keywords every <code>n</code> number of days.</li>
<li>Finally, you can insert random useless source code into your app, so that the hacker is looking for a needle in a haystack. Insert random classes containing snippets from the internet, or just functions for calculating random things like the Fibonacci sequence. Make sure these classes compile, but aren't used by the actual functionality of the app. Add enough of these false classes, and the hacker would have a tough time finding your real code.</li>
</ol>
<p>All in all, there's no way to protect your app 100%. You can make it harder, but not impossible. Your web server could be compromised, the hacker could figure out your keywords by monitoring multiple transaction amounts and the keywords you send for it, the hacker could painstakingly go through the source and figure out which code is a dummy.</p>
<p>You can only fight back, but never win.</p>
</div></text><author><a href="/users/1069068/raghav-sood">Raghav Sood</a></author><comments><comment><text><span class="comment-copy">Instead of doing tricks with values you send to your server, use SSL and properly validate the server certificate. Security by obscurity is generally a bad idea.</span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy">@NikolayElenkov That would only protect the values during the transfer from device to server. By obscuring it, you can protect it while it is in the RAM, and in device storage.</span></text><author><a class="comment-user" href="/users/1069068/raghav-sood" title="62,629 reputation">Raghav Sood</a></author></comment><comment><text><span class="comment-copy">Really? If I have your RAM I own you anyway...</span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy">Well, true :P But there's no point just sitting back and letting the hacker have a free run.</span></text><author><a class="comment-user" href="/users/1069068/raghav-sood" title="62,629 reputation">Raghav Sood</a></author></comment><comment><text><span class="comment-copy">BTW, the same goes for storing things in files: use proper obfuscation or encryption, not easy tricks.</span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy"><b>you can insert random useless source code into your app</b>. This can't really help either. This will only bloat your application up, while making it harder to maintain as well.</span></text><author><a class="comment-user" href="/users/759019/anirudh-ramanathan" title="34,473 reputation">Anirudh Ramanathan</a></author></comment><comment><text><span class="comment-copy">@Cthulhu these aren't meant to help with the server side or the mid transaction. These are meant to help with the case where someone decompiles your app and goes through the code to look at your implementation etc. with the intention to steal it. If you have random code, it's harder for them to find what they want.</span></text><author><a class="comment-user" href="/users/1069068/raghav-sood" title="62,629 reputation">Raghav Sood</a></author></comment><comment><text><span class="comment-copy"><i>harder?</i> Yes. But they don't give you anything but a false sense of security. It isn't that hard to weed out the code which is never executed, so why bother doing that.</span></text><author><a class="comment-user" href="/users/759019/anirudh-ramanathan" title="34,473 reputation">Anirudh Ramanathan</a></author></comment><comment><text><span class="comment-copy">I get that, and I fully agree. While it may not be amazingly secure or a major roadblock to the hacker, it does provide some protection, even if it is minor.</span></text><author><a class="comment-user" href="/users/1069068/raghav-sood" title="62,629 reputation">Raghav Sood</a></author></comment><comment><text><span class="comment-copy">You could also fake use the useless code and send the data to the server which will discard it. False security maybe, but a pain in the ass for the potential hacker, right?</span></text><author><a class="comment-user" href="/users/334493/benoit-duffez" title="4,058 reputation">Benoit Duffez</a></author></comment><comment><text><span class="comment-copy">If your algorithm is worth a million dollars, then just because there's no decompiler for <code>.so</code> files doesn't mean I can't read assembly :) Most of these fall into the same trap, just obfuscating instead of properly protecting yourself. Obfuscation only works if it's not worth an attacker's time to follow through, so if you build something on these techniques you'd better hope they don't get popular, otherwise you're screwed because all of a sudden your codebase is unmaintainable and it needs huge changes.</span></text><author><a class="comment-user" href="/users/160783/phoshi" title="225 reputation">Phoshi</a></author></comment><comment><text><span class="comment-copy">If you try things like replacing numbers with predefined words or saving values after passing them through functions, then you are on the wrong path already. These are the most basic cryptographic techniques that have been used and broken long time ago through the simplest cryptanalitic attacks and they won't last long in your system.</span></text><author><a class="comment-user" href="/users/1646170/bogdan-alexandru" title="2,398 reputation">Bogdan Alexandru</a></author></comment><comment><text><span class="comment-copy">I don't get why this answer has such a high score. 3. and 4. for one are just plain silly and will amount to no security at all.</span></text><author><a class="comment-user" href="/users/227267/matti-virkkunen" title="45,526 reputation">Matti Virkkunen</a></author></comment><comment><text><span class="comment-copy">@RaghavSood :Need your help .Take a look please <a href="http://stackoverflow.com/questions/22602559/how-do-implement-this-in-android" title="how do implement this in android">stackoverflow.com/questions/22602559/…</a></span></text><author><span class="comment-user">user3177895</span></author></comment><comment><text><span class="comment-copy">number 3, 4 and 5 just seem like such a pain. what if I work in a team? I'd be purposely making the code unreadable and unmaintainable for my present (and future) colleagues. what if I leave the team at any point in time after adding a bunch of cryptic stuff to the code?</span></text><author><a class="comment-user" href="/users/3453281/user3453281" title="311 reputation">user3453281</a></author></comment><comment><text><span class="comment-copy"><code>So let's say that Charlie corresponds to $47, and John to $3.</code> It's a joke, right?</span></text><author><a class="comment-user" href="/users/4466589/boramalper" title="638 reputation">boramalper</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>At no point in the history of computing has it ever been possible to prevent reverse-engineering of software when you give a working copy of it to your attacker. Also, in most likelihood, <strong>it never will be possible</strong>.</p>
<p>With that understood, there is an obvious solution: <em>don't give your secrets to your attacker.</em> While you can't protect the contents of your APK, what you <em>can</em> protect is anything you don't distribute. Typically this is server-side software used for things like activation, payments, rule-enforcement, and other juicy bits of code. You can protect valuable assets by <em>not</em> distributing them in your APK. Instead, set up a server that responds to requests from your app, "uses" the assets (whatever that might mean) and then sends the result back to the app. If this model doesn't work for the assets you have in mind, then you may want to re-think your strategy.</p>
<p>Also, <strong>if your primary goal is to prevent app piracy</strong>: don't even bother. You've already burned more time and money on this problem than any anti-piracy measure could possibly ever hope to save you. The return on investment for solving this problem is so low that it doesn't make sense to even think about it.</p>
</div></text><author><a href="/users/86060/tylerl">tylerl</a></author><comments><comment><text><span class="comment-copy">The first paragraph is the best answer.  If your attacker controls the hardware, they will always be able to defeat your software somehow.  Anything that truly needs to be protected must stay on hardware you control, it's as simple as that.  And the final paragraph, about ROI, is spot on as well.</span></text><author><a class="comment-user" href="/users/128397/daniel-pryden" title="35,229 reputation">Daniel Pryden</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p> 1. How can I completely avoid reverse engineering of an Android APK? Is this possible?</p>
</blockquote>
<p><strong>This isn't possible</strong></p>
<blockquote>
<p> 2. How can I protect all the app's resources, assets and source code so that hackers can't hack the APK file in any way?</p>
</blockquote>
<p>When somebody change a .apk extension to .zip, then after unzipping, someone can easily get all resources (except <em>Manifest.xml</em>), but with <strong><a href="http://code.google.com/p/android-apktool/">APKtool</a></strong> one can get the real content of the manifest file too. Again, a no.</p>
<blockquote>
<p> 3. Is there a way to make hacking more tough or even impossible? What more can I do to protect the source code in my APK file?</p>
</blockquote>
<p>Again, no, but you can prevent upto some level, that is, </p>
<ul>
<li>Download a resource from the Web and do some encryption process</li>
<li>Use a pre-compiled native library (C, C++, JNI, NDK)</li>
<li>Always perform some hashing (<a href="http://en.wikipedia.org/wiki/MD5">MD5</a>/<a href="http://en.wikipedia.org/wiki/SHA-1">SHA</a> keys or any other logic)</li>
</ul>
<p>Even with <code>Smali</code>, people can play with your code. All in all, it's not POSSIBLE.</p>
</div></text><author><a href="/users/739270/azhar-shaikh">Azhar Shaikh</a></author><comments><comment><text><span class="comment-copy">RE - "This isn't possible": Sounds like APK system needs some way of encryption somehow. Matlab has a similar problem of needing to protect IP in deployed applications. <a href="http://www.mathworks.com/products/compiler/description1.html" rel="nofollow noreferrer">Matlab's solution was to use some encryption</a>. Do you think maybe Android APK needs something similar?</span></text><author><a class="comment-user" href="/users/52074/trevor-boyd-smith" title="5,515 reputation">Trevor Boyd Smith</a></author></comment><comment><text><span class="comment-copy">@TrevorBoydSmith: Encryption doesn't help much when the OS is open source and rootable.  The system needs a key in order to decrypt the APK and run stuff.  And if the system has a key, and i have unfettered access to the system, then i know where to find the key and can get to it.  Meaning <i>i have the key now too</i>.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@cHao. I purposely did not specify how to do the encryption because encryption is outside of my domain of knowledge.</span></text><author><a class="comment-user" href="/users/52074/trevor-boyd-smith" title="5,515 reputation">Trevor Boyd Smith</a></author></comment><comment><text><span class="comment-copy">@TrevorBoydSmith: It's the "how to do" part, though, that kills the whole idea.  There's simply no way to execute encrypted code directly;  at some point, the decrypted code has to be available.  Which means (1) there must be a key (that i, as root, probably have access to), and (2) I might even be able to find the clear copy in RAM and just not worry about encryption anyway.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">MD5 is not encryption.</span></text><author><a class="comment-user" href="/users/823542/lex-r" title="811 reputation">Lex R</a></author></comment><comment><text><span class="comment-copy">@cHao I think you are misunderstanding my idea a little. ¶ <i>Everything</i> in security is balanced against cost. The purpose of adding a new security feature to the APK system, just like the purpose of physical security, passwords, CAPTCHA, <i>encryption</i>, and the purpose of virtually every other security measure is to increase the cost of circumvention, not to make circumvention impossible. Also see <a href="http://security.stackexchange.com/questions/26656/if-we-know-captcha-can-be-beat-why-are-we-still-using-them/26667#26667">here</a> or <a href="http://security.stackexchange.com/a/26659/6499">here</a>.</span></text><author><a class="comment-user" href="/users/52074/trevor-boyd-smith" title="5,515 reputation">Trevor Boyd Smith</a></author></comment><comment><text><span class="comment-copy">@TrevorBoydSmith: Problem is, in this case you simply can't raise the cost enough to make it not worthwhile.  We're not talking about brute-forcing keys here; we're talking about <i>already having</i> them -- the OS has to have keys, and we have the OS.  The only way to fix that would be to make the OS unrootable.  Good luck with that; even Apple can't manage it.  :)</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@cHao The way you said "you simply <i>can't</i> raise the cost enough" seems to imply you think raising the cost is impossible. I admit raising the cost is more difficult but definitely not impossible ever.</span></text><author><a class="comment-user" href="/users/52074/trevor-boyd-smith" title="5,515 reputation">Trevor Boyd Smith</a></author></comment><comment><text><span class="comment-copy">@TrevorBoydSmith: I don't think raising the cost <i>in general</i> is impossible.  I think (and say), <i>in particular</i>, that your suggestion is impossible -- because <i>it is</i>.  MATLAB is not Android, and has certain freedoms that Android doesn't.  In particular, it has obfuscation on its side; it's a lot harder to hide an encryption key.  Android can't do that.  Anyone who has the source code would know where the keys are hiding, and would have a tool to retrieve them within 10 minutes of the feature being announced.  It's not just possible to do that; it's downright <i>trivial</i>.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@cHao you keep insisting on some form of encryption involving a static key that never changes and is in the same place. That sounds like a terrible idea and I am not sure why you keep on insisting on it. ¶ This entire conversation is not constructive so I am not going to respond anymore.</span></text><author><a class="comment-user" href="/users/52074/trevor-boyd-smith" title="5,515 reputation">Trevor Boyd Smith</a></author></comment><comment><text><span class="comment-copy">@TrevorBoydSmith: I've insisted nothing of the sort. What i'm insisting is that static, changing, moving, etc <b>do not matter</b>. In an open source OS, encryption alone can not protect the code from anyone who could reverse engineer it.  Because i can read the code that would do the decryption, regardless of how the key is acquired, used, and/or stored, i can see how you did it and replicate it -- even more easily than i could reverse some super-secret app code.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">@TrevorBoydSmith Since you clearly aren't getting this, let's make it simple: The CPU is in my complete control. The CPU must be able to see decrypted code to run it. Therefore, I can see decrypted code. Q.E.D.</span></text><author><a class="comment-user" href="/users/119527/jonathon-reinhart" title="72,124 reputation">Jonathon Reinhart</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>First rule of app security:</strong> Any machine to which an attacker gains unrestricted physical or electronic access now belongs to your attacker, regardless of where it actually is or what you paid for it.</p>
<p><strong>Second rule of app security:</strong> Any software that leaves the physical boundaries inside which an attacker cannot penetrate now belongs to your attacker, regardless of how much time you spent coding it.</p>
<p><strong>Third rule:</strong> Any information that leaves those same physical boundaries that an attacker cannot penetrate now belongs to your attacker, no matter how valuable it is to you.</p>
</blockquote>
<p>The foundations of information technology security are based on these three fundamental principles; the only truly secure computer is the one locked in a safe, inside a Farraday cage, inside a steel cage. There are computers that spend most of their service lives in just this state; once a year (or less), they generate the private keys for trusted root certification authorities (in front of a host of witnesses with cameras recording every inch of the room in which they are located).</p>
<p>Now, most computers are not used under these types of environments; they're physically out in the open, connected to the Internet over a wireless radio channel. In short, they're vulnerable, as is their software. They are therefore not to be trusted. There are certain things that computers and their software must know or do in order to be useful, but care must be taken to ensure that they can never know or do enough to cause damage (at least not permanent damage outside the bounds of that single machine).</p>
<p>You already knew all this; that's why you're trying to protect the code of your application. But, therein lies the first problem; obfuscation tools can make the code a mess for a human to try to dig through, but the program still has to run; that means the actual logic flow of the app and the data it uses are unaffected by obfuscation. Given a little tenacity, an attacker can simply un-obfuscate the code, and that's not even necessary in certain cases where what he's looking at can't be anything else but what he's looking for.</p>
<p>Instead, you should be trying to ensure that an attacker cannot do anything with your code, no matter how easy it is for him to obtain a clear copy of it. That means, no hard-coded secrets, because those secrets aren't secret as soon as the code leaves the building in which you developed it.</p>
<p>These key-values you have hard-coded should be removed from the application's source code entirely. Instead, they should be in one of three places; volatile memory on the device, which is harder (but still not impossible) for an attacker to obtain an offline copy of; permanently on the server cluster, to which you control access with an iron fist; or in a second data store unrelated to your device or servers, such as a physical card or in your user's memories (meaning it will eventually be in volatile memory, but it doesn't have to be for long).</p>
<p>Consider the following scheme. The user enters their credentials for the app from memory into the device. You must, unfortunately, trust that the user's device is not already compromised by a keylogger or Trojan; the best you can do in this regard is to implement multi-factor security, by remembering hard-to-fake identifying information about the devices the user has used (MAC/IP, IMEI, etc), and providing at least one additional channel by which a login attempt on an unfamiliar device can be verified.</p>
<p>The credentials, once entered, are obfuscated by the client software (using a secure hash), and the plain-text credentials discarded; they have served their purpose. The obfuscated credentials are sent over a secure channel to the certificate-authenticated server, which hashes them <em>again</em> to produce the data used to verify the validity of the login. This way, the client never knows what is actually compared to the database value, the app server never knows the plaintext credentials behind what it receives for validation, the data server never knows how the data it stores for validation is produced, and a man in the middle sees only gibberish even if the secure channel were compromised.</p>
<p>Once verified, the server transmits back a token over the channel. The token is only useful within the secure session, is composed of either random noise or an encrypted (and thus verifiable) copy of the session identifiers, and the client application must send this token on the same channel to the server as part of any request to do something. The client application will do this many times, because it can't do anything involving money, sensitive data, or anything else that could be damaging by itself; it must instead ask the server to do this task. The client application will never write any sensitive information to persistent memory on the device itself, at least not in plain text; the client can ask the server over the secure channel for a symmetric key to encrypt any local data, which the server will remember; in a later session the client can ask the server for the same key to decrypt the data for use in volatile memory. That data won't be the only copy, either; anything the client stores should also be transmitted in some form to the server.</p>
<p>Obviously, this makes your application heavily dependent on Internet access; the client device cannot perform any of its basic functions without proper connection to and authentication by the server. No different than Facebook, really.</p>
<p>Now, the computer that the attacker wants is your server, because it and not the client app/device is the thing that can make him money or cause other people pain for his enjoyment. That's OK; you get much more bang for your buck spending money and effort to secure the server than in trying to secure all the clients. The server can be behind all kinds of firewalls and other electronic security, and additionally can be physically secured behind steel, concrete, keycard/pin access, and 24-hour video surveillance. Your attacker would need to be very sophisticated indeed to gain any kind of access to the server directly, and you would (should) know about it immediately. </p>
<p>The best an attacker can do is steal a user's phone and credentials and log in to the server with the limited rights of the client. Should this happen, just like losing a credit card, the legitimate user should be instructed to call an 800 number (preferably easy to remember, and not on the back of a card they'd carry in their purse, wallet or briefcase which could be stolen alongside the mobile device) from any phone they can access that connects them directly to your customer service. They state their phone was stolen, provide some basic unique identifier, and the account is locked, any transactions the attacker may have been able to process are rolled back, and the attacker is back to square one.</p>
</div></text><author><a href="/users/436376/keiths">KeithS</a></author><comments><comment><text><span class="comment-copy">perfect answer !! i just loved your way to get data from server with some encrypted token , i think this is next to impossible to decode after that .</span></text><author><a class="comment-user" href="/users/501483/dhams" title="4,901 reputation">dhams</a></author></comment><comment><text><span class="comment-copy">I know this is a bit late but what about accessing the accessing the server part. Services like Microsoft azure provides you something like this to access their server:   MobileServiceClient mClient = new MobileServiceClient(             "MobileServiceUrl", // Replace with the above Site URL             "AppKey",           // replace with the Application Key              this)  and pretty much anyone who has access to that can access their server end edit it</span></text><author><a class="comment-user" href="/users/3452880/edwinj" title="393 reputation">edwinj</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>100% avoidance of reverse engineering of the Android APK is not possible, but you can use these ways to avoid extracting more data, like source code, assets form your APK, and resources:</p>
<ol>
<li><p>Use ProGuard to obfuscate application code</p></li>
<li><p>Use <em>NDK</em> using <em>C and C++</em> to put your application core and secure part of code in <code>.so</code> files</p></li>
<li><p>To secure resources, don't include all important resources in the assets folder with APK. Download these resources at the time of application first start up.</p></li>
</ol>
</div></text><author><a href="/users/1202025/%cf%81%d1%8f%cf%83%d1%95%cf%81%d1%94%d1%8f-k">ρяσѕρєя K</a></author><comments><comment><text><span class="comment-copy">Third one is really easing the attackers' work. Sniffing network communication is easier than reverse engineering.</span></text><author><a class="comment-user" href="/users/802997/totten" title="1,101 reputation">totten</a></author></comment><comment><text><span class="comment-copy">To solve the problem of the third one, one could encrypt the downloaded content and/or use an encrypted connection (e.g. SSL/TLS)</span></text><author><a class="comment-user" href="/users/925861/stradivari" title="517 reputation">Stradivari</a></author></comment><comment><text><span class="comment-copy">Encrypting the connection protects against people who sniff or modify traffic. In the case where the user himself is malicious (i.e. he has your apk and he has trying to hack it), he will still get the content by using your app, extracting resources as a root user; but yes it does help against simple sniffing attacks.</span></text><author><a class="comment-user" href="/users/2669960/kevin-lee" title="760 reputation">Kevin Lee</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Developers can take following steps to prevent an APK from theft somehow,</p>
<ul>
<li><p>the most basic way is to use tools like <code>ProGuard</code> to obfuscate their code, but up until now, it has been quite difficult to completely prevent someone from decompiling an app.</p></li>
<li><p>Also I have heard about a tool <a href="http://www.decompilingandroid.com/hosedex2jar/" rel="noreferrer">HoseDex2Jar</a>.  It stops <code>Dex2Jar</code> by inserting harmless code in an Android APK that confuses and disables <code>Dex2Jar</code> and protects the code from decompilation. It could somehow prevent hackers from decompiling an APK into readable java code. </p></li>
<li><p>Use some server side application to communicate with the application only when it is needed. It could help prevent the important data.</p></li>
</ul>
<p>At all, you can not completely protect your code from the potential hackers. Somehow, you could make it difficult and a bit frustrating task for them to decompile your code. One of the most efficient way is to write in native code(C/C++) and store it as compiled libraries.</p>
</div></text><author><a href="/users/1626878/sahil-mahajan-mj">Sahil Mahajan Mj</a></author><comments><comment><text><span class="comment-copy">HoseDex2Jar is next to useless. It only 'confuses' dex2jar and can easily be blocked. smali/apktool, etc. work just fine with 'hosed' APKs.</span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy">@NikolayElenkov Do you know how HoseDex2Jar works? What they have used to avoid or to confuse dex2jar.Because I can't upload my apk file to web to use HoseDex2Jar. If I can do something like HoseDex2Jar to confuse dex2jar then It will make tough to hack using dex2jar tool.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment><comment><text><span class="comment-copy"><a href="http://intrepidusgroup.com/insight/2012/10/unhosing-apks/" rel="nofollow noreferrer">intrepidusgroup.com/insight/2012/10/unhosing-apks</a></span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy"><a href="https://github.com/strazzere/dehoser" rel="nofollow noreferrer">github.com/strazzere/dehoser</a></span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy">Maybe you misunderstood my point: what HoseDex2Jar does is repack your  APK so that the popular dex2jar tool cannot (out of the box) reverse it. However other tools can, and it is very easy to defeat it generally. No point in using it. No one mentioned Dexguard I thing (by the author of ProGuard; not free), but it is work looking at. It does a few more thing than 'regular' obfuscation.</span></text><author><a class="comment-user" href="/users/242930/nikolay-elenkov" title="43,762 reputation">Nikolay Elenkov</a></author></comment><comment><text><span class="comment-copy">C++ can never be reversed? it's difficult but possible. and there are tools to help you with that like <a href="http://www.hex-rays.com/products/decompiler/index.shtml" rel="nofollow noreferrer">hex-rays.com/products/decompiler/index.shtml</a> (yes, they have ARM version. not it's not THAT easy to get).</span></text><author><a class="comment-user" href="/users/1063214/dkzm" title="795 reputation">dkzm</a></author></comment><comment><text><span class="comment-copy">yes, @VikartiAnatra: I also mentioned <i>Somehow, you could make it difficult</i></span></text><author><a class="comment-user" href="/users/1626878/sahil-mahajan-mj" title="9,545 reputation">Sahil Mahajan Mj</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p> 1. How can I completely avoid reverse engineering of an Android APK? Is this possible?</p>
</blockquote>
<p><strong>That is impossible</strong></p>
<blockquote>
<p> 2. How can I protect all the app's resources, assets and source code so that hackers can't hack the APK file in any way?</p>
</blockquote>
<p><strong>Developers can take steps such as using tools like ProGuard to obfuscate their code, but up until now, it has been quite difficult to completely prevent someone from decompiling an app.</strong></p>
<p>It's a really great tool and can increase the difficulty of 'reversing' your code whilst shrinking your code's footprint.</p>
<p>Integrated ProGuard support: ProGuard is now packaged with the SDK Tools. Developers can now obfuscate their code as an integrated part of a release build.</p>
<blockquote>
<p> 3. Is there a way to make hacking more tough or even impossible? What more can I do to protect the source code in my APK file?</p>
</blockquote>
<p>While researching, I came to know about <a href="http://www.decompilingandroid.com/hosedex2jar/">HoseDex2Jar</a>. This tool will protect your code from decompiling, but it seems not to be possible to protect your code completely.</p>
<p>Some of helpful links, you can refer to them. </p>
<ul>
<li><a href="http://android-developers.blogspot.in/2010/09/proguard-android-and-licensing-server.html">Proguard, Android, and the Licensing Server</a></li>
<li><a href="http://android-developers.blogspot.in/2010/09/securing-android-lvl-applications.html">Securing Android LVL Applications</a></li>
<li>Stack Overflow question <em><a href="http://stackoverflow.com/questions/4336637/is-it-really-impossible-to-protect-android-apps-from-reverse-engineering">Is it really impossible to protect Android apps from reverse engineering?</a></em></li>
<li>Stack Overflow question <em><a href="http://stackoverflow.com/questions/13380097/how-to-prevent-reverse-engineer-for-android-apk-to-secure-code">How to prevent reverse engineering of an Android APK file to secure code?</a></em></li>
</ul>
</div></text><author><a href="/users/646806/robinhood">RobinHood</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The main question here is that can the dex files be decompiled and the answer is they can be "sort of". There are disassemblers like <a href="http://dedexer.sourceforge.net/" rel="noreferrer">dedexer</a> and <a href="http://code.google.com/p/smali/" rel="noreferrer">smali</a>.</p>
<p>ProGuard, properly configured, will obfuscate your code. DexGuard which is a commercial extended version of ProGuard, may help a bit more. However, your code can still be converted into smali and developers with reverse-engineering experience will be able to figure out what you are doing from the smali.</p>
<p>Maybe choose a good license and enforce it by the law in best possible way.</p>
</div></text><author><a href="/users/1610172/abhishek-sabbarwal">Abhishek Sabbarwal</a></author><comments><comment><text><span class="comment-copy">As a side note (disclaimer: IANAL) - license will not protect application under all jurisdictions in all circumstances (for example in some countries in Europe it is allowed to disassembly in order to increase compatibility).</span></text><author><a class="comment-user" href="/users/49107/maciej-piechotka" title="4,343 reputation">Maciej Piechotka</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p> 1. How can I completely avoid reverse engineering of an Android APK? Is this possible?</p>
</blockquote>
<p>Impossible</p>
<blockquote>
<p> 2. How can I protect all the app's resources, assets and source code so that hackers can't hack the APK file in any way?</p>
</blockquote>
<p>Impossible</p>
<blockquote>
<p> 3. Is there a way to make hacking more tough or even impossible? What more can I do to protect the source code in my APK file?</p>
</blockquote>
<p>More tough - possible, but in fact it will be more tough mostly for the average user, who is just googling for hacking guides. If somebody really wants to hack your app - it will be hacked, sooner or later.</p>
</div></text><author><a href="/users/1548085/janot">janot</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Here are few methods you can try:</p>
<ol>
<li>Use <a href="http://en.wikipedia.org/wiki/Obfuscation_%28software%29" rel="nofollow noreferrer">obfuscation</a> and tools like <a href="http://proguard.sourceforge.net/" rel="nofollow noreferrer">ProGuard</a>.</li>
<li>Encrypt some part of source and data.</li>
<li>Use a proprietary inbuilt checksum in the app to detect tampering.</li>
<li>Introduce code to avoid loading in a debugger, that is, let the app have the ability to detect the debugger and exit / kill the debugger.</li>
<li>Separate the authentication as an online service.</li>
<li>Use <a href="http://dl.acm.org/citation.cfm?id=1900550" rel="nofollow noreferrer">application diversity</a> </li>
<li>Use the finger printing technique for e.g., hardware signatures of the devices from different subsystem before authenticating the device.</li>
</ol>
</div></text><author><a href="/users/1020149/shan">Shan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Your client should hire someone that knows what they are doing, who can make the right decisions and can mentor you.</p>
<p>Talk above about you having some ability to change the transaction processing system on the backend is absurd - you shouldn't be allowed to make such architectural changes, so don't expect to be able to.</p>
<p>My rationale on this:</p>
<p>Since your domain is payment processing, its safe to assume that PCI DSS and/or PA DSS (and potential state/federal law) will be significant to your business - to be compliant you must show you are secure. To be insecure then find out (via testing) that you aren't secure, then fixing, retesting, etcetera until security  can be verified at a suitable level = expensive, slow, high-risk way to success. To do the right thing, think hard up front, commit experienced talent to the job, develop in a secure manner, then test, fix (less), etcetera (less) until security can be verified at a suitable level = inexpensive, fast, low-risk way to success.</p>
</div></text><author><a href="/users/1085264/straya">straya</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If we want to make reverse engineering (almost) impossible, we can put the application on a highly tamper-resistant chip, which executes all sensitive stuff internally, and communicates with some protocol to make controlling GUI possible on the host. Even tamper-resistant chips are not 100% crack proof; they just set the bar a lot higher than software methods. Of course, this is inconvenient: the application requires some little USB wart which holds the chip to be inserted into the device.</p>
<p>The question doesn't reveal the motivation for wanting to protect this application so jealously. </p>
<p>If the aim is to improve the security of the payment method by concealing whatever security flaws the application may have (known or otherwise), it is completely wrongheaded.  The security-sensitive bits should in fact be open-sourced, if that is feasible. You should make it as easy as possible for any security researcher who reviews your application to find those bits and scrutinize their operation, and to contact you. Payment applications should not contain any embedded certificates. That is to say, there should be no server appliaction which trusts a device simply because it has a fixed certificate from the factory. A payment transaction should be made on the user's credentials alone, using a correctly designed end-to-end authentication protocol which precludes trusting the application, or the platform, or the network, etc.</p>
<p>If the aim is to prevent cloning, short of that tamper-proof chip, there isn't anything you can do to protect the program from being reverse-engineered and copied, so that someone incorporates a compatible payment method into their own application, giving rise to "unauthorized clients". There are ways to make it difficult to develop unauthorized clients. One would be to create checksums based on snapshots of the program's complete state: all state variables, for everything. GUI, logic, whatever. A clone program will not have exactly the same internal state. Sure, it is a state machine which has similar externally visible state transitions (as can be observed by inputs and outputs), but hardly the same internal state. A server application can interrogate the program: what is your detailed state? (i.e. give me a checksum over all of your internal state variables).  This can be compared against dummy client code which executes on the server in parallel, going through the genuine state transitions. A third party clone will have to replicate all of the relevant state changes of the genuine program in order to give the correct responses, which will hamper its development.</p>
</div></text><author><a href="/users/1250772/kaz">Kaz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The other upvoted answers here are correct. I just want to provide another option.</p>
<p>For certain functionality that you deem important you can host the <a href="http://developer.android.com/reference/android/webkit/WebView.html" rel="noreferrer">WebView</a> control in your app. The functionality would then be implemented on your web server. It will look like it's running in your application.</p>
</div></text><author><a href="/users/35264/sarel-botha">Sarel Botha</a></author><comments><comment><text><span class="comment-copy">completely agree this can be done to maintain security.</span></text><author><a class="comment-user" href="/users/739270/azhar-shaikh" title="29,566 reputation">Azhar Shaikh</a></author></comment><comment><text><span class="comment-copy">@Sarel Botha yes for IMP screens I already used webview &amp; yes this is also one way to maintain security, I'm accepting your answer.</span></text><author><a class="comment-user owner" href="/users/619861/sachin003" title="3,019 reputation">sachin003</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As someone who worked extensively on payment platforms, including one mobile payments application (MyCheck), I would say that you need to delegate this behaviour to the server, no user name or password for the payment processor (whichever it is) should be stored or hardcoded in the mobile application, that's the last thing you want, because the source can be understood even when if you obfuscate the code.</p>
<p>Also, you shouldn't store credit cards or payment tokens on the application, everything should be, again, delegated to a service you built, it will also allow you later on, be PCI-compliant more easily, and the Credit Card companies won't breath down your neck (like they did for us).</p>
</div></text><author><a href="/users/646891/itai-sagi">Itai Sagi</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I suggest you to look at <em><a href="http://www.arxan.com/solutions/" rel="nofollow">Protect Software Applications from Attacks</a></em>. It's a commercial service, but my friend's company used this and they are glad to use it.</p>
</div></text><author><a href="/users/1823424/talha">Talha</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Basically it's not possible. It will never be possible. However, there is hope. You can use an <a href="http://en.wikipedia.org/wiki/Obfuscation_%28software%29" rel="nofollow">obfuscator</a> to make it so some common attacks are a lot harder to carry out including things like:</p>
<ol>
<li>Renaming methods/classes (so in the decompiler you get types like <code>a.a</code>)</li>
<li>Obfuscating control flow (so in the decompiler the code is very hard to read)</li>
<li>Encrypting strings and possibly resources</li>
</ol>
<p>I'm sure there are others, but that's the main ones. I work for a company called PreEmptive Solutions on a <a href="http://en.wikipedia.org/wiki/.NET_Framework" rel="nofollow">.NET</a> obfuscator. They also have a Java obfuscator that works for Android as well one called <a href="http://www.preemptive.com/products/dasho" rel="nofollow">DashO</a>.</p>
<p>Obfuscation always comes with a price, though. Notably, performance is usually worse, and it requires some extra time around releases usually. However, if your intellectual property is extremely important to you, then it's usually worth it.</p>
<p>Otherwise, your only choice is to make it so that your Android application just passes through to a server that hosts all of the real logic of your application. This has its own share of problems, because it means users must be connected to the Internet to use your app.</p>
<p>Also, it's not just Android that has this problem. It's a problem on every app store. It's just a matter of how difficult it is to get to the package file (for example, I don't believe it's very easy on iPhones, but it's still possible).</p>
</div></text><author><a href="/users/69742/earlz">Earlz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Its not possible to completely avoid RE but By making them more complex internally, you put make it more difficult for attackers to see the clear operation of the app, which may reduce the number of attack vectors.</p>
<p>If the application handles highly sensitive data, Various techniques exist which can increase the complexity of reverse engineering your code. One technique is to use C/C++ to limit easy runtime manipulation by the attacker. There are ample C and C++ libraries that are very mature and easy to integrate with  Android offers JNI.  An attacker must first circumvent the debugging restrictions in order to attack the application on a low level. This adds further complexity to an attack. Android applications should have android:debuggable=”false” set in the application manifest to prevent easy run time manipulation by an attacker or malware. </p>
<p><strong>Trace Checking</strong> – An application can determine whether or not it is currently being traced by a debugger or other debugging tool. If being traced, the application can perform any number of possible attack response actions, such as discarding encryption keys to protect user data, notifying a server administrator, or other such type responses in an attempt to defend itself. This can be determined by checking the process status flags or using other techniques like comparing the return value of ptrace attach, checking parent process, blacklist debuggers in the process list or comparing timestamps on different places of the program.</p>
<p><strong>Optimizations</strong> - To hide advanced mathematical computations and other types of complex logic, utilizing compiler optimizations can help <strong>obfuscate</strong> the object code so that it cannot easily be disassembled by an attacker, making it more difficult for an attacker to gain an understanding of the particular code. In Android this can more easily be achieved by utilizing natively compiled libraries with the NDK. In addition, using an LLVM Obfuscator or any protector SDK will provide better machine code obfuscation.</p>
<p><strong>Stripping binaries</strong> – Stripping native binaries is an effective way to increase the amount of time and skill level required of an attacker in order to view the makeup of your application’s low level functions. By stripping a binary, the symbol table of the binary is stripped, so that an attacker cannot easily debug or reverse engineer an application.You can refer techniques used on GNU/Linux systems like sstriping or using UPX.</p>
<p><strong>And at last you must be aware about  obfuscation and tools like ProGuard.</strong></p>
</div></text><author><a href="/users/5021501/sanket-prabhu">Sanket Prabhu</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Aren't TPM chips (Trusted Platform Module) supposed to manage protected code for you ? They are becoming common on PCs (especially Apple ones) and they may already exist in today's smartphone chips. Unfortunately there is no OS API to make use of it yet. Hopefully Android will add support for this one day. That's also the key to clean content DRM (which Google is working on for WebM).</p>
</div></text><author><a href="/users/1266123/robux4">robUx4</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>Nothing is secure when you put it on end-users hand but some common practice may make this harder for attacker to steal data.</p>
</blockquote>
<ul>
<li>Put your main logic (algorithms) into server side.</li>
<li>Communicate with server and client; make sure communication b/w server and client is secured via SSL or HTTPS; or use other techniques key-pair generation algorithms (ECC, RSA). Ensure that sensitive information is remain End-to-End encrypted.</li>
<li>Use sessions and expire them after specific time interval.</li>
<li>Encrypt resources and fetch them from server on demand.</li>
<li><strong>Or you can make Hybrid app which access system via <code>webview</code> protect resource + code on server</strong></li>
</ul>
<p>Multiple approaches; this is obvious you have to sacrifice among <strong>performance</strong> and <strong>security</strong></p>
</div></text><author><a href="/users/1749165/mumair">mumair</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>APK signature scheme v2 in Android N</strong></p>
<p>The PackageManager class now supports verifying apps using the APK signature scheme v2. The APK signature scheme v2 is a whole-file signature scheme that significantly improves verification speed and strengthens integrity guarantees by detecting any unauthorized changes to APK files.</p>
<p>To maintain backward-compatibility, an APK must be signed with the v1 signature scheme (JAR signature scheme) before being signed with the v2 signature scheme. With the v2 signature scheme, verification fails if you sign the APK with an additional certificate after signing with the v2 scheme.</p>
<p>APK signature scheme v2 support will be available later in the N Developer Preview.</p>
<p><a href="http://developer.android.com/preview/api-overview.html#apk_signature_v2" rel="nofollow">http://developer.android.com/preview/api-overview.html#apk_signature_v2</a></p>
</div></text><author><a href="/users/695443/thiagolr">thiagolr</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There is no way to completely avoid reverse engineering of an APK. To protect application assets, resources, you can use encryption.</p>
<ul>
<li>Encryption will make harder to use it without decryption.choosing some strong encryption algorithm will make cracking harder.</li>
<li>Adding some spoof code into your main logic to make more harder for cracking.</li>
<li>If you can write your critical logic in any native language and that surely make harder for decompile.</li>
<li>Using any third party security frameworks like <a href="https://quixxi.com/" rel="nofollow noreferrer">Quixxi</a></li>
</ul>
</div></text><author><a href="/users/2049574/immutable">immutable</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>How can I protect all the app's resources, assets and source code so that hackers can't hack the APK file in any way?</p>
</blockquote>
<p>An APK file is protected with the <a href="http://en.wikipedia.org/wiki/SHA-1" rel="nofollow">SHA-1</a> algorithm. You can see some files in the <strong>META-INF</strong> folder of APK. If you extract any APK file and change any of its content and zip it again and when you run that new APK file on an Android machine, it will not work, because the SHA-1 hashes will never match. </p>
</div></text><author><a href="/users/775964/jeegar-patel">Jeegar Patel</a></author><comments><comment><text><span class="comment-copy">This is true; but it's trivial to resign the APK (with a different certificate) and everything will work again. It's possible to check which signature has been used to sign the APK from within the application itself, and error out if the certificate changes, but it's only slightly less trivial to edit this code out of the application.</span></text><author><a class="comment-user" href="/users/404568/david-given" title="7,591 reputation">David Given</a></author></comment><comment><text><span class="comment-copy">This may prevent the android device from running modified code, but you can still easily extract the relevant code and write new code on a PC which does what you want.</span></text><author><a class="comment-user" href="/users/35264/sarel-botha" title="8,282 reputation">Sarel Botha</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>While I agree there's no 100% solution that's going to protect your code, v3 of <a href="http://www.decompilingandroid.com" rel="nofollow">HoseDex2Jar</a> is now up if you want to give it a try.</p>
</div></text><author><a href="/users/1714356/user1714356">user1714356</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Just an addition to already good answers above.</p>
<p>Another trick I know is to store valuable codes as Java Library. Then set that Library to be your Android Project. Would be good as C .so file but Android Lib would do.</p>
<p>This way these valuable codes stored on Android Library won't be visible after decompiling.</p>
</div></text><author><a href="/users/772374/halim">Halim</a></author><comments><comment><text><span class="comment-copy">They will be visible, just under a different package.</span></text><author><a class="comment-user" href="/users/1069068/raghav-sood" title="62,629 reputation">Raghav Sood</a></author></comment><comment><text><span class="comment-copy">Strangely, not in my case. I have 4 libs. Google Licensing + Pretty Time + android.support.v4.ViewPagerIndicator + My Internal Lib comes from Android Project set as Library. This Android Project as Lib is not visible. While the other 3 are visible.</span></text><author><a class="comment-user" href="/users/772374/halim" title="834 reputation">Halim</a></author></comment><comment><text><span class="comment-copy">it will be visible if you decompile the classes.dex file and open it up</span></text><author><a class="comment-user" href="/users/1069068/raghav-sood" title="62,629 reputation">Raghav Sood</a></author></comment><comment><text><span class="comment-copy">@Raghav, yup I used dex2jar and jd to simulate it. But I cannot find it. Have you tried?</span></text><author><a class="comment-user" href="/users/772374/halim" title="834 reputation">Halim</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>when they have the app on their phone, they have full access to memory of it. so if u want to prevent it from being hacked, you could try to make it so that u cant just get the static memory address directly by using a debugger. they could do a stack buffer overflow if they have somewhere to write and they have a limit. so try to make it so when they write something, if u have to have a limit, if they send in more chars than limit, if (input &gt; limit) then ignore, so they cant put assembly code there.</p>
</div></text><author><a href="/users/3742860/user3742860">user3742860</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Basically, there are 5 methods to protect your APK.
Isolate Java Program, Encrypt Class Files, Convert to Native Codes, Code Obfuscation and <a href="http://www.apkprotect.com/" rel="nofollow">Online Encryption</a>
I suggest you use online encryption because it is safe and convenient. You needn't spend to much time to achieve this. Such as <a href="http://www.apkprotect.com/" rel="nofollow">APK Protect</a>, it is an online encryption website for APK. It provides Java codes and C++ codes protection to achieve anti-debugging and decompile effects. The operation process is simple and easy.</p>
</div></text><author><a href="/users/2563366/user2563366">user2563366</a></author><comments><comment><text><span class="comment-copy">He's asking if it's possible. You're saying yes, it's easy.  You're wrong. It's impossible.</span></text><author><a class="comment-user" href="/users/146043/dr-eval" title="1,564 reputation">Dr Eval</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>I am developing a <strong>payment processing app</strong></p>
</blockquote>
<p>Google <a href="http://techcrunch.com/2010/03/19/google-chrome-1337/" rel="nofollow">have been</a> very successful in avoiding malicious hackers in general by using a <a href="http://www.securityweek.com/google-promises-more-money-chrome-vulnerabilities" rel="nofollow">simple financial method</a> to "protect" <a href="https://www.google.pt/about/appsecurity/chrome-rewards/" rel="nofollow">Google Chrome</a>, and I quote: </p>
<blockquote>
<p>We have a standing $50,000 reward for participants that can compromise a Chromebook or Chromebox with device persistence in guest mode</p>
</blockquote>
<p>Your best bet to actually get closer to 100% "security" is picking the right fight for your money's worth.</p>
<p>Now, that won't protect you from lunatics and lucky pranksters, but... The later group will only enjoy little time in while the system readjusts. While a lunatic is something you only need to worry in case you're big enough to have a nemesis. And that would make a great story! :)</p>
<p>Invest in Ai. Identifying patterns in money flow to predict potential risks is much more "secure" than trying to prevent money leakage.</p>
<p><sup>I tried writing <a href="http://talk.cregox.com/t/cheap-philosophical-links-about-the-financial-rabbit-hole/7748?u=cregox" rel="nofollow">more about all the above in my "blog"</a>, such as why I'm putting "security" and "protect" in quotes (what do they even really mean?).</sup></p>
<hr/>
<p>In other words, instead of asking "<em>how to avoid reverse engineering</em>" try asking "<em>how to engineer a <strong>bullet proof</strong> payment processing app</em>".</p>
<p>Finally, as a <em>processing app</em> you shouldn't care less for whatever fake security you think you can create in your binary code. Worry about your <strong>server</strong> instead. Make a strict communication protocol to make monitoring the server easier, for instance. Now <strong>that</strong> can be reliable!</p>
</div></text><author><a href="/users/274502/cregox">cregox</a></author><comments/></answer></answers></post>