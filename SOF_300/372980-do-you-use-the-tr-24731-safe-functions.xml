<?xml version="1.0" encoding="utf-8"?>
<post><title>c - Do you use the TR 24731 'safe' functions? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>The ISO C committee (<a href="http://www.open-std.org/JTC1/SC22/WG14/" rel="noreferrer">ISO/IEC JTC1/SC21/WG14</a>) has published <a href="http://www.open-std.org/JTC1/SC22/WG14/www/projects#24731-1" rel="noreferrer">TR 24731-1</a> and is working on <a href="http://www.open-std.org/JTC1/SC22/WG14/www/projects#24731-1" rel="noreferrer">TR 24731-2</a>:</p>
<blockquote>
<h3>TR 24731-1: Extensions to the C Library Part I: Bounds-checking interfaces</h3>
<p>WG14 is working on a TR on safer C library functions. This TR is oriented towards modifying existing programs, often by adding an extra parameter with the buffer length. The latest draft is in document N1225. A rationale is in document N1173. This is to become a Technical Report type 2.</p>
<h3>TR 24731-2: Extensions to the C Library - Part II: Dynamic allocation functions</h3>
<p>WG14 is working on a TR on safer C library functions. This TR is oriented towards new programs using dynamic allocation instead of an extra parameter for the buffer length. The latest draft is in document N1337. This is to become a Technical Report type 2.</p>
</blockquote>
<h2>Questions</h2>
<ul>
<li>Do you use a library or compiler with support for the TR24731-1 functions?</li>
<li>If so, which compiler or library and on which platform(s)?</li>
<li>Did you uncover any bugs as a result of fixing your code to use these functions?</li>
<li>Which functions provide the most value?</li>
<li>Are there any that provide no value or negative value?</li>
<li>Are you planning to use the library in the future?</li>
<li>Are you tracking the TR24731-2 work at all?</li>
</ul>
</div></text><author><a href="/users/511601/fred-nurk">Fred Nurk</a></author><comments><comment><text><span class="comment-copy">This is probably a dumb question, but why don't they just add strlen to the code, and not worrying about changing the function definition?</span></text><author><a class="comment-user" href="/users/1115761/marcusj" title="126 reputation">MarcusJ</a></author></comment><comment><text><span class="comment-copy">@MarcusJ: Hmmm — I would need clarification on what you mean about 'add <code>strlen()</code> to the code'.  There are definitely times when <code>strlen()</code> is not the right answer, such as when passing a buffer to an I/O function (such as <code>gets_s()</code>).  But maybe you can elaborate on what you're thinking of?</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">Why change the function definition to add the size of the buffer, when that function can just call strlen on the buffer itself, and store the size in it's own, internal variable? that way the function definition doesn't change.</span></text><author><a class="comment-user" href="/users/1115761/marcusj" title="126 reputation">MarcusJ</a></author></comment><comment><text><span class="comment-copy">@MarcusJ: Because there are functions where that cannot work reliably.  For example, <code>gets()</code> — there's no requirement that the buffer be initialized with a maximum length string before it is used.  Ditto <code>sprintf()</code>, <code>strcpy()</code>.  I don't think you could append anything with <code>strcat()</code> under the rules you're hypothesizing.  It is a non-starter.</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">Why couldn't you use realloc? I mean I've never written my own standard library, so I'm not experienced enough to talk about this stuff, but I don't understand why it's impossible.</span></text><author><a class="comment-user" href="/users/1115761/marcusj" title="126 reputation">MarcusJ</a></author></comment><comment><text><span class="comment-copy">@MarcusJ: You can't use <code>realloc()</code> because the functions that need protection don't allocate. The <code>strcpy()</code> function, for example, doesn't do memory allocation; you can't sanely modify it to do memory allocation, even if you have garbage collection, because people don't generally use the return value but use the value passed as the first argument to <code>strcpy()</code> in further operations.  Similar problems arise with <code>gets()</code> and <code>strcat()</code>.  Those at least return a <code>char *</code> that might point to reallocated space (not that there's a guarantee that the arguments were allocated). <i>[…continued…]</i></span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy"><i>[…continuation…]</i> The problem is worse with functions such as <code>sprintf()</code> which don't return a <code>char *</code>; there is no way for them to tell the calling code that they've 'reallocated' the memory where the result was placed.  Note that one of the reasons why TR 24731-2 did not make it into C11 was that they would be the first functions to explicitly do memory allocation — other than <code>malloc()</code> et al. Please take time to study what the functions do, what the Annex K / TR 24731-1 functions do, the rationales for why they do it, and so on. There are some sound reasons for the decisions made.</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">I'm writing my own input/output library, and I just missed the whole "you can't change the value of a function argument in order to reallocate it" because obvious shit somehow gets past me way more than it should tbh. thanks for the info though, the part about why it was shot down is interesting.</span></text><author><a class="comment-user" href="/users/1115761/marcusj" title="126 reputation">MarcusJ</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I have been a vocal critic of these TRs since their inception (when it was a single TR) and would never use them in any of my software.  They mask symptoms instead of addressing causes and it is my opinion that if anything they will have a negative impact on software design as they provide a false sense of security instead of promoting existing practices that can accomplish the same goals much more effectively.  I am not alone, in fact I am not aware of a single major proponent outside of the committee developing these TRs.</p>
<p>I use glibc and as such know that I will be spared having to deal with this nonsense, as Ulrich Drepper, lead maintainer for glibc, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1106.txt" rel="noreferrer">said about the topic</a>:</p>
<blockquote>
<p>The proposed safe(r) ISO C library
  fails to address to issue completely.
  ... Proposing to make the life of a
  programmer even harder is not going to
  help.  But this is exactly what is
  proposed. ... They all require more
  work to be done or are just plain
  silly.</p>
</blockquote>
<p>He goes on to detail problems with a number of the proposed functions and has elsewhere indicated that glibc would never support this.</p>
<p>The Austin Group (responsible for maintaining POSIX) provided a very critical review of the TR, their comments and the committee responses available <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1118.htm" rel="noreferrer">here</a>.  The Austin Group review does a very good job detailing many of the problems with the TR so I won't go into individual details here.</p>
<p>So the bottom line is: I don't use an implementation that supports or will support this, I don't plan on ever using these functions, and I see no positive value in the TR.  I personally believe that the only reason the TR is still alive in any form is because it is being pushed hard by Microsoft who has recently proved very capable of getting things rammed though standards committees despite wide-spread opposition.  If these functions are ever standardized I don't think they will ever become widely used as the proposal has been around for a few years now and has failed to garner any real community support.</p>
</div></text><author><a href="/users/25222/robert-gamble">Robert Gamble</a></author><comments><comment><text><span class="comment-copy">Citing Ulrich Drepper's opinion as any kind of authority is a good way to shoot down your argument on the spot, regardless of any other redeeming circumstances.</span></text><author><a class="comment-user" href="/users/111335/pavel-minaev" title="77,060 reputation">Pavel Minaev</a></author></comment><comment><text><span class="comment-copy">@Pavel, I cited Drepper as an authority <i>for glibc</i>.  Despite whatever personal issues you may have with him, he is the lead maintainer of glibc and pretty much decides what will and won't be included in glibc, like it or not.  I didn't leverage my case against the TR on his opinion at all, your comment appears to be based on strong personal animosity against one individual and if that blinds you from being able to see the bigger picture, that is a fault you should work on.</span></text><author><a class="comment-user" href="/users/25222/robert-gamble" title="68,419 reputation">Robert Gamble</a></author></comment><comment><text><span class="comment-copy">+1. People that don't know what they're doing should be using VB, not C :-)</span></text><author><a class="comment-user" href="/users/14860/paxdiablo" title="525,442 reputation">paxdiablo</a></author></comment><comment><text><span class="comment-copy">I work for a large company (&gt;60,000 employees, mostly engineering) where use of this library is now a standard requirement for all new code.  I agree it provides a false sense of security for the uninformed, but a modicum of additional security is better than none.</span></text><author><a class="comment-user" href="/users/33342/phord" title="6,526 reputation">phord</a></author></comment><comment><text><span class="comment-copy">For the win: <a href="http://www.kb.cert.org/vuls/id/922681" rel="nofollow noreferrer">Multiple libupnp buffer overflows</a>. Those safer functions that you don't like would have stopped most of them. Good job on peddling bad advice :)</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">^^^ Using programmers who know how to program properly would have stopped all of them...</span></text><author><a class="comment-user" href="/users/2040863/john-hascall" title="6,801 reputation">John Hascall</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h3>Direct answer to question</h3>
<p>I like Robert's answer, but I also have some views on the questions I raised.</p>
<ul>
<li><p>Do you use a library or compiler with support for the TR24731-1 functions?</p>
<blockquote>
<p>No, I don't.</p>
</blockquote></li>
<li><p>If so, which compiler or library and on which platform(s)?</p>
<blockquote>
<p>I believe the functions are provided by MS Visual Studio (MS VC++ 2008 Edition, for example), and there are warnings to encourage you to use them.</p>
</blockquote></li>
<li><p>Did you uncover any bugs as a result of fixing your code to use these functions?</p>
<blockquote>
<p>Not yet.  And I don't expect to uncover many in my code.  Some of the other code I work with - maybe.  But I've yet to be convinced.</p>
</blockquote></li>
<li><p>Which functions provide the most value?</p>
<blockquote>
<p>I like the fact that the printf_s() family of functions do not accept the '<code>%n</code>' format specifier.</p>
</blockquote></li>
<li><p>Are there any that provide no value or negative value?</p>
<blockquote>
<p>The <code>tmpfile_s()</code> and <code>tmpnam_s()</code> functions are a horrible disappointment.  They really needed to work more like <code>mkstemp()</code> which both creates the file and opens it to ensure there is no TOCTOU (time-of-check, time-of-use) vulnerability.  As it stands, those two provide very little value.</p>
<p>I also think that <code>strerrorlen_s()</code> provides very little value.</p>
</blockquote></li>
<li><p>Are you planning to use the library in the future?</p>
<blockquote>
<p>I am in two minds about it.  I started work on a library that would implement the capabilities of TR 24731 over a standard C library, but got caught by the amount of unit testing needed to demonstrate that it is working correctly.  I'm not sure whether to continue that.  I have some code that I want to port to Windows (mainly out of a perverse desire to provide support on all platforms - it's been working on Unix derivatives for a couple of decades now).  Unfortunately, to get it to compile without warnings from the MSVC compilers, I have to plaster the code with stuff to prevent MSVC wittering about me using the perfectly reliable (when carefully used) standard C library functions.  And that is not appetizing.  It is bad enough that I have to deal with most of two decades worth of a system that has developed over that period; having to deal with someone's idea of fun (making people adopt TR 24731 when they don't need to) is annoying.  That was partly why I started the library development - to allow me to use the same interfaces on Unix and Windows.  But I'm not sure what I'll do from here.</p>
</blockquote></li>
<li><p>Are you tracking the TR24731-2 work at all?</p>
<blockquote>
<p>I'd not been tracking it until I went to the standards site while collecting the data for the question.  The <code>asprintf()</code> and <code>vasprintf()</code> functions are probably valuable; I'd use those.  I'm not certain about the memory stream I/O functions.  Having <code>strdup()</code> standardized at the C level would be a huge step forward.  This seems less controversial to me than the part 1 (bounds checking) interfaces.</p>
</blockquote></li>
</ul>
<p>Overall, I'm not convinced by part 1 'Bounds-Checking Interfaces'.  The material in the draft of part 2 'Dynamic Allocation Functions' is better.</p>
<p>If it were up to me, I'd move somewhat along the lines of part 1, but I'd also revised the interfaces in the C99 standard C library that return a <code>char *</code> to the start of the string (e.g. <code>strcpy()</code> and <code>strcat()</code>) so that instead of returning a pointer to the start, they'd return a pointer to the null byte at the end of the new string.  This would make some common idioms (such as repeatedly concatenating strings onto the end of another) more efficient because it would make it trivial to avoid the quadratic behaviour exhibited by code that repeatedly uses <code>strcat()</code>.  The replacements would all ensure null-termination of output strings, like the TR24731 versions do.  I'm not wholly averse to the idea of the checking interface, nor to the exception handling functions.  It's a tricky business.</p>
<hr/>
<h3>Microsoft's implementation is not the same as the standard specification</h3>
<p><sup><em>Update (2011-05-08)</em></sup></p>
<p>See also this <a href="http://stackoverflow.com/questions/2169016/mac-solution-for-safe-alternatives-to-unsafe-c-c-standard-library-functions">question</a>.  Sadly, and fatally to the usefulness of the TR24731 functions, the definitions of some of the functions differs between the Microsoft implementation and the standard, rendering them useless (to me).  My answer there cites <code>vsnprintf_s()</code>.</p>
<blockquote>
<p>For example, TR 24731-1 says the interface to <code>vsnprintf_s()</code> is:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="com">#define</span><span class="pln"> __STDC_WANT_LIB_EXT1__ </span><span class="lit">1</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdarg.h&gt;</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln">
</span><span class="typ">int</span><span class="pln"> vsnprintf_s</span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> restrict s</span><span class="pun">,</span><span class="pln"> </span><span class="typ">rsize_t</span><span class="pln"> n</span><span class="pun">,</span><span class="pln">
                </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> restrict format</span><span class="pun">,</span><span class="pln"> va_list arg</span><span class="pun">);</span></code></pre>
<p>Unfortunately, <a href="http://msdn.microsoft.com/en-us/library/d3xd30zz%28VS.80%29.aspx" rel="nofollow noreferrer">MSDN</a> says the interface to <code>vsnprintf_s()</code> is:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">int</span><span class="pln"> vsnprintf_s</span><span class="pun">(</span><span class="pln">
   </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">buffer</span><span class="pun">,</span><span class="pln">
   </span><span class="typ">size_t</span><span class="pln"> sizeOfBuffer</span><span class="pun">,</span><span class="pln">
   </span><span class="typ">size_t</span><span class="pln"> count</span><span class="pun">,</span><span class="pln">
   </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">format</span><span class="pun">,</span><span class="pln">
   va_list argptr 
</span><span class="pun">);</span></code></pre>
<p>Parameters</p>
<ul>
<li>buffer - Storage location for output.</li>
<li>sizeOfBuffer - The size of the buffer for output.</li>
<li>count - Maximum number of characters to write (not including the terminating null), or _TRUNCATE.</li>
<li>format - Format specification.</li>
<li>argptr - Pointer to list of arguments.</li>
</ul>
<p>Note that this is not simply a matter of type mapping: the number of fixed arguments is different, and therefore irreconcilable. It is also unclear to me (and presumably to the standards committee too) what benefit there is to having both 'sizeOfBuffer' and 'count'; it looks like the same information twice (or, at least, code will commonly be written with the same value for both parameters).</p>
</blockquote>
<p>Similarly, there are also problems with <code>scanf_s()</code> and its relatives.  <a href="http://msdn.microsoft.com/en-us/library/w40768et.aspx" rel="nofollow noreferrer">Microsoft</a> says that the type of the buffer length parameter is <code>unsigned</code> (explicitly stating 'The size parameter is of type <code>unsigned</code>, not <code>size_t</code>'). In contrast, in Annex K, the size parameter is of type <code>rsize_t</code>, which is the restricted variant of <code>size_t</code> (<code>rsize_t</code> is another name for <code>size_t</code>, but <code>RSIZE_MAX</code> is smaller than <code>SIZE_MAX</code>).  So, again, the code calling <code>scanf_s()</code> would have to be written differently for Microsoft C and Standard C.</p>
<p>Originally, I was planning to use the 'safe' functions as a way of getting some code to compile cleanly on Windows as well as Unix, without needing to write conditional code.  Since this is defeated because the Microsoft and ISO functions are not always the same, it is pretty much time to give up.</p>
<hr/>
<h3>Changes in Microsoft's <code>vsnprintf()</code> in Visual Studio 2015</h3>
<p>In the Visual Studio 2015 documentation for <a href="https://msdn.microsoft.com/en-us/library/1kt27hek.aspx" rel="nofollow noreferrer"><code>vsnprintf()</code></a>, it notes that the interface has changed:</p>
<blockquote>
<p>Beginning with the UCRT in Visual Studio 2015 and Windows 10, <code>vsnprintf</code> is no longer identical to <code>_vsnprintf</code>. The <code>vsnprintf</code> function complies with the C99 standard; <code>_vnsprintf</code> is retained for backward compatibility. </p>
</blockquote>
<p>However, the Microsoft interface for <a href="https://msdn.microsoft.com/en-us/library/d3xd30zz.aspx" rel="nofollow noreferrer"><code>vsnprintf_s()</code></a> has not changed.</p>
<hr/>
<h3>Another example of the differences</h3>
<p>The C11 standard variant of <code>localtime_s()</code> is defined in ISO/IEC 9899:2011 Annex K.3.8.2.4 as:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">struct</span><span class="pln"> tm </span><span class="pun">*</span><span class="pln">localtime_s</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">time_t</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> restrict timer</span><span class="pun">,</span><span class="pln">
                       </span><span class="kwd">struct</span><span class="pln"> tm </span><span class="pun">*</span><span class="pln"> restrict result</span><span class="pun">);</span></code></pre>
<p>compared with the MSDN variant of <a href="https://msdn.microsoft.com/en-us/library/a442x3ye.aspx" rel="nofollow noreferrer"><code>localtime_s()</code></a> defined as:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">errno_t</span><span class="pln"> localtime_s</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> tm</span><span class="pun">*</span><span class="pln"> _tm</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">time_t</span><span class="pln"> </span><span class="pun">*</span><span class="pln">time</span><span class="pun">);</span></code></pre>
<p>and the POSIX variant <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime_r.html" rel="nofollow noreferrer"><code>localtime_r()</code></a> defined as:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">struct</span><span class="pln"> tm </span><span class="pun">*</span><span class="pln">localtime_r</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">time_t</span><span class="pln"> </span><span class="pun">*</span><span class="pln">restrict timer</span><span class="pun">,</span><span class="pln">
                       </span><span class="kwd">struct</span><span class="pln"> tm </span><span class="pun">*</span><span class="pln">restrict result</span><span class="pun">);</span></code></pre>
<p>The C11 standard and POSIX functions are equivalent apart from name.  The Microsoft function is different in interface even though it shares a name with the C11 standard.</p>
<hr/>
<h3><em>ISO/IEC 9899:2011 — C11 Standard</em></h3>
<p>The C11 standard (<a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1548.pdf" rel="nofollow noreferrer">December 2010 Draft</a>; you can obtain a PDF copy of the definitive standard, <a href="http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS/ISO/IEC%209899-2012" rel="nofollow noreferrer">ISO/IEC 9899:2011</a>, from the ANSI web store for 30 USD) does have the TR24731-1 functions in it as an optional part of the standard.  They are defined in Annex K (Bounds-checking Interfaces), which is 'normative' rather than 'informational', but it is optional.</p>
<p>The C11 standard does not have the TR24731-2 functions in it — which is sad because the <code>vasprintf()</code> function and its relatives could be really useful.</p>
<p>Quick summary:</p>
<ul>
<li>C11 contains TR24731-1</li>
<li>C11 does not contain TR24731-2</li>
</ul>
<hr/>
<h3>Proposal to remove Annex K from the successor to C11</h3>
<p><a href="https://stackoverflow.com/users/3204551/deduplicator">Deduplicator</a> pointed out in a <a href="https://stackoverflow.com/questions/906599/why-cant-i-use-fopen/907549?noredirect=1#comment55009555_907549">comment</a> to another question that there is a proposal before the ISO C standard committee (ISO/IEC JTC1/SC22/WG14)</p>
<ul>
<li>N1967 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm" rel="nofollow noreferrer">Field Experience with Annex K — Bounds Checking Interfaces</a></li>
</ul>
<p>It contains references to some of the extant implementations of the Annex K functions — none of them widely used (but you can find them via the document if you are interested).</p>
<p>The document ends with the recommendation:</p>
<p><em>Therefore, we propose that Annex K be either removed from the next revision of the C standard, or deprecated and then removed.</em></p>
<p>I support that recommendation.</p>
</div></text><author><a href="/users/15168/jonathan-leffler">Jonathan Leffler</a></author><comments><comment><text><span class="comment-copy">Well, if MS contradicts the standard, it will be MS that needs to change, not the standard...</span></text><author><a class="comment-user" href="/users/2445184/cmaster" title="19,554 reputation">cmaster</a></author></comment><comment><text><span class="comment-copy">I'd like to think so too, but they have an installed base and won't break backwards compatibility, so in practice it continues to mean that MS won't support a C standard more modern than C89 (C90) — sadly.</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>Do you use a library or compiler with support for the TR24731-1 functions? 
  If so, which compiler or library and on which platform(s)? </p>
</blockquote>
<p>Yes, Visual Studio 2005 &amp; 2008 (for Win32 development obviously).</p>
<blockquote>
<p>Did you uncover any bugs as a result of fixing your code to use these functions? </p>
</blockquote>
<p>Sort of....  I wrote my own library of safe functions (only about 15 that we use frequently) that would be used on multiple platforms -- Linux, Windows, VxWorks, INtime, RTX, and uItron.  The reason for creating the safe functions were:</p>
<ul>
<li>We had encountered a large number of bugs due to improper use of the standard C functions.</li>
<li>I was not satisfied with the information passed into or returned from the TR functions, or in some cases, their POSIX alternatives.</li>
</ul>
<p>Once the functions were written, more bugs were discovered.  So yes, there was value in using the functions.</p>
<blockquote>
<p>Which functions provide the most value? </p>
</blockquote>
<p>Safer versions of vsnprintf, strncpy, strncat.</p>
<blockquote>
<p>Are there any that provide no value or negative value? </p>
</blockquote>
<p>fopen_s and similar functions add very little value for me personally.  I'm OK if fopen returns NULL.  You should always check the return value of the function.  If someone ignores the return value of fopen, what is going to make them check the return value of fopen_s?  I understand that fopen_s will return more specific error information which can be useful in some contexts.  But for what I'm working on, this doesn't matter.</p>
<blockquote>
<p>Are you planning to use the library in the future?</p>
</blockquote>
<p>We are using it now -- inside our own "safe" library.</p>
<blockquote>
<p>Are you tracking the TR24731-2 work at all?</p>
</blockquote>
<p>No.</p>
</div></text><author><a>NONE</a></author><comments><comment><text><span class="comment-copy">Thanks for the information, Kevin.</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Ok, now a stand <em>for</em> TR24731-2:</p>
<p>Yes, I've used <code>asprintf()</code>/<code>vasprintf()</code> ever since I've seen them in the glibc, and yes I am a very strong advocate of them.</p>
<p>Why?
Because they deliver precisely what I need over and over again: A powerful, flexible, safe and (relatively) easy to use way to format any text into a freshly allocated string.</p>
<p>I am also much in favor of the memstreams: Like <code>asprintf()</code>, <code>open_memstream()</code> (not <code>fmemopen()</code>!!!) allocates a sufficiently large buffer for you and gives you a <code>FILE*</code> to do your printing, so your printing functions can be entirely ignorant of whether they are printing into a string or a file, and you can simply forget the question, how much space you will need.</p>
</div></text><author><a href="/users/2445184/cmaster">cmaster</a></author><comments><comment><text><span class="comment-copy">Thank you for the feedback.  TR24731-2 is, sadly, not part of the C2011 standard, but is generally a useful set of functions.  I have reservations about the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fmemopen.html" rel="nofollow noreferrer"><code>fmemopen()</code></a> function in POSIX too.  The <a href="http://linux.die.net/man/3/open_memstream" rel="nofollow noreferrer"><code>open_memstream()</code></a> function is interesting.  There are some gotchas in using it, I suspect, since you pass pointers to the buffer pointer and the size variable.  But, on the whole, TR23731-2 is good.</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>No, these functions are absolutely useless and serve no purpose other than to encourage code to be written so it only compiles on Windows.</p>
<p>snprintf is perfectly safe (when implemented correctly) so snprintf_s is pointless. strcat_s will <em>destroy data</em> if the buffer is overflowed (by clearing the concatenated-to string). There are many many other examples of complete ignorance of how things work.</p>
<p>The real useful functions are the BSD strlcpy and strlcat. But both Microsoft and Drepper have rejected these for their own selfish reasons, to the annoyance of C programmers everywhere.</p>
</div></text><author><a href="/users/3080602/user3080602">user3080602</a></author><comments><comment><text><span class="comment-copy">Thanks for the input. I'm not sure 'complete ignorance' is appropriate, but I agree that the new functions are not always as much of an improvement as it could have been.</span></text><author><a class="comment-user owner" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">I would think an strlcat-style function could more have efficiently accepted a pointer to the end of the destination buffer and returned a pointer to the trailing null byte of the destination.  That would have allowed the return value from one call to be passed to another to concatenate multiple values onto a string without having to re-scan the destination string each time.</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment></comments></answer></answers></post>