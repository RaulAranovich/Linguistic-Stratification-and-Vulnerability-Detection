<?xml version="1.0" encoding="utf-8"?>
<post><title>php - Login without HTTPS, how to secure? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>For a webapplication, when HTTPS is not available as a security measure, is it possible to still make the login somewhat secure? E.g.:</p>
<ul>
<li>Tokenize logins, to make repeat attacks difficult?</li>
<li>Somehow encrypt the sent password from a HTML password field?</li>
</ul>
<p>In particular I'm using CakePHP and an AJAX POST call to trigger authentication (includes provided username and password).</p>
<p>Update on the problem:</p>
<ul>
<li>HTTPS is not available. Period. If you don't like the the situation, consider it a theoretical question.</li>
<li>There are no explicit requirements, you have whatever HTTP, PHP and a browser (cookies, JavaScript etc.) offers in real life (no magic RSA binaries, PGP plugins).</li>
<li>Question is, what is the best, you can make out of <em>this</em> situation, that is better than sending the passwords plaintext. Knowing the drawbacks of each such solutions is a plus.</li>
<li>Any improvement better than plain passwords is welcome. We do not aim for a 100% l33tG0Dhx0r-proff solution. Difficult to crack is better than complicated to hack which is better than a trivial sniffing revealing the password.</li>
</ul>
</div></text><author><a href="/users/4044998/vikas-gupta">Vikas Gupta</a></author><comments><comment><text><span class="comment-copy">How secure? How high are the stakes (ballpark dollar figure can be handy guide)? How powerful are potential attackers? I wouldn't trade stocks, or share my darkest secrets on a website that lacked SSL. :)</span></text><author><a class="comment-user" href="/users/83348/mctylr" title="4,451 reputation">mctylr</a></author></comment><comment><text><span class="comment-copy">@mctylr This sort of security is obviously not military, financial nor government grade. But still better than plain text login, which is unfortunately common for small sites or sites that must work behind heavy firewalls filtering out HTTPS, or for cheap hosting sites not providing HTTPS (not even a self signed one for a differnt URL). The question is interested in any possible way to increase any aspect of security.</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">@Michael: Why are you trying to make a point in that HTTPS is required. I know that HTTPS can't be fully mimiced on HTTP with JS/cookies and such. There is still no HTTPS available (See desciption. "If you don't like the the situation, consider it a theoretical question.") But also, most shared hostings are like this. Go to any community forum or self hosted blog or most of the sites with less then 10.000 visitors a day, and you will not see a trusted certificate on port 443. And they are still secure enough! Why not add some more to their security? Btw., HTTPS is also no silver bullet.</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">Using JavaScript to obscure your password is still violation of (A3 Broken Authentication and Session Management)<a href="http://www.owasp.org/images/0/0f/OWASP_T10_-_2010_rc1.pdf" rel="nofollow noreferrer">owasp.org/images/0/0f/OWASP_T10_-_2010_rc1.pdf</a> It is a short read and it is very informative,  and this is my final point in this argument.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@sibidiba I hope the fact that nearly everyone on SO disagrees with you answers your question.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@The Rook: facts and scenarios, just like requirements, aren't democratic</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">how does your application defend against attacks like firesheep or deal with OWASP A9?</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">I don't know. Maybe my application does not defend against FooBarMagicHack9000. But the question is nevertheless about not having HTTPS available and what you do in that particular scenario to make things more difficult to crack. SSL is no silver bullet either.</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">@sibidiba github is now fully https because of firesheep,  facebook and twitter are soon to follow suit. Firesheep is nothing new,  but its brining attention to OWASP A9.  The most recent problem with https came to light with sslstrip,  but thats easy to defend against,  just enable the STS flag.   Also your answer has a -4 because it do anything.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">What about JS-implemented SSL ? just found out this : <a href="http://www-cs-students.stanford.edu/%7Etjw/jsbn/" rel="nofollow noreferrer">www-cs-students.stanford.edu/~tjw/jsbn</a></span></text><author><a class="comment-user" href="/users/1478467/sherbrow" title="14,889 reputation">Sherbrow</a></author></comment><comment><text><span class="comment-copy">@Sherbrow: interesting!</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">If you're running code over an insecure channel, this can't be secured, period. Even if you could send code that establishes a secure channel, it wouldn't matter, because the interceptor can simply replace that code with his own. You should instead be asking how to obscure what's happening to delay the attacker from owning you.</span></text><author><a class="comment-user" href="/users/80243/l%cc%b2%cc%b3o%cc%b2%cc%b3%cc%b3n%cc%b2%cc%b3%cc%b3g%cc%b2%cc%b3%cc%b3p%cc%b2%cc%b3o%cc%b2%cc%b3%cc%b3k%cc%b2%cc%b3%cc%b3e%cc%b2%cc%b3%cc%b3" title="8,609 reputation">L̲̳o̲̳̳n̲̳̳g̲̳̳p̲̳o̲̳̳k̲̳̳e̲̳̳</a></author></comment><comment><text><span class="comment-copy">I strongly recommend changing the answer to this question to anyone else,  or leave it unanswered.  The current answer is terrifying.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">I think the question needs clarification. Or the answerers need to re-read the question. The OP only wants to secure the login, not the whole protocol. Perhaps there is no need for a session token. Perhaps the OP only wants to POST data in association with a login as a one-step process, etc.</span></text><author><a class="comment-user" href="/users/442396/sentinel" title="1,265 reputation">Sentinel</a></author></comment><comment><text><span class="comment-copy">@sibidiba I have updated my answer to provide a real solution. Please change the answer to this post to anyone else.  Security is my profession,  and this is a serious question that needs a serious answer.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">You cannot simulate HTTPS using PHP. There are lot's of options to make your login more secure but if HTTPS is not available, you are out of luck.</span></text><author><a class="comment-user" href="/users/3169577/peter" title="3,136 reputation">Peter</a></author></comment><comment><text><span class="comment-copy">The short answer: You need HTTPS to have secure authentication. It's free, why not use it?</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Why do you believe HTTPS is not an option? Shared hosts provide TLS just fine nowadays.</span></text><author><a class="comment-user" href="/users/1332715/sven-slootweg" title="1,360 reputation">Sven Slootweg</a></author></comment><comment><text><span class="comment-copy">I appreciate your frustration with the answers that don't fit your criteria. For a non-HTTPS solution, please accept <a href="http://stackoverflow.com/a/2336736/1114">SLaks' answer</a> instead. The currently-accepted answer encourages direct password hashing using MD5, which is very broken, and <i>much</i> less secure (against passive observers in the style of Firesheep) that SLaks' suggestion of using RSA or AES. It's a much better way to make the best of the situation. :)</span></text><author><a class="comment-user" href="/users/1114/jeremy-banks" title="59,154 reputation">Jeremy Banks<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@sibidiba Could you please reconsider the acceptance of ESL's answer? It's vapid and has bad security advice. You cannot get security through MD5 hashing, and "it's better than nothing" is incorrect: a MitM can alter the JS to append the plaintext to the HTTP requests and capture passwords that way.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">@sibidiba Your question is worded as follows: <code>For a webapplication, when HTTPS is not available as a security measure, is it possible to still make the login somewhat secure?</code>. The answer is "No." Whether your <i>like</i> that fact or not, is irrelevant. rook's answer is the only correct answer to your question, as asked.</span></text><author><a class="comment-user" href="/users/770230/dan" title="2,705 reputation">Dan</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>HTTPS is <strong>absolutely vital</strong> in maintaining a secure connection between a website and a browser. <a href="http://lifehacker.com/5853483/a-guide-to-sniffing-out-passwords-and-cookies-and-how-to-protect-yourself-against-it" rel="noreferrer">Public wifi networks put users at risk</a>, and when used correctly, <strong>HTTPS is the only tool</strong> that can protect user accounts from <a href="http://readwrite.com/2011/01/26/zuckerbergs_facebook_page_hacked_and_now_facebook" rel="noreferrer">this vulnerability</a>. </p>
<p>If your host doesn't support HTTPS then a service like <a href="http://blog.cloudflare.com/introducing-universal-ssl/" rel="noreferrer">Cloudflare Universal SSL</a> can be used to ensure all browsers connect to your site using HTTPS, <em>even if your server doesn't support SSL/TLS</em>.  The connection between Cloudflare and your website will still be unprotected,  but this Cloudflare service is intended to protect users against threats found on public wifi networks.  From the perspective of a penetration tester, not providing HTTPS is highly suspect, if you aren't providing a basic security requirement as delivering traffic, then what other security requirements are you missing?  HTTPS certificates can be obtained for free using <a href="https://letsencrypt.org/" rel="noreferrer">Let's Encrypt</a> or <a href="https://www.startssl.com/" rel="noreferrer">Start SSL</a>, there is no legitimate reason not to support HTTPS.</p>
<p>HTTPS vital because it does lot more than just "encrypt passwords".  Another important role is that it should prevent the user from giving logging into a malicious server that is impersonating a real server. Using a system to protect the password alone is still a violation of <a href="https://www.owasp.org/index.php/Top_10_2010-A9-Insufficient_Transport_Layer_Protection" rel="noreferrer">OWASP A9 - Insufficient Transport Layer Protection</a> because you would still be transmitting session credentials in plain text which is all the attacker needs (<a href="http://codebutler.com/firesheep" rel="noreferrer">Firesheep</a>).</p>
<ol>
<li><p><a href="http://matasano.com/articles/javascript-cryptography/" rel="noreferrer">JavaScript-based cryptography cannot be used to construct a secure transport layer</a>.</p></li>
<li><p>"Tokenize logins":  If an attacker is sniffing
the traffic, they'll have the plain text username/password and then
they can just login with these new credentials.  (Replay attack)</p></li>
<li><p>"Somehow encrypt the transmitted password":  After the person has logged in
an attacker can sniff the traffic to get the valid <strong>session id</strong>
(cookie)  and then just use this instead of logging in.   If the
entire session was protected with SSL/TLS then this is not a problem.</p></li>
</ol>
<p>There are other more complex attacks that affect both this system and our current SSL infrastructure.  The <a href="http://www.thoughtcrime.org/software/sslstrip/" rel="noreferrer">SSLStrip</a> attack goes into greater detail.  I highly recommend <a href="https://www.youtube.com/watch?v=MFol6IMbZ7Y" rel="noreferrer">watching Moxie Marlinspike's Blackhat 2009 talk</a>,  which lead to the <a href="http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security" rel="noreferrer">HTTP-Strict-Transport-Security standard</a>.</p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments><comment><text><span class="comment-copy">I'm (somewhat) aware of what S offers in HTTPS. But HTTPS is <i>not</i> available in this case. My question is still open, what is the best, what is worth doing, when it is not available?</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">@sibidiba  https should always be available,  even if it is a free self-signed certificate.  If it is not then another encrypted tunnel such as a VPN can be used.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">HTTPS is <b><i>not</i></b> available. Existing problems most of the time can not be solved by requiring the situation to change into one where the problem does not exit.   Assume you are stranded on the South Pole after a plane crash. / Survivor: How do we get out of this? There is no mobile network coverage to call help. / You: We must call help on phone! / Survivor: There is no network coverage on this continent. / You: Network coverage should always be available.</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">He's probably on shared hosting with not shared SSL certificates.</span></text><author><a class="comment-user" href="/users/283055/tower" title="35,977 reputation">Tower</a></author></comment><comment><text><span class="comment-copy">The Rook has listed many of the myriad caveats about the ways you're gonna shoot yourself (mitm is particularly bad here).  The only other suggestion I have is to look at Digest Authentication, which is not particularly swell.  It's still susceptible to MITM because without an SSL login page, I don't even know if the HTML for the login prompt came from you, so I DA could get turned off on me.  Basically you're making a joke of your password system. I'm not saying that to be mean or in-your-face.  Figure out how to break the 'no-SSL' problem, or pray nobody gets interested in your site.</span></text><author><a class="comment-user" href="/users/328304/jason" title="1,190 reputation">Jason</a></author></comment><comment><text><span class="comment-copy">@sibidiba: The point is that without SSL, you <i>can't</i> make it secure. Yes, the scheme you linked to is "better than plaintext passwords." But it's still not even "somewhat secure." Sometimes there just isn't a good solution to a problem, other than changing the scenario. If you want security, your hosting choice (or whatever the limitation is) is wrong.</span></text><author><a class="comment-user" href="/users/2072/andrew-coleson" title="5,041 reputation">Andrew Coleson</a></author></comment><comment><text><span class="comment-copy">@Andrew: so because WEP encryption is easy to crack, you use <i>no encryption at all</i> when only WEP is available? Crackable does not mean that the attacker you aim for is also on the level.</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">@sibidiba: You must've missed the part where I said "Yes, it's better." That doesn't mean you would call WEP "secure", because it isn't. Yes, it's a question of semantics, but it's an important distinction whether you call something "secure."</span></text><author><a class="comment-user" href="/users/2072/andrew-coleson" title="5,041 reputation">Andrew Coleson</a></author></comment><comment><text><span class="comment-copy">@sibidiba <a href="http://en.wikipedia.org/wiki/Satellite_phone" rel="nofollow noreferrer">Network coverage is always availble</a>! Every webserver supports the equivalent of sattelite phones, by default.</span></text><author><a class="comment-user" href="/users/136173/alexanderpas" title="2,015 reputation">alexanderpas</a></author></comment><comment><text><span class="comment-copy">Thanks @Rook :)</span></text><author><a class="comment-user" href="/users/984422/wahyu-kristianto" title="2,388 reputation">Wahyu Kristianto</a></author></comment><comment><text><span class="comment-copy">A strong - 1, this post contains multiple problems. First and foremost, <b>it's not what ask</b> @sibidiba: HTTPS <b>sometimes is not an option</b> (when you don't have power to decide). Additionally, <b>there is not absolut security</b> as you talk, always there are less or more secure options. This post should be modified or removed</span></text><author><a class="comment-user" href="/users/960177/esl" title="433 reputation">ESL</a></author></comment><comment><text><span class="comment-copy">@ESL nothing in your post is "secure" or a "solution"</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@rook 1) There is no "secure" method, HTTPS <b>it's not secure</b>, it's just <i>more</i> secure.[1][2][3] (and a long etc.). If you said so, <b>you lie</b>.   [1]: <a href="http://en.wikipedia.org/wiki/Certificate_authority" rel="nofollow noreferrer">en.wikipedia.org/wiki/Certificate_authority</a>   [2]: <a href="http://en.wikipedia.org/wiki/Heartbleed" rel="nofollow noreferrer">en.wikipedia.org/wiki/Heartbleed</a>   [3]: <a href="http://en.wikipedia.org/wiki/POODLE" rel="nofollow noreferrer">en.wikipedia.org/wiki/POODLE</a></span></text><author><a class="comment-user" href="/users/960177/esl" title="433 reputation">ESL</a></author></comment><comment><text><span class="comment-copy">rook 2) Your answer it's not a solution, <b>it's not even an answer</b> to the @sibidiba question. You made up your own question and answer it.</span></text><author><a class="comment-user" href="/users/960177/esl" title="433 reputation">ESL</a></author></comment><comment><text><span class="comment-copy">@rook 3) Please, <b>stop vandalizing Stackoverflow</b> to censor me. <a href="http://stackoverflow.com/revisions/25758425/3">stackoverflow.com/revisions/25758425/3</a></span></text><author><a class="comment-user" href="/users/960177/esl" title="433 reputation">ESL</a></author></comment><comment><text><span class="comment-copy">dear @rook, what part of "HTTPS is not available" you did not understand?</span></text><author><a class="comment-user" href="/users/6827403/a-costa" title="163 reputation">a.costa</a></author></comment><comment><text><span class="comment-copy">@a.costa then you don't have legs to stand on. <a href="http://i3.kym-cdn.com/entries/icons/original/000/013/970/motherfucking-game.png" rel="nofollow noreferrer">i3.kym-cdn.com/entries/icons/original/000/013/970/…</a></span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Since you cannot do SSL at the web server, and you are not a security expert, look for an existing secure authentication service that you can utilize, and let them handle both the SSL and the complexities of handling credentials for you. </p>
<p>In particular, I would suggest that you use a free third-party authentication service, such as <a href="http://openid.net/developers/" rel="nofollow noreferrer">OpenID</a>. They have libraries for <a href="http://openid.net/developers/libraries/#php" rel="nofollow noreferrer">PHP</a> including one for <a href="http://code.42dh.com/openid/" rel="nofollow noreferrer">CakePHP</a>.</p>
<hr/>
<p><strong>Edit: (about risks)</strong></p>
<p>While using a 3rd-party secure authentication service (that uses HTTPS itself) can mitigate the problem doing authentication itself without using HTTPS (on your server), it does not entirely eliminate the possibility of  attacks.</p>
<p>The most common two attacks would be <em>replay</em> attacks, and <em>session-hijacking</em> where the attacker is able to either re-uses a genuine login session token later, or use a valid session token for their own malicious purpose.</p>
<p>The replay attack can be mitigated by having the session token expiry, and preferably by using a <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce" rel="nofollow noreferrer">nonce</a> to prevent session replay and to reduces the risk of session hijacking. With a nonce, a legitimate session generates an error if successfully hijacked, because the nonce has expired (been used), so their own session is no longer valid.</p>
<p>If you cannot use HTTPS to encrypt the session token while being transmitted to and from your server, you cannot entirely prevent active attacks such as <em>session-hijacking</em> or <em>man-in-the-middle</em> attack. This <em>may</em> be acceptable in some cases, such as websites with a small user base for non-commercial usage.</p>
</div></text><author><a href="/users/83348/mctylr">mctylr</a></author><comments><comment><text><span class="comment-copy">My thinking exactly. If you can't have SSL on your server, let a third party do the SSL for you.</span></text><author><a class="comment-user" href="/users/229253/stevenf" title="161 reputation">stevenf</a></author></comment><comment><text><span class="comment-copy">This is a <b>very</b> bad idea. The problem is that authentication is the least of your worries. You need to protect the entire session. The weakest part of your system is the strength of the entire system. And since you brought up OpenID, <a href="http://www.troyhunt.com/2012/08/is-stack-overflow-secure-kind-of.html" rel="nofollow noreferrer">This article on the broken StackExchange auth is pertinent</a>...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell Except the article you cite, fails to clarify that his demonstration doesn't not identify the potential solution to the weakness discussed, that may be already in place, of server-side session management, where a session is keyed to IP address, perhaps a <a href="http://en.wikipedia.org/wiki/Cryptographic_nonce" rel="nofollow noreferrer">nonce</a> or salt, and has an expiry time. I.e. An attacker would need an active attack doing IP spoofing, rather than merely passively listening (sniffing) to TCP/IP or WiFi traffic, while the legitimate user is actively logged in.</span></text><author><a class="comment-user" href="/users/83348/mctylr" title="4,451 reputation">mctylr</a></author></comment><comment><text><span class="comment-copy"><i>need to protect the entire session</i>: This gets back to the fact that you for a comprehensive answer, you need to do a risk assessment of the <b>particular</b> situation and weight the risk/reward of attacks vs. security. If TLS/SSL is not available, then any solution will be subject to the lack of secrecy (or <i>excess of availability</i> in the <a href="http://it.med.miami.edu/x904.xml" rel="nofollow noreferrer">CIA</a> sense), but that doesn't necessarily mean that integrity, authentication, or <a href="http://en.wikipedia.org/wiki/Non-repudiation" rel="nofollow noreferrer">non-repudiation</a> is entirely impossible depending on the level of confidence required.</span></text><author><a class="comment-user" href="/users/83348/mctylr" title="4,451 reputation">mctylr</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The short answer is that without SSL endpoint to endpoint encryption, it's impossible to do it securely...</p>
<p>One of the primary reasons for this is that you can't do secure crypto in a browser. See <a href="http://www.matasano.com/articles/javascript-cryptography/">this reference - Javascript Cryptography Considered Harmful</a>.</p>
<p>Additionally, there's no way that you can be sure that the source of the credentials are indeed who you're talking to. Meaning that there's absolutely no way without SSL to be sure that there's not a <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-In-The-Middle Attack</a> going on.</p>
<p>So no, you can't do it. </p>
<p>Additionally, don't even try. Get SSL. You can get free certificates. Hosts will usually give you a dedicated IP for a few $$$ per month. And if you really care about security, you'd be using at least a VM with a dedicated IP address anyway. </p>
<p>To even attempt this would be <a href="http://en.wikipedia.org/wiki/Security_through_obscurity">Security Through Obscurity</a> at best, and nothing at worst. SSL is a solved problem. Why not use that solution. Security is not something to guess at. Use the proper techniques. Don't try to invent your own. It won't work...</p>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">I'd just like to add: If anyone is reading this thinking that they found a way to develop a secure protocol better than TLS, they ought to send it to the IETF for consideration for a new internet standard. :)</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As you suggested, you may be able to generate a unique token each time the page is created. That same token would need to be sent back with the form data and could not be reused. You could also keep the password safe by using JavaScript to hash it, if you can rely on it being enabled by your users. </p>
<p>This scheme is still not secure, however. An attacker could still see everything going across the wire. They could intercept the token and send a response back to you before the user does. Or they could just wait for someone to login, steal that person's credentials (as they are sent over the wire), and just make their own login request later on.</p>
<p><b>Bottom Line</b> - you need to use HTTPS to guarantee the site is secure.</p>
</div></text><author><a href="/users/101258/justin-ethier">Justin Ethier</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You can encrypt the password using Javascript and decrypt it on the server.</p>
<p>I would recommend generating an RSA keypair on the server, send the public key along with a timed salt to the browser, then encrypting the password, combined with the salt, using the public key in Javascript.</p>
<p>You can find an RSA implementation in Javascript <a href="http://www-cs-students.stanford.edu/%7Etjw/jsbn/" rel="noreferrer">here</a></p>
<p>You should include both the IP address and the entire <a href="http://en.wikipedia.org/wiki/XFF" rel="noreferrer">X-FORWARDED-FOR</a> hedaer in the authentication cookies to prevent cookie theft behind proxies.</p>
<p>If you're dealing with sensitive data, you could generate a random <a href="http://github.com/markpercival/gibberish-aes" rel="noreferrer">AES key in Javascript</a>, then send it to the server along with the password encrypted with RSA.<br/>
You could then make the entire application use encrypted AJAX requests from a single page and not use an auth cookie at all.</p>
<p>Note that it is not possible to protect against an active man-in-the-middle attack without SSL.  An active attacker can completely replace your site with his own proxy, and there isn't any way to defend against that.  (Since there cannot be any known good code)</p>
</div></text><author><a href="/users/34397/slaks">SLaks</a></author><comments><comment><text><span class="comment-copy">This is a valid use of RSA,  but its a moot point.  Its not going to stop anyone from getting hacked.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Is RSA possible in JavaScript today?. A few years ago I was looking at them, and they did not scale to current key lengths.</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">X-FORWARDED-FOR is not set by all proxies. Also it is trivial for an attacker to spoof X-FORWARDED-FOR.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">The author knows what he is doing regarding cryptography and security, but I don't know if he considers the implementation a secure alternative to SSL. In particular the PRNG looks potentially weak which would undermine the entire thing anyway. There are also attacks on PKCS #1 that this may be vulnerable to. <a href="http://www.iacr.org/archive/eurocrypt2000/1807/18070374-new.pdf" rel="nofollow noreferrer">iacr.org/archive/eurocrypt2000/1807/18070374-new.pdf</a></span></text><author><a class="comment-user" href="/users/83348/mctylr" title="4,451 reputation">mctylr</a></author></comment><comment><text><span class="comment-copy">Actually, I don't see how this approach prevents a man-in-the-middle attack.</span></text><author><a class="comment-user" href="/users/83348/mctylr" title="4,451 reputation">mctylr</a></author></comment><comment><text><span class="comment-copy">@Michael: AFAIK, if you use the <i>entire</i> XFF string plus the physical IP address, you aren't vulnerable to spoofing.  (Except for proxies that don't set it)</span></text><author><a class="comment-user" href="/users/34397/slaks" title="576,191 reputation">SLaks</a></author></comment><comment><text><span class="comment-copy">@mctylr#2: It doesn't.  Read my last paragraph</span></text><author><a class="comment-user" href="/users/34397/slaks" title="576,191 reputation">SLaks</a></author></comment><comment><text><span class="comment-copy">Okay, I did not notice your additional two paragraphs that you added after your initial answer. No problem, glad we can agree.</span></text><author><a class="comment-user" href="/users/83348/mctylr" title="4,451 reputation">mctylr</a></author></comment><comment><text><span class="comment-copy">There's absolutely no point in using RSA here - a digest-based authentication scheme would provide the same security with much less complexity.</span></text><author><a class="comment-user" href="/users/12030/nick-johnson" title="90,861 reputation">Nick Johnson</a></author></comment><comment><text><span class="comment-copy">Except that RSA <a href="http://www.matasano.com/articles/javascript-cryptography/" rel="nofollow noreferrer">can't be done securely on the client side</a>. So all of that work for nothing...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell: Yes.  That's what I said in my last paragraph.</span></text><author><a class="comment-user" href="/users/34397/slaks" title="576,191 reputation">SLaks</a></author></comment><comment><text><span class="comment-copy">This post should be changed,  it is Cargo-Cult security.  <a href="http://matasano.com/articles/javascript-cryptography/" rel="nofollow noreferrer">matasano.com/articles/javascript-cryptography</a></span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@rook Does this not protect the specific password value from a passive observer on the network? It certainly isn't very secure (since the encrypted passwords or session cookies could still be stolen and used to authenticate to the site), but it should provide nonzero value for the many users who reuse passwords. It should at least be better than the answers suggesting standard HTTP Digest authentication. (However, I'm not a security expert. I'd be very interesting in learning if my understanding is wrong in some way.)</span></text><author><a class="comment-user" href="/users/1114/jeremy-banks" title="59,154 reputation">Jeremy Banks<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@Jeremy Banks good question.  In SLacks' scenario, an attacker can <a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/" rel="nofollow noreferrer">obtain the plaintext password by modifying the HTTP response, and backdooring the encryption process</a>. Two other resources on this topic: <a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet" rel="nofollow noreferrer">owasp.org/index.php/Session_Management_Cheat_Sheet</a> and <a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" rel="nofollow noreferrer">owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet</a> .  In short, if a malicious user can obtain an admin account, then who cares what the password is, it's game over.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@rook: Yes; I already said that in my last paragraph.</span></text><author><a class="comment-user" href="/users/34397/slaks" title="576,191 reputation">SLaks</a></author></comment><comment><text><span class="comment-copy">@rook Thanks, but if they're modifying the http traffic then that's not a passive observer. And my comment already explained why you care what the password is: password reuse. I'm not suggesting that it's ever excusable practice from a company, just that it could provide marginal value.</span></text><author><a class="comment-user" href="/users/1114/jeremy-banks" title="59,154 reputation">Jeremy Banks<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@Jeremy Banks It will not benefit your application to assume that the attacker is def and blind.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use <a href="http://en.wikipedia.org/wiki/Digest_access_authentication" rel="noreferrer">HTTP Digest</a> authentication, which is supported by most browsers and does not send the password in clear over the wire. </p>
<p>The downside is the ugly log in box displayed by broswer. If you preffer to stick with forms, then you can implement exactly the same protocol as HTTP Digest in your forms authnetication: send hidden fields containing the realm and the challenge, and have the client add in JavaScript the nonce and compute the digest. This way you'll use a well known and proven exhange protocol, rather than roll your own.</p>
<p>HTTP Digest requires only hash operations.</p>
</div></text><author><a href="/users/105929/remus-rusanu">Remus Rusanu</a></author><comments><comment><text><span class="comment-copy">Is logging out possible by now? How can I detect from the server side that the login was a success?</span></text><author><a class="comment-user owner" href="/users/232542/sibidiba" title="3,703 reputation">sibidiba</a></author></comment><comment><text><span class="comment-copy">You are still in control of the authentication process, it happens on the server php scripts. You authenticate the response form against a user database where you have the user name and the HA1 part of the http digest ie. md5(user:realm:password). From the response you reconstruct the Digest hash, starting from the HA1 stored in the database and compare it with the response in the form submit, if they match it means the user had the correct password.</span></text><author><a class="comment-user" href="/users/105929/remus-rusanu" title="217,519 reputation">Remus Rusanu</a></author></comment><comment><text><span class="comment-copy">The big advantage over other schemes is that it allows for a unified authentication model for browser/user sessions (using forms and cookies, but not transmitting the password over the wire) <i>and</i> REST services, using HTTP Digest.</span></text><author><a class="comment-user" href="/users/105929/remus-rusanu" title="217,519 reputation">Remus Rusanu</a></author></comment><comment><text><span class="comment-copy">Logging out is handled the usual way, by resetting the auth cookie. It is true though that if the user hits in the browser a part that challenges him to do HTTP digest (eg. enters an REST URL from the site) and if the user enters the correct password in the browser log in dialog, is much harder to log out: the user has to manually clear the password from the browser setting. But that should not happen normally, as the UI part of the site is usually separated from the REST part.</span></text><author><a class="comment-user" href="/users/105929/remus-rusanu" title="217,519 reputation">Remus Rusanu</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>What about <a href="http://en.wikipedia.org/wiki/Digest_access_authentication" rel="nofollow noreferrer">HTTP Digest Authentication</a>? It provides security by MD5-hashing username, password and a nonce (among other things) before sending it to the server. MD5 isn't really secure, but it's a good way for simple security with HTTP.</p>
<p>Of course this doesn't prevent hackers from changing the message... but it secures your password.</p>
</div></text><author><a href="/users/245706/andidog">AndiDog</a></author><comments><comment><text><span class="comment-copy">The digest can be sniffed and replied.  HTTP digest authentication requires HTTPS to protect the credentials transmitted as the "Authorization" http header.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>HTTPS has numerous use cases, most of which are designed to defend against Man-in-the-middle attacks. Anyone with a hacker's mindset will shudder to tell you that there is no way other than the established way to accomplish something. The fact is that just because you use TLS (the standard which modern HTTPS uses), does not mean you are using it well. Additionally, just using TLS does not prevent someone from exploiting known weaknesses. Just as you may be finding creative ways to secure your data, there are people who are finding creative ways to exploit your security measures.</p>
<p>So, what to do?</p>
<p>First of all, if you're going to forego TLS, it is helpful to understand how it works. And it is all about a handshake.</p>
<blockquote>
<p>Once the client and server have agreed to use TLS, they negotiate a
  stateful connection by using a handshaking procedure.[7] During this
  handshake, the client and server agree on various parameters used to
  establish the connection's security:</p>
<ul>
<li>The handshake begins when a client connects to a TLS-enabled server
  requesting a secure connection and presents a list of supported cipher
  suites (ciphers and hash functions). </li>
<li>From this list, the server picks
  a cipher and hash function that it also supports and notifies the
  client of the decision. </li>
<li>The server sends back its identification in
  the form of a digital certificate.[contradiction] The certificate
  usually contains the server name, the trusted certificate authority
  (CA) and the server's public encryption key. </li>
<li>The client may contact
  the server that issued the certificate (the trusted CA as above) and
  confirm the validity of the certificate before proceeding. </li>
<li>In order to
  generate the session keys used for the secure connection, the client
  encrypts a random number with the server's public key and sends the
  result to the server. Only the server should be able to decrypt it,
  with its private key. </li>
<li>From the random number, both parties generate
  key material for encryption and decryption.[contradiction] This
  concludes the handshake and begins the secured connection, which is
  encrypted and decrypted with the key material until the connection
  closes.</li>
</ul>
<p>If any one of the above steps fails, the TLS handshake fails, and the
  connection is not created.</p>
</blockquote>
<p>Source: <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" rel="nofollow">Wikipedia</a></p>
<p>So, is it possible? Yes. I was taught that anything is possible. It may be expensive, but it is always possible.</p>
<p>I want to fully disclose that I am NOT a security professional, just an enthusiast. I do not recommend attempting this for a production-grade project or anything other than your own edification. You should DEFINITELY check out <a href="http://stackoverflow.com/a/6658596/1935338">this SO post</a> which provides an excellent explanation as to roadblocks in setting up your own security protocol.</p>
<p>However, if you want to move on, here are some thoughts that come to mind. These are realities that will exist regardless of which direct you went with this project.</p>
<ul>
<li><p>HTTPS is supported by all major modern browsers. Even with this reality, HTTPS load times are slower than plain HTTP. Without extensive production, it is highly likely your alternative implementation will be a fraction as secure while being significantly slower. This will be a drawback of any homegrown implementation unless you are utilizing browser features, which brings us full circle back to using TLS, which is what modern HTTPS utilizes.</p></li>
<li><p>If you manage to encrypt your password without TLS on the browser side using Javascript in an unpredictable enough fashion that an MiTM attack would be difficult, don't rest there. You also should be securing the data you send back and forth. Otherwise the password being encrypted really is irrelevant. Sure, an attacker might not know bobsmith109's password, but he doesn't need it, because he can sniff every single activity on the network. He knows what times bobsmith109 logs in, can probably trace his IP, and any other sensitive piece of data you send back and forth.</p></li>
<li><p>No matter what security measures you take, there is security in depth. So one thing that you can do right off the bat is make sure you encrypt your data in the database while also requiring strong passwords. </p></li>
</ul>
<p>I reiterate that I am <em>not</em> a security professional and <em>strongly discourage</em> this as anything other than to satiate your curiosity. It is astronomically improbable that you can create a viable alternative to TLS without an extraordinarily large group of security professionals contributing to a project for years if not decades, which is what SSL/TLS can boast. That being said, a good starting point if you choose to go forward is to look at the handshake model above and see how you can implement a version of this without TLS.</p>
<p>I would be remiss to not share in my post that most real-life barriers to using HTTPS are being actively fought against. One of the largest - cost - is very close to becoming a non-issue. A free certificate authority will be coming out 2Q 2015 is supported by some big guns, including Mozilla and Akamai, to name a few. <a href="http://www.pcworld.com/article/2849412/eff-mozilla-back-new-certificate-authority-that-will-offer-free-ssl-certificates.html" rel="nofollow">Here is an article</a>.</p>
</div></text><author><a href="/users/1935338/smcjones">smcjones</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Have a look at <strong><a href="http://srp.stanford.edu/" rel="nofollow">"The Secure Remote Password Protocol"</a></strong>.</p>
<p>Instead of formulating it myself, let me quote from their webite:</p>
<blockquote>
<p>The Secure Remote Password protocol performs secure remote authentication of short human-memorizable passwords and resists both passive and active network attacks.</p>
</blockquote>
<p>and:</p>
<blockquote>
<p>[The] protocol combines techniques of zero-knowledge proofs with asymmetric key exchange protocols and offers significantly improved performance over comparably strong extended methods that resist stolen-verifier attacks such as Augmented EKE or B-SPEKE.</p>
</blockquote>
<p>Although the Stanford University doesn't provide implementations for PHP and JavaScript themselves, they link to some 3rd-party implementations.</p>
<p>One of those links leads to <strong>"Clipperz"</strong>, which is an online password manager. It is also available as a community edition on GitHub. There they host their <a href="https://github.com/clipperz/javascript-crypto-library" rel="nofollow">"javascript-crypto-library"</a>, which implements the protocol and the <a href="https://github.com/clipperz/password-manager" rel="nofollow">"password-manager"</a> itself, which contains backends written in PHP and Python.</p>
<p>I can't say how difficult it would be to extract the relevant portions of code, but maybe you can reuse their implementation (it's licensed under AGPL).</p>
<p><strong>Edit 2014/10/24:</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol#Implementations" rel="nofollow">Wikipedia's article on SRP</a> lists some more implementations. Relevant for PHP/JS:</p>
<ul>
<li><a href="https://github.com/symeapp/srp-client" rel="nofollow">srp-client (JS)</a></li>
<li><a href="https://github.com/RuslanZavacky/srp-6a-demo" rel="nofollow">srp-6a-demo (PHP/JS)</a></li>
</ul>
</div></text><author><a href="/users/386711/ben">ben</a></author><comments><comment><text><span class="comment-copy">JavaScript cannot be used as a secuirty system in this context: <a href="http://matasano.com/articles/javascript-cryptography/" rel="nofollow noreferrer">matasano.com/articles/javascript-cryptography</a></span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can try to replicate it to some point, by using public key encryption (GPG maybe) and making use of browser caching.</p>
<blockquote>
<p><strong>This is not something secure, even just putting up SSL won't be enough for a sophisticated attacker, you need to make use of HSTS, public key pinning etc to just to consider a web site secure <em>today</em>.</strong></p>
</blockquote>
<p>The rest of the answer is just food for thought. </p>
<ol>
<li>Create a public-private key pair. Keep private one secure.</li>
<li>Create a js file containing the public key and a <code>encrypt</code> function, find a secure encryption algorithm. This function should encrypt a given string (serialized form) with an additional timestamp, to avoid a replication attack.</li>
<li>Serve this file with <code>Cache-Control:public, max-age=31536000</code> HTTP header. We try to mitigate when the attacker tries to replace the script. The file will always be served from the browser cache. </li>
<li>Send all the forms via Javascript, using the <code>encrypt</code> function. Serve these with the same header as above.</li>
<li>At the server side, <code>decrypt</code> the data, check the timestamp, if it's still valid. Do you thing, if not, discard it.</li>
<li>Create a cookie token which can only be used once for a very short amount of time. If the attacker captures a cookie, he won't have much time to do stuff. However, if the attacker is fast enough, then he might log the original user out.</li>
<li>Change the cookies with every response. But then what do you do when the user sends multiple requests at once and then they arrive in the reverse order? Which cookie is valid? This creates tons of problems at the cost of a false sense of security.</li>
</ol>
<p>Any listeners won't be able to make use of the data going back and forth, and they won't be able to change/inject the <strong>existing</strong> <code>JS</code> files until the cache expires / user clears the cache. However, any sophisticated attacker can replace the whole <code>HTML</code> file which would discard all the security measurements I have just mentioned. If you can at least serve this file / form over <code>HTTPS</code>, you <em>might</em> get away with it, put them on github pages or whatever. However, if you put the file some other domain, then you need to set up <code>CORS</code> for the receiving domain for this to work.</p>
<h2>Another try</h2>
<p>One time passwords sent to email.</p>
<ol>
<li>User fills out their email, clicks a link which then sends a link to their email with a token that will enable them logging in.</li>
<li>User clicks the link</li>
<li>Server checks the token, logs the user in.</li>
<li>Rolls the cookies like the previous example.</li>
</ol>
<p>All in all, whatever you do, it is <strong>not secure</strong>. Given a fast, sophisticated attacker, nothing stands in the way.</p>
<p>Get SSL, if the infrastructure does not support it, change it. If your manager does not believe in SSL, convince him/her. Don't create a false sense of security. Protect your user's data, depending on your location, you are legally required to protect the data of your users.</p>
<p>Then let's talk about how to make a site secure with SSL.</p>
</div></text><author><a href="/users/825780/umur-kontac%c4%b1">Umur Kontacı</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<h2>Login without HTTPS, how to secure?</h2>
<p>Since there is no secure channel between your server and your client:</p>
<ul>
<li>because there is no secure channel, anybody can snoop your traffic.</li>
<li>because anybody can snoop the traffic, you are open to a MITM attack.</li>
<li>because you are open to MITM attack, there is no guarantee you client will see a legitimate page.</li>
<li>because the pages are not legitimate and your page is in effect not being served (the guy in the middle is serving the pages), all tricks used server-side are rendered useless.</li>
</ul>
<h2>What can you do? Theorically?</h2>
<ul>
<li>both client and server need to use encryption to make snooping / MITM less susceptible.</li>
<li>assume you cannot have a handshake,</li>
<li>assume your client already has your key and knows how to speak the same gibberish as your server.</li>
<li>how about some SSL over HTTP but wrapped in base64-encoded message for some gibberish?</li>
</ul>
<p>But wait... Since you said no magic binary, or plugin, not even RSA, I don't know if any of this is possible save for (some potentially very weak) in-house encryption.</p>
<p>--</p>
</div></text><author><a href="/users/1733117/dnozay">dnozay</a></author><comments><comment><text><span class="comment-copy">Any in-house encryption can trivially be stripped.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Before trying to answer, I'd like to mention that every other response here is right about HTTPS/STS.  HTTPS is battle hardened, trusted, and probably your best bet - I'm sure you're tired of hearing it. Now, I'm not a security expert, but this problem is one I've given thought and I did happen to create a way.  I've never used it, and I'd ask everyone to poke holes in it as much as possible.  It only protects against a man-in-the-middle attack.</p>
<p>The idea is to achieve the shared secret portion without the handshake, even if that means piggybacking on another service that is secure (like an email, assuming they use something with TLS to read it).</p>
<h1>Part 1: The Setup</h1>
<ol>
<li><p>Select a symmetric cipher, Rijndael perhaps.</p></li>
<li><p>Select a hashing algorithm, SHA256/512 are favorites of mine.</p></li>
<li><p>Create a large salt, some random piece of data, ideally somewhat beefy. 512 bytes maybe. Let's call it GSALT. (think of it as a variable named GSALT). This will be a global salt. Probably good config file material.</p></li>
<li><p>In your database, the user data should contain a username field, a userhash field, a password field, a salt field, a key field, and keyhash field (plus whatever else you want, I'm only covering relevant fields).  I'll explain what each field should contain:</p>
<ul>
<li>username: The actual username the person picked during registration.</li>
<li>salt: A randomly generated string, should be at least 32 characters long. I like making them 64. That might be wasteful, but I'm paranoid. Let's call this LSALT.</li>
<li>password: The hash of GSALT+actual password+LSALT. Appended in that order. </li>
<li>userhash: Should contain the hash of GSALT+username. Indexed for speed.</li>
<li>key: Should contain a random string (it's basically another salt, but one we'll use semi-publicly)</li>
<li>keyhash: Contains the hash of GSALT+actual password+key. Appended in that order.</li>
</ul></li>
</ol>
<h1>Part 2: Signing Up A New User</h1>
<ol>
<li>In you signup form, prompt for a username, email, but no password.</li>
<li>Once validated and accepted, generate a password server-side and send it to their email.</li>
<li>In your database, generate the different values mentioned in step one (userhash, password, salt, key, keyhash etc)</li>
</ol>
<h1>Part 3: Authentication</h1>
<ol>
<li>Include the global salt with the login.</li>
<li>On a login attempt:

<ul>
<li>Create userhash by hashing GSALT+username</li>
<li>Create a passhash by hashing GSALT+password</li>
<li>Send userhash and passhash up to the server</li>
</ul></li>
<li>On the server receiving these:

<ul>
<li>Find the user record matching userhash</li>
<li>Get the password and salt value from that record, and verify that this username has the correct password by hashing passhash+user salt (LSALT).</li>
<li>If it's a match, your user is authenticated. Produce a nonce (a random number or string of a decent size such that it can't be guessed)</li>
<li>Encrypt the nonce using the keyhash value as the encryption key, and produce a token with the nonce in it's payload. This token should use a separate server-side only key (see JWT scheme).</li>
<li>Send down the key, the encrypted nonce, and the token.</li>
</ul></li>
<li>The client recieves the key, the encrypted nonce, and the token.</li>
<li>The client hashes GSALT+actual password+key to produce the encryption key required to decrypt the nonce.</li>
<li>Discard all other values except the nonce and the token on the client side.</li>
<li>With each client-side request, encrypt the contents using the nonce as a key.  Send the encrypted contents with the token. Do not encrypt the token. Simply send the token as a separate value from the request data.</li>
<li>Server recieves the encrypted request and the token, decrypts the token, then uses the nonce to decrypt the request's contents.</li>
<li>Server generates a response, encrypts it using the nonce, sends it down...back and forth/etc</li>
</ol>
<h1>Issues</h1>
<ol>
<li>It's computationally expensive, on both sides.</li>
<li>It doesn't protect against a lot of other attacks, and is likely more open to a side channel attack.</li>
<li>That global salt is basically a forever deal :/</li>
<li>I'm not a security expert, this might not be air-tight. "Don't roll your own crypto schemes" is parroted for a good reason.</li>
<li>A dedicated enough hacker could build a rainbow table, or brute force check for your hashed password.</li>
<li>It's cheating because we used email to circumvent a trouble area.</li>
</ol>
<p>Still, it's a fun thought experiment! I hope it helps someone (especially if that means it pushes them into using HTTPS)</p>
</div></text><author><a href="/users/3457733/hedzer">Hedzer</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The best solution I have seen for somewhat secure HTTP connections is to use a Javascript implementation of md5sum (or some other hash) to avoid transmitting the password in plaintext. You can create a form onsubmit handler in Javascript that replaces the password field with a hash of the original value. This adds a modest amount of security to an unsecure connection, but relies on Javascript running in the browser to work properly.</p>
</div></text><author><a href="/users/168125/brandon-k">brandon k</a></author><comments><comment><text><span class="comment-copy">This doesn't stop anything, the attacker will just hijack the session after it has been authenticated.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Whatever Michael said.   If you do go with md5, at least have server send unique challenge, client should send md5(challenge+pass). Sending md5(password) for most users is same as pass in clear. More than replay, the bigger concern would be passive attacker can crack most of your users password.  Also if you are over http and you have active attacker, apart form replay and hijacking, it has been demonstrated that attacker can inject script to modify the login form so that they get a copy of entered username, password.  use https unless you are supporting some weird mobile device.</span></text><author><a class="comment-user" href="/users/271355/mar" title="296 reputation">mar</a></author></comment><comment><text><span class="comment-copy">@Rook Your criticism applies to any plausible solution that doesn't use SSL, as you've already amply indicated. Let's take it as a given that they're all vulnerable to this.</span></text><author><a class="comment-user" href="/users/12030/nick-johnson" title="90,861 reputation">Nick Johnson</a></author></comment><comment><text><span class="comment-copy">"but relies on Javascript running in the browser to work properly." ...and the attacker can just replace the js with something that sends him the password.</span></text><author><a class="comment-user" href="/users/80243/l%cc%b2%cc%b3o%cc%b2%cc%b3%cc%b3n%cc%b2%cc%b3%cc%b3g%cc%b2%cc%b3%cc%b3p%cc%b2%cc%b3o%cc%b2%cc%b3%cc%b3k%cc%b2%cc%b3%cc%b3e%cc%b2%cc%b3%cc%b3" title="8,609 reputation">L̲̳o̲̳̳n̲̳̳g̲̳̳p̲̳o̲̳̳k̲̳̳e̲̳̳</a></author></comment><comment><text><span class="comment-copy">JavaScript cannot be used as a security system in this context: <a href="http://matasano.com/articles/javascript-cryptography/" rel="nofollow noreferrer">matasano.com/articles/javascript-cryptography</a></span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The answer is shorter, and if you really matter about security you always have options that different levels of bureauocracy.</p>
<p>Absolut security does not exists. The number one flaw is always on the client side, with <strong>trojans</strong> ans <strong>keyloggers</strong>. SSL doesn't help with that. </p>
<p>1) <strong>Token generators</strong>: banks use them, blizzard uses then. It can be a device or an app. Well.. it's expensive.</p>
<p>2) <strong>SMS pins</strong>. interesting and affordable solution. There is a lot of good prices from trnasactional sms on the market and everyone has a phone capable of receiving it.</p>
<p>3) If you have to use HTTP, you can force a third party oauth service, like <strong>google</strong> or <strong>facebook</strong>. That's the best you can do without a token generator.  </p>
</div></text><author><a href="/users/1148444/guilherme-viebig">Guilherme Viebig</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I guess you care about secure transmission of password to the server? My answer is: dont transmit passwords to the server :)</p>
<p>Infact you may not transmit anything from browser (user) to server to authenticate the user, as an attacker who is spying http traffic would also be able to retransmit the data and authenticate.</p>
<p><strong>Proposal:</strong></p>
<p>Obvious solution would be to use a one-way, one-time transaction authentication originating from server; like a transaction number which can only be used once. Eventually, you still need a secure channel once to sync the list of transaction numbers with user.</p>
<p>You could use something <a href="https://code.google.com/p/google-authenticator/" rel="nofollow" title="Google Authenticator">google authenticator</a>, yet you need a secure channel once to setup parameters on either side. If you consider email to be secure, that would be a way to go.</p>
</div></text><author><a href="/users/1005652/comegetsome">comeGetSome</a></author><comments><comment><text><span class="comment-copy">What about protecting other authentication credentials,  such as session IDs?  Are you familiar with the OWASP Top 10?</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">lol, author is asking about a way to securely login without https, of course there are huge other points to consider, but who asked about session ids? are you sure author wants to maintain sessions?</span></text><author><a class="comment-user" href="/users/1005652/comegetsome" title="1,238 reputation">comeGetSome</a></author></comment><comment><text><span class="comment-copy">Why only protect one type of authentication credential?  This post strike me as cargo-cult security.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">the whole post is against owasp. that does not mean there is no answer.</span></text><author><a class="comment-user" href="/users/1005652/comegetsome" title="1,238 reputation">comeGetSome</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I have the same issue on a system of mine. I have taken steps to try and increase security without compromising the user experience with convoluted mechanisms. What I noticed was that the vast majority of users logged in from the same machine using the same browser, (but not necessarily the same IP address), or from a couple of browsers (eg: desktop or mobile). I decided I could use this to identify a pattern.</p>
<p>1) During registration, users are required to have strong passwords (to prevent dictionary attacks), a security question/answer and standard email verification (as proof of real person)</p>
<p>2) During login, after 5 failed login attempts (not before), a captcha is displayed to prevent brute force attacks.</p>
<p>3) Finally, I created a hash of parts of the user-agent string following a successful login, containing the users OS, browser (general not versions) and language - forming a sort of secondary password. If the useragent hash is significantly different on next login, the user is asked to answer the security question. Then, if this is answered satisfactory, the new UA string is hashed and added to their "safe machines" list, so that they wont be asked again from this machine. This is similar to a mechanism employed by the Steam gaming system.</p>
<p>This has been in use for over a year very successfully with about 700 users and it had the additional benefit of preventing "login sharing" - a problem where multiple users were using the same credentials for convenience!</p>
</div></text><author><a href="/users/1534322/dave">Dave</a></author><comments><comment><text><span class="comment-copy">The user-agent is attacker controlled.  If an attacker is on an open wifi network,  they can sniff traffic,  obtain the full session id,  as well as the current user-agent.  Have you heard of the OWASP top 10?</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Nothing but HTTPS will prevent MITM attacks, the question has asked what measures can be taken to improve security, not stop a dedicated attack. Pattern matching a users behaviour represents an extra layer of security. A casual hacker would need to guess the UA string of the legitimate user in order to spoof it, or be faced with a security question.</span></text><author><a class="comment-user" href="/users/1534322/dave" title="123 reputation">Dave</a></author></comment><comment><text><span class="comment-copy">What this post is describing is cargo-cult security, and the only person it is fooling is the programmer.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook can you add any explanation as to why you think this is cargo-cult? Steam place a lot of reliance on this mechanism and as I have explained, it has solved a very real problem of login sharing within my company.</span></text><author><a class="comment-user" href="/users/1534322/dave" title="123 reputation">Dave</a></author></comment><comment><text><span class="comment-copy">The user agent is an attacker controlled string,  it is not a secret value,  as adversary with access to the Session ID will also have the user-agent.  This security check <b>serves no purpose</b>,  except to have the appearance of "security".  Which makes this cargo-cult programming.  None of these suggestions mitigate the impact of plaintext transmission.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">But you are only considering MITM attacks, where an attacker has access and the necessary knowledge to compromise the users session. My solution is mitigating password loss to a third party other than the legitimate user. This is a far more common form of security breach, and your comment is about another security issue than the one Im trying to prevent.</span></text><author><a class="comment-user" href="/users/1534322/dave" title="123 reputation">Dave</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Try this : On each request of the login page, send across a nonce and a timestamp.
While posting to server, send the following four details :</p>
<p>The username, the nonce and the timestamp in plaintext.
Then concatenate the above with a separator (Eg: newline) and encrypt using the user's password as encryption in chained-block-cipher mode.</p>
<p>On the server end use the username to lookup the password and verify the encrypted string.</p>
<p>Since the password is never sent across in clear, it is secure and the timestamp can be used to avoid a re-submit of the same data.</p>
<p>To avoid hijacking of session by obtaining the session key through a man-in-the-middle attack, the password or a hash of the password can be stored in-memory by the application on the client end and be used for generating unique session keys for validation by server.</p>
<p>Taking a look at <a href="http://tools.ietf.org/html/rfc5849" rel="nofollow">OAuth 1.0</a> is also not a bad idea.</p>
</div></text><author><a href="/users/2862341/ravindra-hv">Ravindra HV</a></author><comments><comment><text><span class="comment-copy">But how do you communicate the password initially...</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy">My answer was to make the login secure. So the user is already expected to know the password.</span></text><author><a class="comment-user" href="/users/2862341/ravindra-hv" title="1,164 reputation">Ravindra HV</a></author></comment><comment><text><span class="comment-copy">I think using a timestamp hashed with the password is an interesting idea provided the server and browser are in time sync. Not sure why this was voted down.</span></text><author><a class="comment-user" href="/users/1534322/dave" title="123 reputation">Dave</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you can't use HTTPS or you don't want to use HTTPS, consider using <a href="http://www.jcryption.org/" rel="nofollow">jCryption</a>. jCryption offers encryption for the data being sent through HTTP requests (POST, GET etc.). </p>
<p>You can test the technique here: <a href="http://www.jcryption.org/#examples" rel="nofollow">http://www.jcryption.org/#examples</a></p>
<p>If you're using Firebug, you'll see that all the data is encrypted.</p>
<p>It has jQuery library to encrypt the data on the front-end and a PHP library to decrypt the data in the back-end.</p>
</div></text><author><a href="/users/1337185/wissam-el-kik">Wissam El-Kik</a></author><comments><comment><text><span class="comment-copy">JavaScript cannot be used to create a secure transport layer: <a href="http://matasano.com/articles/javascript-cryptography/" rel="nofollow noreferrer">matasano.com/articles/javascript-cryptography</a></span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">I totally agree that it's not 100% secure, but jCryption relies on OpenSSL and one several handshake methods. All the data sent through a HTTP Request is encrypted: the keys and the values are completely modified/merged etc. It uses RSA and AES for the encryption and you need to generate a Public and a Private Key to use jCryption.  <a href="http://www.jcryption.org/#howitworks" rel="nofollow noreferrer">Click here to check how it works</a></span></text><author><a class="comment-user" href="/users/1337185/wissam-el-kik" title="1,955 reputation">Wissam El-Kik</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Use hashing mechanisms to store password and always compare the hashed password then nobody knows the real password even you.
It is very simple but it is effective.However, nothing is completely secure and there are some ways to broke the scurity layers.</p>
</div></text><author><a href="/users/4125061/abi">Abi</a></author><comments><comment><text><span class="comment-copy">While your answer is not wrong, it doesn't answer the question. The problem here is about how to transfer the password securely to the server.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli : Not necessarily. A one-use only password could be sent by email or sms. This could actually be used for each request.</span></text><author><a class="comment-user" href="/users/442396/sentinel" title="1,265 reputation">Sentinel</a></author></comment><comment><text><span class="comment-copy">@Sentinel - Password hashing is done server side, so an attacker cannot get the real passwords if he gets the stored hashes. If you send a one time token per sms to the user, there is no advantage in calculating a hash client side. A ManInTheMiddle could simply use the hash, and even when he knows the original token he could not reuse it.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It is <strong>hard</strong> to secure the communication without a <code>trusted third party</code>, however, there are some security tricks for you:</p>
<h2>DO NOT expose users' sensitive information to public network.</h2>
<p>Every sensitive information should be well hashed or public-key encrypted. <strong>Pay attention:</strong> If you choose to encrypt users' sensitive information by a public-key, please make sure that the user can verify the public-key. For example, you could send some kind of public-key fingerprint to user via SMS or even an auto-call.</p>
<h2>Generate a SHARED SECRET after log on successfully</h2>
<p>After a secure log on transaction, a shared secret should be generate. The generation procedure could refer to <code>SSL Handshake</code>. <strong>Pay attention:</strong> Once the shared secret is generated, it must on be transported anymore. The only function of it is to encrypt/decrypt the data between <code>Server</code> and <code>Broswer</code></p>
<h2>There SHOULD be a two-step-verification to avoid repeat attack</h2>
<p>May these tricks will help you</p>
</div></text><author><a href="/users/3024431/user3024431">user3024431</a></author><comments/></answer></answers></post>