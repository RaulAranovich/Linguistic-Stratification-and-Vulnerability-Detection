<?xml version="1.0" encoding="utf-8"?>
<post><title>java - How to limit setAccessible to only "legitimate" uses? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>The more I learned about the power of <code>java.lang.reflect.AccessibleObject.setAccessible</code>, the more astonished I am at what it can do. This is adapted from my answer to the question (<a href="http://stackoverflow.com/questions/2474017/using-reflection-to-change-static-final-file-separatorchar-for-unit-testing/2474242#2474242">Using reflection to change static final File.separatorChar for unit testing</a>).</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">lang</span><span class="pun">.</span><span class="pln">reflect</span><span class="pun">.*;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">EverythingIsTrue</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setFinalStatic</span><span class="pun">(</span><span class="typ">Field</span><span class="pln"> field</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> newValue</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      field</span><span class="pun">.</span><span class="pln">setAccessible</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span><span class="pln">

      </span><span class="typ">Field</span><span class="pln"> modifiersField </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Field</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">.</span><span class="pln">getDeclaredField</span><span class="pun">(</span><span class="str">"modifiers"</span><span class="pun">);</span><span class="pln">
      modifiersField</span><span class="pun">.</span><span class="pln">setAccessible</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
      modifiersField</span><span class="pun">.</span><span class="pln">setInt</span><span class="pun">(</span><span class="pln">field</span><span class="pun">,</span><span class="pln"> field</span><span class="pun">.</span><span class="pln">getModifiers</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">~</span><span class="typ">Modifier</span><span class="pun">.</span><span class="pln">FINAL</span><span class="pun">);</span><span class="pln">

      field</span><span class="pun">.</span><span class="pln">set</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> newValue</span><span class="pun">);</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
   </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{</span><span class="pln">      
      setFinalStatic</span><span class="pun">(</span><span class="typ">Boolean</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">.</span><span class="pln">getField</span><span class="pun">(</span><span class="str">"FALSE"</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">

      </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="str">"Everything is %s"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln"> </span><span class="com">// "Everything is true"</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>You can do truly outrageous stuff:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">UltimateAnswerToEverything</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">[]</span><span class="pln"> ultimateAnswer</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="typ">Integer</span><span class="pun">[]</span><span class="pln"> ret </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">[</span><span class="lit">256</span><span class="pun">];</span><span class="pln">
      java</span><span class="pun">.</span><span class="pln">util</span><span class="pun">.</span><span class="typ">Arrays</span><span class="pun">.</span><span class="pln">fill</span><span class="pun">(</span><span class="pln">ret</span><span class="pun">,</span><span class="pln"> </span><span class="lit">42</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">   
   </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="typ">EverythingIsTrue</span><span class="pun">.</span><span class="pln">setFinalStatic</span><span class="pun">(</span><span class="pln">
         </span><span class="typ">Class</span><span class="pun">.</span><span class="pln">forName</span><span class="pun">(</span><span class="str">"java.lang.Integer$IntegerCache"</span><span class="pun">)</span><span class="pln">
            </span><span class="pun">.</span><span class="pln">getDeclaredField</span><span class="pun">(</span><span class="str">"cache"</span><span class="pun">),</span><span class="pln">
         ultimateAnswer</span><span class="pun">()</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
      </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="str">"6 * 9 = %d"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">9</span><span class="pun">);</span><span class="pln"> </span><span class="com">// "6 * 9 = 42"</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Presumably the API designers realize how abusable <code>setAccessible</code> can be, but must have conceded that it has legitimate uses to provide it. So my questions are:</p>
<ul>
<li>What are the truly legitimate uses for <code>setAccessible</code>?

<ul>
<li>Could Java has been designed as to NOT have this need in the first place?</li>
<li>What would the negative consequences (if any) of such design be?</li>
</ul></li>
<li>Can you restrict <code>setAccessible</code> to legitimate uses only?

<ul>
<li>Is it only through <code>SecurityManager</code>?

<ul>
<li>How does it work? Whitelist/blacklist, granularity, etc?</li>
<li>Is it common to have to configure it in your applications?</li>
</ul></li>
<li>Can I write my classes to be <code>setAccessible</code>-proof regardless of <code>SecurityManager</code> configuration?

<ul>
<li>Or am I at the mercy of whoever manages the configuration?</li>
</ul></li>
</ul></li>
</ul>
<hr/>
<p>I guess one more important question is: DO I NEED TO WORRY ABOUT THIS???</p>
<p>None of my classes have any semblance of enforceable privacy what-so-ever. The singleton pattern (putting doubts about its merits aside) is now impossible to enforce. As my snippets above show, even some basic assumptions of how Java fundamental works is not even close to being guaranteed.</p>
<p>ARE THESE PROBLEMS NOT REAL???</p>
<hr/>
<p>Okay, I just confirmed: thanks to <code>setAccessible</code>, Java strings are <em>NOT</em> immutable.</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">lang</span><span class="pun">.</span><span class="pln">reflect</span><span class="pun">.*;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MutableStrings</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> mutate</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> s</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="typ">Field</span><span class="pln"> value </span><span class="pun">=</span><span class="pln"> </span><span class="typ">String</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">.</span><span class="pln">getDeclaredField</span><span class="pun">(</span><span class="str">"value"</span><span class="pun">);</span><span class="pln">
      value</span><span class="pun">.</span><span class="pln">setAccessible</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
      value</span><span class="pun">.</span><span class="pln">set</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> s</span><span class="pun">.</span><span class="pln">toUpperCase</span><span class="pun">().</span><span class="pln">toCharArray</span><span class="pun">());</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">   
   </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Hello world!"</span><span class="pun">;</span><span class="pln">
      </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln"> </span><span class="com">// "Hello world!"</span><span class="pln">
      mutate</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln">
      </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln"> </span><span class="com">// "HELLO WORLD!"</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Am I the only one who thinks this is a HUGE concern?</p>
</div></text><author><a href="/users/1113392/a4l">A4L</a></author><comments><comment><text><span class="comment-copy">You should see what they can do in C++! (Oh, and probably C#.)</span></text><author><a class="comment-user" href="/users/4725/tom-hawtin-tackline" title="113,096 reputation">Tom Hawtin - tackline</a></author></comment><comment><text><span class="comment-copy">+1 for the awesome question... :)</span></text><author><a class="comment-user" href="/users/184046/legend" title="48,136 reputation">Legend</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p><strong>DO I NEED TO WORRY ABOUT THIS???</strong></p>
<p>That depends entirely on what types of programs you're writing and for what kind of an architecture.</p>
<p>If you're distributing a software component called foo.jar to the people of the world, you're completely at their mercy anyway. They could modify the class definitions inside your .jar (through reverse engineering or direct bytecode manipulation). They could run your code in their own JVM, etc. In this case worrying will do you no good.</p>
<p>If you're writing a web-application that only interfaces with people and systems via HTTP and you control the application server, it's also not a concern. Sure the fellow coders at your company may create code that breaks your singleton pattern, but only if they really want to.</p>
<p>If your future job is writing code at Sun Microsystems/Oracle and you're tasked with writing code for the Java core or other trusted components, it's something you should be aware of. Worrying, however, will just make you lose your hair. In any case they'll probably make you read the <a href="http://java.sun.com/security/seccodeguide.html" rel="noreferrer">Secure Coding Guidelines</a> along with internal documentation.</p>
<p>If you're going to be writing Java applets, the security framework is something you should be aware of. You'll find that unsigned applets trying to call setAccessible will just result in a SecurityException.</p>
<p>setAccessible is not the only thing that goes around conventional integrity checks. There's a non-API, core Java class called sun.misc.Unsafe that can do pretty much anything at all it wants to, including accessing memory directly. Native code (JNI) can go around this kind of control as well.</p>
<p>In a sandboxed environment (for example Java Applets, JavaFX), each class has a set of permissions and access to Unsafe, setAccessible and defining native implementations are controlled by the SecurityManager.</p>
<p>"Java access modifiers are not intended to be a security mechanism."</p>
<p>That very much depends on where the Java code is being run. The core Java classes do use access modifiers as a security mechanism to enforce the sandbox.</p>
<p><strong>What are the truly legitimate uses for setAccessible?</strong></p>
<p>The Java core classes use it as an easy way to access stuff that has to remain private for security reasons. As an example, the Java Serialization framework uses it to invoke private object constructors when deserializing objects. Someone mentioned System.setErr, and it would be a good example, but curiously the System class methods setOut/setErr/setIn all use native code for setting the value of the final field.</p>
<p>Another obvious legitimate use are the frameworks (persistence, web frameworks, injection) that need to peek into the insides of objects.</p>
<p>Debuggers, in my opinion, don't fall into this category, as they normally don't run in the same JVM process, but instead the interface with the JVM using other means (JPDA).</p>
<p><strong>Could Java has been designed as to NOT have this need in the first place?</strong></p>
<p>That's a pretty deep question to answer well. I imagine yes, but you'd need to add some other mechanism(s) that might not be all that preferrable.</p>
<p><strong>Can you restrict setAccessible to legitimate uses only?</strong></p>
<p>The most straight-forward OOTB restriction you can apply is to have a SecurityManager and allow setAccessible only to code coming from certain sources. This is what Java already does - the standard Java classes that come from your JAVA_HOME are allowed to do setAccessible, while unsigned applet classes from foo.com aren't allowed to do setAccessible. As was said before, this permission is binary, in the sense that one either has it or not. There is no obvious way to allow setAccessible to modify certain fields/methods while disallowing others. Using the SecurityManager you could, however, disallow classes from referencing certain packages completely, with or without reflection.</p>
<p><strong>Can I write my classes to be setAccessible-proof regardless of SecurityManager configuration? ... Or am I at the mercy of whoever manages the configuration?</strong></p>
<p>You can't and you most certainly are.</p>
</div></text><author><a href="/users/298689/sami-koivu">Sami Koivu</a></author><comments><comment><text><span class="comment-copy">+1 and welcome to Stack Overflow :)</span></text><author><a class="comment-user" href="/users/217862/ewernli" title="29,921 reputation">ewernli</a></author></comment><comment><text><span class="comment-copy">Thank you, kind sir (for the incoming link to my blog, too) :)</span></text><author><a class="comment-user" href="/users/298689/sami-koivu" title="3,136 reputation">Sami Koivu</a></author></comment><comment><text><span class="comment-copy">+1 Greaaat response, thanks!</span></text><author><a class="comment-user" href="/users/148332/reef" title="1,143 reputation">reef</a></author></comment><comment><text><span class="comment-copy">Great answer, thanks!</span></text><author><a class="comment-user" href="/users/1137529/alexsmail" title="3,041 reputation">alexsmail</a></author></comment><comment><text><span class="comment-copy">"If you're distributing a software component called foo.jar to the people of the world, you're completely at their mercy anyway. They could modify the class definitions inside your .jar (through reverse engineering or direct bytecode manipulation). They could run your code in their own JVM, etc. In this case worrying will do you no good." Is this still the case?  Any advises on making software tamper harder (Hopefully significantly)?  It is hard to just throw java desktop applications out of the window because of this.</span></text><author><a class="comment-user" href="/users/5132301/naaz" title="125 reputation">naaz</a></author></comment><comment><text><span class="comment-copy">@naaz I would have to say nothing has changed. It's just that the architecture is working against you. Any piece of software running on my machine that I have full control over, I can alter. The strongest deterrent might be a legal one, but I don't imagine that will work for all scenarios. I think Java binaries are among the easiest to reverse, but folks with experience will tamper anything. Obfuscation helps by making it difficult to make big changes, but anything sort of boolean (like a copyright check) still is trivial to bypass. You could try putting key parts on a server instead.</span></text><author><a class="comment-user" href="/users/298689/sami-koivu" title="3,136 reputation">Sami Koivu</a></author></comment><comment><text><span class="comment-copy">How about denuvo?</span></text><author><a class="comment-user" href="/users/5132301/naaz" title="125 reputation">naaz</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<ul>
<li>What are the truly legitimate uses for <code>setAccessible</code>?</li>
</ul>
</blockquote>
<p>Unit testing, internals of the JVM (e.g. implementing <code>System.setError(...)</code>) and so on.</p>
<blockquote>
<ul>
<li>Could Java has been designed as to NOT have this need in the first place?</li>
<li>What would the negative consequences (if any) of such design be?</li>
</ul>
</blockquote>
<p>Lots of things would be unimplementable.  For example, various Java persistence, serialization and dependency injections are reliant on reflection.  And pretty much anything that relies on the JavaBeans conventions at runtime.</p>
<blockquote>
<ul>
<li>Can you restrict <code>setAccessible</code> to legitimate uses only?</li>
<li>Is it only through <code>SecurityManager</code>? </li>
</ul>
</blockquote>
<p>Yes.</p>
<blockquote>
<ul>
<li>How does it work? Whitelist/blacklist, granularity, etc?</li>
</ul>
</blockquote>
<p>It depends on the permission, but I believe that the permission to use <code>setAccessible</code> is binary.  If you want granularity, you need to either use a different class loader with a different security manager for the classes that you want to restrict.  I guess you could implement a custom security manager that implements finer grained logic.</p>
<blockquote>
<ul>
<li>Is it common to have to configure it in your applications?</li>
</ul>
</blockquote>
<p>No.</p>
<blockquote>
<ul>
<li>Can I write my classes to be <code>setAccessible</code>-proof regardless of <code>SecurityManager</code> configuration?
  
  <ul>
<li>Or am I at the mercy of whoever manages the configuration?</li>
</ul></li>
</ul>
</blockquote>
<p>No you cannot, and yes you are.</p>
<p>The other alternative is to "enforce" this via source-code analysis tools; e.g. custom <code>pmd</code> or <code>findbugs</code> rules.  Or selective code review of code identified by (say) <code>grep setAccessible ...</code>.</p>
<p><strong>In response to the followup</strong> </p>
<blockquote>
<p>None of my classes have any semblance of enforceable privacy what-so-ever. The singleton pattern (putting doubts about its merits aside) is now impossible to enforce.</p>
</blockquote>
<p>If that worries you, then I suppose you need to worry.  But really you should not be trying can <em>force</em> other programmers to respect your design decisions.  If they are stupid enough to gratuitously create multiple instances of your singletons (for example), they can live with the consequences.  </p>
<p>And if you mean "privacy" to encompass the meaning of protecting sensitive information from disclosure, you are also barking up the wrong tree.  The way to protect sensitive data is not to allow untrusted code into the security sandbox that deals with sensitive data.  Java access modifiers are not intended to be a security mechanism.</p>
<blockquote>
<p>&lt;String example&gt; - Am I the only one who thinks this is a HUGE concern?</p>
</blockquote>
<p>Probably not the <strong>only</strong> one :-).  But IMO, this is not a concern.  It is accepted fact that untrusted code should be executed in a sandbox.  If you have trusted code / a trusted programmer doing things like this, then your problems are worse that having unexpectedly mutable Strings.  (Think logic bombs ...)</p>
</div></text><author><a href="/users/139985/stephen-c">Stephen C</a></author><comments><comment><text><span class="comment-copy">Also useful for things such as persistence implementations. Reflections isn't really useful for debuggers (although it was originally intended to be). You can't usefully change (subclass) the <code>SecurityManager</code> for this, because all you get is the permission check - all you can really do is look at the acc and perhaps walk the stack check the current thread). <code>grep java.lang.reflect.</code></span></text><author><a class="comment-user" href="/users/4725/tom-hawtin-tackline" title="113,096 reputation">Tom Hawtin - tackline</a></author></comment><comment><text><span class="comment-copy">@Stephen C: +1 already, but I'd also appreciate your input on one more question I just added. Thanks in advance.</span></text><author><a class="comment-user owner" href="/users/276101/polygenelubricants" title="232,064 reputation">polygenelubricants</a></author></comment><comment><text><span class="comment-copy">Note that grep is a terrible idea. There are so many ways to dynamically execute code in Java that you'll almost certainly miss one. Blacklisting code in general is a recipe for failure.</span></text><author><a class="comment-user" href="/users/1420279/antimony" title="21,764 reputation">Antimony</a></author></comment><comment><text><span class="comment-copy">"Java access modifiers are not intended to be a security mechanism." -- actually, yes they are.  Java is designed to allow trusted and untrusted code to coexist in the same virtual machine -- this was part of its core requirements from the very beginning.  But only when the system is running with a locked-down SecurityManager.  The ability to sandbox code depends entirely on enforcement of access specifiers.</span></text><author><a class="comment-user" href="/users/441899/jules" title="7,800 reputation">Jules</a></author></comment><comment><text><span class="comment-copy">@Jules - Most Java experts would disagree with that; e.g. <a href="http://stackoverflow.com/questions/9201603/are-private-members-really-more-secure-in-java" title="are private members really more secure in java">stackoverflow.com/questions/9201603/…</a></span></text><author><a class="comment-user" href="/users/139985/stephen-c" title="422,492 reputation">Stephen C</a></author></comment><comment><text><span class="comment-copy">The question there is subtly different.  In a typical application, which is the scenario the OP was apparently talking about, then access specifiers are not a security issue.  This doesn't change the fact that Java was designed, from the ground up, to support sandboxing and that access specifiers are a critical part of that sandboxing mechanism, which therefore means that the specific statement you made, i.e. that they "are not intended to be a security mechanism", is untrue.  In most cases they aren't used as one, but the system is designed to allow them to be one when that is required.</span></text><author><a class="comment-user" href="/users/441899/jules" title="7,800 reputation">Jules</a></author></comment><comment><text><span class="comment-copy">Check your history.  In fact, Java / Oak was designed before that.  The security sandboxing was an afterthought in Java 1.0 when Sun management saw an opportunity to get a foothold in the newly emerging "world wide web" market.  If you read the old Oak specification, security is not mentioned.  Indeed only the current JLS makes only passing reference to "security".  It is not a core property of the Java &gt;&gt;language&lt;&lt;</span></text><author><a class="comment-user" href="/users/139985/stephen-c" title="422,492 reputation">Stephen C</a></author></comment><comment><text><span class="comment-copy">However the JLS does state that &gt;&gt;type security&lt;&lt; is a design goal, and that that (boadly) means that you should not be able to subvert JVM runtime typing from Java code.  But type security and more general security are different things.  Sandboxing is infrastructure that "leverages" properties of the Java language, but it is a too much of a stretch to say that that is why Oak / Java visibility rules were included in the first place.</span></text><author><a class="comment-user" href="/users/139985/stephen-c" title="422,492 reputation">Stephen C</a></author></comment><comment><text><span class="comment-copy">Also, read this: <a href="http://gcc.uni-paderborn.de/www/WI/WI2/wi2_lit.nsf/64ae864837b22662c12573e70058bbb4/abf8d70f07c12eb3c1256de900638899/$FILE/Java%20Technology%20-%20An%20early%20history.pdf" rel="nofollow noreferrer">gcc.uni-paderborn.de/www/WI/WI2/wi2_lit.nsf/…</a></span></text><author><a class="comment-user" href="/users/139985/stephen-c" title="422,492 reputation">Stephen C</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Reflection is indeed orthogonal to safety/security under this perspective. </p>
<p><strong>How can we limit reflection?</strong></p>
<p>Java has security manager and <code>ClassLoader</code> as foundations to its security model. In your case, I guess you need to look at <a href="http://java.sun.com/j2se/1.4.2/docs/guide/security/permissions.html#ReflectPermission" rel="noreferrer"><code>java.lang.reflect.ReflectPermission</code></a>. </p>
<p>But this does not completely solve the problem of reflection. The reflective capabilities that are available should be subject to a fine grained authorization scheme which is not the case now. E.g. to allow certain framework to use reflection (e.g. Hibernate), but no the rest of your code. Or to allow a program to reflect only in a read-only way, for debugging purpose. </p>
<p>One approach that may become mainstream in the future is the usage of so-called <em>mirrors</em> to separate reflective capabilities from classes. See <a href="http://bracha.org/mirrors.pdf" rel="noreferrer">Mirrors: Design Principles for Meta-level Facilities</a>. There are however various <a href="http://www.inria.fr/travailler/mrted/en/eng/details.html?nPostingId=4074&amp;nPostingTargetId=8668" rel="noreferrer">other research</a> that tackles this issue. But I agree that the problem is more severe for dynamic language than static languages.</p>
<p><strong>Should we be worried of the superpower that reflection gives us?</strong> Yes and no. </p>
<p><em>Yes</em> in the sense that the Java platform is supposed to be secured with <code>Classloader</code> and security manager. The ability to mess with reflection can be see as a breach. </p>
<p><em>No</em> in the sense that most system are anyway not entirely secure. A lot of classes can frequently be subclassed and you could potentially already abuse the system with just that. Of course classes can be made <code>final</code>, or <a href="http://java.sun.com/docs/books/tutorial/deployment/jar/sealman.html" rel="noreferrer">sealed</a> so that they can not be subclassed in other jar. But only few classes are secured correctly (e.g. String) according to this. </p>
<p>See this <a href="http://stackoverflow.com/questions/2478846/why-is-string-a-sealed-class-in-c/2478877#2478877">answer about final class</a> for a nice explanation. See also the blog from <a href="http://slightlyrandombrokenthoughts.blogspot.com/" rel="noreferrer">Sami Koivu</a> for more java hacking around security. </p>
<p>The security model of Java can be seen as insufficient to some regard. Some languages such as <a href="http://bracha.org/newspeak.pdf" rel="noreferrer">NewSpeak</a> take even more radical approach to modularity, where you have access only to what is explicitly given to you by dependency inversion (by default nothing).</p>
<p>It's also important to note that security is anyway <em>relative</em>. At the language level, you can for instance not prevent a module form consuming 100% of CPU or consuming all memory up to a <code>OutOfMemoryException</code>. Such concerns need to be addressed by other means. We will maybe see in the future Java extended with resource utilization quotas, but it's not for tomorrow :)</p>
<p>I could expand more on the subject, but I think I've made my point.</p>
</div></text><author><a href="/users/217862/ewernli">ewernli</a></author><comments/></answer></answers></post>