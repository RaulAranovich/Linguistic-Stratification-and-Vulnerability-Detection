<?xml version="1.0" encoding="utf-8"?>
<post><title>c# - How to Implement Password Resets? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm working on an application in ASP.NET, and was wondering specifically how I could implement a <code>Password Reset</code> function if I wanted to roll my own. </p>
<p>Specifically, I have the following questions:</p>
<ul>
<li>What is a good way of generating a Unique ID that is hard to crack?  </li>
<li>Should there be a timer attached to it? If so, how long should it be?</li>
<li>Should I record the IP address? Does it even matter?</li>
<li>What information should I ask for under the "Password Reset" screen ? Just Email address? Or maybe email address plus some piece of information that they 'know'? (Favorite team, puppy's name, etc)</li>
</ul>
<p>Are there any other considerations I need to be aware of?</p>
<blockquote>
<p><strong>NB</strong>: <a href="http://stackoverflow.com/questions/522967/forgot-password-what-is-the-best-method-of-implementing-a-forgot-password-functi">Other questions</a> have <a href="http://stackoverflow.com/questions/270485/password-management-best-practices-soup-to-nuts-not-just-storage-or-generation">glossed over</a> technical implementation entirely. Indeed the accepted answer glosses over the gory details. I hope that this question and subsequent answers will go into the gory details, and I hope by phrasing this question much more narrowly that the answers are less 'fluff' and more 'gore'.</p>
</blockquote>
<p><strong>Edit</strong>: Answers that also go into how such a table would be modeled and handled in SQL Server or any ASP.NET MVC links to an answer would be appreciated.</p>
</div></text><author><a href="/users/16587">George Stocker</a></author><comments><comment><text><span class="comment-copy">ASP.NET MVC uses the default ASP.NET authentication provider, so any code samples you find around that sshould till be relevant for your purposes.</span></text><author><a class="comment-user" href="/users/7301/paulwhit" title="4,360 reputation">paulwhit</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Lots of good answers here, I wont bother repeating it all... </p>
<p>Except for one issue, which is repeated by almost every answer here, even though its wrong:</p>
<blockquote>
<p>Guids are (realistically) unique and
  statistically impossible to guess</p>
</blockquote>
<p>This is not true, GUIDs are very weak identifiers, and should <strong>NOT</strong> be used to allow access to a user's account.<br/>
If you examine the structure, you get a total of 128 bits at most... which is not considered a lot nowadays.<br/>
Out of which the first half is typical invariant (for the generating system), and half of whats left is time-dependant (or somethign else similar).<br/>
All in all, its a very weak and easily bruteforced mechanism.   </p>
<p>So don't use that!</p>
<p>Instead, simply use a cryptographically strong random number generator (System.Security.Cryptography.RNGCryptoServiceProvider), and get at least 256 bits of raw entropy.</p>
<p>All the rest, as the numerous other answers provided.</p>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">Absolutely agree, as far as I know, GUIDs were never designed to be cryptographically strong and impossible to guess.</span></text><author><a class="comment-user" href="/users/3997/jan-soltis" title="2,520 reputation">Jan Soltis</a></author></comment><comment><text><span class="comment-copy">well said, AFAIK MSDN clearly states that GUID should not be used for security.</span></text><author><a class="comment-user" href="/users/40322/dr-evil" title="15,327 reputation">dr. evil</a></author></comment><comment><text><span class="comment-copy">+1 mixing in some form of hashing/crypto is recommended.</span></text><author><a class="comment-user" href="/users/2696/ryan-duffield" title="11,469 reputation">Ryan Duffield</a></author></comment><comment><text><span class="comment-copy">Version 4 UUIDs have been used in Windows since 2000: <a href="http://stackoverflow.com/questions/2757910/how-are-net-4-guids-generated">How are .NET 4 GUIDs generated? - Stack Overflow</a>. They have 122 random bits in them, which I think conforms with NIST recommendations. There was a very bad    vulnerability to a local attack, which according to <a href="http://en.wikipedia.org/wiki/CryptGenRandom#Hebrew_University_Cryptanalysis" rel="nofollow noreferrer">CryptGenRandom - Wikipedia</a> was fixed in Vista and XP by 2008.  So where do you see problems with current use of GUIDs?</span></text><author><a class="comment-user" href="/users/507544/nealmcb" title="3,713 reputation">nealmcb</a></author></comment><comment><text><span class="comment-copy">Hi @nealmcb, that's 122 bits of <i>uniqueness</i>, and <b>not</b> randomness. Linked from that question you linked, is a very good breakdown of the structure, which has basically <i>. <b>14 bits</b> .</i> of randomness. Not nearly enough, not by a long shot... As one of the commenters said on Raymond's blog there: "GUIDs are not defined to be random; they are defined to BE UNIQUE in space &amp; time."</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">I'm not seeing what you're referring to.  But the standard is pretty clear: "[except for 6 bits] Set all the other bits to randomly (or pseudo-randomly) chosen values."  <a href="http://tools.ietf.org/html/rfc4122#page-14" rel="nofollow noreferrer">tools.ietf.org/html/rfc4122#page-14</a>  And from what I've seen, on a patched XP and later at least the values come from CryptGenRandom which seems like the same underlying source you refer to.  So how much does 256 vs 122 bits gain you?</span></text><author><a class="comment-user" href="/users/507544/nealmcb" title="3,713 reputation">nealmcb</a></author></comment><comment><text><span class="comment-copy">I was refering to this: <a href="http://blogs.msdn.com/b/oldnewthing/archive/2008/06/27/8659071.aspx" rel="nofollow noreferrer">blogs.msdn.com/b/oldnewthing/archive/2008/06/27/8659071.aspx</a>‌​. And while I consider CryptGenRandom to be (relatively) secure, it affects only a small part of GUID, as far as I know.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">See also MS on the subject: "4: Random version.   Use random numbers for all sections" at <a href="http://msdn.microsoft.com/en-us/library/aa446557.aspx" rel="nofollow noreferrer">Generating GUIDs on the Pocket PC</a></span></text><author><a class="comment-user" href="/users/507544/nealmcb" title="3,713 reputation">nealmcb</a></author></comment><comment><text><span class="comment-copy">That "Old New Thing" blog is describing deprecated version 1 UUIDs, and cites an Internet Draft (something you're never supposed to do) which expired in 1998, 10 years before the blog post.  I'd be skeptical of them in the future.  We fought those battles long ago, and seem to have won most of them.  I still agree that using a clean API call to a crypto-random source is much better, but don't be quite so hard on GUID/UUIDs at version 4.</span></text><author><a class="comment-user" href="/users/507544/nealmcb" title="3,713 reputation">nealmcb</a></author></comment><comment><text><span class="comment-copy">@nealmcb, hmm, now I have conflicting information... Will look into this some more.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@nealmcb, this is odd - that pocketpc article (which is also WELL out of date, and oddly incongruous with typical MSDN recommendations) has its own internal contradictions - it first cites the fixed structure, including leaving just 6 bytes for "spatial uniqueness", and all the rest predefined - and then it goes on to randomize the whole thing except for version. So... As you say, v4 UUID is not as bad as all that, but I'm still not sure that <code>Guid.NewGUID()</code> uses v4...</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">For what its worth,  this does not answer the question, "how how to reset a password". You just vomited great points about GUIDs.</span></text><author><a class="comment-user" href="/users/264892/rex-whitten" title="430 reputation">Rex Whitten</a></author></comment><comment><text><span class="comment-copy">@starfighterxyz the word <code>vomited</code> made me feel bad. He posted this answer to point out a potential security hole of using GUID, and did mention that all other answers have good flow, but just to change the random number generator to something designed for security. I don't see anything improper here.</span></text><author><a class="comment-user" href="/users/2629095/nevets" title="2,620 reputation">nevets</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>EDIT 2012/05/22: As a follow-up to this popular answer, I no longer use GUIDs myself in this procedure.  Like the other popular answer, I now use my own hashing algorithm to generate the key to send in the URL.  This has the advantage of being shorter as well.  Look into System.Security.Cryptography to generate them, which I usually use a SALT as well.</p>
<h2>First, do not immediately reset the user's password.</h2>
<p>First, do not immediately reset the user's password when they request it.  This is a security breach as someone could guess email addresses (i.e. your email address at the company) and reset passwords at whim.   Best practices these days usually include a "confirmation" link sent to the user's email address, confirming they want to reset it.  This link is where you want to send the unique key link.  I send mine with a link like: <code>domain.com/User/PasswordReset/xjdk2ms92</code></p>
<p>Yes, set a timeout on the link and store the key and timeout on your backend (and salt if you are using one).  Timeouts of 3 days is the norm, and make sure to notify the user of 3 days at the web level when they request to reset.</p>
<h2>Use a unique hash key</h2>
<p>My previous answer said to use a GUID.  I'm now editing this to advise everyone to use a randomly generated hash, e.g. using the <code>RNGCryptoServiceProvider</code>.  And, make sure to eliminate any "real words" from the hash.  I recall a special 6am phone call of where a woman received a certain "c" word in her "suppose to be random" hashed key that a developer did.  Doh!</p>
<h2>Entire procedure</h2>
<ul>
<li>User clicks "reset" password.</li>
<li>User is asked for an email.  </li>
<li>User enters email and clicks send.  Do not confirm or deny the email as this is bad practice as well.  Simply say, "We have sent a password reset request if the email is verified." or something cryptic alike.</li>
<li>You create a hash from the <code>RNGCryptoServiceProvider</code>, store it as a separate entity in an <code>ut_UserPasswordRequests</code> table and link back to the user.  So this so you can track old requests and inform the user that older links has expired.</li>
<li>Send the link to the email.</li>
</ul>
<p>User gets the link, like <code>http://domain.com/User/PasswordReset/xjdk2ms92</code> , and clicks it.  </p>
<p>If the link is verified, you ask for a new password.  Simple, and the user gets to set their own password. Or, set your own cryptic password here and inform them of their new password here (and email it to them).</p>
</div></text><author><a href="/users/56693/eduncan911">eduncan911</a></author><comments><comment><text><span class="comment-copy">I Was Wondering, If the actual user password is hashed, why generate a new HASH Key? Wouldn't be correct to send an email to user with a link to reset password passing the Hashed password? The hashed password can't be reverted, when the user clicks on the link, the server will receive the hashed password, compare with the actual stored, and then allow the user to change password.</span></text><author><a class="comment-user" href="/users/1723944/daniel" title="878 reputation">Daniel</a></author></comment><comment><text><span class="comment-copy">And Another prettly good thing about it, is that you don't need to set Timeout, once the user has changed the password, the old link will automatically not be valid any more, because the hashed password stored in database was changed.</span></text><author><a class="comment-user" href="/users/1723944/daniel" title="878 reputation">Daniel</a></author></comment><comment><text><span class="comment-copy">@Daniel that's a really bad idea. I think you need to Google the term "brute force attacks." Also, the reason you DO want it to expire is in case someone's email is compromised a year down the road (and they never reset it), the hacker gains rights to change password.</span></text><author><a class="comment-user" href="/users/56693/eduncan911" title="9,457 reputation">eduncan911</a></author></comment><comment><text><span class="comment-copy">@educan911. I Know brute force attacks, but also, to have access to the Hashed key, the Bad Intented person, has to have access to the email, and if he has access to that, there is no need to revert the hashed password. Also, to make it almost impossible, you could hash the hashed password, or even better, hash the password with something more. I´m not disagreeing with you, I´m just trying to do a Brainstorm about it</span></text><author><a class="comment-user" href="/users/1723944/daniel" title="878 reputation">Daniel</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>First, we need to know what you already know about the user. Obviously, you have a username and an old password. What else do you know? Do you have an email address? Do you have data regarding the user's favorite flower?</p>
<p>Assuming you have a username, password and working email address, you need to add two fields to your user table (assuming it is a database table): a date called new_passwd_expire and a string new_passwd_id.</p>
<p>Assuming you have the user's email address, when someone requests a password reset, you update the user table as follows:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="pln">new_passwd_expire </span><span class="pun">=</span><span class="pln"> now</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> some number of days
new_passwd_id </span><span class="pun">=</span><span class="pln"> some random </span><span class="kwd">string</span><span class="pln"> of characters </span><span class="pun">(</span><span class="pln">see below</span><span class="pun">)</span></code></pre>
<p>Next, you send an email to the user at that address:</p>
<blockquote>
<p>Dear so-and-so</p>
<p>Someone has requested a new password for user account &lt;username&gt; at &lt;your website name&gt;. If you did request this password reset, follow this link:</p>
<p><a href="http://example.com/yourscript.lang?update=%3Cnew_password_id" rel="nofollow noreferrer">http://example.com/yourscript.lang?update=&lt;new_password_id</a>&gt;</p>
<p>If that link does not work you can go to <a href="http://example.com/yourscript.lang" rel="nofollow noreferrer">http://example.com/yourscript.lang</a> and enter the following into the form: &lt;new_password_id&gt;</p>
<p>If you did not request a password reset, you may ignore this email.</p>
<p>Thanks, yada yada</p>
</blockquote>
<p>Now, coding yourscript.lang: This script needs a form. If the var update passed on the URL, the form just asks for the user's username and email address. If update is not passed, it asks for username, email address, and the id code sent in the email. You also ask for a new password (twice of course).</p>
<p>To verify the user's new password, you verify the username, email address, and the id code all match, that the request has not expired, and that the two new passwords match. If successful, you change the user's password to the new password and clear the password reset fields from the user table. Also be sure to log the user out/clear any login related cookies and redirect the user to the login page.</p>
<p>Essentially, the new_passwd_id field is a password that only works on the password reset page.</p>
<p>One potential improvement: you could remove &lt;username&gt; from the email. "Someone has request a password reset for an account at this email address...." Thus making the username something only the user knows if the email is intercepted. I didn't start off that way because if someone is attacking the account, they already know the username. This added obscurity stops man-in-the-middle attacks of opportunity in case someone malicious happens to intercept the email.</p>
<p>As for your questions:</p>
<p>generating the random string: It doesn't need to be extremely random. Any GUID generator or even md5(concat(salt,current_timestamp())) is sufficient, where salt is something on the user record like timestamp account was created. It has to be something the user can't see.</p>
<p>timer: Yes, you need this just to keep your database sane. No more than a week is really necessary but at least 2 days since you never know how long an email delay might last.</p>
<p>IP Address: Since the email could be delayed by days, IP address is only useful for logging, not for validation. If you want to log it, do so, otherwise you don't need it.</p>
<p>Reset Screen: See above.</p>
<p>Hope that covers it. Good luck.</p>
</div></text><author><a href="/users/44065/jmucchiello">jmucchiello</a></author><comments><comment><text><span class="comment-copy">Wouldn't a potential attacker be able to use the MD5 of the current datestamp to get in?</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Salt can fix that. I'll update....</span></text><author><a class="comment-user" href="/users/44065/jmucchiello" title="13,257 reputation">jmucchiello</a></author></comment><comment><text><span class="comment-copy">I would strongly recommend against sending a password in email over the wire. Most of the users leave these emails undeleted which is a security breach - some of them will like to just copy-paste it every time from their 'favourite' emails. What if the certificate of the users company mail server is expired and the traffic is sniffed? To minimize this possible breach is to (1) set a short expiration time of this particular password - 1 hour, and (2) force the user to update it on the next log on.</span></text><author><a class="comment-user" href="/users/1042934/ognyan-dimitrov" title="2,543 reputation">Ognyan Dimitrov</a></author></comment><comment><text><span class="comment-copy">Ognyan, the password sent in email only works once. They have to change their password after login and the email does not contain the user login name. So, no they cannot just copy-paste it every time. Not deleting the email is not a security issue since it is just a meaningless string of letters/numbers that will gain the attacker NOTHING after the password is reset.</span></text><author><a class="comment-user" href="/users/44065/jmucchiello" title="13,257 reputation">jmucchiello</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A GUID sent to the email address of record is likely enough for most run-of-the-mill applications - with timeout even better.</p>
<p>After all, if the users emailbox has been compromised(i.e. a hacker has the logon/password for the email address), there is not much you can do about that.</p>
</div></text><author><a href="/users/53686/e-j-brennan">E.J. Brennan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You could send an email to user with a link. This link would contain some hard to guess string (like GUID). On server side you would also store the same string as you sent to user. Now when user presses on link you can find in your db entry with a same secret string and reset its password.</p>
</div></text><author><a href="/users/79708/sergej-andrejev">Sergej Andrejev</a></author><comments><comment><text><span class="comment-copy">More details would be helpful.</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>1) For generating the unique id you could use Secure Hash Algorithm.
2) timer attached? Did you mean an Expiry for the reset pwd link?
   Yes you can have an Expiry set
3) You can ask for some more information other than the emailId to validate..
    Like date of birth or some security questions
4) You could also generate random characters and ask to enter that also along with the 
   request.. to make sure the password request is not automated by some spyware or things like that..</p>
</div></text><author><a href="/users/79676/java-guy">Java Guy</a></author><comments/></answer></answers></post>