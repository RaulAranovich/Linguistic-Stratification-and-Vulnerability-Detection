<?xml version="1.0" encoding="utf-8"?>
<post><title>c - Why is printf with a single argument (without conversion specifiers) deprecated? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>In a book that I'm reading, it's written that <code>printf</code> with a single argument (without conversion specifiers) is deprecated. It recommends to substitute</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="str">"Hello World!"</span><span class="pun">);</span></code></pre>
<p>with</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">puts</span><span class="pun">(</span><span class="str">"Hello World!"</span><span class="pun">);</span></code></pre>
<p>or</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="str">"%s"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Hello World!"</span><span class="pun">);</span></code></pre>
<p>Can someone tell me why <code>printf("Hello World!");</code> is wrong? It is written in the book that it contains vulnerabilities. What are these vulnerabilities?</p>
</div></text><author><a href="/users/3049655/cool-guy">Cool Guy</a></author><comments><comment><text><span class="comment-copy">Note: <code>printf("Hello World!")</code> is <b>not</b> the same as <code>puts("Hello World!")</code>.  <code>puts()</code> appends a <code>'\n'</code>.  Instead compare <code>printf("abc")</code> to <code>fputs("abc", stdout)</code></span></text><author><a class="comment-user" href="/users/2410359/chux" title="55,063 reputation">chux</a></author></comment><comment><text><span class="comment-copy">You are aware that <code>puts</code> adds a newline? <a href="http://man7.org/linux/man-pages/man3/puts.3.html" rel="nofollow noreferrer">man7.org/linux/man-pages/man3/puts.3.html</a></span></text><author><a class="comment-user" href="/users/3204551/deduplicator" title="29,200 reputation">Deduplicator</a></author></comment><comment><text><span class="comment-copy">by the way, <code>printf</code> is also about 50% slower than <code>fputs</code>.</span></text><author><a class="comment-user" href="/users/885605/andreas-grapentin" title="2,955 reputation">Andreas Grapentin</a></author></comment><comment><text><span class="comment-copy">What's that book? I don't think <code>printf</code> is deprecated in the same way that for example <code>gets</code> is deprecated in C99, so you may consider editing your question to be more precise.</span></text><author><a class="comment-user" href="/users/226648/el-pescado" title="12,600 reputation">el.pescado</a></author></comment><comment><text><span class="comment-copy">It sounds like the book you're reading is not very good - a good book should not just say something like this is "deprecated" (that's factually false unless the author is using the word to describe their own opinion) and should explain what usage is actually invalid and dangerous rather than showing safe/valid code as an example of something you "shouldn't do".</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">Can you identify the book?</span></text><author><a class="comment-user" href="/users/827263/keith-thompson" title="159,193 reputation">Keith Thompson</a></author></comment><comment><text><span class="comment-copy">Please specify the title of the book, author and page reference. Thx.</span></text><author><a class="comment-user" href="/users/4424636/greenonline" title="427 reputation">Greenonline</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p><code>printf("Hello World!");</code> is IMHO not vulnerable but consider this:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">str</span><span class="pun">;</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
printf</span><span class="pun">(</span><span class="pln">str</span><span class="pun">);</span></code></pre>
<p>If <code>str</code> happens to point to a string containing <code>%s</code> format specifiers, your program will exhibit undefined behaviour (mostly a crash), whereas <code>puts(str)</code> will just display the string as is.</p>
<p>Example:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="str">"%s"</span><span class="pun">);</span><span class="pln">   </span><span class="com">//undefined behaviour (mostly crash)</span><span class="pln">
puts</span><span class="pun">(</span><span class="str">"%s"</span><span class="pun">);</span><span class="pln">     </span><span class="com">// displays "%s"</span></code></pre>
</div></text><author><a href="/users/898348/michael-walz">Michael Walz</a></author><comments><comment><text><span class="comment-copy">Further to causing the program to crash, there are many other exploits possible with format strings.  See here for more info: <a href="https://en.wikipedia.org/wiki/Uncontrolled_format_string" rel="nofollow noreferrer">en.wikipedia.org/wiki/Uncontrolled_format_string</a></span></text><author><a class="comment-user" href="/users/725163/e-dan" title="4,600 reputation">e.dan</a></author></comment><comment><text><span class="comment-copy">Another reason is that <code>puts</code> will be presumably faster.</span></text><author><a class="comment-user" href="/users/2692339/black" title="5,881 reputation">black</a></author></comment><comment><text><span class="comment-copy"><code>puts( "%s" );</code> would actually display <code>%s\n</code> as <code>puts()</code> appends a newline.</span></text><author><a class="comment-user" href="/users/4756299/andrew-henle" title="10,971 reputation">Andrew Henle</a></author></comment><comment><text><span class="comment-copy">@black: <code>puts</code> is "presumably" faster, and this is probably another reason people recommend it, but it is not <i>actually</i> faster.  I just printed <code>"Hello, world!"</code> 1,000,000 times, both ways.  With <code>printf</code> it took 0.92 seconds.  With <code>puts</code> it took 0.93 seconds.  There are things to worry about when it comes to efficiency, but <code>printf</code> vs. <code>puts</code> is not one of them.</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy">@SteveSummit, that's because gcc compiles <code>printf</code> to <code>puts</code>.</span></text><author><a class="comment-user" href="/users/607405/konstantin-weitz" title="2,491 reputation">Konstantin Weitz</a></author></comment><comment><text><span class="comment-copy">@KonstantinWeitz: But (a) I was not using gcc, and (b) it doesn't matter <i>why</i> the claim "<code>puts</code> is faster" is false, it's still false.</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy">@SteveSummit, your experiment does not provide evidence that "puts is the same speed as printf", it provides evidence that a program that calls "printf with a literal format string and no format arguments compiled to assembly runs as fast as an equivalent program using puts, for some unspecified compiler". I just wanted to clarify that.</span></text><author><a class="comment-user" href="/users/607405/konstantin-weitz" title="2,491 reputation">Konstantin Weitz</a></author></comment><comment><text><span class="comment-copy">@KonstantinWeitz: The claim I provided evidence for was (the opposite of) the claim user black was making. I am just trying to clarify that programmers should not be worried about calling <code>puts</code> for this reason. (But if you wanted to argue about it: I would be surprised if you could find any modern compiler for any modern machne where <code>puts</code> is significantly faster than <code>printf</code> under any circumstances.)</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy">@SteveSummit Just for the heck of it, I've tested the performance of <code>printf()</code> vs <code>fputs()</code>. It turns out that <code>fputs()</code> really is slightly faster. You can refer to my answer for details. But then it shouldn't really be the bottleneck anyway.</span></text><author><a class="comment-user" href="/users/3488231/ace" title="2,136 reputation">ace</a></author></comment><comment><text><span class="comment-copy">@SteveSummit Your test was very likely flawed due to the bottleneck of your output being the screen buffer or file buffer.  Pipe the output to /dev/null and see the performance difference.</span></text><author><a class="comment-user" href="/users/1219247/captaincodeman" title="799 reputation">CaptainCodeman</a></author></comment><comment><text><span class="comment-copy">No, I did not print it 1,000,000 times to the screen.  I piped it into <code>tail</code>, which may or may not perturb the result in the same way as redirecting to <code>/dev/null</code>. But in any case: I would not agree that such a test is "flawed".  If anything, the test with output redirected to <code>/dev/null</code> is flawed, because it is unrealistic.  The interesting claim is not "<code>printf</code> is about the same speed as <code>puts</code>", but rather, "<code>printf</code> is about the same speed as <code>puts</code> <i>in practice</i>". (And again, all we're arguing about is whether "use <code>puts</code> instead of <code>printf</code> because it's faster" is good advice.)</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy">I can imagine the difference being optimised away when a constant string does not contain <code>%</code>. And I can imagine that outputting a string can be slightly faster than outputting a string, followed by a newline.</span></text><author><a class="comment-user" href="/users/1016716/mr-lister" title="27,573 reputation">Mr Lister</a></author></comment><comment><text><span class="comment-copy">@SteveSummit "Hello World" is not a good test. First, at parity of strings, they don't do the same thing (<code>puts</code> appends a <code>\n</code>, which may incur in further overhead). Second, <code>printf</code> gets slower with longer format strings as it <i>has</i> to go through it searching for <code>%</code>, unlike <code>puts.</code> Finally, did you check the assembly whether <code>printf</code> got optimized to <code>puts</code> (likely if you did <code>printf("Hello World\n")</code>)?</span></text><author><a class="comment-user" href="/users/2692339/black" title="5,881 reputation">black</a></author></comment><comment><text><span class="comment-copy">@black: This is a pointless argument. I should not have implied that <code>printf</code> is always just as fast, but you should not have implied that <code>puts</code> is always faster. (By the way, the argument that <code>printf</code> has to scan the whole string looking for <code>%</code> characters is not convincing, because <code>puts</code> has to scan the whole string -- looking for the terminating `\0' -- also.)</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy"><code>gcc</code> automatically converts <code>printf</code> to <code>puts</code> when there is only a single argument, the format string doesn't contain any %-field, and it's terminated with <code>'\n'</code>. No need to activate optimizations for that. Just look at the assembly code produced by <code>gcc -S</code>.</span></text><author><a class="comment-user" href="/users/1881196/dlask" title="5,984 reputation">dlask</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><code>printf("Hello world");</code></p>
<p>is fine and has no security vulnerability.</p>
<p>The  problem lies with:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="pln">p</span><span class="pun">);</span></code></pre>
<p>where <code>p</code> is a pointer to an input that is controlled by the user. It is prone to   <a href="https://www.owasp.org/index.php/Format_string_attack" rel="noreferrer">format strings attacks</a>: user can insert conversion specifications to take control of the program, e.g., <code>%x</code> to dump memory or <code>%n</code> to overwrite memory.</p>
<p>Note that <code>puts("Hello world")</code> is not equivalent in behavior to <code>printf("Hello world")</code> but to <code>printf("Hello world\n")</code>. Compilers usually are smart enough to optimize the latter call to replace it with <code>puts</code>.</p>
</div></text><author><a href="/users/1119701/ouah">ouah</a></author><comments><comment><text><span class="comment-copy">Of course  <code>printf(p,x)</code> would be just as problematic if the user has control over <code>p</code>. So the problem is <i>not</i> the use of <code>printf</code> with just one argument but rather with a user-controlled format string.</span></text><author><a class="comment-user" href="/users/1640715/hagen-von-eitzen" title="1,207 reputation">Hagen von Eitzen</a></author></comment><comment><text><span class="comment-copy">@HagenvonEitzen That's technically true, but few would deliberately use a user-provided format string. When people write <code>printf(p)</code>, it's because they don't realize that it's a format string, they just think they're printing a literal.</span></text><author><a class="comment-user" href="/users/1491895/barmar" title="310,463 reputation">Barmar</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Further to the other answers, <code>printf("Hello world! I am 50% happy today")</code> is an easy bug to make, potentially causing all manner of nasty memory problems (it's UB!).</p>
<p>It's just simpler, easier and more robust to "require" programmers to be absolutely clear <strong>when they want a verbatim string and nothing else</strong>.</p>
<p>And that's what <code>printf("%s", "Hello world! I am 50% happy today")</code> gets you. It's entirely foolproof.</p>
<p>(Steve, of course <code>printf("He has %d cherries\n", ncherries)</code> is absolutely not the same thing; in this case, the programmer is not in "verbatim string" mindset; she is in "format string" mindset.)</p>
</div></text><author><a href="/users/560648/boundaryimposition">BoundaryImposition</a></author><comments><comment><text><span class="comment-copy">This is not worth an argument, and I understand what you're saying about the verbatim vs. format string mindset, but, well, not everybody thinks that way, which is one reason one-size-fits-all rules can rankle.  Saying "never print constant strings with <code>printf</code>" is just about exactly like saying "always write <code>if(NULL == p)</code>.  These rules may be useful for some programmers, but not all.  And in both cases (mismatched <code>printf</code> formats and Yoda conditionals), modern compilers warn about mistakes anyway, so the artificial rules are even less important.</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy">@Steve If there are exactly zero upsides to using something, but quite a few downsides, then yes there's really no reason to use it. Yoda conditions on the other hand <i>do</i> have the downside that they make the code harder to read (you'd intuitively say "if p is zero" not "if zero is p").</span></text><author><a class="comment-user" href="/users/144746/voo" title="17,633 reputation">Voo</a></author></comment><comment><text><span class="comment-copy">@Voo <code>printf("%s", "hello")</code> is going to be slower than <code>printf("hello")</code>, so there is a downside.  A small one, because IO is almost always way slower than such simple formatting, but a downside.</span></text><author><a class="comment-user" href="/users/1774667/yakk" title="122,511 reputation">Yakk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'll just add a bit of information <strong>regarding the vulnerability</strong> part here.</p>
<p>It's said to be vulnerable because of printf string format vulnerability. In your example, where the string is hardcoded, it's harmless (even if hardcoding strings like this is never fully recommended). But specifying the parameter's types is a good habit to take. Take this example: </p>
<p>If someone puts format string character in your printf instead of a regular string (say, if you want to print the program stdin), printf will take whatever he can on the stack.</p>
<p>It was (and still is) very used to exploit programs into exploring stacks to access hidden information or bypass authentication for example.</p>
<p>Example (C):</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="typ">int</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">argv</span><span class="pun">[])</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    printf</span><span class="pun">(</span><span class="pln">argv</span><span class="pun">[</span><span class="pln">argc </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]);</span><span class="pln"> </span><span class="com">// takes the first argument if it exists</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>if I put as input of this program <code>"%08x %08x %08x %08x %08x\n"</code></p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf </span><span class="pun">(</span><span class="str">"%08x %08x %08x %08x %08x\n"</span><span class="pun">);</span><span class="pln"> </span></code></pre>
<p>This instructs the printf-function to retrieve five parameters from the stack and display them as 8-digit padded hexadecimal numbers. So a possible output may look like:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="lit">40012980</span><span class="pln"> </span><span class="lit">080628c4</span><span class="pln"> bffff7a4 </span><span class="lit">00000005</span><span class="pln"> </span><span class="lit">08059c04</span></code></pre>
<p>See <a href="http://www.cis.syr.edu/%7Ewedu/Teaching/cis643/LectureNotes_New/Format_String.pdf" rel="nofollow">this</a> for a more complete explanation and other examples.</p>
</div></text><author><a href="/users/3803389/p1kachu">P1kachu</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This is misguided advice.  Yes, if you have a run-time string to print,</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="pln">str</span><span class="pun">);</span></code></pre>
<p>is quite dangerous, and you should always use</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="str">"%s"</span><span class="pun">,</span><span class="pln"> str</span><span class="pun">);</span></code></pre>
<p>instead, because in general you can never know whether <code>str</code> might contain a <code>%</code> sign.  However, if you have a compile-time <em>constant</em> string, there's nothing whatsoever wrong with</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="str">"Hello, world!\n"</span><span class="pun">);</span></code></pre>
<p>(Among other things, that is the most classic C program ever, literally from the C programming book of Genesis.  So anyone deprecating that usage is being rather heretical, and I for one would be somewhat offended!)</p>
</div></text><author><a href="/users/3923896/steve-summit">Steve Summit</a></author><comments><comment><text><span class="comment-copy"><code>because printf's first argument is always a constant string</code> I am not exactly sure about what you mean with that.</span></text><author><a class="comment-user" href="/users/76722/sebastian-mach" title="26,641 reputation">Sebastian Mach</a></author></comment><comment><text><span class="comment-copy">As I said, <code>"He has %d cherries\n"</code> is a constant string, meaning that it is a compile-time constant.  But, to be fair, the author's advice was not "don't pass constant strings as <code>printf</code>'s first argument", it was "don't pass strings without <code>%</code> as <code>printf</code>'s first argument."</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy"><code>literally from the C programming book of Genesis. Anyone deprecating that usage is being quite offensively heretical</code> - you haven't actually read K&amp;R in recent years. There's a ton of advice and coding styles in there that's not just deprecated but just plain bad practice these days.</span></text><author><a class="comment-user" href="/users/144746/voo" title="17,633 reputation">Voo</a></author></comment><comment><text><span class="comment-copy">@Voo: Well, let's just say that not everything that's considered bad practice is <i>actually</i> bad practice.  (The advice to "never use plain <code>int</code>" springs to mind.)</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment><comment><text><span class="comment-copy">@Steve I've no idea where you heard that one, but that's certainly not the kind of bad (bad?) practice we're talking about there. Don't misunderstand me, for the time the code was perfectly fine, but you really don't want to look at k&amp;r for much but as a historical note these days. "It's in k&amp;r" just isn't an indicator of good quality these days, that's all</span></text><author><a class="comment-user" href="/users/144746/voo" title="17,633 reputation">Voo</a></author></comment><comment><text><span class="comment-copy">@Voo: large numbers of C programmers -- sometimes I fear as much as 50% -- utterly believe that you must always use <code>int32_t</code> and <code>uint16_t</code> and the like, that you must never use plain <code>int</code> "because you don't know how big it is".  If you haven't encountered this mindset you're lucky. ¶ As for K&amp;R, although you're right that I haven't read it in years, I definitely still feel that it contains far more good advice than bad.  But perhaps I'm just old-fashioned, as I had the privilege to meet and communicate with Dennis from time to time, and contribute something to the C literature myself.</span></text><author><a class="comment-user" href="/users/3923896/steve-summit" title="6,523 reputation">Steve Summit</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Calling <code>printf</code> with literal format strings is safe and efficient, and there
exist tools to automatically warn you if your invocation of <code>printf</code> with user 
provided format strings is unsafe.</p>
<p>The most severe attacks on <code>printf</code> take advantage of the <code>%n</code> format 
specifier. In contrast to all other format specifiers, e.g. <code>%d</code>, <code>%n</code> actually
writes a value to a memory address provided in one of the format arguments.
This means that an attacker can overwrite memory and thus potentially take
control of your program. <a href="https://en.wikipedia.org/wiki/Uncontrolled_format_string" rel="nofollow noreferrer">Wikipedia</a>
provides more detail.</p>
<p>If you call <code>printf</code> with a literal format string, an attacker cannot sneak
a <code>%n</code> into your format string, and you are thus safe. In fact,
gcc will change your call to <code>printf</code> into a call to <code>puts</code>, so there litteraly
isn't any difference (test this by running <code>gcc -O3 -S</code>).</p>
<p>If you call <code>printf</code> with a user provided format string, an attacker can
potentially sneak a <code>%n</code> into your format string, and take control of your
program. Your compiler will usually warn you that his is unsafe, see 
<code>-Wformat-security</code>. There are also more advanced tools that ensure that
an invocation of <code>printf</code> is safe even with user provided format strings, and 
they might even check that you pass the right number and type of arguments to 
<code>printf</code>. For example, for Java there is <a href="http://errorprone.info/" rel="nofollow noreferrer">Google's Error Prone</a> 
and the <a href="https://checkerframework.org/" rel="nofollow noreferrer">Checker Framework</a>.</p>
</div></text><author><a href="/users/607405/konstantin-weitz">Konstantin Weitz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>A rather nasty aspect of <code>printf</code> is that even on platforms where the stray memory reads could only cause limited (and acceptable) harm, one of the formatting characters, <code>%n</code>, causes the next argument to be interpreted as a pointer to a writable integer, and causes the number of characters output thus far to be stored to the variable identified thereby.  I've never used that feature myself, and sometimes I use lightweight printf-style methods which I've written to include only the features I actually use (and don't include that one or anything similar) but feeding standard printf functions strings received from untrustworthy sources may expose security vulnerabilities beyond the ability to read arbitrary storage.</p>
</div></text><author><a href="/users/363751/supercat">supercat</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Since no one has mentioned, I'd add a note regarding their performance.</p>
<p>Under normal circumstances, assuming no compiler optimisations are used (i.e. <code>printf()</code> actually calls <code>printf()</code> and not <code>fputs()</code>), I would expect <code>printf()</code> to perform less efficiently, especially for long strings. This is because <code>printf()</code> has to parse the string to check if there are any conversion specifiers.</p>
<p>To confirm this, I have run some tests. The testing is performed on Ubuntu 14.04, with gcc 4.8.4. My machine uses an Intel i5 cpu. The program being tested is as follows:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln">
</span><span class="typ">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">int</span><span class="pln"> count </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10000000</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">count</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// either</span><span class="pln">
        printf</span><span class="pun">(</span><span class="str">"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"</span><span class="pun">);</span><span class="pln">
        </span><span class="com">// or</span><span class="pln">
        fputs</span><span class="pun">(</span><span class="str">"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"</span><span class="pun">,</span><span class="pln"> stdout</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    fflush</span><span class="pun">(</span><span class="pln">stdout</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Both are compiled with <code>gcc -Wall -O0</code>. Time is measured using <code>time ./a.out &gt; /dev/null</code>. The following is the result of a typical run (I've run them five times, all results are within 0.002 seconds).</p>
<p>For the <code>printf()</code> variant:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">real    </span><span class="lit">0m0.416s</span><span class="pln">
user    </span><span class="lit">0m0.384s</span><span class="pln">
sys     </span><span class="lit">0m0.033s</span></code></pre>
<p>For the <code>fputs()</code> variant:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">real    </span><span class="lit">0m0.297s</span><span class="pln">
user    </span><span class="lit">0m0.265s</span><span class="pln">
sys     </span><span class="lit">0m0.032s</span></code></pre>
<p>This effect is amplified if you have a <em>very</em> long string.</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> STR </span><span class="str">"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> STR2 STR STR
</span><span class="com">#define</span><span class="pln"> STR4 STR2 STR2
</span><span class="com">#define</span><span class="pln"> STR8 STR4 STR4
</span><span class="com">#define</span><span class="pln"> STR16 STR8 STR8
</span><span class="com">#define</span><span class="pln"> STR32 STR16 STR16
</span><span class="com">#define</span><span class="pln"> STR64 STR32 STR32
</span><span class="com">#define</span><span class="pln"> STR128 STR64 STR64
</span><span class="com">#define</span><span class="pln"> STR256 STR128 STR128
</span><span class="com">#define</span><span class="pln"> STR512 STR256 STR256
</span><span class="com">#define</span><span class="pln"> STR1024 STR512 STR512
</span><span class="typ">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">int</span><span class="pln"> count </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10000000</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">count</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// either</span><span class="pln">
        printf</span><span class="pun">(</span><span class="pln">STR1024</span><span class="pun">);</span><span class="pln">
        </span><span class="com">// or</span><span class="pln">
        fputs</span><span class="pun">(</span><span class="pln">STR1024</span><span class="pun">,</span><span class="pln"> stdout</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    fflush</span><span class="pun">(</span><span class="pln">stdout</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>For the <code>printf()</code> variant (ran three times, real plus/minus 1.5s):</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">real    </span><span class="lit">0m39.259s</span><span class="pln">
user    </span><span class="lit">0m34.445s</span><span class="pln">
sys     </span><span class="lit">0m4.839s</span></code></pre>
<p>For the <code>fputs()</code> variant (ran three times, real plus/minus 0.2s):</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">real    </span><span class="lit">0m12.726s</span><span class="pln">
user    </span><span class="lit">0m8.152s</span><span class="pln">
sys     </span><span class="lit">0m4.581s</span></code></pre>
<p><strong>Note:</strong> After inspecting the assembly generated by gcc, I realised that gcc optimises the <code>fputs()</code> call to an <code>fwrite()</code> call, even with <code>-O0</code>. (The <code>printf()</code> call remains unchanged.) I am not sure whether this will invalidate my test, as the compiler calculates the string length for <code>fwrite()</code> at compile-time.</p>
</div></text><author><a href="/users/3488231/ace">ace</a></author><comments><comment><text><span class="comment-copy">It won't invalidate your test, as <code>fputs()</code> is often used with string constants and that optimisation opportunity is part of the point you wanted to make.This said, adding a test run with a dynamicly generated string with <code>fputs()</code> and <code>fprintf()</code> would be a nice supplemental data point.</span></text><author><a class="comment-user" href="/users/146377/patrick-schl%c3%bcter" title="8,016 reputation">Patrick Schlüter</a></author></comment><comment><text><span class="comment-copy">@PatrickSchlüter Testing with dynamically generated strings seems to defeat the purpose of this question though... OP seems to be interested in only string literals to be printed.</span></text><author><a class="comment-user" href="/users/3488231/ace" title="2,136 reputation">ace</a></author></comment><comment><text><span class="comment-copy">He doesn't state it explicitly even if his example uses string literals. In fact, I think his confusion about the advice of the book is a result of the use of string literals in the example. With string literals, the books advice is somehow dubious, with dynamic strings it is good advice.</span></text><author><a class="comment-user" href="/users/146377/patrick-schl%c3%bcter" title="8,016 reputation">Patrick Schlüter</a></author></comment><comment><text><span class="comment-copy"><code>/dev/null</code> sort of makes this a toy, in that usually when generating formatted output, your goal is for the output to go somewhere, not be discarded.  Once you add in "actually not discarding the data" time, how do they compare?</span></text><author><a class="comment-user" href="/users/1774667/yakk" title="122,511 reputation">Yakk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">printf</span><span class="pun">(</span><span class="str">"Hello World\n"</span><span class="pun">)</span></code></pre>
<p>automatically compiles to </p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">puts</span><span class="pun">(</span><span class="str">"Hello World"</span><span class="pun">)</span></code></pre>
<p>you can check it with diassembling your executable:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="pln">push rbp
mov rbp</span><span class="pun">,</span><span class="pln">rsp
mov edi</span><span class="pun">,</span><span class="pln">str</span><span class="pun">.</span><span class="typ">Helloworld</span><span class="pun">!</span><span class="pln">
call dword imp</span><span class="pun">.</span><span class="pln">puts
mov eax</span><span class="pun">,</span><span class="lit">0x0</span><span class="pln">
pop rbp
ret</span></code></pre>
<p>using</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">variable</span><span class="pun">;</span><span class="pln">
</span><span class="pun">...</span><span class="pln"> 
printf</span><span class="pun">(</span><span class="pln">variable</span><span class="pun">)</span></code></pre>
<p>will lead to security issues, <strong>don't ever use printf that way!</strong></p>
<p>so your book is actually correct, using printf with one variable is deprecated but you can still use printf("my string\n") because it will automatically become puts </p>
</div></text><author><a href="/users/2394143/%c3%81brah%c3%a1m-endre">Ábrahám Endre</a></author><comments><comment><text><span class="comment-copy">This behaviour actually depends entirely on the compiler.</span></text><author><a class="comment-user" href="/users/898348/michael-walz" title="16,096 reputation">Michael Walz</a></author></comment><comment><text><span class="comment-copy">This is misleading. You state <code>A compiles to B</code>, but in reality you mean <code>A and B compile to C</code>.</span></text><author><a class="comment-user" href="/users/76722/sebastian-mach" title="26,641 reputation">Sebastian Mach</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>For gcc it is possible to enable specific warnings for checking <code>printf()</code> and <code>scanf()</code>. </p>
<p>The gcc documentation states:</p>
<blockquote>
<p><code>-Wformat</code> is included in <code>-Wall</code>. For more control over some aspects
  of format checking, the options <code>-Wformat-y2k</code>,
  <code>-Wno-format-extra-args</code>, <code>-Wno-format-zero-length</code>,
  <code>-Wformat-nonliteral</code>, <code>-Wformat-security</code>, and <code>-Wformat=2</code> are
  available, but are not included in <code>-Wall</code>.</p>
</blockquote>
<p>The <code>-Wformat</code> which is enabled within the <code>-Wall</code> option does not enable several special warnings that help to find these cases:</p>
<ul>
<li><code>-Wformat-nonliteral</code> will warn if you do not pass a string litteral as format specifier.</li>
<li><code>-Wformat-security</code> will warn if you pass a string that might contain a dangerous construct. It's a subset of <code>-Wformat-nonliteral</code>.</li>
</ul>
<p>I have to admit that enabling <code>-Wformat-security</code> revealed several bugs we had in our codebase (logging module, error handling module, xml output module, all had some functions that could do undefined things if they had been called with % characters in their parameter. For info, our codebase is now around 20 years old and even if we were aware of these kind of problems, we were extremely surprised when we enabled these warnings how many of these bugs were still in the codebase).</p>
</div></text><author><a href="/users/146377/patrick-schl%c3%bcter">Patrick Schlüter</a></author><comments/></answer></answers></post>