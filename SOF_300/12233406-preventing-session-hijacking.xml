<?xml version="1.0" encoding="utf-8"?>
<post><title>php - Preventing session hijacking - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>How do you prevent multiple clients from using the same session ID? I'm asking this because I want to add an extra layer of security to prevent session hijacking on my website. If a hacker somehow figures out another user's session ID and makes requests with that SID, how can I detect that there are different clients sharing a single SID on the server and then reject the hijack attempt?</p>
<p><strong>EDIT</strong></p>
<p>I have accepted Gumbo's answer after careful consideration because I've come to the realization that what I'm asking for is impossible due to the restrictions of a <em>stateless HTTP protocol</em>. I forgot about what is perhaps the most fundamental principle of HTTP, and now that I think about this question seems a bit trivial.</p>
<p>Let me elaborate what I mean:</p>
<p>After User A logs in on example.com, he is given some random session ID, for simplicity's sake, let it be 'abc123'. This session ID is stored as a cookie on the client side and is validated with a server-side session to ensure the user who logged in remains logged in as he moves from one webpage to another. This cookie of course would not need to exist if HTTP were not stateless. For that reason, if User B steals User A's SID, and creates a cookie on his computer with the value 'abc123', he would have successfully hijacked User A's session, but there is simply no way for the server to legitimately recognize that User B's request is any different from User A's requests, and therefore the server has no reason to reject any request. Even if we were to list the sessions that were already active on the server and try to see if someone is accessing a session that is already active, how can we determine that it is another user who is accessing the session illegitimately and not the same user who is already logged in with a session ID, but simply trying to make another request with it (ie navigate to a different webpage). We can't. Checking the user agent? Can be spoofed - but good as a Defense in Depth measure nevertheless. IP Address? Can change for legitimate reasons - but instead of not checking for the IP address at all, I suggest checking something like the first two octets of the IP, as even a user on a data plan network who constantly has a changing IP for perfectly legitimate reasons would only usually have the last two octets of their IP change.</p>
<p>In consclusion, it is the stateless HTTP that condemns us to never being able to fully protect our websites from session hijacking, but good practices (like the ones Gumbo has provided) will be good enough to prevent a good majority of session attacks. Trying to protect sessions from hijacking by denying multiple requests of the same SID is therefore simply ludicrous, and would defeat the whole purpose of sessions.</p>
</div></text><author><a href="/users/1576985/hesson">hesson</a></author><comments><comment><text><span class="comment-copy">Well! checking first two octets of the IP is not effective as well. Different people using same internet service likely have same first two octets though they have different IP addresses as a whole.</span></text><author><a class="comment-user" href="/users/744987/watsmyname" title="2,306 reputation">WatsMyName</a></author></comment><comment><text><span class="comment-copy">The first two octets may also legitimately change - for example in a large organisation where there are multiple internet gateways through different ISPs.</span></text><author><a class="comment-user" href="/users/453389/shonky-linux-user" title="1,887 reputation">shonky linux user</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Unfortunately, there is no effective way to unmistakably identify a request that originates from an attacker in opposite to a genuine request. Because most properties that counter measures check like the IP address or user agent characteristics are either not reliable (IP address might change among multiple requests) or can be forged easily (e. g. <em>User-Agent</em> request header) and thus can yield unwanted false positives (i. e. genuine user switched IP address) or false negatives (i. e. attacker was able to successfully forge request with same <em>User-Agent</em>).</p>
<p>That’s why the best method to prevent session hijacking is to make sure an attacker cannot find out another user’s session ID. This means you should design your application and its session management that (1) an attacker cannot guess a valid session ID by using enough entropy, and (2) that there is no other way for an attacker to obtain a valid session ID by known attacks/vulerabilities like sniffing the network communication, Cross-Site Scripting, leakage through <em>Referer</em>, etc.</p>
<p>That said, you should:</p>
<ul>
<li>use enough random input for generating the session ID (see <a href="http://php.net/manual/en/session.configuration.php#ini.session.entropy-file" rel="noreferrer"><em>session.entropy_file</em></a>, <a href="http://php.net/manual/en/session.configuration.php#ini.session.entropy-length" rel="noreferrer"><em>session.entropy_length</em></a>, and <a href="http://php.net/manual/en/session.configuration.php#ini.session.hash-function" rel="noreferrer"><em>session.hash_function</em></a>)</li>
<li>use HTTPS to protect the session ID during transmission</li>
<li>store the session ID in a cookie and not in the URL to avoid leakage though <em>Referer</em> (see <a href="http://php.net/manual/en/session.configuration.php#ini.session.use-only-cookies" rel="noreferrer"><em>session.use_only_cookies</em></a>)</li>
<li>set the cookie with the <code>HttpOnly</code> and <code>Secure</code> attributes to forbid access via JavaScript (in case of XSS vulnerabilities) and to forbid transmission via insecure channel (see <a href="http://php.net/manual/en/session.configuration.php#ini.session.cookie-httponly" rel="noreferrer"><em>session.cookie_httponly</em></a> and <a href="http://php.net/manual/en/session.configuration.php#ini.session.cookie-secure" rel="noreferrer"><em>session.cookie_secure</em></a>)</li>
</ul>
<p>Besides that, you should also regenerate the session ID while invalidating the old one (see <a href="http://php.net/session_regenerate_id" rel="noreferrer"><code>session_regenerate_id</code> function</a>) after certain session state changes (e. g. confirmation of authenticity after login or change of authorization/privileges) and you can additionally do this periodically to reduce the time span for a successful session hijacking attack.</p>
</div></text><author><a href="/users/53114/gumbo">Gumbo</a></author><comments><comment><text><span class="comment-copy">+1 I agree.   I would also mention that session id's must expire and that /dev/urandom should be used as the entropy_file.  ( <a href="http://blog.ptsecurity.com/2012/08/not-so-random-numbers-take-two.html" rel="nofollow noreferrer">blog.ptsecurity.com/2012/08/not-so-random-numbers-take-two.h‌​tml</a> ).  Also Session Riding, aka CSRF is a concern.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">I don't understand. If all session info is stored on the server, how could it not be possible to retrieve data that is stored on your own server?  I've looked at PHP's session handler, but I don't think it accomplishes what I'm looking for, maybe I'm wrong?</span></text><author><a class="comment-user owner" href="/users/1576985/hesson" title="838 reputation">hesson</a></author></comment><comment><text><span class="comment-copy">@hesson  you are trying to prevent a session from being compromised,  well this prevents common attacks used to compromise the session id.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook I'm aware of the points Gumbo has suggested. More than anything, I just want to learn whether PHP has a mechanism of retrieving all active sessions, and if not, why? It seems possible in theory because PHP sessions are server-side, so there must be a good reason to not have such a mechanism present because it would have huge benefits for the security of the website. Thanks.</span></text><author><a class="comment-user owner" href="/users/1576985/hesson" title="838 reputation">hesson</a></author></comment><comment><text><span class="comment-copy">@hesson PHP does not have such a feature built-in; you would need to implement it yourself depending on the storage you chose. But how would that prevent session hijacking?</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo Well, the idea is if I could get a list of the active sessions, then I can detect duplicate SIDs before logging the client in, and destroy the session effectively eliminating the threat of session hijacking.</span></text><author><a class="comment-user owner" href="/users/1576985/hesson" title="838 reputation">hesson</a></author></comment><comment><text><span class="comment-copy">@hesson The session ID is to identify a session and thus it must be unique. If you know a session ID, you can use that session and have access its data. And that’s what happens during a session hijacking attack. The attacker simply sends the victim’s session ID to the server to use the same session as the victim.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">What if the attacker in the same LAN as of the user sniffs the users request and get the session ids?</span></text><author><a class="comment-user" href="/users/4021769/anandu-m-das" title="134 reputation">Anandu M Das</a></author></comment><comment><text><span class="comment-copy">@AnanduMDas HTTPS is a must, no matter in what network you are. Even an intranet should be considered as untrusted.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo I am not trying to say https is not a must, instead, even if u use https an attacker in the same LAN of yours can easily sniff your session cookie. So mere https implementation along with the methods you suggested won't work.</span></text><author><a class="comment-user" href="/users/4021769/anandu-m-das" title="134 reputation">Anandu M Das</a></author></comment><comment><text><span class="comment-copy">@AnanduMDas How would you eavesdrop a proper HTTPS connection?</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo LAN Sniffing! It may be encrypted. But who cares?</span></text><author><a class="comment-user" href="/users/4021769/anandu-m-das" title="134 reputation">Anandu M Das</a></author></comment><comment><text><span class="comment-copy">@AnanduMDas Then good luck decrypting it.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo You don't need to decrypt a cookie to use it. :)</span></text><author><a class="comment-user" href="/users/4021769/anandu-m-das" title="134 reputation">Anandu M Das</a></author></comment><comment><text><span class="comment-copy">@AnanduMDas But you need to decrypt the encrypted HTTP message to read the cookie.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo, I am following all the steps u suggested above, additionally I m trying to append loggedIn userId in SessionId(using form auth &amp; InProc) but user was not authenticated at the time of SessionId generation and validation, Is it possible to append or I am doing something wrong.</span></text><author><a class="comment-user" href="/users/2314401/vishwanath-mishra" title="100 reputation">Vishwanath Mishra</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Can we do something like this.</p>
<p>Store session id in database.
Also store the Ip address and the HTTP_USER_AGENT for that session id.
Now when a request comes to the server containing that matching session id, Check from which agent and ip it is coming from in your script.</p>
<p>Can make this funda work by make common function or class for session so that every request is verified before it is processed. It would hardly take some micro seconds. But, If many users are visiting your site and you have huge database of sessions, then this might be little performance issue. But, It would surely be very secure compared o other methods like
=&gt; Using regenerating sessions.</p>
<p>In regenerating session ids, there is again little chance of session hijacking.</p>
<p>suppose, user's session id is copied and that user is not working or active for sometime and no request is made to server with old session id asking to regenerate new one. Then In case session id is hijacked, hacker will use that session id and make request to server with that id, then server will respond back with regenerated session id and so that hacker can go on using the services. Actual user will no longer be able to operate because he is unknown of what the regenerated id is and what request session id is to be passed in request. Completely Gone.</p>
<p>Please correct me if i m wrong somewhere.</p>
</div></text><author><a href="/users/1147842/kanchan">kanchan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are lots of standard defenses against session hijacking. One of them is to match each session to a single IP address.</p>
<p><a href="http://msdn.microsoft.com/en-us/magazine/cc300500.aspx" rel="nofollow noreferrer">Other schemes</a> may use an HMAC generated from:</p>
<ul>
<li>the network address of the client's IP</li>
<li>the user-agent header sent by the client</li>
<li>the SID</li>
<li>a secret key stored on the server</li>
</ul>
<p>The reason only the network address of the IP is used is in case the user is behind a public proxy, in which case their IP address can change with each request, but the network address remains the same.</p>
<p>Of course, to truly be secure, you really ought to force SSL for all requests so that the SID can't be intercepted by would-be attackers in the first place. But not all sites do this (<em>::cough:: <a href="https://meta.stackexchange.com/questions/69171/why-doesnt-the-stack-overflow-team-fix-the-firesheep-style-cookie-theft">Stack Overflow</a> ::cough::</em>).</p>
</div></text><author><a href="/users/370940/l%c3%a8se-majest%c3%a9">Lèse majesté</a></author><comments><comment><text><span class="comment-copy">ip address is impractical, checking the user-agent is a joke espeically if its stored in a cookie value so the attacker knows what the UA is if he has the session token (but he should know that anyway if he knows the cookie value).  You made no mention of cookie flags.  Please read gumbo's answer.  Also don't build your own session handler,  PHP's session handler is better than this.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook: I don't see how the UA being stored in an encrypted cookie value is any worse than simply grabbing it from the header. The latter is the weakspot in this scheme, not the HMAC. Secondly, this type of scheme could be used on top of the PHP session handler. You don't have to build your own session handler. Lastly, as I said, the only true way to defend against hijacking is to use SSL. But short of that, these are measures you can take to attenuate the threat.</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment><comment><text><span class="comment-copy">an hmac is not a method of encryption.  Also,  if the session id is stolen using XSS or by an OWASP A9 violation the attacker will also have the user-agent.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook: An HMAC is <i>by definition</i> encrypted (in the implementation I linked to, it's encrypted using SHA-1). If the attacker wanted to find out the UA string from the HMAC, they'd have to figure out what the secret key stored server-side is and then try to crack the HMAC. But, like I said, if they can get to the HMAC, then they can already see the unencrypted UA string, so why bother?</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment><comment><text><span class="comment-copy">hmac means "hashed message authentication code",  hashed != encrypted,  authentication is different from secrecy and usually you need both.  Also, I strongly dislike your session handler.  Gumbo has the correct answer.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook: I strongly suspect you're trolling at this point, but how is using a cryptographic hash function to encrypt data not encryption? And what exactly is <i>my</i> session handler? As I already told you, everything I suggested in my answer is intended as a supplement to PHP's session handler. There's nothing here to suggest that you shouldn't use PHP's session handler or that contradicts Gumbo's answer.</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment><comment><text><span class="comment-copy">Never confuse a hash function with an encryption function, this is probably the best way to spot a non-cryptographer.  If you don't believe me try posting to <a href="http://crypto.stackexchange.com/">crypto.stackexchange.com</a>.  Also you can't depend on an attacker controlled variable to enforce access control.  Its like you are suggesting having a cookie variable that says <code>is_hacker=false</code>.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook: OK, for the proper crypto terminology, the correct adjective I should have used was "hashed", but it seemed redundant since we were already talking about an HMAC. That aside, it doesn't really change anything. It's incredibly difficult for an attacker to spoof the HMAC if they don't know the secret key that's stored server-side. It's not quite the same as having an <code>is_hacker</code> cookie that just has a "true"/"false" value.</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment><comment><text><span class="comment-copy">spoof hmac?  What on earth are you talking about?  This is what i am talking about: <a href="https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/" rel="nofollow noreferrer">addons.mozilla.org/en-US/firefox/addon/user-agent-switcher</a>  You are not proposing a security system because you are depending on an attacker controlled variable that will <b><i>always be known to the attacker</i></b>. If you have the session id you will <b>ALWAYS</b> have the incredibly predictable user-agent.  So please delete this awful post and never recommend this system to anyone,  EVER!</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook: You need to get your own argument straight. You claimed that putting the UA in the HMAC cookie somehow lessens security. It took me this many posts just to explain to you how it doesn't. Did I not mention that the UA could be grabbed directly from the header in my VERY FIRST REPLY to you? The fact that the user can spoof their UA is why you don't use UA-matching only. But in the case where the attacker can see your HTTP traffic in plain-text (and send traffic on the same network address), then there is no defense, period. (This was acknowledged in my answer!)</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment><comment><text><span class="comment-copy">@Rook: At the very least, this type of scheme allows you to detect some hijacking attempts where the attacker doesn't try to spoof their UA or are not on the same network or same IP (depending on how much you want to inconvenience your users). How is deflect <i>some</i> attacks worse than deflecting none? Or are you of the attitude that if you're not using SSL for all requests, that you just shouldn't try to prevent session hijacking at all?</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment><comment><text><span class="comment-copy">SSL is required for for the life of the session(owasp a9).  The only defense is preventing the id from being compromised in the first place.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In my view you can store session id in database when users login and check everyone for the same before loggin in. delete the same session id which you have stored in database when users logout. You can easily findout session id of each and every user or else I can help you.</p>
</div></text><author><a href="/users/1628329/sk-miraj">Sk MiRaj</a></author><comments><comment><text><span class="comment-copy">storing the session id in the database weakens the session.  An attacker can steal it with sql injection and login without having to break the password hash.  use's php's session handler,  don't roll your own.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook, I looked at PHP's session handler, but I'm not sure how I could use it as a solution to my problem. If you know how to implement PHP's session handler to reject multiple SIDs, kindly post it as an answer.</span></text><author><a class="comment-user owner" href="/users/1576985/hesson" title="838 reputation">hesson</a></author></comment><comment><text><span class="comment-copy">@hesson Gumbo's answer is great.  You use the protection systems that everyone else uses. Additionally,  make sure your system is free from XSS flaws and owasp a9 violations,  after all these are the most common two flaws that lead to a session compromise.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Rook, the PHP's session handler supports database storage.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@Rook: If you've got an SQL injection vulnerability in your site, then you've already got serious problems. The solution isn't to move the SID out of the database (a perfectly reasonable place to put it), but to secure your SQL injection vulnerability--unless you're suggesting that a secure site shouldn't use an SQL database at all.</span></text><author><a class="comment-user" href="/users/370940/l%c3%a8se-majest%c3%a9" title="6,078 reputation">Lèse majesté</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>One of the easy implementations can be done by making a table in database , as logged users , then at login, update that table with user name and his SID , this will prevent other logins as same user , now at the time of log out , just run a simple query , which deletes the logged in data in database , this can also be used to trace logged in user on ur website at a time .</p>
</div></text><author><a href="/users/1080407/ratan-kumar">Ratan Kumar</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Obviously when you'll set session cookie in the browser, that cookie is sent in the request. Now when request comes, Server will check the session id in database and grant access. To prevent that only its important to store agent and ip so that before checking server makes sure that sessions access is granted to the unique client and not the unique session id which can be hijacked.</p>
</div></text><author><a href="/users/1147842/kanchan">kanchan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I don't know about the coding part well. So I can tell u an algorithm to do this. Setting stuffs like SSL, or setting the session cookie to secure and httpOnly wont work if a user sniffs the session id from a LAN network(Provided user and attacker are in the same LAN). </p>
<p>So what you can do is, once the user successfully logs into the application, set unique token  to each and every pages of the web application and keep a track of this at the server side. So that if the valid user sends the request to access a particular page, the token of that page will also be sent to the server side. Since the tokens are unique for a user for a particular session, even if the attacker can get the session id, he cannot hijack the users session as he cannot provide the valid token to the server. </p>
</div></text><author><a href="/users/4021769/anandu-m-das">Anandu M Das</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>@Anandu M Das:</p>
<p>I believe what you may be referring to is the use of session tokens with each session ID. This site can explain the use of tokens with sessions:</p>
<p><a href="https://blog.whitehatsec.com/tag/session-token/" rel="nofollow">https://blog.whitehatsec.com/tag/session-token/</a></p>
<p>Although session tokens are easily compromised by an XSS attack, this doesn't mean that they should never be used. I mean let's face it, if something was compromisable by a security vulnerability on the server, its not the fault of the method, its the fault of the programmer who introduced that vulnerability (to highlight points made by Hesson and Rook).</p>
<p>If you follow proper security conventions and practicies and secure your site from SQL injection, XSS, and require all sessions be managed over HTTPS, then you can easily manage the potential attack from CSRF by use of server-side tokens, stored within the session, and updated everytime the user would cause a manipulation to their session (like a $_POST being submitted). Also, NEVER store sessions or their contents in a url, no matter how well you think they are encoded.</p>
<p>When the security of your users is paramount (which it should be), the use of session tokens will allow better or more advanced functionality to be provided without compromising their session security.</p>
</div></text><author><a href="/users/3449006/user253780">user253780</a></author><comments/></answer></answers></post>