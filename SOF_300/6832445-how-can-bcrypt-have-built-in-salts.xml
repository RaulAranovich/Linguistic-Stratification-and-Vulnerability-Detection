<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How can bcrypt have built-in salts? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Coda Hale's article <a href="http://codahale.com/how-to-safely-store-a-password/" rel="noreferrer">"How To Safely Store a Password"</a> claims that:</p>
<blockquote>
<p>bcrypt has salts built-in to prevent rainbow table attacks.</p>
</blockquote>
<p>He cites <a href="http://www.usenix.org/events/usenix99/provos/provos_html/node6.html#SECTION00051000000000000000" rel="noreferrer">this paper</a>, which says that in OpenBSD's implementation of <code>bcrypt</code>:</p>
<blockquote>
<p>OpenBSD generates the 128-bit bcrypt salt from an arcfour
  (arc4random(3)) key stream, seeded with random data the kernel
  collects from device timings.</p>
</blockquote>
<p>I don't understand how this can work. In my conception of a salt:</p>
<ul>
<li>It needs to be different for each stored password, so that a separate rainbow table would have to be generated for each</li>
<li>It needs to be stored somewhere so that it's repeatable: when a user tries to log in, we take their password attempt, repeat the same salt-and-hash procedure we did when we originally stored their password, and compare</li>
</ul>
<p>When I'm using Devise (a Rails login manager) with bcrypt, there is no salt column in the database, so I'm confused. If the salt is random and not stored anywhere, how can we reliably repeat the hashing process?</p>
<p>In short, <strong>how can bcrypt have built-in salts</strong>?</p>
</div></text><author><a href="/users/4376/nathan-long">Nathan Long</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>This is bcrypt:</p>
<p>Generate a random salt. A "cost" factor has been pre-configured. Collect a password.</p>
<p>Derive an encryption key from the password using the salt and cost factor. Use it to encrypt a well-known string. <em>Store</em> the cost, <em>salt,</em> and cipher text. Because these three elements have a known length, it's easy to concatenate them and store them in a single field, yet be able to split them apart later.</p>
<p>When someone tries to authenticate, retrieve the stored cost and salt. Derive a key from the input password. Encrypt the same well-known string. If the generated cipher text matches the stored cipher text, the password is a match.</p>
<p>Bcrypt operates in a very similar manner to more traditional schemes based on algorithms like PBKDF2. The main difference in its use of a derived key to encrypt known plain text; other schemes (reasonably) assume the key derivation function is irreversible, and store the derived key directly.</p>
<hr/>
<p>Stored in the database, a <code>bcrypt</code> "hash" might look something like this:</p>
<blockquote>
<p>$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa</p>
</blockquote>
<p>This is actually three fields, delimited by "$":</p>
<ul>
<li><code>2a</code> identifies the <code>bcrypt</code> algorithm version that was used.</li>
<li><code>10</code> is the cost factor; 2<sup>10</sup> iterations of the key derivation function are used (which is not enough, by the way. I'd recommend a cost of 12 or more.)</li>
<li><code>vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa</code> is the salt and the cipher text, concatenated and encoded in a modified Base-64. The first 22 characters decode to a 16-byte value for the salt. The remaining characters are cipher text to be compared for authentication.</li>
</ul>
<p>This example is taken from the <a href="https://github.com/codahale/bcrypt-ruby" rel="noreferrer">documentation for Coda Hale's ruby implementation.</a></p>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">Would you have more details as to why cost factor of 10 would not be enough? In Grails, I noticed that 10 is the default value for cost factor/log rounds for bcrypt so it might be worth updating given your suggestion.</span></text><author><a class="comment-user" href="/users/275800/paul-sns" title="920 reputation">paul_sns</a></author></comment><comment><text><span class="comment-copy">@erickson a cost of 16 takes almost 10 seconds on my host .. I can't have that every time someone's logging in.  Is my hardware really just that crappy?</span></text><author><a class="comment-user" href="/users/454533/explosion-pills" title="127,981 reputation">Explosion Pills</a></author></comment><comment><text><span class="comment-copy">@ExplosionPills what language and library are you using? If an interpreter is executing most of the algorithm it could appear much slower.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">@erickson <code>php</code> with <code>crypt</code> (<code>CRYPT_BLOWFISH</code>).  Am I screwed?</span></text><author><a class="comment-user" href="/users/454533/explosion-pills" title="127,981 reputation">Explosion Pills</a></author></comment><comment><text><span class="comment-copy">@ExplosionPills I'm afraid I don't know much about PHP. From what I understand, most PHP deployments nowadays use pre-compiled byte-code, which should be fairly fast. Do you know whether this <code>crypt()</code> function is implemented by more PHP code, or it is actually implemented by a compiled library (written in C or C++ and compiled for the host architecture)? If the latter, it seems like it should be fast.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">@ExplosionPills I've done some benchmarking, and the <code>bcrypt</code> key generation algorithm <i>is</i> very slow, much slower than the PBKDF2 with SHA-1 HMAC I had assumed was comparable when I recommended a cost factor. <code>bcrypt</code> with a cost factor of 16 takes about 5.6 seconds on my machine. In that time, I can do almost 4 million PBKDF2 iterations. So, the cost factor for bcrypt could be safely lowered, maybe to 12. This should take less than 1 second, even on your host.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">@erickson all right, thanks for the help!</span></text><author><a class="comment-user" href="/users/454533/explosion-pills" title="127,981 reputation">Explosion Pills</a></author></comment><comment><text><span class="comment-copy">The cost factor for bcrypt is exponential, or rather, a cost factor of 10 means 2^10 rounds (1024), a cost factor of 16 would mean 2^16 rounds (65536).  It's natural then that it would take 5-10 seconds.  It should take about 64 times as long as a cost factor of 10 does.  To clear up other misinformation, PHP's crypt function uses the unix crypt library which is implemented in c.</span></text><author><a class="comment-user" href="/users/53212/thomasrutter" title="73,740 reputation">thomasrutter</a></author></comment><comment><text><span class="comment-copy">@thomasrutter Thanks for answering my question about PHP's <code>crypt()</code> implementation. I am not aware of any "misinformation" though. Can you clarify?</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">Sorry, just referring to your speculation that crypt may be implemented as PHP and executed as bytecode, which it isn't (it calls a C library).  I realise you weren't stating that as fact though because you weren't sure.  Just clearing it up.</span></text><author><a class="comment-user" href="/users/53212/thomasrutter" title="73,740 reputation">thomasrutter</a></author></comment><comment><text><span class="comment-copy">Very informative.</span></text><author><a class="comment-user" href="/users/1103090/edward" title="95 reputation">Edward</a></author></comment><comment><text><span class="comment-copy">The mode of operation makes sense, but if I have access to the database and can generate a password for me (in Devise), it seems I can now copy that to any other users encrypted password field entry and I "know" their password. What am I missing?</span></text><author><a class="comment-user" href="/users/969193/tjchambers" title="995 reputation">TJChambers</a></author></comment><comment><text><span class="comment-copy">@TJChambers That's right; if you can set the password on the account, you will be able to authenticate. Password hashing isn't intended to prevent that attack. It's meant to prevent an attacker with read-only access to the password table from authenticating. For example, you get a backup tape with the table on it.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">thanks @erickson. I guess the theory for me (if I understand it correctly) is if someone breaks in far enough to get access to the password database itself and can write to the database, AND they can establish their own password to a known account (their own), then they can access anyone elses account by copying their encrypted password to that account and logging in. At least until the other party realizes they cannot log in and resets their password. It seems like including the primary key (i.e. username or email) into the embedded salt process would eliminate that.</span></text><author><a class="comment-user" href="/users/969193/tjchambers" title="995 reputation">TJChambers</a></author></comment><comment><text><span class="comment-copy">I have to assume the attacker can compute hashes with the same known inputs. Otherwise I'm relying on "security through obscurity" rather than strong cryptography. To thwart an attacker who can write to the table, I'd need to be able to hide some master secret that could be used to authenticate information in the table. For example, compute a digital signature or MAC on the table or its entries. And keeping the master secret hidden from such an attacker would be hard.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">If I understand you correctly, @erickson, then it would require an "unknown" input to prevent access. Or at least an unknown verifying outcome (like a digital signature), to at least detect the intrusion.</span></text><author><a class="comment-user" href="/users/969193/tjchambers" title="995 reputation">TJChambers</a></author></comment><comment><text><span class="comment-copy">@TJChambers That's right. But most password authentication systems don't incorporate this, because if an attacker has write access, you've already lost.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">@erickson Question with reference to this statement-- "The main difference in its use of a derived key to encrypt known plain text; other schemes (reasonably) assume the key derivation function is irreversible, and store the derived key directly."  So is it accurate to say that breaking bcrypt would depend on somehow breaking through two algorithms-- both the KDF and the cipher, whereas something like PBKDF2 only requires the KDF to be broken? And therefore bcrypt is <i>arguably</i> more secure in that sense?</span></text><author><a class="comment-user" href="/users/1029146/aerovistae" title="12,297 reputation">Aerovistae</a></author></comment><comment><text><span class="comment-copy">@Aerovistae Yes, bcrypt can only be "broken" (in the sense of there being a shortcut to recover a password) if the cipher and the key derivation function are each broken.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,723 reputation">erickson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I believe that phrase should have been worded as follows:</p>
<blockquote>
<p>bcrypt has salts <strong><em>built into the generated hashes</em></strong> to prevent rainbow table attacks.</p>
</blockquote>
<p>The <code>bcrypt</code> utility itself does not appear to maintain a list of salts. Rather, salts are generated randomly and appended to the output of the function so that they are remembered later on (according to <a href="http://code.google.com/p/jbcrypt/source/browse/trunk/src/main/java/org/mindrot/jbcrypt/BCrypt.java">the Java implementation of <code>bcrypt</code></a>). Put another way, the "hash" generated by <code>bcrypt</code> is not <strong><em>just</em></strong> the hash. Rather, it is the hash <strong><em>and</em></strong> the salt concatenated.</p>
</div></text><author><a href="/users/41619/adam-paynter">Adam Paynter</a></author><comments><comment><text><span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/5881169/storing-a-hashed-password-bcrypt-in-a-database-type-length-of-column/5882472#5882472" title="storing a hashed password bcrypt in a database type length of column">stackoverflow.com/questions/5881169/…</a></span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,771 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">OK, so I sign up for a site and choose a the password "foo". <code>Bcrypt</code> adds a random salt of "akd2!*", resulting in "fooakd2!*", which is hashed and stored. Later, I try to sign in with password "bar". To see if I'm correct, it needs to hash "barakd2!*". If the salt was generated randomly to start with, how does it know how to add it back to "bar" before hashing and comparing?</span></text><author><a class="comment-user owner" href="/users/4376/nathan-long" title="58,846 reputation">Nathan Long</a></author></comment><comment><text><span class="comment-copy">@Nathan: <code>bcrypt</code> knows how to extract the salt back out of the generated output (which is stored in the database). When it comes time to authenticate, <code>bcrypt</code> separates the original output into its hash and salt components. The salt component is applied to the incoming password typed by the user.</span></text><author><a class="comment-user" href="/users/41619/adam-paynter" title="31,499 reputation">Adam Paynter</a></author></comment><comment><text><span class="comment-copy">To answer Nathan Long's comment, a good way of thinking of this is that salts are not meant to be secret.  This is why the salt is included in the output from the bcrypt function as one of the answers pointed out above.  The salt is there to prevent rainbow tables, which are lists of common passwords, or just brute force, etc... of different passwords but hashed.  Without salt, the hash for a password in database A would be the same as a hash for a password in database B.  Salt merely changes up the hash values making it harder for someone who stole the database to decrypt (unhash) passwords.</span></text><author><a class="comment-user" href="/users/1606689/joseph-astrahan" title="1,620 reputation">Joseph Astrahan</a></author></comment><comment><text><span class="comment-copy">@Nathan but can an attacker just remove the known salts in all passwords and then create a table with them?</span></text><author><a class="comment-user" href="/users/931050/oscar" title="762 reputation">Oscar</a></author></comment><comment><text><span class="comment-copy">I am waiting for reply on @Oscar comment.  Also I still didn't get it the final statement. So, while matching the incoming password, we just need to call the same function (used while encrypting) and it will generate the same hashed password again?  Is this correct statement or am I missing something?</span></text><author><a class="comment-user" href="/users/3839581/amarmishra" title="131 reputation">amarmishra</a></author></comment><comment><text><span class="comment-copy">@amarmishra see Joseph's comment: the password is still stored with the salt applied and the salt is a random value for each and every user. That means that an attacker cannot use a pre-existing Rainbow Table. He/She would have to brute force each and every password separately.</span></text><author><a class="comment-user" href="/users/467944/korgen" title="3,553 reputation">Korgen</a></author></comment><comment><text><span class="comment-copy">But say a user is a president, and his salt is known, a rainbow table can be generated for that salt specifically, right? It would take very long of course, but a secret-ish salt sounds better to me in this case.</span></text><author><a class="comment-user" href="/users/3978539/stephan-bijzitter" title="1,901 reputation">Stephan Bijzitter</a></author></comment></comments></answer></answers></post>