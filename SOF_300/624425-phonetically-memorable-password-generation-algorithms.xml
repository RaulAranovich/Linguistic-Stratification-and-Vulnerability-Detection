<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Phonetically Memorable Password Generation Algorithms - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<h3>Background</h3>
<p>While at the Gym the other day, I was working with my combination lock, and realized something that would be useful to me as a programmer.  To wit, my combination is three seperate sets of numbers that either sound alike, or have some other relation that makes them easy to remember. For instance, 5-15-25, 7-17-2, 6-24-5.  These examples <em>seem</em> easy to remember. </p>
<h3>Question</h3>
<p>How would I implement something similar for passwords?  Yes, they ought to be hard to crack, but they also should be easy for the end user to remember.  Combination Locks do that with a mix of numbers that have similar sounds, and with numbers that have similar properties (7-17-23: All Prime, 17 rolls right off the tongue after 7, and 23 is another prime, and is (out of that set), the 'hard' one to remember).</p>
<h3>Criteria</h3>
<ul>
<li>The Password should be easy to remember. <code>Dog!Wolf</code> is easy to remember, but once an attacker knows that your website gives out that combination, it makes it infinitely easier to check.</li>
<li>The words or letters should mostly follow the same sounds (for the most part).</li>
<li>At least 8 letters</li>
<li>Not use <code>!@#$%^&amp;*();'{}_+&lt;&gt;?,./</code> These punctuation marks, while appropriate for 'hard' passwords, do not have an 'easy to remember' sound. </li>
</ul>
<h3>Resources</h3>
<p>This question is language-agnostic, but if there's a specific implementation for C#, I'd be glad to hear of it.</p>
<h3>Update</h3>
<p>A few users have said that 'this is bad password security'. <strong>Don't</strong> assume that this is for a website.  This could just be for me to make an application for myself that generates passwords according to these rules.  Here's an example.  </p>
<blockquote>
<p>The letters
  <strong>A</strong>-<strong>C</strong>-<strong>C</strong>-<strong>L</strong>-<strong>I</strong>-<strong>M</strong>-<strong>O</strong>-<strong>P</strong> 'flow', and they happen to be two
  regular words put together
  (<strong>Acclimate</strong> and <strong>Mop</strong>). Further,
  when a user <em>says</em> these letters, or
  says them as a word, it's an actual
  word for them.  Easy to remember, but
  hard to crack (dictionary attack,
  obviously).</p>
</blockquote>
<p>This question has a two-part goal:</p>
<ol>
<li>Construct Passwords from letters that sound similar (using alliteration) or</li>
<li>Construct Passwords that mesh common words similarly to produce a third set of letters that is not in a dictionary.</li>
</ol>
</div></text><author><a href="/users/16587/george-stocker">George Stocker</a></author><comments><comment><text><span class="comment-copy">This seems way to subjective to ever get any kind of useful answer. EG: prime numbers make sense to math/programming geeks, but nobody else knows or cares about them. It'd likewise be similar for words/letters</span></text><author><a class="comment-user" href="/users/234/orion-edwards" title="75,205 reputation">Orion Edwards</a></author></comment><comment><text><span class="comment-copy">@Orion Edwards: 'subjective' in TMTOWTDI? I'm not sure what is 'subjective' about the answer. Are there methods to do this, or aren't? If there are methods, how would we go about doing them? I'm not sure any of that is subjective; but feel free to respond with why it is subjective.</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">The more rules you have to your algorithm the more chance that the password can be brute forced. Disallowing characters totally diminishes the strength of any passwords generated.</span></text><author><a class="comment-user" href="/users/74861/fraser" title="8,880 reputation">Fraser</a></author></comment><comment><text><span class="comment-copy">No, subjective in that "easy sounding" is entirely dependent on who you are, where you live, etc</span></text><author><a class="comment-user" href="/users/234/orion-edwards" title="75,205 reputation">Orion Edwards</a></author></comment><comment><text><span class="comment-copy">Doesn't the update state this is NOT programming related? Where's the close war?</span></text><author><a class="comment-user" href="/users/44065/jmucchiello" title="13,257 reputation">jmucchiello</a></author></comment><comment><text><span class="comment-copy">Huh? I think the word 'program' indicates programming related. as does 'algorithm'.</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Downvoted by SO Sucks (as retaliation, according to him): <a href="http://stackoverflow.com/questions/311030/we-need-more-moderators/654237#654237" title="we need more moderators">stackoverflow.com/questions/311030/we-need-more-moderators/…</a></span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Also, you may want to check: Microsoft Research Paraphrase Phrase Tables: <a href="http://research.microsoft.com/en-us/downloads/eceb4aba-f3a9-4535-9a07-95959611f613/" rel="nofollow noreferrer">research.microsoft.com/en-us/downloads/…</a></span></text><author><a class="comment-user" href="/users/74861/fraser" title="8,880 reputation">Fraser</a></author></comment><comment><text><span class="comment-copy">I can't believe no-one has linked to this article on The Daily WTF: <a href="http://thedailywtf.com/Articles/The-Automated-Curse-Generator.aspx" rel="nofollow noreferrer">thedailywtf.com/Articles/The-Automated-Curse-Generator.aspx</a></span></text><author><a class="comment-user" href="/users/276957/codinginsomnia" title="1,278 reputation">CodingInsomnia</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>You might want to look at:</p>
<ul>
<li>The pronouncable password generation algorithm used by <a href="http://www.adel.nursat.kz/apg/" rel="nofollow noreferrer">apg</a> and explained in <a href="http://www.nist.gov/manuscript-publication-search.cfm?pub_id=901456" rel="nofollow noreferrer">FIPS-181</a></li>
<li><a href="http://shorl.com/koremutake" rel="nofollow noreferrer">Koremutake</a></li>
</ul>
</div></text><author><a href="/users/2119/can-berk-g%c3%bcder">Can Berk Güder</a></author><comments><comment><text><span class="comment-copy">I like passook =&gt;  <a href="http://mackers.com/misc/scripts/passook/" rel="nofollow noreferrer">mackers.com/misc/scripts/passook</a> for this.</span></text><author><a class="comment-user" href="/users/67819/randomnickname42" title="4,892 reputation">RandomNickName42</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>First of all make sure the password is long. Consider using a "pass-phrase" instead of a single "pass-word". Breaking pass-phrases like "Dogs and wolves hate each other." is very hard yet they are quite easy to remember.</p>
<p>Some sites may also give you an advice which may be helpful, like <a href="http://www.microsoft.com/protect/yourself/password/create.mspx" rel="noreferrer">Strong passwords: How to create and use them</a> (linked from <a href="http://www.microsoft.com/protect/yourself/password/checker.mspx" rel="noreferrer">Password checker</a>, which is a useful tool on its own).</p>
<p>Also, instead of trying to create easy to remember password, in some cases a much better alternative is to avoid remembering the password at all by using (and educating your users to use) a good password management utility (see <a href="http://stackoverflow.com/questions/11362/what-is-your-favorite-password-storage-tool">What is your favourite password storage tool?</a>) - when doing this, the only part left is to create a hard to crack password, which is easy (any long enough random sentence will do).</p>
</div></text><author><a href="/users/16673/suma">Suma</a></author><comments><comment><text><span class="comment-copy">How do you deal with case sensitivity, or with how a user forgets how they wrote it; with security questions, I run into that all the time.</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">I think the plural is "wolves"... :-)</span></text><author><a class="comment-user" href="/users/73869/jimmy-j" title="1,382 reputation">Jimmy J</a></author></comment><comment><text><span class="comment-copy">The other problem is that the longer the password, the less usable it is. Sure, we can type 100+ WPM, but the average user hunts-and-pecks.</span></text><author><a class="comment-user" href="/users/22184/adriano-varoli-piazza" title="3,972 reputation">Adriano Varoli Piazza</a></author></comment><comment><text><span class="comment-copy">@Adriano Varoli Piazza: Excellent point!</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Reminds me of how precisely a phrase can locate one particular document on the web.  Often I can't remember a document's title (or context), and only recall a particular phrase - it works surprisingly well.  Another trick is a phrase across sentences (end of one sentence + start of the next one).</span></text><author><a class="comment-user" href="/users/50979/13ren" title="5,655 reputation">13ren</a></author></comment><comment><text><span class="comment-copy">@Jimmy J: No guessing-this-password for YOU!  :-)</span></text><author><a class="comment-user" href="/users/50979/13ren" title="5,655 reputation">13ren</a></author></comment><comment><text><span class="comment-copy">Unfortunately a lot of websites truncate passwords, commonly to 32 characters but in some extreme cases clip it to 10.</span></text><author><a class="comment-user" href="/users/74496/rjh" title="31,290 reputation">rjh</a></author></comment><comment><text><span class="comment-copy">Another problem is that you need to make sure the pass has at least one upper case, one special symbol, one lowercase and one number, to pass the stupid rules in all those stupid sites that force all these rules. These are the hardest to remember for me.</span></text><author><a class="comment-user" href="/users/3314/daniel-magliola" title="11,422 reputation">Daniel Magliola</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You could use Markov Chains to generate words that sounds like English(or any other language you want) but they are not actual words. </p>
<p>The question of easy to remember is really subjective, so I don't think you can write an algorithm like this that will be good for everyone. </p>
<p>And why use short passwords on web sites/computer applications instead of pass phrases? They are easy to remember but hard to crack.</p>
</div></text><author><a href="/users/11525/alex-reitbort">Alex Reitbort</a></author><comments><comment><text><span class="comment-copy">@Alex: Three questions, What are Markov Chains, How would they help me, and three, what methods are there for using pass phrases for Web Applications (specifically, .NET, but any language would do).</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">@Gortok: Pass phrase is using some phrase like "My name is Alex" as password.</span></text><author><a class="comment-user" href="/users/11525/alex-reitbort" title="11,197 reputation">Alex Reitbort</a></author></comment><comment><text><span class="comment-copy">@Gortok: Markov chains let you generate words that easier to remember then random passwords, but still they not words, so they can sustain dictionary attack</span></text><author><a class="comment-user" href="/users/11525/alex-reitbort" title="11,197 reputation">Alex Reitbort</a></author></comment><comment><text><span class="comment-copy">@Alex: That was a subtle hint for you to include something about Markov chains (more than 'use them') in your answer. If Stack Overflow is to be a repository for useful programming information, then Google should not be a primary resource. Other sites may be, but not Google.</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">ok kids, re:Markov Chains, basically scan some English text, letter by letter, and gather probability of each letter following each other letter. Then use those probabilities to generate random password, letter by letter.</span></text><author><a class="comment-user" href="/users/76859/zvolkov" title="13,333 reputation">zvolkov</a></author></comment><comment><text><span class="comment-copy">Please be aware that Markov chains by definition can also generate "real" words, including those that were used to build them and those you don't want to appear in production code (slurs, insults, obscenities, etc).</span></text><author><a class="comment-user" href="/users/92048/alan-plum" title="7,379 reputation">Alan Plum</a></author></comment><comment><text><span class="comment-copy">@AlexReitbort The password generator at <a href="http://www.multicians.org/thvv/gpw.html" rel="nofollow noreferrer">multicians.org/thvv/gpw.html</a> does what you suggest with Markov chains. <a href="http://aspirine.org/htpasswd.html" rel="nofollow noreferrer">aspirine.org/htpasswd.html</a> too, with a few refinements like complete passphrases in several languages.</span></text><author><a class="comment-user" href="/users/2637094/fpirsch" title="90 reputation">fpirsch</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I am surprised no one has mentioned the Multics algorithm described at <a href="http://www.multicians.org/thvv/gpw.html" rel="nofollow noreferrer">http://www.multicians.org/thvv/gpw.html</a> , which is similar to the FIPS algorithm but based on trigraphs rather than digraphs.  It produces output such as </p>
<pre><code>ahmouryleg
thasylecta
tronicatic
terstabble
</code></pre>
<p>I have ported the code to python as well:  <a href="http://pastebin.com/f6a10de7b" rel="nofollow noreferrer">http://pastebin.com/f6a10de7b</a></p>
</div></text><author><a href="/users/76310/joe-koberg">Joe Koberg</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>After many years, I have decided to use the first letter of words in a passphrase. It's impossible to crack, versatile for length and restrictions like "you must have a digit", and hard to make errors.  </p>
<p>This works by creating a phrase. A <strong>crazy fun vivid topic</strong> is useful!
"Stack Overflow aliens landed without using rockets or wheels".
Take the first letter, your password is "soalwurow"</p>
<p>You can type this <strong>quickly</strong> and <strong>accurately</strong> since you're not remembering letter by letter, you're just speaking a sentence inside your head.</p>
<p>I also like having words alternate from the left and right side of the keyboard, it gives you a fractionally faster typing speed and more pleasing rhythm. Notice in my example, your hands alternate left-right-left-right.</p>
</div></text><author><a href="/users/74222/spworley">SPWorley</a></author><comments><comment><text><span class="comment-copy">The only think one needs to be careful about is not using single letter word substitutions, like "u" or "c". Otherwise, "What are you to do if you see flying pigs" could be wru2diucfp instead of waytdiysfp. Argh! The pundits were right, text messaging shortcuts ARE killing the English language. :-)</span></text><author><a class="comment-user" href="/users/26931/armstrongest" title="8,801 reputation">Armstrongest</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I have a few times used a following algorithm:</p>
<ol>
<li>Put all lowercase vowels (from a-z) into an array <em>Vowels</em></li>
<li>Put all lowercase consonants (from a-z) into another array <em>Consonants</em></li>
<li>Create a third array <em>Pairs</em> of two letters in such a way, that you create all possible pairs of letters between <em>Vowels</em> and <em>Consonants</em> ("ab", "ba", "ac", etc...)</li>
<li>Randomly pick 3-5 elements from <em>Pairs</em> and concatenate them together as string <em>Password</em></li>
<li>Randomly pick <code>true</code> or <code>false</code>
<ol>
<li>If <code>true</code>, remove the last letter from <em>Password</em></li>
<li>If <code>false</code>, don't do anything</li>
</ol></li>
<li>Substitute 2-4 randomly chosen characters in <em>Password</em> with its uppercase equivalent</li>
<li>Substitute 2-4 randomly chosen characters in <em>Password</em> with a randomly chosen integer 0-9</li>
</ol>
<p>Voilá - now you should have a password of length between 5 and 10 characters, with upper and lower case alphanumeric characters. Having vowels and consonants take turns frequently make them semi-pronounceable and thus easier to remember.</p>
</div></text><author><a href="/users/2238/henrik-paul">Henrik Paul</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>FWIW I quite like jumbling word syllables for an easy but essentially random password. Take "Bongo" for example as a random word. Swap the syllables you get "Gobong". Swap the o's for zeros on top (or some other common substitution) and you've got an essentially random character sequence with some trail that helps you remember it.</p>
<p>Now how you pick out syllables programmatically - that's a whole other question!</p>
</div></text><author><a href="/users/7262/marce">MarcE</a></author><comments><comment><text><span class="comment-copy">So how do you pick them out programmatically if you were to use this approach you suggest?</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Hmmm. I've just done some looking and it appears that algorithmically defining a "syllable" isn't easy; I can't even find a pre-canned dictionary of them to use. So it's probably not an approach suited to a program. Sorry, not really an answer after all :-(</span></text><author><a class="comment-user" href="/users/7262/marce" title="2,540 reputation">MarcE</a></author></comment><comment><text><span class="comment-copy">You could look for a regex pattern at the end of the word. Off the top of my head, the consonant before the last vowel, and don't include "e" if it's the final letter. Works for the first five words that I think of: monKEY, giRAFFE ( "e" excluded ), influenZA, granoLA, polymorpHISM. (ALMOST works, I guess you'd have to include common compound letters, like th, ph, sh etc.) This would be so much simpler in Japanese. Each character represents a full syllable.</span></text><author><a class="comment-user" href="/users/26931/armstrongest" title="8,801 reputation">Armstrongest</a></author></comment><comment><text><span class="comment-copy">The great thing about the di- and tri-graph weight based generators, is they automatically take into account how syllables are constructed</span></text><author><a class="comment-user" href="/users/76310/joe-koberg" title="13,918 reputation">Joe Koberg</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>When you generate a password for the user and send it by email, the first thing you should do when they first login if force them to change their password. Passwords created by the system do not need to be easy to remember because they should only be needed once. </p>
<p>Having easy to remember, hard to guess passwords is a useful concept for your users but is not one that the system should in some manner enforce. Suppose you send a password to your user's gmail account and the user doesn't change the password after logging in. If the password to the gmail account is compromised, then the password to your system is compromised.</p>
<p>So generating easy to remember passwords for your users is not helpful if they have to change the password immediately. And if they aren't changing it immediately, you have other problems.</p>
</div></text><author><a href="/users/44065/jmucchiello">jmucchiello</a></author><comments><comment><text><span class="comment-copy">Great Answer: but I should have been more clear. This isn't necessarily for other users to use.  This could be making a self password generator. I have about 7 random passwords I use, and I'd like to implement an 'easier to remember' structure. $ and ! are not easy to 'say (and commit to memory)</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I prefer giving users a "hard" password, requiring them to change it on the first use, and giving them guidance on how to construct a good, long pass phrase.  I would also couple this with reasonable password complexity requirements (8+ characters, upper/lower case mix, and punctuation or digits).  My rationale for this is that people are much more likely to remember something that they choose themselves and less likely to write it down somewhere if they can remember it.</p>
</div></text><author><a href="/users/12950/tvanfosson">tvanfosson</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>A spin on the 'passphrase' idea is to take a phrase and write the first letters of each word in the phrase. E.g.</p>
<pre><code>"A specter is haunting Europe - the specter of communism."
</code></pre>
<p>Becomes</p>
<pre><code>asihe-tsoc
</code></pre>
<p>If the phrase happens to have punctation, such as !, ?, etc - might as well shove it in there. Same goes for numbers, or just substitute letters, or add relevant numbers to the end. E.g. Karl Marx (who said this quote) died in 1883, so why not 'asihe-tsoc83'?</p>
<p>I'm sure a creative brute-force attack could capitalise on the statistical properties of such a password, but it's still orders of magnitude more secure than a dictionary attack.</p>
<hr/>
<p>Another great approach is just to make up ridiculous words, e.g. 'Barangamop'. After using it a few times you will commit it to memory, but it's hard to brute-force. Append some numbers or punctuation for added security, e.g. '386Barangamop!'</p>
</div></text><author><a href="/users/74496/rjh">rjh</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Here's part 2 of your idea prototyped in a shell script.  It takes 4, 5 and 6 letter words (roughly 50,000) from the Unix dictionary file on your computer, and concatenate those words on the first character.</p>
<pre><code>#! /bin/bash

RANDOM=$$
WORDSFILE=./simple-words
DICTFILE=/usr/share/dict/words
grep -ve '[^a-z]' ${DICTFILE} | grep -Ee '^.{4,6}$' &gt; ${WORDSFILE}
N_WORDS=$(wc -l &lt; ${WORDSFILE})
for i in $(seq 1 20); do
    password=""
    while [ ! "${#password}" -ge 8 ] || grep -qe"^${password}$" ${DICTFILE}; do
        while [ -z "${password}" ]; do
            password="$(sed -ne "$(( (150 * $RANDOM) % $N_WORDS + 1))p" ${WORDSFILE})"
            builtfrom="${password}"
        done
        word="$(sort -R ${WORDSFILE} | grep -m 1 -e "^..*${password:0:1}")"
        builtfrom="${word} ${builtfrom}"
        password="${word%${password:0:1}*}${password}"
    done
    echo "${password} (${builtfrom})"
done
</code></pre>
<p>Like most password generators, I cheat by outputting them in sets of twenties.  This is often defended in terms of "security" (someone looking over your shoulder), but really its just a hack to let the user just pick the friendliest password.</p>
<p>I found the 4-to-6 letter words from the dictionary file still containing obscure words.</p>
<p>A better source for words would be a written document.  I copied all the words on this page and pasted them into a text document, and then ran the following set of commands to get the <em>actual</em> english words.</p>
<pre><code>perl -pe 's/[^a-z]+/\n/gi' ./624425.txt | tr A-Z a-z | sort -u &gt; ./words
ispell -l ./words | grep -Fvf - ./words &gt; ./simple-words
</code></pre>
<p>Then I used these 500 or so very simple words from this page to generate the following passwords with the shell script -- the script parenthetically shows the words that make up a password.</p>
<pre><code>backgroundied (background died)
soundecrazy (sounding decided crazy)
aboupper (about upper)
commusers (community users)
reprogrammer (replacing programmer)
alliterafter (alliteration after)
actualetter (actual letter)
statisticrhythm (statistical crazy rhythm)
othereplacing (other replacing)
enjumbling (enjoying jumbling)
feedbacombination (feedback combination)
rinstead (right instead)
unbelievabut (unbelievably but)
createdogso (created dogs so)
apphours (applications phrase hours)
chainsoftwas (chains software was)
compupper (computer upper)
withomepage (without homepage)
welcomputer (welcome computer)
choosome (choose some)
</code></pre>
<p>Some of the results in there are winners.  </p>
<p>The prototype shows it can probably be done, but the intelligence you require about alliteration or syllable information requires a better data source than just words.  You'd need pronunciation information.  Also, I've shown you probably want a database of good simple words to choose from, and not <em>all</em> words, to better satisfy your memorable-password requirement.</p>
<p>Generating a single password the first time and every time -- something you need for the Web -- will take both a better data source and more sophistication.  Using a better programming language than Bash with text files and using a database could get this to work instantaneously.  Using a database system you could use the SOUNDEX algorithm, or some such.</p>
<p>Neat idea.  Good luck.</p>
</div></text><author><a href="/users/73449/ashawley">ashawley</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm completely with rjh. The advantage of just using the starting letters of a pass-phrase is that it looks random, which makes it damn hard to remember if you don't know the phrase behind it, in case Eve looks over your shoulder as you type the password.<br/>
OTOH, if she sees you type about 8 characters, among which 's' twice, and then 'o' and 'r' she may guess it correctly the first time.<br/>
Forcing the use of at least one digit doesn't really help; you simply <em>know</em> that it will be "pa55word" or "passw0rd".</p>
<p>Song lyrics are an inexhaustible source of pass-phrases. </p>
<pre><code>"But I should have known this right from the start"
</code></pre>
<p>becomes "bishktrfts". 10 letters, even only lowercase gives you 10^15 combinations, which is <em>a lot</em>, especially since there's no shortcut for cracking it. (At 1 million combinations a second it takes 30 years to test all 10^15 combinations.)<br/>
As an extra (in case Eve knows you're a Police fan), you could swap e.g. the 2nd and 3rd letter, or take the second letter of the third word. Endless possibilities.</p>
</div></text><author><a href="/users/66056/stevenvh">stevenvh</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>System generated passwords are a bad idea for anything other than internal service accounts or temporary resets (etc).</p>
<p>You should always use your own "passphrases" that are easy for you to remember but that are almost impossible to guess or brute force. For example the password for my old university account was.</p>
<blockquote>
<p><code>Here to study again!</code></p>
</blockquote>
<p>That is 20 characters using upper and lower case with punctuation. This is an unbelievably strong password and there is no piece of software that could generate a more secure one that is easier to remember for me.</p>
</div></text><author><a href="/users/74861/fraser">Fraser</a></author><comments><comment><text><span class="comment-copy">Pretend I want this to generate my own random letters that would make up a password; and not necessarily to hand out as a password to general users.</span></text><author><a class="comment-user owner" href="/users/16587/george-stocker" title="41,730 reputation">George Stocker<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy"><a href="http://www.codinghorror.com/blog/archives/000342.html" rel="nofollow noreferrer">codinghorror.com/blog/archives/000342.html</a></span></text><author><a class="comment-user" href="/users/3/jarrod-dixon" title="12,852 reputation">Jarrod Dixon<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Jarrrod, are you trying to say I copied that site? I like helping people and they are my own words. I agree there is a striking similarity and I would be suspicious too if it was not a such a common practice. I'm sorry if that was not your implication but I am not a plagiarist!</span></text><author><a class="comment-user" href="/users/74861/fraser" title="8,880 reputation">Fraser</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Take look at the <a href="http://www.multicians.org/thvv/tvvtools.html#SecurityTools" rel="nofollow noreferrer">gpw tool</a>.  The package is also available in Debian/Ubuntu repositories.</p>
</div></text><author><a href="/users/13767/rafa%c5%82-rawicki">Rafał Rawicki</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>One way to generate passwords that 'sound like' words would be to use a markov chain. An n-degree markov chain is basically a large set of n-tuples that appear in your input corpus, along with their frequency. For example, "aardvark", with a 2nd-degree markov chain, would generate the tuples (a, a, 1), (a, r, 2), (r, d, 1), (d, v, 1), (v, a, 1), (r, k, 1). Optionally, you can also include 'virtual' start-word and end-word tokens.</p>
<p>In order to create a useful markov chain for your purposes, you would feed in a large corpus of english language data - there are many available, including, for example, Project Gutenburg - to generate a set of records as outlined above. For generating natural language words or sentences that at least mostly follow rules of grammar or composition, a 3rd degree markov chain is usually sufficient.</p>
<p>Then, to generate a password, you pick a random 'starting' tuple from the set, weighted by its frequency, and output the first letter. Then, repeatedly select at random (again weighted by frequency) a 'next' tuple - that is, one that starts with the same letters that your current one ends with, and has only one letter different. Using the example above, suppose I start at (a, a, 1), and output 'a'. My only next choice is (a, r, 2), so I output another 'a'. Now, I can choose either (r, d, 1) or (r, k, 1), so I pick one at random based on their frequency of occurrence. Suppose I pick (r, k, 1) - I output 'r'. This process continues until you reach an end-of-word marker, or decide to stop independently (since most markov chains form a cyclic graph, you can potentially never finish generating if you don't apply an artificial length limitation).</p>
<p>At a word level (eg, each element of the tuple is a word), this technique is used by some 'conversation bots' to generate sensible-seeming nonsense sentences. It's also used by spammers to try and evade spam filters. At a letter level, as outlined above, it can be used to generate nonsense words, in this case for passwords.</p>
<p>One drawback: If your input corpus doesn't contain anything other than letters, nor will your output phrases, so they won't pass most 'secure' password requirements. You may want to apply some post-processing to substitute some characters for numbers or symbols.</p>
</div></text><author><a href="/users/12030/nick-johnson">Nick Johnson</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>edit: After answering, I realized that this is in no way phonetically memorable. Leaving the answer anyway b/c I find it interesting.     /edit</p>
<p>Old thread, I know... but it's worth a shot.</p>
<p>1) I'd probably build the largest dictionary you can ammass. Arrange them into buckets by part of speech.</p>
<p>2)Then, build a grammar that can make several types of sentences. "Type" of sentence is determined by permutations of parts of speech.</p>
<p>3)Randomly (or as close to random as possible), pick a type of sentence. What is returned is a pattern with placeholders for parts of speech (n-v-n would be noun-verb-noun)</p>
<p>3)Pick words at random in each part of speech bucket to stand in for the placeholders. Fill them in. (The example above might become something like car-ate-bicycle.)</p>
<p>4)randomly scan each character deciding whether or not you want to replace it with either a similar-sounding character (or set of characters), or a look-alike. This is the hardest step of the problem.</p>
<p>5) resultant password would be something like kaR@tebyCICle</p>
<p>6) laugh at humorous results like the above that look like "karate bicycle"</p>
</div></text><author><a href="/users/124493/san-jacinto">San Jacinto</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would really <strong>love</strong> to see someone implement passwords with control characters like "<code>&lt;Ctrl&gt;+N</code>" or even combo characters like "<code>A+C</code>" at the same time.  Converting this to some binary equivalent would, IMHO, make password requirements much easier to remember, faster to type, and harder to crack (MANY more combinations to check).</p>
</div></text><author><a href="/users/62248/mike">Mike</a></author><comments/></answer></answers></post>