<?xml version="1.0" encoding="utf-8"?>
<post><title>android - How to keep the OAuth consumer secret safe, and how to react when it's compromised? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>This question is about trying to understand the security risks involved in implementing oauth on a mobile platform like Android. Assumption here is that we have an Android application that has the consumer key/secret embedded in the code.</p>
<p>Assuming a consumer secret has been compromised, and a hacker has gotten a hold of it, what are the consequences of this ?</p>
<p><strong>Compromised Consumer Secret assumptions</strong><br/>
Am I correct in stating that a compromised consumer secret as such has no effect on the user's security, or any data stored at the OAuth enabled provider that the user was interacting with. The data itself is not compromised and cannot be retrieved by the hacker. </p>
<p>The hacker would need to get a hold of a valid user access token, and that's a lot harder to get.</p>
<p><strong>What could a hacker do with a compromised consumer secret ?</strong><br/>
Am I also correct in stating the following : </p>
<ul>
<li>The hacker can setup/publish an
application that imitates my app. </li>
<li>The hacker can attract users that will go
through the OAuth flow, retrieving an
access token via the hackers OAuth
dance (using the compromised consumer
key/secret). </li>
<li>The user might think
he's dealing with my app, as he will
see a familiar name (consumer key)
during the authorization process.</li>
<li>When a consumer issues a request via
the hacker, the hacker can easily
intercept the access token, and
combined with the consumer secret can
now sign requests on my behalf to
gain access to my resources.</li>
</ul>
<p><strong>End-user impact</strong><br/>
In the assumption that </p>
<ul>
<li>a hacker has setup an application /
site using my consumer secret </li>
<li>one of my users was tricked into authorizing
access to that application / site</li>
</ul>
<p>The following might happen :</p>
<ul>
<li>the end-user may being noticing that something fishy is going on, and inform the service provider (ex: Google) about the malicious app  </li>
<li>the service provider can then revoke the consumer key/secret</li>
</ul>
<p><strong>OAuth consumer (my application) impact :</strong><br/>
My app (containing the consumer secret) would need to be updated, as otherwise all my clients would not be able to authorize my application do to requests on their behalf anymore (as my consumer secret would no longer be valid).</p>
<p><strong>Delegating all OAuth traffic</strong><br/>
Although it would be possible to delegate a lot of the OAuth interactions via an intermediate webserver (doing the OAuth dance and sending the access token to the user), one would have to proxy all service interactions also, as the consumer key/secret is required for signing each request. Is this the only way to keep the consumer key/secret outside of the mobile app, and stored in a more secure place on the intermediate webserver ?</p>
<p><strong>Alternatives</strong><br/>
Are there alternatives for this proxy-ing ? Is it possible to store the consumer secret at the intermediate webserver, and have some kind of mechanism that the Android application (published in the market and properly signed), can do a secure request to the intermediate webserver to fetch the consumer secret and store it internally in the app ? Can a mechanism be implemented that the intermediate webserver "knows" that this is an official android app that is requesting to fetch the consumer secret, and that the intermediate webserver will only handout the consumer secret to that particular android app ?</p>
</div></text><author><a href="/users/492410/ddewaele">ddewaele</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p><strong>Summary</strong>: I would just take the risk and keep the secret in the client app.</p>
<p><strong>Proxy server alternative</strong>:</p>
<p>The only way you can reasonable mitigate the problems I list below and make the proxy-ing work, would be to go the whole nine yards - move all the business logic for dealing with the resources on the third party webservice to your proxy server, and make the client app dumb terminal with rich UI. This way, the only actions the malicious app would be able to make the proxy perform on its behalf would be only what your business logic legitimately needs.</p>
<p>But now you get in the realm of a whole slew of other problems having to deal with reliability and scalability.</p>
<p><strong>Long deliberation on why simple proxy wouldn't work</strong>:</p>
<blockquote>
<p>Some people, when confronted with a
  problem, think “I know, I'll add my
  own proxy server” Now they have two
  problems. (with apologies to Jamie
  Zawinski)</p>
</blockquote>
<p>Your assumptions are largely right. Right down to the point where you start thinking about your own server, whether it keeps the secret and proxies the calls for the client app, or it attempts to determine if the app is legitimate and give it the secret. In both approaches, you still have to solve the problem of "is this request coming from a piece of code I wrote"?</p>
<p>Let me repeat - <strong>there is no way to distinguish on the wire that particular piece of software is running. If the data in the messages looks right, nothing can prove it's another app that's sending that message</strong>.</p>
<p>At the end of the day, if I am writing a malicious app, I don't care if I actually know the real secret, as long as I can make somebody that knows it do a work on my behalf. So, if you think a malicious app can impersonate your app to the third party OAuth servers, why are you certain it can't impersonate your app to your proxy?</p>
<p>But wait, there's more. The domain at which your proxy service is located, is your identity to both your clients and the OAuth provider (as shown to the end user by the OAuth provider). If a malicious app can make your server do bad stuff, not only is your key revoked, but your public web identity is also not trusted anymore.</p>
<hr/>
<p>I will start with the obvious - there is no way to distinguish on the wire that particular piece of software is running. If the data in the messages looks right, nothing can prove it's another app that's sending that message.</p>
<p>Thus, any algorithm that relies on app-side stored secret can be spoofed. OAuth's strength is that it never gives the user's credentials to the app, instead giving the app temporary credentials of it's own that the user can revoke if necessary.</p>
<p>Of course, the weak point here is that a sufficiently good app can get the user to trust it and not revoke the credentials, before it finished its nefarious deeds.</p>
<p>However, one way to mitigate this is Google's approach of using 3-legged OAuth, instead of the standard 2-legged. In the 3-legged OAuth, there's no pre-assigned secret, but on every authentication a new access token secret is issued, along with each access token. While ultimately this suffers from the same drawback, as a bad app can read the good app's token secret from its process, it does result in the user having to approve the app access every time it needs new access token.</p>
<p>And of course, this also means that it's a bit more inconvenient and annoying for the user.</p>
</div></text><author><a href="/users/17028/franci-penov">Franci Penov</a></author><comments><comment><text><span class="comment-copy">I've edited the question a bit. I want to make sure that the assumptions I'm making in the question are correct. I also don't want to avoid the inconvenience towards the users. So I see 2 options. 1. just take the risk, keep the secret in the code and do some obfuscation. or 2. do the proxy-ing and keep the secret on the webserver where I'm fairly sure it would not get compromised. Is that a fair conclusion ?</span></text><author><a class="comment-user owner" href="/users/492410/ddewaele" title="16,727 reputation">ddewaele</a></author></comment><comment><text><span class="comment-copy">Thanks a lot for the updated answer !</span></text><author><a class="comment-user owner" href="/users/492410/ddewaele" title="16,727 reputation">ddewaele</a></author></comment><comment><text><span class="comment-copy">I have one question about this. Why do you say it's impossible to see that the code calling is the one you wrote. Couldn't you just send some token that is linked to your app signature which in turn is linked to your certificate. Only your apps are signed with your certificate and this file is kept private anyway.</span></text><author><a class="comment-user" href="/users/2161029/psixo" title="1,987 reputation">PSIXO</a></author></comment><comment><text><span class="comment-copy">What I mean is, authorise calls to your proxy server with value you get from this Signature[] sigs = context.getPackageManager().getPackageInfo(context.getPackag‌​eName(), PackageManager.GET_SIGNATURES).signatures; for (Signature sig : sigs) {     Trace.i("MyApp", "Signature hashcode : " + sig.hashCode()); }</span></text><author><a class="comment-user" href="/users/2161029/psixo" title="1,987 reputation">PSIXO</a></author></comment><comment><text><span class="comment-copy">And why can't my app run that same code, but instead of <code>context.getPackageInfo()</code> it hardcodes <code>"com.your.app_name"</code>?</span></text><author><a class="comment-user" href="/users/17028/franci-penov" title="59,266 reputation">Franci Penov</a></author></comment></comments></answer></answers></post>