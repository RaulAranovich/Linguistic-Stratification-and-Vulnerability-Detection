<?xml version="1.0" encoding="utf-8"?>
<post><title>security - The definitive guide to form-based website authentication - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<h2>Form-based authentication for websites</h2>
<p>We believe that Stack Overflow should not just be a resource for very specific technical questions, but also for general guidelines on how to solve variations on common problems. "Form based authentication for websites" should be a fine topic for such an experiment.</p>
<h3>It should include topics such as:</h3>
<ul>
<li>How to log in</li>
<li>How to remain logged in</li>
<li>Managing cookies (including recommended settings)</li>
<li>SSL/HTTPS encryption</li>
<li>How to store passwords</li>
<li>Using secret questions</li>
<li>Forgotten username/password functionality</li>
<li>Use of <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce" rel="noreferrer">nonces</a> to prevent <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noreferrer">cross-site request forgeries (CSRF)</a></li>
<li><a href="http://openid.net/" rel="noreferrer">OpenID</a></li>
<li>"Remember me" checkbox</li>
<li>Browser autocompletion of usernames and passwords</li>
<li>Secret URLs (public <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Locator" rel="noreferrer">URL</a> protected by digest)</li>
<li>Checking password strength</li>
<li>E-mail validation</li>
<li><em>and much more about</em> <a href="http://en.wikipedia.org/wiki/Form-based_authentication" rel="noreferrer">form based authentication</a>...</li>
</ul>
<h3>It should not include things like:</h3>
<ul>
<li>Roles and authorization</li>
<li>HTTP basic authentication</li>
</ul>
<h3>Please help us by:</h3>
<ol>
<li>Suggesting subtopics</li>
<li>Submitting good articles about this subject</li>
<li>Editing the official answer</li>
</ol>
</div></text><author><a href="/users/136">Michiel de Mare</a></author><comments><comment><text><span class="comment-copy">Why exclude HTTP Basic Authentication? It can work in HTML Forms via Ajax: <a href="http://www.peej.co.uk/articles/http-auth-with-html-forms.html" rel="nofollow noreferrer">peej.co.uk/articles/http-auth-with-html-forms.html</a></span></text><author><a class="comment-user" href="/users/52963/system-pause" title="19,505 reputation">system PAUSE</a></author></comment><comment><text><span class="comment-copy">HTTP Basic Auth has the property of being (comparatively) difficult to make a browser forget. It's also horribly insecure if you don't use it with SSL to secure the connection (i.e., HTTPS).</span></text><author><a class="comment-user" href="/users/301832/donal-fellows" title="88,464 reputation">Donal Fellows</a></author></comment><comment><text><span class="comment-copy">I think it'd be worth talking about sessions (including fixation and hijacking) cookies (the secure and http only flags) HTTP based SSO</span></text><author><a class="comment-user" href="/users/223992/symcbean" title="35,653 reputation">symcbean</a></author></comment><comment><text><span class="comment-copy">Key Stretching for decreasing dictionary attacks if your passwords are comprimised - <a href="http://en.wikipedia.org/wiki/Key_strengthening" rel="nofollow noreferrer">en.wikipedia.org/wiki/Key_strengthening</a></span></text><author><a class="comment-user" href="/users/252253/james" title="5,479 reputation">James</a></author></comment><comment><text><span class="comment-copy">The super-useful <code>HttpOnly</code> cookie flag, which prevents JavaScript-based cookie theft (a subset of XSS attacks), should be mentioned somewhere too.</span></text><author><a class="comment-user" href="/users/211327/alan-h" title="7,353 reputation">Alan H.</a></author></comment><comment><text><span class="comment-copy">We should probably have a best-practices tag or something similar for excellent questions and answers like this one.</span></text><author><a class="comment-user" href="/users/202648/ptman" title="587 reputation">ptman</a></author></comment><comment><text><span class="comment-copy">reference implementations?</span></text><author><a class="comment-user" href="/users/55948/kenwarner" title="16,138 reputation">kenwarner</a></author></comment><comment><text><span class="comment-copy">I vote on closing because I believe this question in its current state does not fit SO format. One long answer that everyone's editing seems plain wrong. Instead, I would reformat it into <a href="http://programmers.stackexchange.com/questions/46716/what-should-a-developer-know-before-building-a-public-web-site">small useful chunks like they did with this question</a> (most upvoted question on Programmers).</span></text><author><a class="comment-user" href="/users/458193/dan-abramov" title="100,068 reputation">Dan Abramov</a></author></comment><comment><text><span class="comment-copy">Wow. Lengthy answers, dozens of upvotes for some of them, yet nobody mentions the common mistake of serving login forms over HTTP. I've even argued with people who said "but it submits to https://..." and only got blank stares when I asked if they were sure an attacker didn't rewrite the non-encrypted page the form was served over.</span></text><author><a class="comment-user" href="/users/162354/dzuelke" title="1,978 reputation">dzuelke</a></author></comment><comment><text><span class="comment-copy">Good point @dzuelke, not to mention that the user has no direct way of checking that its sensitive data is going to be transmitted over a secure connection to a trustworthy server (i mean, checking the server certificate)</span></text><author><a class="comment-user" href="/users/4483113/idelvall" title="728 reputation">idelvall</a></author></comment><comment><text><span class="comment-copy"><a href="https://github.com/FallibleInc/security-guide-for-developers" rel="nofollow noreferrer">github.com/FallibleInc/security-guide-for-developers</a> is a good reference</span></text><author><a class="comment-user" href="/users/56145/matt-kocaj" title="7,441 reputation">Matt Kocaj</a></author></comment><comment><text><span class="comment-copy">There is a suggestion to move the question to SO Documentation <a href="http://meta.stackoverflow.com/questions/332092/should-we-move-so-guides-to-documentation" title="should we move so guides to documentation">meta.stackoverflow.com/questions/332092/…</a></span></text><author><a class="comment-user" href="/users/52277/michael-freidgeim" title="7,893 reputation">Michael Freidgeim</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<h2>PART I: How To Log In</h2>
<p>We'll assume you already know how to build a login+password HTML form which POSTs the values to a script on the server side for authentication. The sections below will deal with patterns for sound practical auth, and how to avoid the most common security pitfalls.</p>
<p><strong>To HTTPS or not to HTTPS?</strong></p>
<p>Unless the connection is already secure (that is, tunneled through HTTPS using SSL/TLS), your login form values will be sent in cleartext, which allows anyone eavesdropping on the line between browser and web server will be able to read logins as they pass through. This type of wiretapping is done routinely by governments, but in general we won't address 'owned' wires other than to say this: If you are protecting anything important, use HTTPS.</p>
<p>In essence, the only <strong>practical</strong> way to protect against wiretapping / packet sniffing during login is by using HTTPS or another certificate-based encryption scheme (for example, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noreferrer">TLS</a>) or a proven &amp; tested challenge-response scheme (for example, the <a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" rel="noreferrer">Diffie-Hellman</a>-based SRP). <em>Any other method can be easily circumvented</em> by an eavesdropping attacker.</p>
<p>Of course, if you are willing to get a little bit impractical, you could also employ some form of two-factor authentication scheme (e.g. the Google Authenticator app, a physical 'cold war style' codebook, or an RSA key generator dongle). If applied correctly, this could work even with an unsecured connection, but it's hard to imagine that a dev would be willing to implement two-factor auth but not SSL.</p>
<p><strong>(Do not) Roll-your-own JavaScript encryption/hashing</strong></p>
<p>Given the nonzero cost and perceived technical difficulty of setting up an SSL certificate on your website, some developers are tempted to roll their own in-browser hashing or encryption schemes in order to avoid passing cleartext logins over an unsecured wire.</p>
<p>While this is a noble thought, it is essentially useless (and can be a <a href="http://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end">security flaw</a>) unless it is combined with one of the above - that is, either securing the line with strong encryption or using a tried-and-tested challenge-response mechanism (if you don't know what that is, just know that it is one of the most difficult to prove, most difficult to design, and most difficult to implement concepts in digital security).</p>
<p>While it is true that hashing the password <em>can be</em> effective against <strong>password disclosure</strong>, it is vulnerable to replay attacks, Man-In-The-Middle attacks / hijackings (if an attacker can inject a few bytes into your unsecured HTML page before it reaches your browser, they can simply comment out the hashing in the JavaScript), or brute-force attacks (since you are handing the attacker both username, salt and hashed password).</p>
<p><strong>CAPTCHAS against humanity</strong></p>
<p><a href="http://en.wikipedia.org/wiki/CAPTCHA" rel="noreferrer">CAPTCHAs</a> are meant to thwart one specific category of attack: automated dictionary/brute force trial-and-error with no human operator. There is no doubt that this is a real threat, however there are ways of dealing with it seamlessly that don't require a CAPTCHA, specifically properly designed serverside login throttling schemes - we'll discuss those later.</p>
<p>Know that CAPTCHA implementations are not created alike; they often aren't human-solvable, most of them are actually ineffective against bots, all of them are ineffective against cheap third-world labor (according to <a href="http://en.wikipedia.org/wiki/OWASP" rel="noreferrer">OWASP</a>, the current sweatshop rate is $12 per 500 tests), and some implementations may be technically illegal in some countries (see <a href="https://www.owasp.org/index.php/Authentication_Cheat_Sheet" rel="noreferrer">OWASP Authentication Cheat Sheet</a>). If you must use a CAPTCHA, use Google's <a href="http://en.wikipedia.org/wiki/ReCAPTCHA" rel="noreferrer">reCAPTCHA</a>, since it is OCR-hard by definition (since it uses already OCR-misclassified book scans) and tries very hard to be user-friendly.</p>
<p>Personally, I tend to find CAPTCHAS annoying, and use them only as a last resort when a user has failed to login a number of times and throttling delays are maxxed out. This will happen rarely enough to be acceptable, and it strengthens the system as a whole.</p>
<p><strong>Storing Passwords / Verifying logins</strong></p>
<p>This may finally be common knowledge after all the highly-publicized hacks and user data leaks we've seen in recent years, but it has to be said: Do not store passwords in cleartext in your database. User databases are routinely hacked, leaked or gleaned through SQL injection, and if you are storing raw, plaintext passwords, that is instant game over for your login security.</p>
<p>So if you can't store the password, how do you check that the login+password combination POSTed from the login form is correct? The answer is hashing using a <a href="https://en.wikipedia.org/wiki/Key_derivation_function" rel="noreferrer">key derivation function</a>. Whenever a new user is created or a password is changed, you take the password and run it through a KDF, such as bcrypt, scrypt or PBKDF2, turning the cleartext password ("correcthorsebatterystaple") into a long, random-looking string, which is a lot safer to store in your database. To verify a login, you run the same hash function on the entered password, this time passing in the salt and compare the resulting hash string to the value stored in your database. bcrypt and scrypt store the salt with the hash already. Check out this <a href="https://security.stackexchange.com/a/31846/8340">article</a> on sec.stackexchange for more detailed information.</p>
<p>The reason a salt is used is because hashing in itself is not sufficient -- you'll want to add a so-called 'salt' to protect the hash against <a href="https://en.wikipedia.org/wiki/Rainbow_table" rel="noreferrer">rainbow tables</a>. A salt effectively prevents two passwords that exactly match from being stored as the same hash value, preventing the whole database being scanned in one run if an attacker is executing a password guessing attack.</p>
<p>A cryptographic hash should not be used for password storage because user selected passwords are not strong enough (i.e. do not usually contain enough entropy) and a password guessing attack could be completed in a relatively short time by an attacker with access to the hashes. This is why a KDF is used - these effectively <a href="https://en.wikipedia.org/wiki/Key_stretching" rel="noreferrer">"stretch the key"</a> meaning that each password guess an attacker makes involves iterating the hashing algorithm multiple times, for example 10,000 times, making the attacker's password guessing 10,000 times slower.</p>
<p><strong>Session data - "You are logged in as Spiderman69"</strong></p>
<p>Once the server has verified the login and password against your user database and found a match, the system needs a way to remember that the browser has been authenticated. This fact should only ever be stored server side in the session data.</p>
<blockquote>
<p>If you are unfamiliar with session data, here's how it works: A single randomly-generated string is stored in an expiring cookie and used to reference a collection of data - the session data - which is stored on the server. If you are using an MVC framework, this is undoubtedly handled already.</p>
</blockquote>
<p>If at all possible, make sure the session cookie has the secure and HTTP Only flags set when sent to the browser. The httponly flag provides some protection against the cookie being read by a XSS attack. The secure flag ensures that the cookie is only sent back via HTTPS, and therefore protects against network sniffing attacks. The value of the cookie should not be predictable. Where a cookie referencing a non-existent session is presented, its value should be replaced immediately to prevent <a href="https://www.owasp.org/index.php/Session_fixation" rel="noreferrer">session fixation</a>.</p>
<h2>PART II: How To Remain Logged In - The Infamous "Remember Me" Checkbox</h2>
<p>Persistent Login Cookies ("remember me" functionality) are a danger zone; on the one hand, they are entirely as safe as conventional logins when users understand how to handle them; and on the other hand, they are an enormous security risk in the hands of careless users, who may use them on public computers and forget to log out, and who may not know what browser cookies are or how to delete them.</p>
<p>Personally, I like persistent logins for the web sites I visit on a regular basis, but I know how to handle them safely. If you are positive that your users know the same, you can use persistent logins with a clean conscience. If not - well, then you may subscribe to the philosophy that users who are careless with their login credentials brought it upon themselves if they get hacked. It's not like we go to our user's houses and tear off all those facepalm-inducing Post-It notes with passwords they have lined up on the edge of their monitors, either.</p>
<p>Of course, some systems can't afford to have <em>any</em> accounts hacked; for such systems, there is no way you can justify having persistent logins.</p>
<p><strong>If you DO decide to implement persistent login cookies, this is how you do it:</strong></p>
<ol>
<li><p>First, take some time to read <a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence" rel="noreferrer">Paragon Initiative's article</a> on the subject. You'll need to get a bunch of elements right, and the article does a great job of explaining each.</p></li>
<li><p>And just to reiterate one of the most common pitfalls, <strong>DO NOT STORE THE PERSISTENT LOGIN COOKIE (TOKEN) IN YOUR DATABASE, ONLY A HASH OF IT!</strong> The login token is Password Equivalent, so if an attacker got their hands on your database, they could use the tokens to log in to any account, just as if they were cleartext login-password combinations. Therefore, use hashing (according to <a href="https://security.stackexchange.com/a/63438/5002">https://security.stackexchange.com/a/63438/5002</a> a weak hash will do just fine for this purpose) when storing persistent login tokens.</p></li>
</ol>
<h2>PART III: Using Secret Questions</h2>
<p><strong>Don't implement 'secret questions'</strong>. The 'secret questions' feature is a security anti-pattern. Read the paper from link number 4 from the MUST-READ list. You can ask Sarah Palin about that one, after her Yahoo! email account got hacked during a previous presidential campaign because the answer to her security question was... "Wasilla High School"!</p>
<p>Even with user-specified questions, it is highly likely that most users will choose either:</p>
<ul>
<li><p>A 'standard' secret question like mother's maiden name or favourite pet</p></li>
<li><p>A simple piece of trivia that anyone could lift from their blog, LinkedIn profile, or similar</p></li>
<li><p>Any question that is easier to answer than guessing their password. Which, for any decent password, is every question you can imagine</p></li>
</ul>
<p><strong>In conclusion, security questions are inherently insecure in virtually all their forms and variations, and should not be employed in an authentication scheme for any reason.</strong></p>
<p>The true reason why security questions even exist in the wild is that they conveniently save the cost of a few support calls from users who can't access their email to get to a reactivation code. This at the expense of security and Sarah Palin's reputation. Worth it? Probably not.</p>
<h2>PART IV: Forgotten Password Functionality</h2>
<p>I already mentioned why you should <strong>never use security questions</strong> for handling forgotten/lost user passwords; it also goes without saying that you should never e-mail users their actual passwords. There are at least two more all-too-common pitfalls to avoid in this field:</p>
<ol>
<li><p>Don't <em>reset</em> a forgotten password to an autogenerated strong password - such passwords are notoriously hard to remember, which means the user must either change it or write it down - say, on a bright yellow Post-It on the edge of their monitor. Instead of setting a new password, just let users pick a new one right away - which is what they want to do anyway.</p></li>
<li><p>Always hash the lost password code/token in the database. <strong><em>AGAIN</em></strong>, this code is another example of a Password Equivalent, so it MUST be hashed in case an attacker got their hands on your database. When a lost password code is requested, send the plaintext code to the user's email address, then hash it, save the hash in your database -- and <em>throw away the original</em>. Just like a password or a persistent login token.</p></li>
</ol>
<p>A final note: always make sure your interface for entering the 'lost password code' is at least as secure as your login form itself, or an attacker will simply use this to gain access instead. Making sure you generate very long 'lost password codes' (for example, 16 case sensitive alphanumeric characters) is a good start, but consider adding the same throttling scheme that you do for the login form itself.</p>
<h2>PART V: Checking Password Strength</h2>
<p>First, you'll want to read this small article for a reality check: <a href="http://www.whatsmypass.com/?p=415" rel="noreferrer">The 500 most common passwords</a></p>
<p>Okay, so maybe the list isn't the <em>canonical</em> list of most common passwords on <em>any</em> system <em>anywhere ever</em>, but it's a good indication of how poorly people will choose their passwords when there is no enforced policy in place. Plus, the list looks frighteningly close to home when you compare it to publicly available analyses of recently stolen passwords.</p>
<p>So: With no minimum password strength requirements, 2% of users use one of the top 20 most common passwords. Meaning: if an attacker gets just 20 attempts, 1 in 50 accounts on your website will be crackable.</p>
<p>Thwarting this requires calculating the entropy of a password and then applying a threshold.  The National Institute of Standards and Technology (NIST) <a href="http://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63" rel="noreferrer">Special Publication 800-63</a> has a set of very good suggestions.  That, when combined with a dictionary and keyboard layout analysis (for example, 'qwertyuiop' is a bad password), can <a href="http://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html" rel="noreferrer">reject 99% of all poorly selected passwords</a> at a level of 18 bits of entropy.  Simply calculating password strength and <a href="https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/" rel="noreferrer">showing a visual strength meter</a> to a user is good, but insufficient.  Unless it is enforced, a lot of users will most likely ignore it.</p>
<p>And for a refreshing take on user-friendliness of high-entropy passwords, Randall Munroe's <a href="https://xkcd.com/936/" rel="noreferrer">Password Strength xkcd</a> is highly recommended.</p>
<h2>PART VI: Much More - Or: Preventing Rapid-Fire Login Attempts</h2>
<p>First, have a look at the numbers: <a href="http://www.lockdown.co.uk/?pg=combi&amp;s=articles" rel="noreferrer">Password Recovery Speeds - How long will your password stand up</a></p>
<p>If you don't have the time to look through the tables in that link, here's the list of them:</p>
<ol>
<li><p>It takes <em>virtually no time</em> to crack a weak password, even if you're cracking it with an abacus</p></li>
<li><p>It takes <em>virtually no time</em> to crack an alphanumeric 9-character password, if it is <strong>case insensitive</strong></p></li>
<li><p>It takes <em>virtually no time</em> to crack an intricate, symbols-and-letters-and-numbers, upper-and-lowercase password, if it is <strong>less than 8 characters long</strong> (a desktop PC can search the entire keyspace up to 7 characters in a matter of days or even hours)</p></li>
<li><p><strong>It would, however, take an inordinate amount of time to crack even a 6-character password, <em>if you were limited to one attempt per second!</em></strong></p></li>
</ol>
<p>So what can we learn from these numbers? Well, lots, but we can focus on the most important part: the fact that preventing large numbers of rapid-fire successive login attempts (ie. the <em>brute force</em> attack) really isn't that difficult. But preventing it <em>right</em> isn't as easy as it seems.</p>
<p>Generally speaking, you have three choices that are all effective against brute-force attacks <em>(and dictionary attacks, but since you are already employing a strong passwords policy, they shouldn't be an issue)</em>:</p>
<ul>
<li><p>Present a <strong>CAPTCHA</strong> after N failed attempts (annoying as hell and often ineffective -- but I'm repeating myself here)</p></li>
<li><p><strong>Locking accounts</strong> and requiring email verification after N failed attempts (this is a <a href="http://en.wikipedia.org/wiki/Denial-of-service_attack" rel="noreferrer">DoS</a> attack waiting to happen)</p></li>
<li><p>And finally, <strong>login throttling</strong>: that is, setting a time delay between attempts after N failed attempts (yes, DoS attacks are still possible, but at least they are far less likely and a lot more complicated to pull off).</p></li>
</ul>
<p><strong>Best practice #1:</strong> A short time delay that increases with the number of failed attempts, like:</p>
<ul>
<li>1 failed attempt = no delay</li>
<li>2 failed attempts = 2 sec delay</li>
<li>3 failed attempts = 4 sec delay</li>
<li>4 failed attempts = 8 sec delay</li>
<li>5 failed attempts = 16 sec delay</li>
<li>etc.</li>
</ul>
<p>DoS attacking this scheme would be very impractical, since the resulting lockout time is slightly larger than the sum of the previous lockout times.</p>
<blockquote>
<p>To clarify: The delay is <em>not</em> a delay before returning the response to the browser. It is more like a timeout or refractory period during which login attempts to a specific account or from a specific IP address will not be accepted or evaluated at all. That is, correct credentials will not return in a successful login, and incorrect credentials will not trigger a delay increase.</p>
</blockquote>
<p><strong>Best practice #2:</strong> A medium length time delay that goes into effect after N failed attempts, like:</p>
<ul>
<li>1-4 failed attempts = no delay</li>
<li>5 failed attempts = 15-30 min delay</li>
</ul>
<p>DoS attacking this scheme would be quite impractical, but certainly doable. Also, it might be relevant to note that such a long delay can be very annoying for a legitimate user. Forgetful users will dislike you.</p>
<p><strong>Best practice #3:</strong> Combining the two approaches - either a fixed, short time delay that goes into effect after N failed attempts, like:</p>
<ul>
<li>1-4 failed attempts = no delay</li>
<li>5+ failed attempts = 20 sec delay</li>
</ul>
<p>Or, an increasing delay with a fixed upper bound, like:</p>
<ul>
<li>1 failed attempt = 5 sec delay</li>
<li>2 failed attempts = 15 sec delay</li>
<li>3+ failed attempts = 45 sec delay</li>
</ul>
<p>This final scheme was taken from the OWASP best-practices suggestions (link 1 from the MUST-READ list), and should be considered best practice, even if it is admittedly on the restrictive side.</p>
<blockquote>
<p><em>As a rule of thumb however, I would say: the stronger your password policy is, the less you have to bug users with delays. If you require strong (case-sensitive alphanumerics + required numbers and symbols) 9+ character passwords, you could give the users 2-4 non-delayed password attempts before activating the throttling.</em></p>
</blockquote>
<p>DoS attacking this final login throttling scheme would be <strong><em>very</em></strong> impractical. And as a final touch, always allow persistent (cookie) logins (and/or a CAPTCHA-verified login form) to pass through, so legitimate users won't even be delayed <em>while the attack is in progress</em>. That way, the very impractical DoS attack becomes an <em>extremely</em> impractical attack.</p>
<p>Additionally, it makes sense to do more aggressive throttling on admin accounts, since those are the most attractive entry points</p>
<h2>PART VII: Distributed Brute Force Attacks</h2>
<p>Just as an aside, more advanced attackers will try to circumvent login throttling by 'spreading their activities':</p>
<ul>
<li><p>Distributing the attempts on a botnet to prevent IP address flagging</p></li>
<li><p>Rather than picking one user and trying the 50.000 most common passwords (which they can't, because of our throttling), they will pick THE most common password and try it against 50.000 users instead. That way, not only do they get around maximum-attempts measures like CAPTCHAs and login throttling, their chance of success increases as well, since the number 1 most common password is far more likely than number 49.995</p></li>
<li><p>Spacing the login requests for each user account, say, 30 seconds apart, to sneak under the radar</p></li>
</ul>
<p>Here, the best practice would be <strong>logging the number of failed logins, system-wide</strong>, and using a running average of your site's bad-login frequency as the basis for an upper limit that you then impose on all users.</p>
<p>Too abstract? Let me rephrase:</p>
<p>Say your site has had an average of 120 bad logins per day over the past 3 months. Using that (running average), your system might set the global limit to 3 times that -- ie. 360 failed attempts over a 24 hour period. Then, if the total number of failed attempts across all accounts exceeds that number within one day (or even better, monitor the rate of acceleration and trigger on a calculated threshold), it activates system-wide login throttling - meaning short delays for ALL users (still, with the exception of cookie logins and/or backup CAPTCHA logins).</p>
<p>I also posted a question with <a href="http://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure">more details and a really good discussion of how to avoid tricky pitfals</a> in fending off distributed brute force attacks</p>
<h2>PART VIII: Two-Factor Authentication and Authentication Providers</h2>
<p>Credentials can be compromised, whether by exploits, passwords being written down and lost, laptops with keys being stolen, or users entering logins into phishing sites.  Logins can be further protected with two-factor authentication, which use out-of-band factors such as single-use codes received from a phone call, SMS message, app, or dongle. Several providers offer two-factor authentication services.</p>
<p>Authentication can be completely delegated to a single-sign-on service, where another provider handles collecting credentials. This pushes the problem to a trusted third party. Google and Twitter both provide standards-based SSO services, while Facebook provides a similar proprietary solution.</p>
<h2>MUST-READ LINKS About Web Authentication</h2>
<ol>
<li><a href="https://www.owasp.org/index.php/Authentication_Cheat_Sheet" rel="noreferrer">OWASP Guide To Authentication</a> / <a href="https://www.owasp.org/index.php/Authentication_Cheat_Sheet" rel="noreferrer">OWASP Authentication Cheat Sheet</a></li>
<li><a href="https://pdos.csail.mit.edu/papers/webauth:sec10.pdf" rel="noreferrer">Dos and Don’ts of Client Authentication on the Web (very readable MIT research paper)</a></li>
<li><a href="http://en.wikipedia.org/wiki/HTTP_cookie#Drawbacks_of_cookies" rel="noreferrer">Wikipedia: HTTP cookie</a></li>
<li><a href="http://cups.cs.cmu.edu/soups/2008/proceedings/p13Rabkin.pdf" rel="noreferrer">Personal knowledge questions for fallback authentication: Security questions in the era of Facebook (very readable Berkeley research paper)</a></li>
</ol>
</div></text><author><a href="/users/57068">Jens Roland</a></author><comments><comment><text><span class="comment-copy">Well, I don't really agree with the Captcha part, yes Captchas are annoying and they can be broken (except recaptcha but this is barely solvable by humans!) but this is exactly like saying don't use a spam filter because it has less than 0.1% false negatives .. this very site uses Captchas, they are not perfect but they cut a considerable amount of spam and there's simply no good alternative to them</span></text><author><a class="comment-user" href="/users/676066/waleed-eissa" title="4,229 reputation">Waleed Eissa</a></author></comment><comment><text><span class="comment-copy">@Jeff: I'm sorry to hear that you have issues with my reply. I didn't know there was a debate on Meta about this answer, I would have gladly edited it myself if you'd asked me to. And deleting my posts just deleted 1200 reputation from my account, which hurts :(</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">Great answer, thanks.  Can you explain why the 'Improved' Best Practices for persistent login is flawed?  At first blush it does seem like it addresses the DOS scenario for invalidating sessions with Miller's approach, what am I missing?</span></text><author><a class="comment-user" href="/users/170976/jfager" title="134 reputation">jfager</a></author></comment><comment><text><span class="comment-copy">Don't forget to look at your crypto algorithm.  You wouldn't want to be hit by a side channel attack such as timing.</span></text><author><a class="comment-user" href="/users/79842/colin-bowern" title="1,471 reputation">Colin Bowern</a></author></comment><comment><text><span class="comment-copy">"After sending the authentication tokens, the system needs a way to remember that you have been authenticated - this fact should only ever be stored serverside in the session data. A cookie can be used to reference the session data."  Not quite. You can (and should, for stateless servers!) use a cryptographically signed cookie. That's impossible to forge, doesn't tie up server resources, and doesn't need sticky sessions or other shenanigans.</span></text><author><a class="comment-user" href="/users/22227/martin-probst" title="6,371 reputation">Martin Probst</a></author></comment><comment><text><span class="comment-copy">Are there any good articles discussing either (1) theory behind and/or (2) implementation of challenge-response mechanisms?</span></text><author><a class="comment-user" href="/users/168775/eykanal" title="13,143 reputation">eykanal</a></author></comment><comment><text><span class="comment-copy">For persistent login. How is the Username+token better than just a random session-id that the server has mapped to the username and loginstatus? I have never even heard of the first method before.</span></text><author><a class="comment-user" href="/users/863754/aero" title="147 reputation">aero</a></author></comment><comment><text><span class="comment-copy">This is the longest and most interesting answer I have ever seen on Stack Overflow. But it really is more suitable for a blog post!</span></text><author><a class="comment-user" href="/users/416623/r3st0r3" title="1,324 reputation">r3st0r3</a></author></comment><comment><text><span class="comment-copy">How is a second cookie for persistent login better than one cookie/session with a longer expiration time?</span></text><author><a class="comment-user" href="/users/84745/s4y" title="28,316 reputation">s4y</a></author></comment><comment><text><span class="comment-copy">While Tyler Atkin's password strength library looks excellent, it is licensed under the GPL which is kind of weird for a JavaScript library. Providing a link to an alternative implementation that can be used without restriction in a commercial web app would be good.</span></text><author><a class="comment-user" href="/users/428876/bayard-randel" title="7,443 reputation">Bayard Randel</a></author></comment><comment><text><span class="comment-copy">"a desktop PC can search the FULL KEYSPACE up to 7 characters in less than 90 days"  A machine with a recent GPU can search the full 7 char keyspace in less than 1 day.  A top of the line GPU can manage 1 billion hashes per second.  <a href="http://www.golubev.com/hashgpu.htm" rel="nofollow noreferrer">golubev.com/hashgpu.htm</a>  This leads to some conclusions about password storage which aren't directly addressed.</span></text><author><a class="comment-user" href="/users/82769/frank-farmer" title="23,963 reputation">Frank Farmer</a></author></comment><comment><text><span class="comment-copy">I totally agree with you on security questions. They are very bad. I just wish I could explain this to my bank.</span></text><author><a class="comment-user" href="/users/36157/tim-matthews" title="3,239 reputation">Tim Matthews</a></author></comment><comment><text><span class="comment-copy">OpenID was left out. Is there a chance that someone could add it?</span></text><author><a class="comment-user" href="/users/140367/tam%c3%a1s-szelei" title="12,440 reputation">Tamás Szelei</a></author></comment><comment><text><span class="comment-copy">@aero: By including the username in the persistent login cookie token, you avoid a scenario where an attacker has 10 million chances to guess a correct token (on a site with 10 million users). Of course, if the token string is long enough, it shouldn't be a big issue, but I would still recommend it.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Sidnicious: Session cookies are transient by definition, ie. they automatically expire when the user closes the browser window.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Colin Bowern: Are you aware of any successful timing attacks on remote web sites? From the literature I've read on successful timing attacks, they require sub-millisecond variance, which makes them impractical for remote attacking web sites (where common response times are in the 20-50 millisecond range)</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@fjager: sure - I added a simple note to the post explaining why it doesn't add significant security to the system.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Jens Why? If the purpose of the cookie is to store information about the login session, why wouldn't it last as long as the login is going to last? It seems like have separate session/remember-me cookies just adds complexity.</span></text><author><a class="comment-user" href="/users/84745/s4y" title="28,316 reputation">s4y</a></author></comment><comment><text><span class="comment-copy">@Sidnicious: You are not talking about a session cookie then. Session cookies by definition have no expires directive. If you add an expires directive to a session cookie, it becomes a persistent cookie. It sounds like you want to make your "session" cookie persistent and eliminate the true session-limited cookie. I guess that's possible, but you lose all the useful things you can do with session cookies, i.e. keeping transient lightweight state objects in memory (you don't want to keep all session data alive for months, trust me).</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">I'm surprised CSRF protection hasn't been mentioned...</span></text><author><a class="comment-user" href="/users/212159/flukey" title="4,693 reputation">Flukey</a></author></comment><comment><text><span class="comment-copy">@Jens Roland: About the rememberMe, in the cookie, I should save the same token  that is stored in the DB? If not, I should save in the cookie the value that originated the Token?</span></text><author><a class="comment-user" href="/users/710693/jcm" title="3,510 reputation">JCM</a></author></comment><comment><text><span class="comment-copy">@Jonathan: The token is just a random generated value. Save the user ID and token in the cookie, then save a hash of the token in the DB. that way, you can validate the login cookie by re-hashing the token and checking the user record for a match</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Mike: Good points. If a user tries to log in (ie. posts login credentials to the server) they will not be checked and an error is returned. A server-synchronized countdown clock should be displayed next to the login form to inform the user of the throttling. The form itself or the submit button should be disabled until the countdown is done.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Mike: Account-based 'locking' should IMO only happen if the user breaks your site's TOS while logged in, if account fees are unpaid, or if the user is investigated by the authorities. Until the user has logged in correctly, you (generally) can't be sure that the failed login attempts aren't a malicious third party trying to lockout the real user.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Mike: IP-based 'locking' however, can be advisable in case of obvious DoS attacks. That doesn't have anything to do with login form security in itself though, and is usually handled directly on the network traffic, so that request flooding from a single IP automatically triggers an IP block for a number of hours.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Jens, thanks for the clarifications. I was just thinking that I have accounts with two different banks. One of them locks your account for 2 hours with 3 failed logins. The other locks your account indefinitely after 5'ish failed logins and forces you to call their tech support to reenable it. Neither (as far as I could tell) lock your IP address.</span></text><author><a class="comment-user" href="/users/811240/mike" title="11,571 reputation">Mike</a></author></comment><comment><text><span class="comment-copy">@jfager: When the user re-logs-in, nothing is deleted, since the safety deletion only occurs if the site is passed an old cookie containing a valid series identifier and an invalid token. Since there is no such cookie (because the attacker deleted it), the system simply initiates a new series and doesn't even warn the user. (remember: a user can have many laptops = many series identifiers, and the 'improved' system can't tell the difference)</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@jfager: Absolutely correct - I didn't mean to portray it as a drawback, my only point is that the 'improvement' doesn't actually deliver on its promise. It can make implementors and site owners believe their auth system protects against cookie stealing, and it doesn't -- and fake security is worse than no security.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">There are a few things here which were either briefly mentioned or not at all. One being the use of hash algorithms specific to passwords (e.g. bcrypt). This means that the time to compute the hash increases to 0.1 seconds (at least) but that makes a big difference when searching an entire keyspace. The second thing is that security must be everywhere: sanatizing user inputs, using prepared statements for sql, making sure that resources arent url predictable, then there is the whole XSS set of issues...</span></text><author><a class="comment-user" href="/users/516813/chacham15" title="5,466 reputation">chacham15</a></author></comment><comment><text><span class="comment-copy">Agreed with @chacham15. Lockout and throttling policy is great, but using a <i>password</i> digest like bcrypt or scrypt instead of a general purpose hashing function enforces this at the lowest level possible. There is no way around having to put in the full amount of work to generate a password digest, so no developer can simply forget to implement or accidentally disable the throttling mechanism.</span></text><author><a class="comment-user" href="/users/99646/stephen-touset" title="1,383 reputation">Stephen Touset</a></author></comment><comment><text><span class="comment-copy">@namelessjon: Correction: Even if all users had high-entropy passwords, we'd still want to hash them in case of database theft</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Ferdy: Thanks :) a fixed 1 or 2 second delay will still work, but increasing it incrementally to 10 or 20 seconds will multiply the resilience against brute force attacks.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@JensRoland Thanks for confirming the simplified model works. Albeit it less effective, I would prefer avoiding the pain that is reliably tracking login attempts. Better yet, I like part VIII of your answer best: outsourcing the issue alltogether. It's not just security that is a pain in building your own user management system, something as seemingly simple as reliably sending out emails is a pain as well.</span></text><author><a class="comment-user" href="/users/80969/ferdy" title="1,499 reputation">Ferdy</a></author></comment><comment><text><span class="comment-copy">NEVER use recaptcha, if you want to retain any of your custoemrs, ever.  Seriously, if you have to use a captcha then use one that humans have a chance of solving first time, they might not be unbreakable but they're a good compromise because most will stop a variety of bots without annoying your customers too much.</span></text><author><a class="comment-user" href="/users/56007/jonhobbs" title="5,545 reputation">jonhobbs</a></author></comment><comment><text><span class="comment-copy">@MikeMike: "..and loop through them in php" -- why not just select the row in SQL? <code>SELECT * FROM LoginTokens WHERE UserID=[userid from cookie] AND HashedToken=[hash(token from cookie)]</code> should work just fine (remember to use prepared statements / stored procedures for the SQL though)</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">Does anyone know where I can find a vetted PHP/MySQL implementation of Charles Miller's almost-10-year-old "Persistent Login Cookie" solution?  Please post it here:  <a href="http://stackoverflow.com/questions/15647261/where-can-i-find-a-php-mysql-implementation-of-charles-millers-persistent-logi" title="where can i find a php mysql implementation of charles millers persistent logi">stackoverflow.com/questions/15647261/…</a></span></text><author><a class="comment-user" href="/users/869849/programmergirl" title="1,363 reputation">ProgrammerGirl</a></author></comment><comment><text><span class="comment-copy">@JensRoland: How would you select the row in SQL when the Token is hashed with bcrypt?  Please answer here:  <a href="http://stackoverflow.com/questions/15685951/how-to-check-cookie-token-against-bcrypt-hashed-token-in-db-when-using-persisten" title="how to check cookie token against bcrypt hashed token in db when using persisten">stackoverflow.com/questions/15685951/…</a></span></text><author><a class="comment-user" href="/users/869849/programmergirl" title="1,363 reputation">ProgrammerGirl</a></author></comment><comment><text><span class="comment-copy">@Jesse: I would agree with you if the 'improved' system actually did that, but if an attacker deletes the cookie, the site has no clue that an attack has taken place - only that a new chain has been added to the collection of valid chains. If and only if the user monitors his own number of valid chains stored in the database, never clears his own cookies, and keeps track of 100% of the devices he uses to authenticate on the site, will he be able to deduce that an attack MAY have taken place. The scenario where the system automatically detects the intrusion does not apply to cookie deletion.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@Jesse: You are correct, but the improvement seems highly speculative to me, since essentially every attack vector which would allow a third party access to the cookie would also enable them to delete it. Hoping that they won't is nothing more than security through obscurity. Even if there is added protection against the weakest attackers, I would still argue that giving the site owners / legitimate users a false sense of security by advertising an 'intrusion detection' mechanism which doesn't actually protect them, is downright irresponsible and should be discouraged.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">Just a thought. What about bitcoin-like hashing for credentials on the client? Iterative hashing of username, password &amp; a random number (session specific) that takes couple of seconds on the client (legitimate users won't mind slight delay) and it would be a nightmare for attackers. Valid credentials and proof of work would be required for successful authentication.</span></text><author><a class="comment-user" href="/users/696475/patrick" title="444 reputation">Patrick</a></author></comment><comment><text><span class="comment-copy">"hashing the password client-side": more than just saying that this is "useless", it should be made <i>very</i> clear that <b>this is a security flaw</b>. This makes the hash <i>password equivalent</i>, and means that the server, by storing the password hash, is effectively storing the password (and none of us do that, right?) <a href="http://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end">Here's a question on this exact point.</a></span></text><author><a class="comment-user" href="/users/229792/jameshfisher" title="8,279 reputation">jameshfisher</a></author></comment><comment><text><span class="comment-copy">@JensRoland Great post, thank you. If my site doesn't have any state it wants to keep in the session cookie for example, then do my session cookie and persistent cookie basically each only contain distinct large random strings (and username for the persistent)?</span></text><author><a class="comment-user" href="/users/29502/newtang" title="2,722 reputation">Newtang</a></author></comment><comment><text><span class="comment-copy">@Newtang: The persistent cookie should always be a large random string (and optionally a username for convenience). The session cookie is usually set by your web/MVC framework (ASP.NET_SessionId, PHPSESSID, ci_session, JSESSIONID) and should contain just the session identifier (another large random string). If you want to keep additional state about the session, that state should normally be stored server-side, with the session identifier used as a primary key.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@shannon: Absolutely - as long your user data is protected by strong encryption, you could theoretically upload it to Pastebin and it wouldn't be a problem -- and yet I don't think anyone would feel comfortable with such a setup. Some frameworks actually provide such an encrypted-cookie solution as an alternative to a session database, and it is a viable solution, no doubt. The problems begin when people implement that solution with weak or no encryption (and they do), or exceed the data limits on cookie data.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@JensRoland: I guess my thought was, if we assume the encryption is weak, then we have to worry that even a simple session token is also not safe, and we risk session hijacking, replays, and any number of other related attacks.</span></text><author><a class="comment-user" href="/users/608220/shannon" title="4,669 reputation">shannon</a></author></comment><comment><text><span class="comment-copy">Would not a "secret question" be beneficial when used in conjunction with typical password reset functionality?  A typical password reset process ensures only the possessor of the email account can reset their password.  But if the user has had their email account compromised, then the addition of a security question could foil an attempt to reset their password and gain access to a site.</span></text><author><a class="comment-user" href="/users/2045006/user2045006" title="1,087 reputation">user2045006</a></author></comment><comment><text><span class="comment-copy">I saw one Captcha that was done in Canvas HTML 5 which was moving three balls around so that they were in the smallest to largest (circles rather than balls) and it was actually really nice. I have not come across that page in a while.</span></text><author><a class="comment-user" href="/users/2487995/doug-hauf" title="972 reputation">Doug Hauf</a></author></comment><comment><text><span class="comment-copy">@Andrew: That's not actually the case. Multiple SIDs (chains) are permitted because it's the way multiple logged in devices (e.g. the home PC, work PC, and iPad) are supported. Under a single-chain (single-device) scheme, each time a user switches between devices, the 'theft' warning is raised, eventually rendering it worthless because the user sees it all the time.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@JensRoland If you want to allow remember-me for multiple devices, then you have to modify the solution. I think one way would be instead of SID, store IP (hashed) in the cookie and in the DB. The DB would have a pool of IPs, some of them marked as Valid and others marked as Banned. Upon manual login, User's IP is stored in the cookie and in the DB and marked as Valid. Upon every auto or manual login, the incoming user's IP is checked against the DB (token too). If IP is found and Valid - green light. If IP is not found - then green light, BUT incoming user's IP is marked as Valid and</span></text><author><a class="comment-user" href="/users/560972/andrew" title="383 reputation">Andrew</a></author></comment><comment><text><span class="comment-copy">and the old IP (from the cookie) is marked as Banned in the DB. If owner logs in using old (banned) IP, red light - theft is assumed. Everything gets cleared. This is not 100% proof, as until the real owner comes back, thief will be using the site and also during that time Owners IP might change, but the chances are minimized and multiple devices are allowed. Optionally, the banned IP's could be deleted every month / 3 months, etc, as ISP might assign 'old' IP again.</span></text><author><a class="comment-user" href="/users/560972/andrew" title="383 reputation">Andrew</a></author></comment><comment><text><span class="comment-copy">Just a note: SSL is NOT the only solution for "safe login". You can actually make a sniffer-safe login process using a hashed password. Basically, when generating the login page you send a salt to the browser (which will be saved on server-side too), and when submitting the form data, you'll send the hashed password and salt (look @ crypto-js), server then hashes the password + generated salt on the session and compares both. If the password on the server is hashed, just hash the password on the browser, then concat the salt and hash again.</span></text><author><a class="comment-user" href="/users/1085920/wolfulus" title="1,119 reputation">WoLfulus</a></author></comment><comment><text><span class="comment-copy">@WoLfulus: First of all, as an MITM attacker all I have to do is replace the salt (or the JS hashing function) you're sending to the browser over an unencrypted connection and your entire scheme is void. Secondly, even if I can't manipulate the server response ahead of time, simple sniffing will give me the salt, the hash function and the hashed password+salt, which opens you up to simple dictionary and brute force attacks. Never trust client side hashing for security.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@JensRoland The salt is stored on the server side for validation too, if you change it on the client you'll fail the validation on the server, resulting in an invalid password. I agree with the bruteforce.</span></text><author><a class="comment-user" href="/users/1085920/wolfulus" title="1,119 reputation">WoLfulus</a></author></comment><comment><text><span class="comment-copy">@WoLfulus: Even if the login doesn't go through, I now own your password, despite your effort to mask it with hashing.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@jameshfisher " more than just saying that this is "useless", it should be made very clear that this is a security flaw. This makes the hash password equivalent, and means that the server, by storing the password hash, is effectively storing the password" It's only a security flaw if you don't also use a separate salted hash on the server side. If you simple hash on the client side, then salted hash on the server side, the password itself is never in transit, and cracking the database still doesn't mean being able to authenticate.</span></text><author><a class="comment-user" href="/users/3680301/parthian-shot" title="747 reputation">Parthian Shot</a></author></comment><comment><text><span class="comment-copy">@ParthianShot has a point, but client side hashing is still useless -- and adding needless complexity to a security system just creates another moving part that can confuse the maintainer and potentially introduce security flaws (such as leading an inexperienced dev to drop the server side salt+rehashing)</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">@JensRoland "leading an inexperienced dev to drop the server side salt+rehashing" Reminds me of "a common mistake that people make when trying to design something completely foolproof is to underestimate the ingenuity of complete fools". You kind of need to assume that you have a competent dev team. However, salting the hash client side has one huge advantage; a person who decrypts traffic after-the-fact can still only use what they get as an auth token on your site, whether or not the end user is using the same password across multiple sites. Although defense in depth does add complexity.</span></text><author><a class="comment-user" href="/users/3680301/parthian-shot" title="747 reputation">Parthian Shot</a></author></comment><comment><text><span class="comment-copy">I'm not a fan of Charlie Miller's strategy to be honest. The system I favor just employs two random values: One is stored in the database as an index, the other is stored in the client's cookie and its hash is stored in the database. We then compare the hashes in constant-time. <a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence" rel="nofollow noreferrer">paragonie.com/blog/2015/04/…</a> - Explained in detail here.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">I'm thinking about the Session data: "This fact should only ever be stored server side in the session data". And about a clustered environment (like in a cloud)? How the user session should be stored?</span></text><author><a class="comment-user" href="/users/879821/kavain" title="192 reputation">kavain</a></author></comment><comment><text><span class="comment-copy">@kavain: In such environments, it's common to keep sessions in a database (hosted on a separate server). This decouples sessions from the specific web server handling the request (stateless HTTP FTW) and has a minimum security level equal to your database security, which is usually a good thing</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">Interesting that SRP is mentioned in the answer yet so many of the comments discuss obsolete hashing. JavaScript SRP libraries like thinbus-srp are fast and effective with the only overhead being the fetch of a salt and challenge few the server to perform a zero-knowledge password-proof to the server.</span></text><author><a class="comment-user" href="/users/329496/simbo1905" title="2,331 reputation">simbo1905</a></author></comment><comment><text><span class="comment-copy">@Wiki: "Dos and Don’ts of Client Authentication on the Web (very readable MIT research paper" link is down, can you edit the link if it got changed.</span></text><author><a class="comment-user" href="/users/1809096/sagar-trehan" title="1,480 reputation">Sagar Trehan</a></author></comment><comment><text><span class="comment-copy">@JensRoland Thanks for the great answer! Can you please elaborate on this - "The delay is not a delay before returning the response to the browser. It is more like a timeout ... during which login attempts to a specific account ... will not be accepted or evaluated at all." - I understand you're basically saying that using something like sleep(30) before the "invalid login details" response is sent won't do, since the bot/hacker can continue submitting login attempts with separate requests executed in parallel; but how do you suggest enforcing a timeout then? Disabling the form's login button?</span></text><author><a class="comment-user" href="/users/993623/kosta-kontos" title="1,553 reputation">Kosta Kontos</a></author></comment><comment><text><span class="comment-copy">@KostaKontos you'll need to trigger an asychronous timeout which runs on the server side, that's all. How you display that to the user is only a UI problem, since the security measure isn't on the front end at all.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">Good piece. However, password strength is almost totally irrelevant - uniqueness between sites is all that matters. Either the database has been captured in which case the actual user data is lost. Or the attacker is attempting a brute force web attack - which you can easily mitigate. Unless a user's password is extremely weak (eg monkey123) - so long as a password is unique across sites super strong passwords are largely pointless and will contribute to users forgetting them. If you specifically tell users to use a unique password and they don't, that's their responsibility.</span></text><author><a class="comment-user" href="/users/2254951/niico" title="2,419 reputation">niico</a></author></comment><comment><text><span class="comment-copy">@niico password strength is not irrelevant if an attacker wishes to target a specific user (on some systems it may suffice for an attacker to gain access to any random account, but in many cases, such as on social sites, attackers want to crack specific user accounts). The difficulty of cracking a single user password depends on the number of permitted login attempts, but also largely on the password strength. If people are allowed to use low-entropy passwords, they will choose 'password', 'secret', 'qwerty', and 'letmein' (and their dog's name). You don't need many attempts to guess those.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment><comment><text><span class="comment-copy">What about the email verification code/token? AES-GCM encode the email address with a periodically changing key?</span></text><author><a class="comment-user" href="/users/2312578/dalu" title="958 reputation">dalu</a></author></comment><comment><text><span class="comment-copy">The article says <code>some implementations may be technically illegal in some countries</code> and it provides a link to <code>OWASP</code>, but there's nothing there about the illegality of <code>CAPTCHAs</code>. Could someone give me an example on how a <code>CAPTCHA</code> implementation could be illegal?</span></text><author><a class="comment-user" href="/users/1227166/mfeinstein" title="1,328 reputation">mFeinstein</a></author></comment><comment><text><span class="comment-copy">mFeinstein: Some CAPTCHA implementations can not be passed by people with particular disabilities (e.g. a visually impaired user relying on screen reader software); depending on your type of site (government, nonprofit organisations, etc.) and which jurisdiction you are in, you may be subject to accessibility laws.</span></text><author><a class="comment-user" href="/users/57068/jens-roland" title="22,312 reputation">Jens Roland</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h1>Definitive Article</h1>
<h3>Sending credentials</h3>
<p>The only practical way to send credentials 100% securely is by using <a href="http://en.wikipedia.org/wiki/SSL" rel="nofollow noreferrer">SSL</a>. Using JavaScript to hash the password is not safe. Common pitfalls for client-side password hashing:</p>
<ul>
<li>If the connection between the client and server is unencrypted, everything you do is <a href="http://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding">vulnerable to man-in-the-middle attacks</a>. An attacker could replace the incoming javascript to break the hashing or send all credentials to their server, they could listen to client responses and impersonate the users perfectly, etc. etc. SSL with trusted Certificate Authorities is designed to prevent MitM attacks.</li>
<li>The hashed password received by the server is <a href="https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing">less secure</a> if you don't do additional, redundant work on the server.</li>
</ul>
<p>There's another secure method called <strong>SRP</strong>, but it's patented (although it is <a href="http://srp.stanford.edu/license.txt" rel="nofollow noreferrer">freely licensed</a>) and there are few good implementations available.</p>
<h3>Storing passwords</h3>
<p>Don't ever store passwords as plaintext in the database. Not even if you don't care about the security of your own site. Assume that some of your users will reuse the password of their online bank account. So, store the hashed password, and throw away the original. And make sure the password doesn't show up in access logs or application logs. The best hashing function seems to be <a href="https://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage"><strong>bcrypt</strong></a>. </p>
<p>Hashes by themselves are also insecure. For instance, identical passwords mean identical hashes--this makes hash lookup tables an effective way of cracking lots of passwords at once. Instead, store the <strong>salted</strong> hash. A salt is a string appended to the password prior to hashing - use a different (random) salt per user. The salt is a public value, so you can store them with the hash in the database. See <a href="http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right" rel="nofollow noreferrer">here</a> for more on this.</p>
<p>This means that you can't send the user their forgotten passwords (because you only have the hash). Don't reset the user's password unless you have authenticated the user (users must prove that they are able to read emails sent to the stored (and validated) email address.)</p>
<h3>Security questions</h3>
<p>Security questions are insecure - avoid using them. Why? Anything a security question does, a password does better. Read <strong><em>PART III: Using Secret Questions</em></strong> in <a href="http://srp.stanford.edu/license.txt" rel="nofollow noreferrer">@Jens Roland answer</a> here in this wiki.</p>
<h3>Session cookies</h3>
<p>After the user logs in, the server sends the user a session cookie. The server can retrieve the username or id from the cookie, but nobody else can generate such a cookie (TODO explain mechanisms).</p>
<p><a href="http://en.wikipedia.org/wiki/Session_hijacking" rel="nofollow noreferrer">Cookies can be hijacked</a>: they are only as secure as the rest of the client's machine and other communications. They can be read from disk, sniffed in network traffic, lifted by a cross-site scripting attack, phished from a poisoned DNS so the client sends their cookies to the wrong servers. Don't send persistent cookies. Cookies should expire at the end of the client session (browser close or leaving your domain).</p>
<p>If you want to autologin your users, you can set a persistent cookie, but it should be distinct from a full-session cookie. You can set an additional flag that the user has auto-logged in, and needs to login for real for sensitive operations. This is popular with shopping sites that want to provide you with a seamless, personalized shopping experience but still protect your financial details. For example, when you return to visit Amazon, they show you a page that looks like you're logged in, but when you go to place an order (or change your shipping address, credit card etc.), they ask you to confirm your password.</p>
<p>Financial web sites such as banks and credit cards, on the other hand, only have sensitive data and should not allow auto-login or a low-security mode.</p>
<h3>List of external resources</h3>
<ul>
<li><a href="http://pdos.csail.mit.edu/papers/webauth:sec10.pdf" rel="nofollow noreferrer">Dos and Don'ts of Client Authentication on the Web (PDF)</a><br/>
21 page academic article with many great tips.  </li>
<li><a href="http://news.ycombinator.com/item?id=205572" rel="nofollow noreferrer">Ask YC: Best Practices for User Authentication</a><br/>
Forum discussion on the subject  </li>
<li><a href="http://www.codinghorror.com/blog/archives/000953.html" rel="nofollow noreferrer">You're Probably Storing Passwords Incorrectly</a><br/>
Introductory article about storing passwords</li>
<li><a href="http://news.ycombinator.com/item?id=55660" rel="nofollow noreferrer">Discussion: Coding Horror: You're Probably Storing Passwords Incorrectly</a><br/>
Forum discussion about a Coding Horror article.</li>
<li>Never store passwords in a database!<br/>
Another warning about storing passwords in the database.</li>
<li><a href="http://en.wikipedia.org/wiki/Password_cracking" rel="nofollow noreferrer">Password cracking</a><br/>
Wikipedia article on weaknesses of several password hashing schemes.</li>
<li><a href="http://www.securityfocus.com/blogs/262" rel="nofollow noreferrer">Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</a><br/>
Discussion about rainbow tables and how to defend against them, and against other threads. Includes extensive discussion.</li>
</ul>
</div></text><author><a href="/users/136">Michiel de Mare</a></author><comments><comment><text><span class="comment-copy">Given the recent MITM vulnerability surrounding signed SSL certificates (<a href="https://blog.startcom.org/?p=145" rel="nofollow noreferrer">blog.startcom.org/?p=145</a>) so a combination of SSL and some kind of Challenge response authentication (There are alternatives to SRP) is probably a better solution.</span></text><author><a class="comment-user" href="/users/13834/kevin-loney" title="5,644 reputation">Kevin Loney</a></author></comment><comment><text><span class="comment-copy">a lot of this stuff is situational. i tend not to use session cookies at all. cookies getting hijacked is almost always the servers fault. man in the middle / packet sniffing arent that common</span></text><author><a class="comment-user" href="/users/26/shawn" title="10,515 reputation">Shawn</a></author></comment><comment><text><span class="comment-copy">BCrypt Nuget package : <a href="http://nuget.org/List/Packages/BCrypt" rel="nofollow noreferrer">nuget.org/List/Packages/BCrypt</a></span></text><author><a class="comment-user" href="/users/66973/fabian-vilers" title="1,912 reputation">Fabian Vilers</a></author></comment><comment><text><span class="comment-copy">Note 1 about this answer: it is a draft, to be edited as a wiki. If you can edit this, you're welcome to.</span></text><author><a class="comment-user" href="/users/63550/peter-mortensen" title="11,046 reputation">Peter Mortensen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>First, a strong caveat that this answer is not the best fit for this exact question. It should definitely not be the top answer!</p>
<p>I will go ahead and mention Mozilla’s proposed <a href="https://browserid.org/" rel="noreferrer">BrowserID</a> (or perhaps more precisely, the <a href="https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest" rel="noreferrer">Verified Email Protocol</a>) in the spirit of finding an upgrade path to better approaches to authentication in the future.</p>
<p>I’ll summarize it this way:</p>
<ol>
<li>Mozilla is a nonprofit with <a href="http://www.mozilla.org/about/manifesto.en.html" rel="noreferrer">values</a> that align well with finding good solutions to this problem.</li>
<li>The reality today is that most websites use form-based authentication</li>
<li>Form-based authentication has a big drawback, which is increased risk of <a href="http://en.wikipedia.org/wiki/Phishing" rel="noreferrer">phishing</a>. Users are asked to enter sensitive information into an area controlled by a remote entity, rather than an area controlled by their User Agent (browser).</li>
<li>Since browsers are implicitly trusted (the whole idea of a User Agent is to act on behalf of the User), they can help improve this situation.</li>
<li>The primary force holding back progress here is <a href="http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf" rel="noreferrer">deployment deadlock</a>. Solutions must be decomposed into steps which provide some incremental benefit on their own.</li>
<li>The simplest decentralized method for expressing identity that is built into the internet infrastructure is the domain name.</li>
<li>As a second level of expressing identity, each domain manages its own set of accounts.</li>
<li>The form “account<code>@</code>domain” is concise and supported by a wide range of protocols and URI schemes. Such an identifier is, of course, most universally recognized as an email address.</li>
<li>Email providers are already the de-facto primary identity providers online. Current password reset flows usually let you take control of an account if you can prove that you control that account’s associated email address.</li>
<li>The Verified Email Protocol was proposed to provide a secure method, based on public key cryptography, for streamlining the process of proving to domain B that you have an account on domain A.</li>
<li>For browsers that don’t support the Verified Email Protocol (currently all of them), Mozilla provides a shim which implements the protocol in client-side JavaScript code.</li>
<li>For email services that don’t support the Verified Email Protocol, the protocol allows third parties to act as a trusted intermediary, asserting that they’ve verified a user’s ownership of an account. It is not desirable to have a large number of such third parties; this capability is intended only to allow an upgrade path, and it is much preferred that email services provide these assertions themselves.</li>
<li>Mozilla offers their own service to act as such a trusted third party. Service Providers (that is, Relying Parties) implementing the Verified Email Protocol may choose to trust Mozilla's assertions or not. Mozilla’s service verifies users’ account ownership using the conventional means of sending an email with a confirmation link.</li>
<li>Service Providers may, of course, offer this protocol as an option in addition to any other method(s) of authentication they might wish to offer.</li>
<li>A big user interface benefit being sought here is the “identity selector”. When a user visits a site and chooses to authenticate, their browser shows them a selection of email addresses (“personal”, “work”, “political activism”, etc.) they may use to identify themselves to the site.</li>
<li>Another big user interface benefit being sought as part of this effort is <a href="https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session" rel="noreferrer">helping the browser know more about the user’s session</a> – who they’re signed in as currently, primarily – so it may display that in the browser chrome.</li>
<li>Because of the distributed nature of this system, it avoids lock-in to major sites like Facebook, Twitter, Google, etc. Any individual can own their own domain and therefore act as their own identity provider.</li>
</ol>
<p>This is not strictly “form-based authentication for websites”. But it is an effort to transition from the current norm of form-based authentication to something more secure: browser-supported authentication.</p>
</div></text><author><a href="/users/139320">Charlie</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I just thought I'd share this solution that I found to be working just fine.</p>
<p>I call it the <strong>Dummy Field</strong> (though I haven't invented this so don't credit me).</p>
<p>In short: you just have to insert this into your <code>&lt;form&gt;</code> and check for it to be empty at when validating:</p>
<pre><code>&lt;input type="text" name="email" style="display:none" /&gt;
</code></pre>
<p>The trick is to fool a bot into thinking it has to insert data into a required field, that's why I named the input "email". If you already have a field called email that you're using you should try naming the dummy field something else like "company", "phone" or "emailaddress". Just pick something you know you don't need and what sounds like something people would normally find logical to fill in into a web form. Now hide the <code>input</code> field using CSS or JavaScript/jQuery - whatever fits you best - just <strong>don't</strong> set the input <code>type</code> to <code>hidden</code> or else the bot won't fall for it.</p>
<p>When you are validating the form (either client or server side) check if your dummy field has been filled to determine if it was send by a human or a bot.</p>
<p>Example:</p>
<p><strong>In case of a human:</strong>
The user will not see the dummy field (in my case named "email") and will not attempt to fill it. So the value of the dummy field should still be empty when the form has been send.</p>
<p><strong>In case of a bot:</strong> The bot will see a field whose type is <code>text</code> and a name <code>email</code> (or whatever it is you called it) and will logically attempt to fill it with appropriate data. It doesn't care if you styled the input form with some fancy CSS, web-developers do it all the time. Whatever the value in the dummy field is, we don't care as long as it's larger than <code>0</code> characters.</p>
<p>I used this method on a guestbook in combination with <a href="http://en.wikipedia.org/wiki/CAPTCHA">CAPTCHA</a>, and I haven't seen a single spam post since. I had used a CAPTCHA-only solution before, but eventually it resulted in about five spam posts every hour. Adding the dummy field in the form has stopped (at least till now) all the spam from appearing. </p>
<p>I believe this can also be used just fine with a login/authentication form.</p>
<p><strong>Warning</strong>: Of course this method is not 100% fool proof. Bots can be programmed to ignore input fields with the style <code>display:none</code> applied to it. You also have to think about people who use some form of auto-completion (like most browsers have built-in!) to auto-fill all form fields for them. They might just as well pick up a dummy field.</p>
<p>You can also vary this up a little by leaving the dummy field visible but outside the boundaries of screen, but this is totally up to you. </p>
<p>Be creative!</p>
</div></text><author><a href="/users/192310">Pieter888</a></author><comments><comment><text><span class="comment-copy">This is a useful anti-spam trick, but I would suggest using a field name other than 'email', or you may find that browser auto-fill's fill it in, inadvertently blocking genuine users of your site.</span></text><author><a class="comment-user" href="/users/140293/nico-burns" title="9,242 reputation">Nico Burns</a></author></comment><comment><text><span class="comment-copy">I already noted that in the Warning section, but yeah that's true.</span></text><author><a class="comment-user" href="/users/192310/pieter888" title="2,133 reputation">Pieter888</a></author></comment><comment><text><span class="comment-copy">Aww, I came up with this on my own one day, and as you mentioned, once I applied it to my contact forms across multiple websites it has absolutely blocked spam for over a year. Love it, but I was dreading the day when I saw it mentioned on a high visibility website. ;)</span></text><author><a class="comment-user" href="/users/433327/dustin-graham" title="1,478 reputation">Dustin Graham</a></author></comment><comment><text><span class="comment-copy">you can turn off autocomplete for individual form fields.  what you should be careful of is humans using useragents that do not recognise style sheets.</span></text><author><a class="comment-user" href="/users/76392/bluesmoon" title="2,664 reputation">bluesmoon</a></author></comment><comment><text><span class="comment-copy">I also have several more of these using <code>visibility:hidden</code> and also <code>position:absolute;top:-9000px</code> you can also do <code>text-indent</code> and also <code>z-index</code> on a few of these elements and place them in compressed CSS file names with awkward names - since bots can detect 1display:none` and they now check for a range of combinations - I actually use these methods and they're old tricks of the trade. +1</span></text><author><a class="comment-user" href="/users/596952/theblackbenzkid" title="12,201 reputation">TheBlackBenzKid</a></author></comment><comment><text><span class="comment-copy">Thought I would mention the potential accessibility concern here. You should include a message (which can also be hidden) that the field should be left blank.</span></text><author><a class="comment-user" href="/users/123695/michael-mior" title="18,457 reputation">Michael Mior</a></author></comment><comment><text><span class="comment-copy">What happens when a user with a vision impairment is using a screenreader to navigate the form?</span></text><author><a class="comment-user" href="/users/561665/gtcharlie" title="437 reputation">gtcharlie</a></author></comment><comment><text><span class="comment-copy">This technique has a name: the honeypot <a href="http://en.wikipedia.org/wiki/Honeypot_%28computing%29" rel="nofollow noreferrer">en.wikipedia.org/wiki/Honeypot_(computing)</a></span></text><author><a class="comment-user" href="/users/53960/pixeline" title="13,406 reputation">pixeline</a></author></comment><comment><text><span class="comment-copy">No need for inline styling. Just add a class to the field (maybe use a weird word that could never mean anything to a bot), and hide it via the site's CSS file. Like: <code>&lt;input type="text" name="email" class="cucaracha"&gt;</code> and in your CSS: <code>.cucaracha { display:none; }</code>.</span></text><author><a class="comment-user" href="/users/321555/ricardo-zea" title="3,795 reputation">Ricardo Zea</a></author></comment><comment><text><span class="comment-copy">Careful of usability, as users who want to use auto-populating fields by plug-ins or browser settings may populate these fields automagically.  Then you're hurting your users above preventing hackers.</span></text><author><a class="comment-user" href="/users/209259/erik-philips" title="32,435 reputation">Erik Philips</a></author></comment><comment><text><span class="comment-copy">Instead of z-indexing the input, how about leaving it as a completely normal-looking <code>&lt;input type="text" name="email" /&gt;</code> and then z-index something over the top of it?</span></text><author><a class="comment-user" href="/users/1094772/rybo111" title="6,131 reputation">rybo111</a></author></comment><comment><text><span class="comment-copy">FYI, it is called the honeypot technique. Very useful against bots, presumably not so much against spamming sweat farms where real humans interact with your forms.</span></text><author><a class="comment-user" href="/users/53960/pixeline" title="13,406 reputation">pixeline</a></author></comment><comment><text><span class="comment-copy">@NicoBurns, that is a good point, but I think emptying the field by js can help.</span></text><author><a class="comment-user" href="/users/932473/dav" title="4,176 reputation">dav</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I do not think the above answer is "wrong" but there are large areas of authentication that are not touched upon (or rather the emphasis is on "how to implement cookie sessions", not on "what options are available and what are the trade offs".</p>
<p>My suggested edits / answers are</p>
<ul>
<li>The problem lies more in account setup than in password checking.</li>
<li>The use of two factor authenitication is much more secure than more clever means of password encryption</li>
<li><p>Do NOT try to implement your own login form or database storage of passwords, unless 
the data being stored is valueless at account creation and self-generated (that is, web 2.0 style like Facebook, <a href="http://en.wikipedia.org/wiki/Flickr" rel="noreferrer">Flickr</a>, etc.)</p>
<ol>
<li>Digest Authentication is a standards based approach supported in all major browsers and servers, that will not send a password even over a secure channel.</li>
</ol></li>
</ul>
<p>This avoids any need to have "sessions" or cookies as the browser itself will re-encrypt the communication each time. It is the most "lightweight" development approach.</p>
<p>However, I do not recommend this, except for public, low value services. This is an issue with some of the other answers above - do not try an re-implement server-side authetication mechanisms - this problem has been solved and is supported by most major browsers. Do not use cookies. Do not store anything in your own hand-rolled database. Just ask, per request, if the request is autheticated. Everything else should be supported by configuration and third-party trusted software.</p>
<p>So ...</p>
<p>First, we are confusing the initial creation of an account (with a password) with the 
re-checking of the password subsequently. If I am Flickr and creating your site for the first time, the new user has access to zero value (blank web space). I truly do not care if the person creating the account is lying about their name. If I am creating an account of the hospital intranet / extranet, the value lies in all the medical records, and so I <em>do</em> care about the identity (*) of the account creator.</p>
<p>This is the very very hard part. The <em>only</em> decent solution is a web of trust. For example, you join the hospital as a doctor. You create a web page hosted somewhere with your photo, your passport number and a public key, and hash them all with the private key. You then visit the hospital and the system administrator looks at your passport, sees if the photo matches you, and then hashes the web page / photo hash with the hospital private key. From now on we can securely exchange keys and tokens. As can anyone who trusts the hospital (there is the secret sauce BTW). The system administrator can also give you an <a href="http://en.wikipedia.org/wiki/RSA_%28security_firm%29" rel="noreferrer">RSA</a> dongle or other two-factor authentication.</p>
<p>But this is a <em>lot</em> of hassle, and not very web 2.0. However, it is the only secure way to create new accounts that have access to valuable information that is not self-created.</p>
<ol>
<li><p>Kerberos and SPNEGO - single sign on mechanisms with a trusted third party - basically the user verifies against a trusted third party. (NB this is not in any way the not to be trusted <a href="http://en.wikipedia.org/wiki/OAuth" rel="noreferrer">OAuth</a>)</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol" rel="noreferrer">SRP</a> - sort of clever password authentication without a trusted third party. But here we are getting into the realms of "it's safer to use two factor authentication, even if that's costlier"</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/SSL" rel="noreferrer">SSL</a> client side - give the clients a public key certificate (support in all major browsers - but raises questions over client machine security).</p></li>
</ol>
<p>In the end it's a tradeoff - what is the cost of a security breach vs the cost of implementing more secure approaches. One day, we may see a proper <a href="http://en.wikipedia.org/wiki/Public-key_infrastructure" rel="noreferrer">PKI</a> widely accepted and so no more own rolled authentication forms and databases. One day...</p>
</div></text><author><a href="/users/571567">you cad sir - take that</a></author><comments><comment><text><span class="comment-copy">Hard to tell which answer you are talking about in 'I do not think the above answer is "wrong"'</span></text><author><a class="comment-user" href="/users/128583/davorak" title="5,670 reputation">Davorak</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>When hashing, don't use fast hash algorithms such as MD5 (many hardware implementations exist).  Use something like SHA-512.  For passwords, slower hashes are better.</p>
<p>The faster you can create hashes, the faster any brute force checker can work. Slower hashes will therefore slow down brute forcing. A slow hash algorithm will make brute forcing impractical for longer passwords (8 digits +)</p>
</div></text><author><a href="/users/884964">josh</a></author><comments><comment><text><span class="comment-copy">SHA-512 is also fast, so you need thousands of iterations.</span></text><author><a class="comment-user" href="/users/6475/seun-osewa" title="3,850 reputation">Seun Osewa</a></author></comment><comment><text><span class="comment-copy">"dont use fast hash algorithms... slower hashes are better" - Explanation? Documentation?</span></text><author><a class="comment-user" href="/users/146610/one-beat-consumer" title="6,551 reputation">one.beat.consumer</a></author></comment><comment><text><span class="comment-copy">Explanation: The faster you can create hashes, the faster any brute force checker can work. Slower hashes will therefore slow down brute forcing. A slow hash algorithm will make brute forcing impractical for longer passwords (8 digits +)</span></text><author><a class="comment-user" href="/users/229587/nickg" title="3,313 reputation">NickG</a></author></comment><comment><text><span class="comment-copy">More like something like bcrypt which is designed to hash slowly.</span></text><author><a class="comment-user" href="/users/133704/fabian-nicollier" title="2,112 reputation">Fabian Nicollier</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A good article about realistic password strength estimation is:</p>
<p><em><a href="https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/">Dropbox Tech Blog » Blog Archive » zxcvbn: realistic password strength estimation</a></em></p>
</div></text><author><a href="/users/1148529">blade19899</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>My favourite rule in regards to authentication systems: use passphrases, not passwords. Easy to remember, hard to crack.
More info: <a href="http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html" rel="noreferrer">Coding Horror: Passwords vs. Pass Phrases</a></p>
</div></text><author><a href="/users/1148529">blade19899</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'd like to add one suggestion I've used, based on defense in depth. You don't need to have the same auth&amp;auth system for admins as regular users. You can have a separate login form on a separate url executing separate code for requests that will grant high privileges. This one can make choices that would be a total pain to regular users. One such that I've used is to actually scramble the login URL for admin access and email the admin the new URL. Stops any brute force attack right away as your new URL can be arbitrarily difficult (very long random string) but your admin user's only inconvenience is following a link in their email. The attacker no longer knows where to even POST to. </p>
</div></text><author><a href="/posts/31486842/revisions" id="history-31486842" title="show revision history for this post">
        Iain Duncan
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would like to add one very-important comment:</p>
<ul>
<li>"In a <em>corporate,</em> <strong>intra-</strong> net setting," most if not all of the foregoing might not apply!</li>
</ul>
<p>Many corporations deploy "internal use only" websites which are, effectively, "corporate applications" that happen to have been implemented through URLs. These URLs can <em>(supposedly ...)</em> only be resolved within "the company's internal network." <em>(Which network magically includes all VPN-connected 'road warriors.')</em> </p>
<p>When a user is dutifully-connected to the aforesaid network, their identity <em>("authentication")</em> is [already ...] "conclusively known," as is their permission <em>("authorization")</em> to do certain things ... such as ... "to access this website."</p>
<p>This "authentication + authorization" service can be provided by several different technologies, such as LDAP <em>(Microsoft OpenDirectory)</em>, or Kerberos.</p>
<p>From your point-of-view, you simply know this: that <em>anyone</em> who legitimately winds-up at your website <em>must</em> be accompanied by [an environment-variable magically containing ...] a "token." (<em>i.e.</em> The absence of such a token must be immediate grounds for <code>404 Not Found</code>.)</p>
<p>The token's value makes no sense to you, <em>but,</em> should the need arise, "appropriate means exist" by which your web-site can "[authoritatively] ask someone who knows (LDAP... etc.)" about any <em>and every(!)</em> question that you may have. In other words, you do <strong>not</strong> avail yourself of <em>any</em> "home-grown logic." Instead, you inquire of The Authority and implicitly trust its verdict.</p>
<p>Uh huh ... it's <em>quite</em> a mental-switch from the "wild-and-wooly Internet."</p>
</div></text><author><a href="/users/4811873">Mike Robinson</a></author><comments><comment><text><span class="comment-copy">Did you fell in the punctuation well as a child? :) I've read it three times and I am still lost at what point you are trying to make. But if you are saying "Sometimes you do not need form based authentication" then you are right. But considering we are discussing when we do need it, I dont see why this is very important to note?</span></text><author><a class="comment-user" href="/users/434949/hugo-delsing" title="9,354 reputation">Hugo Delsing</a></author></comment><comment><text><span class="comment-copy">My point is that the world <i>outside</i> a corporation is entirely different from the world <i>inside.</i>  If you are building an app that is accessible to the "wooly wide web," and for general consumption by the public, then you have no choice but to roll your own authentication and authorization methods.  But, inside a corporation, where the only way to get there is to be there or to use VPN, then it is very likely that the application will not have – <i>must not</i> have – "its own" methods for doing these things.  The app <i>must</i> use these methods instead, to provide consistent, centralized management.</span></text><author><a class="comment-user" href="/users/4811873/mike-robinson" title="3,308 reputation">Mike Robinson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I dont't know whether it was best to answer this as an answer or as a comment. I opted for the first option.</p>
<p>Regarding the poing <strong>PART IV: Forgotten Password Functionality</strong> in the first answer, I would make a point about Timing Attacks. </p>
<p>In the <strong>Remember your password</strong> forms, an attacker could potentially check a full list of emails and detect which are registered to the system (see link below). </p>
<p>Regarding the Forgotten Password Form, I would add that it is a good idea to equal times between successful and unsucessful queries with some delay function. </p>
<p><a href="https://crypto.stanford.edu/%7Edabo/papers/webtiming.pdf">https://crypto.stanford.edu/~dabo/papers/webtiming.pdf</a></p>
</div></text><author><a href="/posts/32038011/revisions" id="history-32038011" title="show revision history for this post">
        j__
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Use <a href="http://openid.net/connect/" rel="nofollow">OpenID Connect</a> or <a href="https://kantarainitiative.org/confluence/display/uma/Home" rel="nofollow">User-Managed Access</a>.</p>
<p>As nothing is more efficient than not doing it at all.</p>
</div></text><author><a href="/posts/38874818/revisions" id="history-38874818" title="show revision history for this post">
        jwilleke
        </a></author><comments/></answer></answers></post>