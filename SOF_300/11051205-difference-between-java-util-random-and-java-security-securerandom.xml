<?xml version="1.0" encoding="utf-8"?>
<post><title>Difference between java.util.Random and java.security.SecureRandom - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>My team got handed over some server side code (in Java) that generates random tokens and I have a question regarding the same -</p>
<p>The purpose of these tokens is fairly sensitive - used for session id, password reset links etc. So they do need to be cryptographically random to avoid somebody guessing them or brute force them feasibly. The token is a "long" so it is 64 bits long.</p>
<p>The code currently uses the <code>java.util.Random</code> class to generate these tokens. The documentation ([<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Random.html][1]" rel="noreferrer">http://docs.oracle.com/javase/7/docs/api/java/util/Random.html][1]</a>) for <code>java.util.Random</code> clearly states the following: </p>
<blockquote>
<p>Instances of java.util.Random are not cryptographically secure. Consider instead using SecureRandom to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.</p>
</blockquote>
<p>However, the way the code is currently using <code>java.util.Random</code> is this - It instantiates the <code>java.security.SecureRandom</code> class and then uses the <code>SecureRandom.nextLong()</code> method to obtain the seed that is used for instantiating the <code>java.util.Random</code>class. Then it uses <code>java.util.Random.nextLong()</code> method to generate the token.</p>
<p>So my question now - Is it still insecure given that the <code>java.util.Random</code> is being seeded using <code>java.security.SecureRandom</code>? Do I need to modify the code so that it uses <code>java.security.SecureRandom</code> exclusively to generate the tokens?</p>
<p>Currently the code seed's the <code>Random</code> once at startup</p>
</div></text><author><a href="/users/102937/robert-harvey">Robert Harvey</a></author><comments><comment><text><span class="comment-copy">Once seeded, output from java.util.Random is deterministic sequence of numbers. You may not want that.</span></text><author><a class="comment-user" href="/users/47190/peter-%c5%a0tibran%c3%bd" title="24,221 reputation">Peter Štibraný</a></author></comment><comment><text><span class="comment-copy">Does the code seed the <code>Random</code> once at startup, or does it seed a new one for every token? Hopefully, this is a stupid question, but i thought i'd check.</span></text><author><a class="comment-user" href="/users/116639/tom-anderson" title="32,051 reputation">Tom Anderson</a></author></comment><comment><text><span class="comment-copy">Random only has a 48-bit internal state and will repeat after 2^48 calls to nextLong() which means that it won't produce all possible <code>long</code> or <code>double</code> values.</span></text><author><a class="comment-user" href="/users/57695/peter-lawrey" title="379,447 reputation">Peter Lawrey</a></author></comment><comment><text><span class="comment-copy">There is another severe problem. 64bits means 1.84*10^19 possible combinations which is too few to withstand a sophisticated attack. There are machines out there which cracked a 56 bit DES code (factor 256 less) with 90*10^9 keys per second in 60 hours. Use 128 bits or two longs !</span></text><author><a class="comment-user" href="/users/224774/thorsten-s" title="2,779 reputation">Thorsten S.</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The standard Oracle JDK 7 implementation uses what's called a Linear Congruential Generator  to produce random values in <code>java.util.Random</code>. </p>
<p>Taken from <code>java.util.Random</code> source code (JDK 7u2), from a comment on the method <code>protected int next(int bits)</code>, which is the one that generates the random values:</p>
<blockquote>
<p>This is a linear congruential pseudorandom number generator, as
    defined by D. H. Lehmer and described by Donald E. Knuth in
    <i>The Art of Computer Programming,</i> Volume 3:
    <i>Seminumerical Algorithms</i>, section 3.2.1.</p>
</blockquote>
<h3>Predictability of Linear Congruential Generators</h3>
<p>Hugo Krawczyk wrote a pretty good paper about how these LCGs can be predicted ("How to predict congruential generators"). If you're lucky and interested, you may still find a free, downloadable version of it on the web. And there's plenty more research that clearly shows that you should <strong>never</strong> use an LCG for security-critical purposes. This also means that your random numbers <em>are</em> predictable right now, something you don't want for session IDs and the like.</p>
<h3>How to break a Linear Congruential Generator</h3>
<p>The assumption that an attacker would have to wait for the LCG to repeat after a full cycle is wrong. Even with an optimal cycle (the modulus m in its recurrence relation) it is very easy to predict future values in much less time than a full cycle. After all, it's just a bunch of modular equations that need to be solved, which becomes easy as soon as you have observed enough output values of the LCG. </p>
<p>The security doesn't improve with a "better" seed. It simply doesn't matter if you seed with a random value generated by <code>SecureRandom</code> or even produce the value by rolling a die several times. </p>
<p>An attacker will simply compute the seed from the output values observed. This takes <em>significantly less</em> time than 2^48 in the case of <code>java.util.Random</code>. Disbelievers may try out this <a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" rel="noreferrer">experiment</a>, where it is shown that you can predict future <code>Random</code> outputs observing only two(!) output values in time roughly 2^16. It takes not even a second on a modern computer to predict the output of your random numbers right now.</p>
<h3>Conclusion</h3>
<p>Replace your current code. Use <code>SecureRandom</code> exclusively. Then at least you will have a little guarantee that the result will be hard to predict. If you want the properties of a cryptographically secure PRNG (in your case, that's what you want), then you have to go with <code>SecureRandom</code> only. Being clever about changing the way it was supposed to be used will almost always result in something less secure...</p>
</div></text><author><a href="/users/827060/emboss">emboss</a></author><comments><comment><text><span class="comment-copy">Very helpful, may be you could also explain how SecureRandom works (just like you explain how Random works)..</span></text><author><a class="comment-user" href="/users/1401148/gresdiplitude" title="1,137 reputation">gresdiplitude</a></author></comment><comment><text><span class="comment-copy">That defeats the purpose of secureRandom</span></text><author><a class="comment-user" href="/users/1406409/azulflame" title="1,102 reputation">Azulflame</a></author></comment><comment><text><span class="comment-copy">@azulflame security through obscurity rarely works</span></text><author><a class="comment-user" href="/users/208527/kilotaras" title="1,319 reputation">kilotaras</a></author></comment><comment><text><span class="comment-copy">I know, learned that lesson the hard way. But a tough cypher and hard-to-find source works well. Notch could learn something on that (he encodes his user's password in a  .lastlogin file, encoded with basic encryption using "passwordfile" as the key)</span></text><author><a class="comment-user" href="/users/1406409/azulflame" title="1,102 reputation">Azulflame</a></author></comment><comment><text><span class="comment-copy">The real question here: if java can produce a more secure prng with a similar API, why didn't they just replace the broken one?</span></text><author><a class="comment-user" href="/users/3043/joel-coehoorn" title="262,375 reputation">Joel Coehoorn</a></author></comment><comment><text><span class="comment-copy">@JoelCoehoorn It's not that <code>Random</code> is broken - it should just be used in different scenarios. Of course, you could always use SecureRandom. But in general, <code>SecureRandom</code> is noticeably slower than pure <code>Random</code>. And there are cases where you are only interested in good statistical properties and excellent performance, but you don't really care about security: Monte-Carlo simulations are a good example. I made comments about that in a <a href="http://stackoverflow.com/questions/11099241/behaviour-of-securerandom/11101379#11101379">similar answer</a>, maybe you'll find it useful.</span></text><author><a class="comment-user" href="/users/827060/emboss" title="28,430 reputation">emboss</a></author></comment><comment><text><span class="comment-copy">@Vaishali Thanks! If I get the time, I'll try to lose a few words about the default SecureRandom implementation. In the meantime, maybe you'll find <a href="http://stackoverflow.com/questions/11099241/behaviour-of-securerandom/11101379#11101379">this</a> interesting...</span></text><author><a class="comment-user" href="/users/827060/emboss" title="28,430 reputation">emboss</a></author></comment><comment><text><span class="comment-copy">The fresh article on the same subject. There's also implementation inside that able to predict double values. (<a href="http://franklinta.com/2014/08/31/predicting-the-next-math-random-in-java/" rel="nofollow noreferrer">franklinta.com/2014/08/31/…</a>)</span></text><author><a class="comment-user" href="/users/880457/artspb" title="379 reputation">artspb</a></author></comment><comment><text><span class="comment-copy">@emboss The "experiment" provided on the blog actually does not work - the if condition never comes out as true.  Other people on that blog comment list have also made that comment.</span></text><author><a class="comment-user" href="/users/298742/amrinder-arora" title="552 reputation">Amrinder Arora</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A random has only 48 bits where as SecureRandom can have upto 128 bits. So the chances of repeating in securerandom is very small.<br/><br/> <strong>Random</strong> uses the <code>system clock</code> as the seed/or to generate the seed. So they can be reproduced easily if the attacker knows the time at which the seed was generated. But <strong>SecureRandom</strong> takes <code>Random Data</code> from your <code>os</code>(they can be interval between keystrokes etc - most os collect these data store them in files -  <code>/dev/random and /dev/urandom in case of linux/solaris</code>) and uses that as the seed. <br/>So if the small token size is okay(in case of Random), you can continue using your code without any changes, since you are using SecureRandom to generate the seed. But if you want larger tokens(which cannot be subject to <code>brute force attacks</code>) go with SecureRandom - <br/>In case of random just <code>2^48</code> attempts are required, with todays advanced cpu's it is possible to break it in practical time. But for securerandom <code>2^128</code> attempts will be required, which will take years and years to break even with today's advanced machines.<br/><br/>
See <a href="http://resources.infosecinstitute.com/random-number-generation-java/"> this </a> link for more details.
<br/>
<strong>EDIT</strong><br/>
After reading the links provided by @emboss, it is clear that the seed, however random it maybe, 
should not be used with java.util.Random. It is very easy to calculate the seed by observing the output.<br/><br/>
<strong>Go for SecureRandom</strong> - Use <strong>Native PRNG</strong> (as given in the link above) because it takes random values from the <code>/dev/random</code> file for each call to <code>nextBytes()</code>. This way an attacker observing the output will not be able to make out anything unless he is controlling the contents of the <code>/dev/random</code> file(which is very unlikely) <br/>
The <strong>sha1 prng</strong> algorithm calculates the seed only once and if your VM is running for months using the same seed, it might be cracked by an attacker who is passively observing the output.<br/><br/>
<strong>NOTE</strong> - If you are calling the <code>nextBytes()</code> faster than your os is able to write random bytes(entropy) into the <code>/dev/random</code>, you might land into  trouble when using  <strong>NATIVE PRNG</strong>. In that case use a SHA1 PRNG instance of SecureRandom and every few minutes(or some interval), seed this instance with the value from <code>nextBytes()</code> of a NATIVE PRNG instance of SecureRandom. Running these two parallely will ensure that you are seeding regularly with true random values, while also not exhausting the entropy obtained by the Operating System.</p>
</div></text><author><a href="/users/1139023/ashwin">Ashwin</a></author><comments><comment><text><span class="comment-copy">It requires much less than 2^48 to predict a <code>Random</code>, the OP shouldn't be using <code>Random</code> at all.</span></text><author><a class="comment-user" href="/users/827060/emboss" title="28,430 reputation">emboss</a></author></comment><comment><text><span class="comment-copy">@emboss : I am talking about bruteforce.</span></text><author><a class="comment-user" href="/users/1139023/ashwin" title="3,317 reputation">Ashwin</a></author></comment><comment><text><span class="comment-copy">Take care with Linux: it can reach entropy exhaustion (more in VM than with hardware) ! Look at <code>/proc/sys/kernel/random/entropy_avail</code> and check with some thread dumps that there is no too long wait when reading on <code>/dev/random</code></span></text><author><a class="comment-user" href="/users/737790/yves-martin" title="8,004 reputation">Yves Martin</a></author></comment><comment><text><span class="comment-copy">Notice that Oracle JRE (at least 1.7) works with /dev/urandom by default and not /dev/random so the suffix of your answer is no longer correct. to verify check $JAVA_HOME/lib/security/java.security for the securerandom.source property</span></text><author><a class="comment-user" href="/users/1055844/boaz" title="2,709 reputation">Boaz</a></author></comment><comment><text><span class="comment-copy">Our java.security file had securerandom.source=file:/dev/urandom instead of file:///dev/urandom (two slashes after colon for file protocol, then one more slash for root of filesystem), causing it to fall back to /dev/random, which caused problems with entropy pool exhaustion.  Couldn't edit it, so had to set a system property java.security.egd to the right one at app startup.</span></text><author><a class="comment-user" href="/users/244994/maxpolk" title="1,112 reputation">maxpolk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you run twice <code>java.util.Random.nextLong()</code> with the same seed, it will produce the same number. For security reasons you want to stick with <code>java.security.SecureRandom</code> because it's a lot less predictable.</p>
<p>The 2 Classes are similar, I think you just need to change <code>Random</code> to <code>SecureRandom</code> with a refactoring tool and most of your existing code will work.</p>
</div></text><author><a href="/users/747047/mualig">Mualig</a></author><comments><comment><text><span class="comment-copy">If you take two instances of any PRNG and seed it with the same value you always get the same random numbers, even using SecureRandom does not change that. All PRNGs are deterministic and therefore predictable if you know the seed.</span></text><author><a class="comment-user" href="/users/150978/robert" title="19,397 reputation">Robert</a></author></comment><comment><text><span class="comment-copy">There are different SecureRandom implementations, some are PRNGs, some are not. On the other hand, java.util.Random is always PRNG (as defined in its Javadoc).</span></text><author><a class="comment-user" href="/users/47190/peter-%c5%a0tibran%c3%bd" title="24,221 reputation">Peter Štibraný</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If changing your existing code is an affordable task, I suggest you use the SecureRandom class as suggested in Javadoc. </p>
<p>Even if you find the Random class implementation uses the SecureRandom class internally. you should not take it for granted that: </p>
<ol>
<li>Other VM implementations do the same thing. </li>
<li>Implementation of the Random class in future versions of the JDK still use the SecureRandom class </li>
</ol>
<p>So it's a better choice to follow the documentation suggestion and go directly with SecureRandom.</p>
</div></text><author><a href="/users/410860/andrea-parodi">Andrea Parodi</a></author><comments><comment><text><span class="comment-copy">I don't believe the original question stated that the <code>java.util.Random</code> implementation used <code>SecureRandom</code> internally, it said <i>their code</i> uses <code>SecureRandom</code> to seed the <code>Random</code>. Still, I agree with both the answers so far; it's best to use <code>SecureRandom</code> to avoid an explicitly deterministic solution.</span></text><author><a class="comment-user" href="/users/603369/palpatim" title="6,560 reputation">Palpatim</a></author></comment><comment><text><span class="comment-copy">Oh, yes. My fault...</span></text><author><a class="comment-user" href="/users/410860/andrea-parodi" title="3,672 reputation">Andrea Parodi</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The current reference implementation of <code>java.util.Random.nextLong()</code> makes two calls to the method <code>next(int)</code> which <em>directly</em> exposes 32 bit of the current seed:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> next</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> bits</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">long</span><span class="pln"> nextseed</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// calculate next seed: ...</span><span class="pln">
    </span><span class="com">// and store it in the private "seed" field.</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">nextseed </span><span class="pun">&gt;&gt;&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">48</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> bits</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> nextLong</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// it's okay that the bottom word remains signed.</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">long</span><span class="pun">)(</span><span class="pln">next</span><span class="pun">(</span><span class="lit">32</span><span class="pun">))</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">32</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> next</span><span class="pun">(</span><span class="lit">32</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>The upper 32 bit of the result of <code>nextLong()</code> are the bits of the seed at the time. Since the width of the seed is 48 bit (says the javadoc), it suffices* to iterate over the remaining 16 bit (that's only 65.536 tries) to determine the seed which produced the second 32 bit.</p>
<p>Once the seed is known, all following tokens can easily be computed.</p>
<p><strong>Using the output of <code>nextLong()</code> directly, partly the secret of the PNG to a degree that the entire secret can be computed with very little efford. Dangerous!</strong></p>
<p>* There is some effort needed if the second 32 bit are negative, but one can find that out.</p>
</div></text><author><a href="/users/924331/matt">Matt</a></author><comments><comment><text><span class="comment-copy">Correct. See how to quickly crack java.util.random at <a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" rel="nofollow noreferrer">jazzy.id.au/default/2010/09/20/…</a> !</span></text><author><a class="comment-user" href="/users/325452/ingyhere" title="3,508 reputation">ingyhere</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The seed is meaningless. A good random generator differs in the chosen primenumber. Every random generator starts from a number and iterates through a 'ring'. Which means, you come from one number to the next, with the old internal value. But after a while you reach the beginning again and start all over again. So you run cycles. (the return value from a random generator is not the internal value)</p>
<p>If you use a prime number for creating a ring, all numbers in that ring gets chosen, before you complete a full cycle through all possible numbers. If you take non prime numbers, not all numbers are chosen and you get shorter cycles.</p>
<p>Higher prime numbers mean, longer cycles, before your returning to the first element again. So, the secure random generator just has a longer cycle, before reaching the beginning again, thats why it is safer. You can't predict the number generation as easy as with shorter cycles.</p>
<p>With other words: You have to replace all.</p>
</div></text><author><a href="/users/1396846/nicolas">Nicolas</a></author><comments/></answer></answers></post>