<?xml version="1.0" encoding="utf-8"?>
<post><title>security - What is the best way to prevent session hijacking? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Specifically this is regarding when using a client session cookie to identify a session on the server.</p>
<p>Is the best answer to use SSL/HTTPS encryption for the entire web site, and you have the best guarantee that no man in the middle attacks will be able to sniff an existing client session cookie?</p>
<p>And perhaps second best to use some sort of encryption on the session value itself that is stored in your session cookie?</p>
<p>If a malicious user has physical access to a machine, they can still look at the filesystem to retrieve a valid session cookie and use that to hijack a session?</p>
</div></text><author><a href="/users/2134/chris">Chris</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Encrypting the session value will have zero effect. The session cookie is already an arbitrary value, encrypting it will just generate another arbitrary value that can be sniffed.</p>
<p>The only real solution is HTTPS. If you don't want to do SSL on your whole site (maybe you have performance concerns), you might be able to get away with only SSL protecting the sensitive areas. To do that, first make sure your login page is HTTPS. When a user logs in, set a secure cookie (meaning the browser will only transmit it over an SSL link) in addition to the regular session cookie. Then, when a user visits one of your "sensitive" areas, redirect them to HTTPS, and check for the presence of that secure cookie. A real user will have it, a session hijacker will not.</p>
<p><strong>EDIT</strong>: This answer was originally written in 2008. It's 2016 now, and there's no reason not to have SSL across your entire site. No more plaintext HTTP!</p>
</div></text><author><a href="/users/2527/josh-hinman">Josh Hinman</a></author><comments><comment><text><span class="comment-copy">HTTPS will prevent the sniffing only. But if you have a XSS, or the session IDs can be guessed easily, or you are vulnerable to session fixation, or your session ID storage is weak (SQL injection?), SSL will be no improvement at all.</span></text><author><a class="comment-user" href="/users/333599/calimo" title="2,914 reputation">Calimo</a></author></comment><comment><text><span class="comment-copy">@Josh If a malicious user has physical access to a machine, they can still look at the filesystem to retrieve a valid session cookie and use that to hijack a session?</span></text><author><a class="comment-user" href="/users/632951/pacerier" title="33,795 reputation">Pacerier</a></author></comment><comment><text><span class="comment-copy">If a malicious user has physical access to a filesystem, they don't need to hijack a session.</span></text><author><a class="comment-user" href="/users/2527/josh-hinman" title="5,046 reputation">Josh Hinman</a></author></comment><comment><text><span class="comment-copy">@Josh. Not true, sometimes a user has limited time physical access to a filesystem. Imagine a laptop left unlocked by a colleague rushing to the toilet, now all I need to do is to go to that laptop, install EditThisCookie plugin, grab his cookies at plus.google.com using EditThisCookie export feature <b>and now I have his account</b>. Time taken: 18 seconds.</span></text><author><a class="comment-user" href="/users/632951/pacerier" title="33,795 reputation">Pacerier</a></author></comment><comment><text><span class="comment-copy">I'm pretty sure google will have some kind of security feature build-in as this is obviously the first thing you would think of when talking about session hijacking</span></text><author><a class="comment-user" href="/users/1024322/xorinzor" title="1,413 reputation">xorinzor</a></author></comment><comment><text><span class="comment-copy">Are we talking about cookies or session scoped variables.</span></text><author><a class="comment-user" href="/users/1229594/leeish" title="3,950 reputation">Leeish</a></author></comment><comment><text><span class="comment-copy">even redirect from http to https is not a good option. this redirection will lead to MITM attack. A man-in-the-middle attacker attempts to intercept traffic from a victim user using an invalid certificate and hopes the user will accept the bad certificate HSTS does not allow a user to override the invalid certificate message. but it seems most of the web browser haven't implemented this feature yet</span></text><author><a class="comment-user" href="/users/3411933/anshuman-singh" title="369 reputation">anshuman singh</a></author></comment><comment><text><span class="comment-copy">-1 for suggesting only having HTTPS on certain parts of your site, session hijacking is just as easy if you have one SSL vulnerability on your site. If the user visits that one page, another person on the same network can easily sniff out the session id.</span></text><author><a class="comment-user" href="/users/6617493/dastur" title="367 reputation">Dastur</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The SSL only helps with sniffing attacks. If an attacker has access to your machine I will assume they can copy your secure cookie too.  </p>
<p>At the very least, make sure old cookies lose their value after a while. Even a successful hijaking attack will be thwarted when the cookie stops working. If the user has a cookie from a session that logged in more than a month ago, make them reenter their password. Make sure that whenever a user clicks on your site's "log out" link, that the old session UUID can never be used again. </p>
<p>I'm not sure if this idea will work but here goes: Add a serial number into your session cookie, maybe a string like this:</p>
<p>SessionUUID, Serial Num, Current Date/Time</p>
<p>Encrypt this string and use it as your session cookie. Regularly change the serial num - maybe when the cookie is 5 minutes old and then reissue the cookie.  You could even reissue it on every page view if you wanted to. On the server side, keep a record of the last serial num you've issued for that session.  If someone ever sends a cookie with the wrong serial number it means that an attacker may be using a cookie they intercepted earlier so invalidate the session UUID and ask the user to reenter their password and then reissue a new cookie.</p>
<p>Remember that your user may have more than one computer so they may have more than one active session. Don't do something that forces them to log in again every time they switch between computers.</p>
</div></text><author><a>NONE</a></author><comments><comment><text><span class="comment-copy">I know this is an old post, but just wanted to include that if an attacker were to hijack the session within the window allotted by the "serial number" then this wouldn't affect him.</span></text><author><a class="comment-user" href="/users/1195273/crush" title="11,288 reputation">crush</a></author></comment><comment><text><span class="comment-copy">@crush, but then the attacker would be locked out after the allotted window, right? So at the very least the attack window is small(er).</span></text><author><a class="comment-user" href="/users/2151700/johanneke" title="2,566 reputation">Johanneke</a></author></comment><comment><text><span class="comment-copy">Very clever idea!</span></text><author><a class="comment-user" href="/users/558670/gabriel-graves" title="983 reputation">Gabriel Graves</a></author></comment><comment><text><span class="comment-copy">Only problem is if the user leaves your website for 5 minutes, they'll have to login again</span></text><author><a class="comment-user" href="/users/3576887/user3576887" title="104 reputation">user3576887</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Have you considered reading a book on PHP security? Highly recommended.</p>
<p>I have had much success with the following method for non SSL certified sites.</p>
<ol>
<li><p>Dis-allow multiple sessions under the same account, making sure you aren't checking this solely by IP address. Rather check by token generated upon login which is stored with the users session in the database, as well as IP address, HTTP_USER_AGENT and so forth</p></li>
<li><p>Using Relation based hyperlinks
Generates a link ( eg. <a href="http://example.com/secure.php?token=2349df98sdf98a9asdf8fas98df8" rel="nofollow noreferrer">http://example.com/secure.php?token=2349df98sdf98a9asdf8fas98df8</a> )
The link is appended with a x-BYTE ( preferred size ) random salted MD5 string, upon page              redirection the randomly generated token corresponds to a requested page. </p>
<ul>
<li>Upon reload, several checks are done. </li>
<li>Originating IP Address</li>
<li>HTTP_USER_AGENT </li>
<li>Session Token</li>
<li>you get the point.</li>
</ul></li>
<li><p>Short Life-span session authentication cookie.
as posted above, a cookie containing a secure string, which is one of the direct references to the sessions validity is a good idea. Make it expire every x Minutes, reissuing that token, and re-syncing the session with the new Data. If any mis-matches in the data, either log the user out, or having them re-authenticate their session.</p></li>
</ol>
<p>I am in no  means an expert on the subject, I'v had a bit of experience in this particular topic, hope some of this helps anyone out there.  </p>
</div></text><author><a href="/users/827372/nathan">Nathan</a></author><comments><comment><text><span class="comment-copy">Are there any books you would recommend?</span></text><author><a class="comment-user" href="/users/829305/rikki" title="682 reputation">Rikki</a></author></comment><comment><text><span class="comment-copy">Especially given that the OP didn't state anything about PHP specifically, I would say that it's better to look at just a general security book (especially as the security between different languages differs only in implementation details, but the concepts remain the same).</span></text><author><a class="comment-user" href="/users/1503619/matts1" title="367 reputation">matts1</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<pre><code>// Collect this information on every request
$aip = $_SERVER['REMOTE_ADDR'];
$bip = $_SERVER['HTTP_X_FORWARDED_FOR'];
$agent = $_SERVER['HTTP_USER_AGENT'];
session_start();

// Do this each time the user successfully logs in.
$_SESSION['ident'] = hash("sha256", $aip . $bip . $agent);

// Do this every time the client makes a request to the server, after authenticating
$ident = hash("sha256", $aip . $bip . $agent);
if ($ident != $_SESSION['ident'])
{
    end_session();
    header("Location: login.php");
    // add some fancy pants GET/POST var headers for login.php, that lets you
    // know in the login page to notify the user of why they're being challenged
    // for login again, etc.
}
</code></pre>
<p>What this does is capture 'contextual' information about the user's session, pieces of information which should not change during the life of a single session. A user isn't going to be at a computer in the US and in China at the same time, right? So if the IP address changes suddenly within the same session that strongly implies a session hijacking attempt, so you secure the session by ending the session and forcing the user to re-authenticate. This thwarts the hack attempt, the attacker is also forced to login instead of gaining access to the session. Notify the user of the attempt (ajax it up a bit), and vola, Slightly annoyed+informed user and their session/information is protected.</p>
<p>We throw in User Agent and X-FORWARDED-FOR to do our best to capture uniqueness of a session for systems behind proxies/networks. You may be able to use more information then that, feel free to be creative.</p>
<p>It's not 100%, but it's pretty damn effective.</p>
<p>There's more you can do to protect sessions, expire them, when a user leaves a website and comes back force them to login again maybe. You can detect a user leaving and coming back by capturing a blank HTTP_REFERER (domain was typed in the URL bar), or check if the value in the HTTP_REFERER equals your domain or not (the user clicked an external/crafted link to get to your site).</p>
<p>Expire sessions, don't let them remain valid indefinitely.</p>
<p>Don't rely on cookies, they can be stolen, it's one of the vectors of attack for session hijacking.</p>
</div></text><author><a href="/users/3063333/theironyis">theironyis</a></author><comments><comment><text><span class="comment-copy">I've run into a situation before where a certain (fairly large, but technically backward) ISP would change the IP of the user's browser from time-to-time based on re-routing their users' connections. This made the REMOTE_ADDR check return false negatives for us.</span></text><author><a class="comment-user" href="/users/275501/goofballlogic" title="7,688 reputation">goofballLogic</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Try Secure Cookie protocol described in <a href="http://www.cse.msu.edu/%7Ealexliu/publications/Cookie/cookie.pdf" rel="nofollow noreferrer">this</a> paper by Liu, Kovacs, Huang, and Gouda:</p>
<p>As stated in document:</p>
<blockquote>
<p>A secure
  cookie protocol that runs between a client and a server
  needs to provide the following four services: authentication, confidentiality, integrity and anti-replay.</p>
</blockquote>
<p>As for ease of deployment:</p>
<blockquote>
<p>In terms of efficiency, our protocol does not involve any database
  lookup or public key cryptography. In terms of deployability, our protocol can be easily deployed on an existing web server, and it does not require any change to
  the Internet cookie specication.</p>
</blockquote>
<p>In short: it is secure, lightweight, works for me just great.</p>
</div></text><author><a href="/users/29525/hubert">Hubert</a></author><comments><comment><text><span class="comment-copy">Your link is a spec of the protocol - do you have a link to an implementation?  That would be great - thanks.</span></text><author><a class="comment-user owner" href="/users/1341/adam" title="13,138 reputation">Adam</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>First of all sory for my bad english.</p>
<p>There is no way to prevent session hijaking 100%, but with some aproach can we reduce the time for an attaker to hijaking the session.</p>
<p>Method to prevent session hijaking:</p>
<p>1 - always use session with ssl certificate;</p>
<p>2 - send session cookie only with httponly set to true(prevent javascript to access session cookie)</p>
<p>2 - use session regenerate id at login and logout(note: do not use session regenerate at each request because if you have consecutive ajax request then you have a chance to create multiple session.)</p>
<p>3 - set a session timeout</p>
<p>4 - store browser user agent in a $_SESSION variable an compare with $_SERVER['HTTP_USER_AGENT'] at each request</p>
<p>5 - set a token cookie ,and set expiration time of that cookie to 0(until the browser is closed).
Regenerate the cookie value for each request.(For ajax request do not regenerate token cookie).
EX:</p>
<pre><code>    //set a token cookie if one not exist
    if(!isset($_COOKIE['user_token'])){
                    //generate a random string for cookie value
        $cookie_token = bin2hex(mcrypt_create_iv('16' , MCRYPT_DEV_URANDOM));

        //set a session variable with that random string
        $_SESSION['user_token'] = $cookie_token;
        //set cookie with rand value
        setcookie('user_token', $cookie_token , 0 , '/' , 'donategame.com' , true , true);
    }

    //set a sesison variable with request of www.example.com
    if(!isset($_SESSION['request'])){
        $_SESSION['request'] = -1;
    }
    //increment $_SESSION['request'] with 1 for each request at www.example.com
    $_SESSION['request']++;

    //verify if $_SESSION['user_token'] it's equal with $_COOKIE['user_token'] only for $_SESSION['request'] &gt; 0
    if($_SESSION['request'] &gt; 0){

        // if it's equal then regenerete value of token cookie if not then destroy_session
        if($_SESSION['user_token'] === $_COOKIE['user_token']){
            $cookie_token = bin2hex(mcrypt_create_iv('16' , MCRYPT_DEV_URANDOM));

            $_SESSION['user_token'] = $cookie_token;

            setcookie('user_token', $cookie_token , 0 , '/' , 'donategame.com' , true , true);
        }else{
            //code for session_destroy


        }

    }

            //prevent session hijaking with browser user agent
    if(!isset($_SESSION['user_agent'])){
        $_SESSION['user_agent'] = $_SERVER['HTTP_USER_AGENT'];
    }

    if($_SESSION['user_agent'] != $_SERVER['HTTP_USER_AGENT']){
      die('session hijaking - user agent');
    }
</code></pre>
<p>note: do not regenerate token cookie with ajax request
note: the code above is an example.
note: if users logout then the cookie token must be destroyed as well as the session</p>
<p>6 - it's not a good aproach to use user ip for preventing session hijaking because some users ip change with each request. THAT AFFECT VALID USERS</p>
<p>7 - personaly i store session data in database , it's up to you what method you adopt</p>
<p>If you find mistake in my aproch please correct me. If you have more ways to prevent session hyjaking plese tell me.</p>
</div></text><author><a href="/users/2750086/alexandru">Alexandru</a></author><comments><comment><text><span class="comment-copy">hi, i m trying to prevent session hijacking (in ASP.NET)and considered all above steps u suggested. It is approximate working but when I use InPrivateBrowsing/incognito mode of browser the session is Hijacked. Can u please suggest any additional thing to add in sessionId string?</span></text><author><a class="comment-user" href="/users/2314401/vishwanath-mishra" title="100 reputation">Vishwanath Mishra</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Ensure you don't use incremting integers for session IDs.  Much better to use a GUID, or some other long randomly generated character string.</p>
</div></text><author><a href="/users/1862/kibbee">Kibbee</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are many ways to create protection against session hijack, however all of them are either reducing user satisfaction or are not secure.</p>
<ul>
<li><p>IP and/or X-FORWARDED-FOR checks. These work, and are pretty secure... but imagine the pain of users. They come to an office with WiFi, they get new IP address and lose the session. Got to log-in again.</p></li>
<li><p>User Agent checks. Same as above, new version of browser is out, and you lose a session. Additionally, these are really easy to "hack". It's trivial for hackers to send fake UA strings.</p></li>
<li><p>localStorage token. On log-on generate a token, store it in browser storage and store it to encrypted cookie (encrypted on server-side). This has no side-effects for user (localStorage persists through browser upgrades). It's not as secure - as it's just security through obscurity. Additionally you could add some logic (encryption/decryption) to JS to further obscure it.</p></li>
<li><p>Cookie reissuing. This is probably the right way to do it. The trick is to only allow one client to use a cookie at a time. So, active user will have cookie re-issued every hour or less. Old cookie is invalidated if new one is issued. Hacks are still possible, but much harder to do - either hacker or valid user will get access rejected. </p></li>
</ul>
</div></text><author><a href="/users/1167116/hatch">Hatch</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Let us consider that during the login phase the client and server can agree on a secret salt value. Thereafter the server provides a count value with each update and expects the client to respond with the hash of the (secret salt + count). The potential hijacker does not have any way to obtain this secret salt value and thus cannot generate the next hash.</p>
</div></text><author><a href="/users/2529070/davej">davej</a></author><comments><comment><text><span class="comment-copy">But how do you want to store this salt on client side that no one could steal it?</span></text><author><a class="comment-user" href="/users/1907924/dcortez" title="321 reputation">Dcortez</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To reduce the risk you can also associate the originating IP with the session. That way an attacker has to be within the same private network to be able to use the session.</p>
<p>Checking referer headers can also be an option but those are more easily spoofed.</p>
</div></text><author><a href="/users/2148/julio-c%c3%a9sar">Julio César</a></author><comments><comment><text><span class="comment-copy">no, you can't use the originating IP, as it may change - either through dynamic IPs, changed when a user is temporarily disconnected, or through the (implicit or explicit) usage of a proxy farm.   Also, session hijackers coming from the same ISP may use the same proxy &amp; IP as a legitimate user...</span></text><author><a class="comment-user" href="/users/13447/olaf-kock" title="31,690 reputation">Olaf Kock</a></author></comment><comment><text><span class="comment-copy">PHP-Nuke has a good page about their session approach, and they talk in detail about how hooking it to the IP doesn't work with all ISPs <a href="http://phpnuke.org/modules.php?name=PHP-Nuke_HOWTO&amp;page=how-sessions-work.html" rel="nofollow noreferrer">phpnuke.org/…</a></span></text><author><a class="comment-user" href="/users/18110/sembiance" title="810 reputation">Sembiance</a></author></comment><comment><text><span class="comment-copy">Changing Ip's are very common with mobile internet providers. With Vodafone, my IP changes with EVERY request.</span></text><author><a class="comment-user" href="/users/451480/blaise" title="6,295 reputation">Blaise</a></author></comment><comment><text><span class="comment-copy">Somewhat of an old post but to further this. IP's are as mentioned a bad idea. As mentioned mobile users tend to roam IP's. Some ISP's in the past also had roaming IP's (such as AOL) however this approach is becoming more popular now with the shortage of IPv4 IP's. Such ISP's include Plus net and BT</span></text><author><a class="comment-user" href="/users/904100/peter" title="605 reputation">Peter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Protect by:</p>
<pre><code>$ip=$_SERVER['REMOTE_ADDER'];
$_SESSEION['ip']=$ip;
</code></pre>
</div></text><author><a href="/users/822755/nima">Nima</a></author><comments><comment><text><span class="comment-copy">I fail to see what you are doing here.</span></text><author><a class="comment-user" href="/users/1640606/samayo" title="5,510 reputation">samayo</a></author></comment></comments></answer></answers></post>