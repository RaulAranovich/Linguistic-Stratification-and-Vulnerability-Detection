<?xml version="1.0" encoding="utf-8"?>
<post><title>regex - Is there any way to put malicious code into a regular expression? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I want to add regular expression search capability to my public web page. Other than <a href="http://en.wikipedia.org/wiki/HTML" rel="noreferrer">HTML</a> encoding the output, do I need to do anything to guard against malicious user input?</p>
<p>Google searches are swamped by people solving the converse problem-- using regular expressions to detect malicious input--which I'm not interested in. In my scenario, the user input <em>is</em> a regular expression.</p>
<p>I'll be using the <em>Regex</em> library in .NET (C#).</p>
</div></text><author><a href="/users/63550/peter-mortensen">Peter Mortensen</a></author><comments><comment><text><span class="comment-copy">This could depend on what language and/or regex library you use.</span></text><author><a class="comment-user" href="/users/459640/aschepler" title="38,782 reputation">aschepler</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<h2>Denial‐of‐Service Concerns</h2>
<p>The most common concern with regexes is a denial‐of‐service attack through pathological patterns that go exponential — or even super‐exponential! — and so appear to take forever to solve. These may only show up on particular input data, but one can generally create one wherein this doesn’t matter.</p>
<p>Which ones these are will depend somewhat on how smart the regex compiler you’re using happens to be, because some of these can be detected during compilation time.  Regex compilers that implement recursion usually have a built‐in recursion‐depth counter for checking non‐progression.</p>
<p>Russ Cox’s excellent 2007 paper on <a href="http://swtch.com/%7Ersc/regexp/regexp1.html" rel="noreferrer">Regular Expression Matching Can Be Simple And Fast 
(but is slow in Java, Perl, PHP, Python, Ruby, ...)</a> talks about ways that most modern NFAs, which all seem to derive from Henry Spencer’s code, suffer severe performance degradation, but where a Thompson‐style NFA has no such problems.</p>
<p>If you only admit patterns that can be solved by DFAs, you can compile them up as such, and they will run faster, possibly much faster. However, it takes <em>time</em> to do this. The Cox paper mentions this approach and its attendant issues. It all comes down to a classic time–space trade‐off.</p>
<p>With a DFA, you spend more time building it (and allocating more states), whereas with an NFA you spend more time executing it, since it can be multiple states at the same time, and backtracking can eat your lunch — and your CPU.</p>
<h2>Denial‐of‐Service Solutions</h2>
<p>Probably the most reasonable way to address these patterns that are on the losing end of a race with the heat‐death of the universe is to wrap them with a timer that effectively places  a maximum amount of time allowed for their execution. Usually this will be much, much less than the default timeout that most HTTP servers provide. </p>
<p>There are various ways to implement these, ranging form a simple <code>alarm(N)</code> at the C level, to some sort of <code>try {}</code> block the catches alarm‐type exceptions, all the way to spawning off a new thread that’s specially created with a timing constraint built right into it.</p>
<h2>Code Callouts</h2>
<p>In regex languages that admit code callouts, some mechanism for allowing or disallowing these from the string you’re going to compile <em>should</em> be provided.  Even if code callouts are only to code in the language you are using, you should restrict them; they don’t have to be able to call external code, although if they can, you’ve got much bigger problems.</p>
<p>For example, in Perl one cannot have code callouts in regexes created from string interpolation (as these would be, as they’re compiled during run‐time) unless the special lexically‐scoped pragma <code>use re "eval";</code> in active in the current scope. </p>
<p>That way nobody can sneak in a code callout to run system programs like <code>rm -rf *</code>, for example. Because code callouts are so security‐sensitive, Perl disables them by default on all interpolated strings, and you have to go out of your way to re‐enable them.</p>
<h2>User‐Defined \P{roperties}</h2>
<p>There remains one more security‐sensitive issue related to Unicode-style properties — like <code>\pM</code>, <code>\p{Pd}</code>, <code>\p{Pattern_Syntax}</code>, or <code>\p{Script=Greek}</code> — that <em>may</em> exist in some regex compilers that support that notation. </p>
<p>The issue is that in some of these, the set of possible properties is user‐extensible. That means you can have custom properties that are actual code callouts to named functions in some particular namepace, like <code>\p{GoodChars}</code> or <code>\p{Class::Good_Characters}</code>.  How your language handles those might be worth looking at. </p>
<h2>Sandboxing</h2>
<p>In Perl, a sandboxed compartment via the <code>Safe</code> module would give control over namespace visibility. Other languages offer similar sandboxing technologies. If such devices are available, you might want to look into them, because they are specifically designed for limited execution of untrusted code.</p>
</div></text><author><a href="/users/471272/tchrist">tchrist</a></author><comments><comment><text><span class="comment-copy">+1 for a very good answer, covering the major points and pointing out where trade-offs are present.</span></text><author><a class="comment-user" href="/users/301832/donal-fellows" title="88,474 reputation">Donal Fellows</a></author></comment><comment><text><span class="comment-copy">Excellent answer. Thank you so much for the insight!</span></text><author><a class="comment-user" href="/users/226526/kristopher-ives" title="2,847 reputation">Kristopher Ives</a></author></comment><comment><text><span class="comment-copy">NFA-&gt;DFA conversion can produce exponential state explosion, turning a time DoS into a space DoS, as well as the time cost of generating the exponential number of states.</span></text><author><a class="comment-user" href="/users/3712/barry-kelly" title="34,218 reputation">Barry Kelly</a></author></comment><comment><text><span class="comment-copy">but probably he won't need the whole regular expressions capabilities, what do you think about restricting the power of regular expressions like the google did: <a href="http://www.google.com/intl/en/help/faq_codesearch.html#regexp" rel="nofollow noreferrer">google.com/intl/en/help/faq_codesearch.html#regexp</a></span></text><author><a class="comment-user" href="/users/50676/systemsfault" title="5,578 reputation">systemsfault</a></author></comment><comment><text><span class="comment-copy">@Barry Quite right. I’d been thinking of Russ Cox’s strategy described in one of his papers of incrementally compiling parts of the NFA into an equivalent DFA but throwing it away if it got too big. But there’s no silver bullet in a DFA, even if Thompson did prove it equivalent to an NFA, because you do have to the pay the piper at some point or another. Time spent begging the operating system for more space, and the attendant page-table set-up costs, can sometimes nudge the balancing scale further the other way and make the conversion from time to space less attractive than it would be.</span></text><author><a class="comment-user" href="/users/471272/tchrist" title="62,319 reputation">tchrist</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Adding to tchrist's excellent answer: the same Russ Cox who wrote the "Regular Expression" page has also released code! <a href="http://code.google.com/p/re2/" rel="noreferrer">re2</a> is a C++ library which guarantees O(length_of_regex) runtime and configurable memory-use limit. It's used within Google so that you can type a regex into google code search -- meaning that it's been battle tested.</p>
</div></text><author><a href="/users/580788/brian-bloniarz">Brian Bloniarz</a></author><comments><comment><text><span class="comment-copy">Indeed so. You can swap re2 into Perl’s regex engine with a module, and it will use re2 if possible and Perl if not.  Works quite well.</span></text><author><a class="comment-user" href="/users/471272/tchrist" title="62,319 reputation">tchrist</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Yes.</p>
<p><a href="http://msdn.microsoft.com/en-us/magazine/ff646973.aspx" rel="noreferrer">Regexes can be used to perform DOS attacks</a>.<br/>
There is no simple solution.</p>
</div></text><author><a href="/users/34397/slaks">SLaks</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You'll want to read this paper:</p>
<p><a href="http://www.usenix.org/event/woot08/tech/full_papers/drewry/drewry_html/">Insecure Context Switching: Inoculating regular expressions for survivability</a>  The paper is more about what can go wrong with regular expression engines (e.g. PCRE), but it may help you understand what you're up against.</p>
</div></text><author><a href="/users/208139/bruce-ediger">Bruce Ediger</a></author><comments><comment><text><span class="comment-copy">Here's a security advisory on the GNU libc regcomp(3) code: <a href="http://securityreason.com/achievement_securityalert/93" rel="nofollow noreferrer">securityreason.com/achievement_securityalert/93</a>  How timely! At least under linux, the vulnerability is easy to demonstrate: grep -E ".*{10,}{10,}{10,}{10,}{10,}"</span></text><author><a class="comment-user" href="/users/208139/bruce-ediger" title="564 reputation">Bruce Ediger</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You have to not only worry about the matching itself, but how you do the matching. For example, if your input goes through some sort of eval phase or command substitution on its way to the regular expression engine there could be code that gets executed inside the pattern. Or, if your regular expression syntax allows for embedded commands you have to be wary of that, too. Since you didn't specify the language in your question it's hard to say for sure what all the security implications are.</p>
</div></text><author><a href="/users/7432/bryan-oakley">Bryan Oakley</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>A good way to test your RegEx's for security issues (at least for Windows) is the <a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=8737519c-52d3-4291-9034-caa71855451f" rel="nofollow">SDL RegEx fuzzing tool</a> released by Microsoft recently.  This can help avoid pathologically bad RegEx construction.</p>
</div></text><author><a href="/users/67819/randomnickname42">RandomNickName42</a></author><comments/></answer></answers></post>