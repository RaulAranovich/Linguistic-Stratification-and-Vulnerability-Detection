<?xml version="1.0" encoding="utf-8"?>
<post><title>wcf - Best Practices for securing a REST API / web service - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>When designing a REST API or service are there any established best practices for dealing with security (Authentication, Authorization, Identity Management) ?</p>
<p>When building a SOAP API you have WS-Security as a guide and much literature exists on the topic. I have found less information about securing REST endpoints.</p>
<p>While I understand REST intentionally does not have specifications analogous to WS-* I am hoping best practices or recommended patterns have emerged.</p>
<p>Any discussion or links to relevant documents would be very much appreciated.
If it matters, we would be using WCF with POX/JSON serialized messages for our REST API's/Services built using v3.5 of the .NET Framework.</p>
</div></text><author><a href="/users/3017003/jakub-kubrynski">Jakub Kubrynski</a></author><comments><comment><text><span class="comment-copy">do you know any full real application using good patterns and practices with REST API and webServices in github?</span></text><author><a class="comment-user" href="/users/4051367/preguntoncojonerocabr%c3%b3n" title="197 reputation">PreguntonCojoneroCabrón</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>As tweakt said, Amazon S3 is a good model to work with. Their request signatures do have some features (such as incorporating a timestamp) that help guard against both accidental and malicious request replaying.</p>
<p>The nice thing about HTTP Basic is that virtually all HTTP libraries support it. You will, of course, need to require SSL in this case because sending plaintext passwords over the net is almost universally a bad thing. Basic is preferable to Digest when using SSL because even if the caller already knows that credentials are required, Digest requires an extra roundtrip to exchange the nonce value. With Basic, the callers simply sends the credentials the first time.</p>
<p>Once the identity of the client is established, authorization is really just an implementation problem. However, you could delegate the authorization to some other component with an existing authorization model. Again the nice thing about Basic here is your server ends up with a plaintext copy of the client's password that you can simply pass on to another component within your infrastructure as needed.</p>
</div></text><author><a href="/users/893/greg-hewgill">Greg Hewgill</a></author><comments><comment><text><span class="comment-copy">SSL is an important part of security, but not all applications require that level of encryption.  If someone steals in-transit what you are going to post publicly on Twitter, is that such a significant drawback?  For the majority of API's SSL encryption is going to be preferred.  The infrastructure requirements of SSL are somewhat higher than with plaintext and no intermediate (read here edge based) caching servers can participate in the caching of repeatedly accessed content.  Beware, your scalability may suffer if you absolutely require the encryption offered.</span></text><author><a class="comment-user" href="/users/77329/norman-h" title="1,758 reputation">Norman H</a></author></comment><comment><text><span class="comment-copy">@NormanH: Your argument is specious, because if somebody can see the entire transaction that I use to post to Twitter, then they could therefore impersonate me and post their own messages under my name.</span></text><author><a class="comment-user" href="/users/893/greg-hewgill" title="549,681 reputation">Greg Hewgill</a></author></comment><comment><text><span class="comment-copy">@GregHewgill yes, I did consider that, however authentication tokens could be encrypted even though the entire channel is not SSL encrypted.</span></text><author><a class="comment-user" href="/users/77329/norman-h" title="1,758 reputation">Norman H</a></author></comment><comment><text><span class="comment-copy">Quoting from wikipedia on Digest authentication, "Digest access authentication is one of the agreed-upon methods a web server can use to negotiate credentials with a user's web browser. It applies a hash function to a password before sending it over the network, which is safer than basic access authentication, which sends plaintext." which would be one standard way of accomplishing what I alluded to above. (See <a href="http://en.wikipedia.org/wiki/Digest_access_authentication" rel="nofollow noreferrer">en.wikipedia.org/wiki/Digest_access_authentication</a> for the details)</span></text><author><a class="comment-user" href="/users/77329/norman-h" title="1,758 reputation">Norman H</a></author></comment><comment><text><span class="comment-copy">@WillSargent The BuzzFeed article is phenomenal - great resource. One gotcha that I hadn't considered is to not put authentication tokens of any sort into the URL or parameters - these could get captured in the server's access logs.</span></text><author><a class="comment-user" href="/users/10973/kevin-day" title="12,198 reputation">Kevin Day</a></author></comment><comment><text><span class="comment-copy"><code>"sending plaintext passwords over the net is almost universally a bad thing"</code> - Can you elaborate on the "almost"? When is it not a bad idea?</span></text><author><a class="comment-user" href="/users/1407656/toniedzwiedz" title="9,557 reputation">toniedzwiedz</a></author></comment><comment><text><span class="comment-copy">@Tom: Perhaps in situations such as within a private network it might be okay. Also, various systems send plaintext passwords over email all the time (still not a good idea, but it happens).</span></text><author><a class="comment-user" href="/users/893/greg-hewgill" title="549,681 reputation">Greg Hewgill</a></author></comment><comment><text><span class="comment-copy">@GregHewgill even in a private network, I wouldn't want my users to be able to intercept each others' passwords. The only situation I can think of, in which it's OK to send a password over a network is when the user is alone in the network. The fact that such things happen elsewhere is hardly a reason to allow it.</span></text><author><a class="comment-user" href="/users/1407656/toniedzwiedz" title="9,557 reputation">toniedzwiedz</a></author></comment><comment><text><span class="comment-copy">If you use ssl, you don't need to care about replay attacks. See: <a href="http://security.stackexchange.com/questions/20105/are-ssl-encrypted-requests-vulnerable-to-replay-attacks" title="are ssl encrypted requests vulnerable to replay attacks">security.stackexchange.com/questions/20105/…</a></span></text><author><a class="comment-user" href="/users/633961/guettli" title="2,821 reputation">guettli</a></author></comment><comment><text><span class="comment-copy">@guettli that is not 100% correct. SSL establishes a secure connection but does not prevent to replay messages inside that connection. It prevents to replay a dump collected with a sniffer, but if someone can decrypt the original message (not that hard) then it is possible to rebuild the messages (or create new) and resend the messages, unless some king of message level security is used. SSL by itself is not very secure.</span></text><author><a class="comment-user" href="/users/598493/nflash" title="346 reputation">nflash</a></author></comment><comment><text><span class="comment-copy">@nflash please provide details. Your quote "SSL by itself is not very secure" is very vague. How can you decrypt the original message? I don't get why you say this is not that hard.</span></text><author><a class="comment-user" href="/users/633961/guettli" title="2,821 reputation">guettli</a></author></comment><comment><text><span class="comment-copy">@guettli just by using SSL doesn't mean your app is secure. I see lots of (mobile) developers ignoring Certificate Validation... even if they validate the certificate in an environment controlled by others there are ways to go around this and allow a man in the middle (I have seen and done this in a controlled environment with out of the box tools and without much knowledge about the subject). That’s why I say that SSL by itself is not very secure, but is one of the security layers that you should use</span></text><author><a class="comment-user" href="/users/598493/nflash" title="346 reputation">nflash</a></author></comment><comment><text><span class="comment-copy">@nflash I am still missing an explanation of "SSL establishes a secure connection but does not prevent to replay messages inside that connection." and "but if someone can decrypt the original message (not that hard)"</span></text><author><a class="comment-user" href="/users/633961/guettli" title="2,821 reputation">guettli</a></author></comment><comment><text><span class="comment-copy">@guettli a comment does not allow enough chareters for giving a more detail answer. look for Man in the middle or SSL proxy and you will see how to capture and decrypt messages inside a secure channel (easy with some control over the enviorment). If the messages itself are not authenticated or secured in someway you will be able to reconstruct the message and replay it or even change it and send it. Certitificate validation plays a key role in SSL and if you overcome this then the secure channel is no longer secure.</span></text><author><a class="comment-user" href="/users/598493/nflash" title="346 reputation">nflash</a></author></comment><comment><text><span class="comment-copy">@nflash I know that it is possible. But it is hard. Running <a href="http://mitmproxy.org/" rel="nofollow noreferrer">mitmproxy.org</a> is very easy. But first you need run the proxy between the client and the server. Next you need a valid cert for the requested domain. I wouldn't call this "not that hard". It is possible, but not easy.</span></text><author><a class="comment-user" href="/users/633961/guettli" title="2,821 reputation">guettli</a></author></comment><comment><text><span class="comment-copy">@guettli as I said: "I see lots of (mobile) developers ignoring Certificate Validation... even if they validate the certificate in an environment controlled by others there are ways to go around this and allow a man in the middle". If you controll the enviorment you can easly install certificates as trusted. In the cases where certificate validation is ignored you don't even have to do this.</span></text><author><a class="comment-user" href="/users/598493/nflash" title="346 reputation">nflash</a></author></comment><comment><text><span class="comment-copy">@NormanH: yes, seeing somebody's tweets before they are published is no big deal but with no cryptographic protection, the attacker can also modify them. And that IS a big deal.</span></text><author><a class="comment-user" href="/users/16590/roman-pl%c3%a1%c5%a1il" title="1,528 reputation">Roman Plášil</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There are no standards for REST other than HTTP. There are established REST services out there. I suggest you take a peek at them and get a feel for how they work. </p>
<p>For example, we borrowed a lot of ideas from Amazon's S3 REST service when developing our own. But we opted not to use the more advanced security model based on request signatures. The simpler approach is HTTP Basic auth over SSL. You have to decide what works best in your situation.</p>
<p>Also, I highly recommend the book <a href="http://oreilly.com/catalog/9780596529260/" rel="noreferrer">RESTful Web Services</a> from O'reilly. It explains the core concepts and does provide some best practices. You can generally take the model they provide and map it to your own application.</p>
</div></text><author><a href="/users/758/mark-renouf">Mark Renouf</a></author><comments><comment><text><span class="comment-copy">RESTful Web Services is definitely a great book.  A must read in this area.  It was downright inspiring.</span></text><author><a class="comment-user" href="/users/3068/edgarverona" title="1,128 reputation">EdgarVerona</a></author></comment><comment><text><span class="comment-copy">How is it that @aehlke has received so many upvotes for that comment considering (1) there is no such thing as a REST specification and (2) the Fielding Dissertation on the Architectural Styles and the Design of Network-based Software Architectures explicitly mentions REST and HTTP in 6.3: REST Applied to HTTP.</span></text><author><span class="comment-user">user4903</span></author></comment><comment><text><span class="comment-copy">HTTP is not a requirement for REST.</span></text><author><a class="comment-user" href="/users/105484/nategood" title="6,572 reputation">nategood</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You may also want to take a look at <a href="http://oauth.net/" rel="noreferrer">OAuth</a>, an emerging open protocol for token-based authorization specifically targeting http apis.</p>
<p>It is very similar to the approach taken by <a href="http://www.flickr.com/services/api/" rel="noreferrer">flickr</a> and <a href="http://www.rememberthemilk.com/services/api/" rel="noreferrer">remember the milk</a> "rest" apis (not necessarily good examples of restful apis, but good examples of the token-based approach).</p>
</div></text><author><a href="/users/3054/john-spurlock">John Spurlock</a></author><comments><comment><text><span class="comment-copy">But it seems that 2-legged oAuth, which i think is what is need here, isn't covered (lack of info) as much as the 3-legged one.</span></text><author><a class="comment-user" href="/users/299843/redben" title="3,336 reputation">redben</a></author></comment><comment><text><span class="comment-copy">OAuth is about delegation of authorization i.e. I the owner of the information / account let service A interact with my data on service B (e.g. I let Twitter write on my facebook). It's not authorization in the broader sense which is about controlling what users can do on resources (data, information, services...). This is where XACML steps in. XACML lets you define authorization policies about who can do what.</span></text><author><a class="comment-user" href="/users/1021725/david-brossard" title="5,935 reputation">David Brossard</a></author></comment><comment><text><span class="comment-copy">Sorry, but when I see the word <i>apis</i>, I think of bees.</span></text><author><a class="comment-user" href="/users/209139/trig" title="5,759 reputation">TRiG</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm kind of surprised SSL with client certificates hasn't been mentioned yet. Granted, this approach is only really useful if you can count on the community of users being identified by certificates.  But a number of governments/companies do issue them to their users.  The user doesn't have to worry about creating yet another username/password combination, and the identity is established on each and every connection so communication with the server can be entirely stateless, no user sessions required.  (Not to imply that any/all of the other solutions mentioned require sessions)</p>
</div></text><author><a href="/users/72676/stinkymatt">stinkymatt</a></author><comments><comment><text><span class="comment-copy">We actually do use this for some integrations as well as encrypted vpn tunnels to support older systems that we don't control that can not communicate over https.</span></text><author><a class="comment-user" href="/users/147373/casey" title="6,029 reputation">Casey</a></author></comment><comment><text><span class="comment-copy">Client certs can make trouble when you need load balancing... it can be done, but it's less straight-forward.</span></text><author><a class="comment-user" href="/users/76835/jeremy-logan" title="32,338 reputation">Jeremy Logan</a></author></comment><comment><text><span class="comment-copy">@fiXedd - The opposite has been my experience with client certs because they are truly stateless. Client cert authenticated connections can be load balanced with a dumb load balancer with no regard to connection stickyness because they require absolutely zero shared state between the client and server.</span></text><author><a class="comment-user" href="/users/72676/stinkymatt" title="1,395 reputation">stinkymatt</a></author></comment><comment><text><span class="comment-copy">Oh, you can do it.... you can just have the load balancer forward the TCP traffic, but you can't, for instance, have the load balancer be the termination point for the SSL.</span></text><author><a class="comment-user" href="/users/76835/jeremy-logan" title="32,338 reputation">Jeremy Logan</a></author></comment><comment><text><span class="comment-copy">Is it still secure if the client certificates and its root authority are self-signed? The root authority will be imported into the client's trusted root certificate authorities.</span></text><author><a class="comment-user" href="/users/804702/joyce" title="103 reputation">Joyce</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Everyone in these answers has overlooked true access control / authorization.</p>
<p>If for instance your REST APIs / web services are about POSTing / GETing medical records, you may want to define access control policie about who can access the data and under which circumstances. For instance:</p>
<ul>
<li>doctors can GET the medical record of a patient they have a care relationship with</li>
<li>no one can POST medical data outside practice hours (e.g. 9 to 5)</li>
<li>end-users can GET medical records they own or medical records of patients for whom they are the guardian</li>
<li>nurses can UPDATE the medical record of a patient that belongs to the same unit as the nurse.</li>
</ul>
<p>In order to define and implement those fine-grained authorizations, you will need to use an attribute-based access control language called XACML, the eXtensible Access Control Markup Language.</p>
<p>The other standards here are for the following:</p>
<ul>
<li>OAuth: id. federation and delegation of authorization e.g. letting a service act on my behalf on another service (Facebook can post to my Twitter)</li>
<li>SAML: identity federation / web SSO. SAML is very much about who the user is.</li>
<li>WS-Security / WS-* standards: these focus on the communication between SOAP services. They are specific to the application-level messaging format (SOAP) and they deal with aspects of messaging e.g. reliability, security, confidentiality, integrity, atomicity, eventing... None cover access control and all are specific to SOAP.</li>
</ul>
<p>XACML is technology-agnostic. It can be applied to java apps, .NET, Python, Ruby... web services, REST APIs, and more.</p>
<p>The following are interesting resources:</p>
<ul>
<li>the OASIS XACML <a href="http://oasis-open.org/committees/tc_home.php?wg_abbrev=xacml">website</a></li>
<li>the <a href="http://csrc.nist.gov/projects/abac/">NIST ABAC standard</a></li>
</ul>
</div></text><author><a href="/users/1021725/david-brossard">David Brossard</a></author><comments><comment><text><span class="comment-copy">I don't understand why can't you just implement token system that will get the user and his permissions which will essentially be the same thing?</span></text><author><a class="comment-user" href="/users/440611/stan" title="9,283 reputation">Stan</a></author></comment><comment><text><span class="comment-copy">You can take a token-based approach. That works well too but you still need the logic that defines which permissions users get, in other words, which permissions to insert inside the token. That's what XACML can help you achieve. It also avoids token bloat.</span></text><author><a class="comment-user" href="/users/1021725/david-brossard" title="5,935 reputation">David Brossard</a></author></comment><comment><text><span class="comment-copy">As a side comment, what does "9 to 5" contribute to security? As if attackers are only active at night? Not to speak of the severe usage implications, as if doctors only work "9 to 5".</span></text><author><a class="comment-user" href="/users/1845672/roland" title="1,282 reputation">Roland</a></author></comment><comment><text><span class="comment-copy">That's a common requirement in healthcare scenarios. Check out HL7 for instance. There are break-the-glass scenarios too in case a doctor does need access outside hours. As for hackers, once they're in all bets are off</span></text><author><a class="comment-user" href="/users/1021725/david-brossard" title="5,935 reputation">David Brossard</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I've used OAuth a few times, and also used some other methods (BASIC/DIGEST). I wholeheartedly suggest OAuth. The following link is the best tutorial I've seen on using OAuth:</p>
<p><a href="http://hueniverse.com/oauth/guide/" rel="nofollow noreferrer">http://hueniverse.com/oauth/guide/</a></p>
</div></text><author><a href="/users/53517/rob-ottaway">Rob Ottaway</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>One of the best posts I've ever come across regarding Security as it relates to REST is over at <a href="http://1raindrop.typepad.com/1_raindrop/2006/12/rest_security_o.html" rel="noreferrer">1 RainDrop</a>.  The MySpace API's use OAuth also for security and you have full access to their custom channels in the RestChess code, which I did a lot of exploration with. This was demo'd at Mix and you can find the posting <a href="http://blogs.msdn.com/vbertocci/archive/2008/03/10/wcf-rest-at-mix08-the-tale-of-myspace-apis.aspx" rel="noreferrer">here</a>. </p>
</div></text><author><a href="/users/18218/degnome">degnome</a></author><comments><comment><text><span class="comment-copy">Thanks for the link (1 RainDrop) - very interesting discussion of security as it relates to SOAP v REST</span></text><author><a class="comment-user owner" href="/users/541/nathan" title="6,921 reputation">Nathan</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Thanks for the excellent advice. We ended up using a custom HTTP header to pass an identity token from the client to the service, in preparation for integrating our RESTful API with the the upcoming Zermatt Identity framework from Microsoft. I have described the problem <a href="http://www.thefreakparade.com/2008/09/flowing-identity-from-a-client-to-a-service-when-using-restful-wcf-part-1-the-problem/" rel="noreferrer">here</a> and our solution <a href="http://www.thefreakparade.com/2008/09/flowing-identity-from-a-client-to-a-service-when-using-restful-wcf-part-2-a-solution/" rel="noreferrer">here</a>. I also took <a href="http://stackoverflow.com/questions/7551/best-practices-for-securing-a-rest-api-web-service#7562">tweakt</a>'s advice and bought <a href="http://oreilly.com/catalog/9780596529260/" rel="noreferrer">RESTful Web Services</a> - a very good book if you're building a RESTful API of any kind.</p>
</div></text><author><a href="/users/541/nathan">Nathan</a></author><comments><comment><text><span class="comment-copy">This approach sounds fishy to me. What prevents an attacker from using the identity token to masquerade the client? HTTPS doesn't protect the URL or headers the last time I checked...</span></text><author><a class="comment-user" href="/users/14731/gili" title="30,064 reputation">Gili</a></author></comment><comment><text><span class="comment-copy">Hmmm...not sure you're right about that. I believe that except for the few headers required to understand what kind of encryption is required, all other headers are encrypted.</span></text><author><a class="comment-user owner" href="/users/541/nathan" title="6,921 reputation">Nathan</a></author></comment><comment><text><span class="comment-copy">That is wrong. HTTPS protects EVERYTHING. It goes: TCP handshake... TLS handshake... &lt;ENCRYPTED&gt; GET /foo 200 OK... teardown &lt;/ENCRYPTED&gt;.</span></text><author><a class="comment-user" href="/users/758/mark-renouf" title="19,870 reputation">Mark Renouf</a></author></comment><comment><text><span class="comment-copy">I also used custom headers to pass a token.</span></text><author><a class="comment-user" href="/users/324072/tarasb" title="1,563 reputation">TarasB</a></author></comment><comment><text><span class="comment-copy">Note that you can also pass a token as a cookie (instead of a custom header). This behaves well in browsers as it uses an HTTP header with standard behaviours in most toolkits and applications. On the service side, the cookie does not have to relate to a session, you can use it to communicate any token you wish.</span></text><author><a class="comment-user" href="/users/99003/bruce-alderson" title="1,388 reputation">Bruce Alderson</a></author></comment><comment><text><span class="comment-copy">Nathan, your problem and solution links on the githubs are gone. Do you have planned to post them back somewhere? Thx.</span></text><author><a class="comment-user" href="/users/319058/win-myo-htet" title="3,603 reputation">Win Myo Htet</a></author></comment><comment><text><span class="comment-copy">I'm sorry I don't - I don't work with .NET anymore and let my .NET blog hosting lapse, so alas they are gone forever. Sorry.</span></text><author><a class="comment-user owner" href="/users/541/nathan" title="6,921 reputation">Nathan</a></author></comment><comment><text><span class="comment-copy">The Wayback Machine is a beautiful thing: <a href="http://web.archive.org/web/20110525082448/http://www.thefreakparade.com/2008/09/flowing-identity-from-a-client-to-a-service-when-using-restful-wcf-part-1-the-problem/" rel="nofollow noreferrer">problem description</a> and <a href="http://web.archive.org/web/20110525082818/http://www.thefreakparade.com/2008/09/flowing-identity-from-a-client-to-a-service-when-using-restful-wcf-part-2-a-solution/" rel="nofollow noreferrer">solution</a></span></text><author><a class="comment-user" href="/users/1038369/cjc343" title="2,926 reputation">cjc343</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>OWASP(Open Web Application Security Project) has some cheat sheets covering about all aspects of Web Application development. This Project is a very valuable and reliable source of information.
Regarding REST services you can check this: <a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet">https://www.owasp.org/index.php/REST_Security_Cheat_Sheet</a></p>
</div></text><author><a href="/users/3033698/welsonjr">WelsonJR</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would recommend OAuth 2/3. You can find more information at <a href="http://oauth.net/2/" rel="noreferrer">http://oauth.net/2/</a></p>
</div></text><author><a href="/users/403872/abhijit-gaikwad">Abhijit Gaikwad</a></author><comments><comment><text><span class="comment-copy">Care to elaborate why would you recommend version 2 when it remains largely incomplete? IMHO, version 1.0a remains a solid solution for most apps.</span></text><author><a class="comment-user" href="/users/81194/claude" title="885 reputation">Claude</a></author></comment><comment><text><span class="comment-copy">@Claude Do you have any arguments ? I look for good solution.. Thanks in advance !</span></text><author><a class="comment-user" href="/users/2856360/tomasz-waszczyk" title="428 reputation">Tomasz Waszczyk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I searched a lot about restful ws security and we also ended up with using token via cookie from client to server to authenticate the requests . I  used spring security for authorization of requests in service because I had to authenticate and authorized each request based on specified security policies that has already been in DB.  </p>
</div></text><author><a href="/users/1395913/parisa-kachoui">Parisa Kachoui</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The fact that the SOAP world is pretty well covered with security standards doesn't mean that it's secure by default. In the first place, the standards are <strong>very</strong> complex. Complexity is not a very good friend of security and implementation vulnerabilities such as <a href="https://ipsec.pl/node/1119" rel="nofollow">XML signature wrapping attacks</a> are endemic here. </p>
<p>As for the .NET environment I won't help much, but <a href="http://amzn.to/1auRwqA" rel="nofollow">“Building web services with Java”</a> (a brick with ~10 authors) did help me <em>a lot</em> in understanding the WS-* security architecture and, especially, its quirks.</p>
</div></text><author><a href="/users/1274149/kravietz">kravietz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>REST itself offers no security standards, but things like OAuth and SAML are rapidly becoming the standards in this space.  However, authentication and authorization are only a small part of what you need to consider.  Many of the known vulnerabilities relating to web applications apply very much to REST apis.  You have to consider input validation, session cracking, inappropriate error messages, internal employee vulnerabilities and so on.  It is a big subject.</p>
</div></text><author><a href="/users/1566117/robert-morschel">Robert Morschel</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I want to add(in line with stinkeymatt), simplest solution would be to add SSL certificates to your site. In other words, make sure your url is HTTPS://. That will cover your transport security (bang for the buck). With RESTful url's, idea is to keep it simple (unlike WS* security/SAML), you can use <a href="https://github.com/thinktecture/Thinktecture.AuthorizationServer" rel="nofollow">oAuth2/openID connect</a> or even Basic Auth (in simple cases). But you will still need SSL/HTTPS. Please check ASP.NET Web API 2 security here: <a href="http://www.asp.net/web-api/overview/security" rel="nofollow">http://www.asp.net/web-api/overview/security</a> (Articles and Videos)</p>
</div></text><author><a href="/users/486867/manish-jain">Manish Jain</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As @Nathan ended up with which is a simple HTTP Header, and some had said OAuth2 and client side SSL certificates.  The gist of it is this... your REST API shouldn't have to handle security as that should really be outside the scope of the API.</p>
<p>Instead a security layer should be put on top of it, whether it is an HTTP Header behind a web proxy (a common approach like SiteMinder, Zermatt or even Apache HTTPd), or as complicated as OAuth 2.</p>
<p>The key thing is the requests should work without any end-user interaction.  All that is needed is to ensure that the connection to the REST API is authenticated.  In Java EE we have the notion of a <code>userPrincipal</code> that can be obtained on an <code>HttpServletRequest</code>.  It is also managed in the deployment descriptor that a URL pattern can be secure so the REST API code does not need to check anymore.</p>
<p>In the WCF world, I would use <code>ServiceSecurityContext.Current</code> to get the current security context.  You need to configure you application to require authentication.</p>
<p>There is one exception to the statement I had above and that's the use of a nonce to prevent replays (which can be attacks or someone just submitting the same data twice).  That part can only be handled in the application layer.</p>
</div></text><author><a href="/users/242042/archimedes-trajano">Archimedes Trajano</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>For Web Application Security, you should take a look at OWASP (<a href="https://www.owasp.org/index.php/Main_Page" rel="nofollow">https://www.owasp.org/index.php/Main_Page</a>) which provides cheatsheets for various security attacks. You can incorporate as many measures as possible to secure your Application. 
With respect to API security (authorization, authentication, identity management), there are multiple ways as already mentioned (Basic,Digest and OAuth). There are loop holes in OAuth1.0, so you can use OAuth1.0a (OAuth2.0 is not widely adopted due to concerns with the specification)</p>
</div></text><author><a href="/users/268850/java-geek">java_geek</a></author><comments/></answer></answers></post>