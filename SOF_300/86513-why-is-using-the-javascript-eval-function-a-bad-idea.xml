<?xml version="1.0" encoding="utf-8"?>
<post><title>performance - Why is using the JavaScript eval function a bad idea? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>The eval function is a powerful and easy way to dynamically generate code, so what are the caveats?</p>
</div></text><author><a href="/users/63550/peter-mortensen">Peter Mortensen</a></author><comments><comment><text><span class="comment-copy">Don't be eval() by Simon Willison - <a href="http://24ways.org/2005/dont-be-eval" rel="nofollow noreferrer">24ways.org/2005/dont-be-eval</a></span></text><author><a class="comment-user owner" href="/users/5471/brian-singh" title="2,688 reputation">Brian Singh</a></author></comment><comment><text><span class="comment-copy">As outlined in <a href="http://moduscreate.com/javascript-performance-tips-tricks/" rel="nofollow noreferrer">moduscreate.com/javascript-performance-tips-tricks</a> - (new Function(str))() is more performant than eval(str). Just my 2 cents :)</span></text><author><a class="comment-user" href="/users/857756/grgur" title="2,224 reputation">Grgur</a></author></comment><comment><text><span class="comment-copy">apparently new fcuntion(a) is 67% slower than eval(a) on chrome</span></text><author><a class="comment-user" href="/users/2792719/what-is-sleep" title="863 reputation">what is sleep</a></author></comment><comment><text><span class="comment-copy">for me new functions(a) is 80% slower latest chrome on osx</span></text><author><a class="comment-user" href="/users/1712905/john-smith" title="8,945 reputation">john Smith</a></author></comment><comment><text><span class="comment-copy">I added a static function, just to compare the performance. <a href="http://jsperf.com/eval-vs-new-function/2" rel="nofollow noreferrer">jsperf.com/eval-vs-new-function/2</a></span></text><author><a class="comment-user" href="/users/810830/nepoxx" title="1,082 reputation">Nepoxx</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<ol>
<li><p>Improper use of eval opens up your
code for injection attacks</p></li>
<li><p>Debugging can be more challenging
(no line numbers, etc.)</p></li>
<li><p>eval'd code executes more slowly (no opportunity to compile/cache eval'd code)</p></li>
</ol>
<p>Edit: As @Jeff Walden points out in comments, #3 is less true today than it was in 2008. However, while some caching of compiled scripts may happen this will only be limited to scripts that are eval'd repeated with no modification. A more likely scenario is that you are eval'ing scripts that have undergone slight modification each time and as such could not be cached. Let's just say that SOME eval'd code executes more slowly.</p>
</div></text><author><a href="/users/5628/prestaul">Prestaul</a></author><comments><comment><text><span class="comment-copy">@JeffWalden, great comment. I've updated my post although I realize it has been a year since you posted. Xnzo72, if you had qualified your comment somewhat (as Jeff did) then I might be able to agree with you. Jeff pointed out the key: "eval of the same string multiple times can avoid parse overhead". As it is, you are just wrong; #3 holds true for many scenarios.</span></text><author><a class="comment-user" href="/users/5628/prestaul" title="54,526 reputation">Prestaul</a></author></comment><comment><text><span class="comment-copy">@Prestaul: Since the supposed attacker can just use whatever developer tool to change the JavaScript in the client, why do you say Eval() opens up your code to injection attacks? Isn't already opened? (I'm talking about client JavaScript of course)</span></text><author><a class="comment-user" href="/users/2385/eduardo-molteni" title="29,239 reputation">Eduardo Molteni</a></author></comment><comment><text><span class="comment-copy">@EduardoMolteni, we don't care (and indeed cannot prevent) users from executing js in their own browsers. The attacks we are trying to avoid are when user provided values get saved, then later placed into javascript and eval'd. For example, I might set my username to: <code>badHackerGuy'); doMaliciousThings();</code> and if you take my username, concat it into some script and eval it in other people's browsers then I can run any javascript I want on their machines (e.g. force them to +1 my posts, post their data to my server, etc.)</span></text><author><a class="comment-user" href="/users/5628/prestaul" title="54,526 reputation">Prestaul</a></author></comment><comment><text><span class="comment-copy">AFAIK, google-chrome &amp; chromium dev tools makes debugging eval'ed code just like debugging other js files. but you cannot put breakpoints though.</span></text><author><span class="comment-user">user405398</span></author></comment><comment><text><span class="comment-copy">In general, #1 is true for quite a lot, if not most function calls. eval() shouldn't be singled out and avoided by experienced programmers, just because inexperienced programmers abuse it. However, experienced programmers often have a better architecture in their code, and eval() will rarely be required or even thought about due to this better architecture.</span></text><author><a class="comment-user" href="/users/1667011/frodeborli" title="450 reputation">frodeborli</a></author></comment><comment><text><span class="comment-copy">@frodeborli, I disagree with your opening statement. <code>eval</code> is fundamentally different from a function call. Read my comment to EduardoMolteni (2 above yours) for an explanation. Injection attacks specifically refer to taking user input and allowing it to execute somewhere other than their own browser. (e.g. the server or another user's browser) I do, however, agree that <code>eval</code> is rarely required if you architect your applications well. It should be avoided because there is almost always a better and more secure solution.</span></text><author><a class="comment-user" href="/users/5628/prestaul" title="54,526 reputation">Prestaul</a></author></comment><comment><text><span class="comment-copy">@TamilVendhan Sure you can put breakpoints. You can access the virtual file created by Chrome for your evaled coded by adding the <code>debugger;</code> statement to your source code. This will stop the execution of your program on that line. Then after that you can add debug breakpoints like it was just another JS file.</span></text><author><a class="comment-user" href="/users/123991/sid" title="997 reputation">Sid</a></author></comment><comment><text><span class="comment-copy">Thank you. This concise answer just told be exactly my I can use eval in my current task/context. There is so much unclear advice to just not use it.</span></text><author><a class="comment-user" href="/users/8741/profk" title="11,924 reputation">ProfK</a></author></comment><comment><text><span class="comment-copy">@frodeborli Your second statement is also wrong. Many experienced programmers / frameworks still use <code>evil()</code> a lot. Take a look at SAP OpenUI5 for example.</span></text><author><a class="comment-user" href="/users/1692735/andr%c3%a9-fiedler" title="601 reputation">André Fiedler</a></author></comment><comment><text><span class="comment-copy">@ProfK Think well before using <code>eval()</code>! There are more strict CSP out there preventing you from using <code>eval()</code>. Take Firefox OS for example.</span></text><author><a class="comment-user" href="/users/1692735/andr%c3%a9-fiedler" title="601 reputation">André Fiedler</a></author></comment><comment><text><span class="comment-copy">@AndreFiedler Neither of my statements are wrong. You might disagree, if you wish. Any functionality can be implemented in any Turing complete language. Only a few languages have eval, thus eval is never NEEDED - it is just a convenience. Whether or not eval is a function call or a language construct is a completely different question.</span></text><author><a class="comment-user" href="/users/1667011/frodeborli" title="450 reputation">frodeborli</a></author></comment><comment><text><span class="comment-copy">@frodeborli yeah, it's never NEEDED, but my statement was about <code>experienced programmers often have a better architecture in their code</code>. Not so often as you thought. ;)</span></text><author><a class="comment-user" href="/users/1692735/andr%c3%a9-fiedler" title="601 reputation">André Fiedler</a></author></comment><comment><text><span class="comment-copy">@AndreFiedler Experienced programmers may have poor code. That we can agree on. :) But a group of experienced programmers usually have a better architecture than they used to have when they were inexperienced, is what I meant to say.</span></text><author><a class="comment-user" href="/users/1667011/frodeborli" title="450 reputation">frodeborli</a></author></comment><comment><text><span class="comment-copy">webpack will argue with you :)</span></text><author><a class="comment-user" href="/users/2312709/%d0%9f%d0%b0%d0%b2%d0%b5%d0%bb-%d0%98%d0%b2%d0%b0%d0%bd%d0%be%d0%b2" title="568 reputation">Павел Иванов</a></author></comment><comment><text><span class="comment-copy"><code>eval</code> isn't all that bad. I use it in my <a href="http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript/35302975#35302975"><code>Epic Random String Generator</code></a> and it works great!</span></text><author><a class="comment-user" href="/users/900807/spyk3hh" title="17,127 reputation">SpYk3HH</a></author></comment><comment><text><span class="comment-copy">If you're executing different code each time, compiling and caching would have no benefit, regardless of whether that you're using <code>eval</code> or not.</span></text><author><a class="comment-user" href="/users/2789762/kevin" title="685 reputation">Kevin</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>eval isn't always evil. There are times where it's perfectly appropriate.</p>
<p>However, eval is currently and historically massively over-used by people who don't know what they're doing. That includes people writing JavaScript tutorials, unfortunately, and in some cases this can indeed have security consequences - or, more often, simple bugs. So the more we can do to throw a question mark over eval, the better. Any time you use eval you need to sanity-check what you're doing, because chances are you could be doing it a better, safer, cleaner way.</p>
<p>To give an all-too-typical example, to set the colour of an element with an id stored in the variable 'potato':</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">eval</span><span class="pun">(</span><span class="str">'document.'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> potato </span><span class="pun">+</span><span class="pln"> </span><span class="str">'.style.color = "red"'</span><span class="pun">);</span></code></pre>
<p>If the authors of the kind of code above had a clue about the basics of how JavaScript objects work, they'd have realised that square brackets can be used instead of literal dot-names, obviating the need for eval:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">document</span><span class="pun">[</span><span class="pln">potato</span><span class="pun">].</span><span class="pln">style</span><span class="pun">.</span><span class="pln">color </span><span class="pun">=</span><span class="pln"> </span><span class="str">'red'</span><span class="pun">;</span></code></pre>
<p>...which is much easier to read as well as less potentially buggy.</p>
<p>(But then, someone who /really/ knew what they were doing would say:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="pln">potato</span><span class="pun">).</span><span class="pln">style</span><span class="pun">.</span><span class="pln">color </span><span class="pun">=</span><span class="pln"> </span><span class="str">'red'</span><span class="pun">;</span></code></pre>
<p>which is more reliable than the dodgy old trick of accessing DOM elements straight out of the document object.)</p>
</div></text><author><a href="/users/18936/bobince">bobince</a></author><comments><comment><text><span class="comment-copy">Hmm, guess I got lucky when I was first learning JavaScript. I always used "document.getElementById" to access the DOM; ironically, I only did it at the time because I didn't have a clue how objects worked in JavaScript ;-)</span></text><author><a class="comment-user" href="/users/17862/mike-spross" title="5,598 reputation">Mike Spross</a></author></comment><comment><text><span class="comment-copy">agree. Sometimes eval is ok e.g. for JSON responses from webservices</span></text><author><a class="comment-user" href="/users/108238/schoetbi" title="4,605 reputation">schoetbi</a></author></comment><comment><text><span class="comment-copy">@schoetbi: Shouldn't you use <code>JSON.parse()</code> instead of <code>eval()</code> for JSON?</span></text><author><a class="comment-user" href="/users/492203/nyuszika7h" title="4,149 reputation">nyuszika7h</a></author></comment><comment><text><span class="comment-copy">@Nyuszika7H: when you can, sure. There are still a fair few extant browsers that don't have it, alas.</span></text><author><a class="comment-user" href="/users/18936/bobince" title="387,698 reputation">bobince</a></author></comment><comment><text><span class="comment-copy">@bobince <a href="http://code.google.com/p/json-sans-eval/" rel="nofollow noreferrer">code.google.com/p/json-sans-eval</a> works on all browsers, so does <a href="https://github.com/douglascrockford/JSON-js" rel="nofollow noreferrer">github.com/douglascrockford/JSON-js</a> .  Doug Crockford's json2.js does use eval internally, but with checks. Besides, it's forward-compatible with built-in browser support for JSON.</span></text><author><a class="comment-user" href="/users/3092116/martijn" title="8,654 reputation">Martijn</a></author></comment><comment><text><span class="comment-copy">Sure, you can use libraries if you like. But all browsers are going to have to download the library code, even if they have native support so will never use it. For cases where I'm sure the JSON is going to be safe, and valid as a JS literal as well as JSON, I'd much rather save the extra bulk and plump for <code>eval</code>.</span></text><author><a class="comment-user" href="/users/18936/bobince" title="387,698 reputation">bobince</a></author></comment><comment><text><span class="comment-copy">@bobince There is something called feature-detection and polyfills to handle missing JSON libraries and other things (look at <a href="http://modernizr.com/" rel="nofollow noreferrer">modernizr.com</a>)</span></text><author><a class="comment-user" href="/users/854672/mauganra" title="329 reputation">MauganRa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I believe it's because it can execute any JavaScript function from a string. Using it makes it easier for people to inject rogue code into the application.</p>
</div></text><author><a href="/users/1942/kevin">Kevin</a></author><comments><comment><text><span class="comment-copy">What is the alternative then?</span></text><author><a class="comment-user" href="/users/990192/moderns" title="403 reputation">moderns</a></author></comment><comment><text><span class="comment-copy">Really the alternative is just write code that doesn't require it.  Crockford goes into length about this, and if you need to use it, he pretty much says that its a program design flaw and needs to be reworked.  In truth, I agree with him too. JS for all it's flaws is really flexible, and allows a lot of room to make it flexible.</span></text><author><a class="comment-user" href="/users/1942/kevin" title="82,080 reputation">Kevin</a></author></comment><comment><text><span class="comment-copy">but when  you get a response from the server by AJAX, you will get response text xmlHttp.responseText, and you will need to use eval to execute it.</span></text><author><a class="comment-user" href="/users/990192/moderns" title="403 reputation">moderns</a></author></comment><comment><text><span class="comment-copy">Not true, most frameworks have a method to parse JSON, and if you aren't using a framework, you can use JSON.parse ().  Most browsers support it, and if you're really in a pinch, you could write a parser for JSON pretty easily.</span></text><author><a class="comment-user" href="/users/1942/kevin" title="82,080 reputation">Kevin</a></author></comment><comment><text><span class="comment-copy">I don't buy this argument, because it already is easy to inject rogue code into a Javascript application. We have browser consoles, script extensions, etc... Every single piece of code sent to the client is optional for the client to execute.</span></text><author><a class="comment-user" href="/users/2867288/user2867288" title="979 reputation">user2867288</a></author></comment><comment><text><span class="comment-copy">The point is that's it's easier for me to inject code into your browser.  Let's say you're using eval on a query string.  If I trick you into clicking a link that goes to that site with my query string attached, I've now executed my code on your machine with full permission from the browser.  I want to key log everything you type on that site and send it to me? Done and no way to stop me because when eval executes, the browser gives it highest authority.</span></text><author><a class="comment-user" href="/users/1942/kevin" title="82,080 reputation">Kevin</a></author></comment><comment><text><span class="comment-copy">I use it for dynamic formula processing where the formula is sent from a server.  There is no security risk here and the only alternative would be to write a big JavaScript function to deconstruct the formulas.</span></text><author><a class="comment-user" href="/users/1337078/nuander" title="662 reputation">nuander</a></author></comment><comment><text><span class="comment-copy">@Kevin Then how do you feature-detect for ECMAScript 6 (ES6) support without <code>eval</code>? Or does Crockford recommend just shunning ES6 entirely?</span></text><author><a class="comment-user" href="/users/2738262/damian-yerrick" title="3,005 reputation">Damian Yerrick</a></author></comment><comment><text><span class="comment-copy">@nuander Then serve the big function as a separate .js file and include it by appending a script element to the document.</span></text><author><a class="comment-user" href="/users/2738262/damian-yerrick" title="3,005 reputation">Damian Yerrick</a></author></comment><comment><text><span class="comment-copy">@DamianYerrick It's impossible in some feature detection to not use it.  At that point I would question if ES6 was really worth implementing in that scenario.  If you have to do feature detection to see if you can use it, that means you have to account for the scenarios where you can't.  This really means that you have to write your code twice (once in ES5 and once in ES6).  I'd just stay with ES5, or write the code in TypeScript etc so I can transpile to ES6 when I don't have to support 5 anymore.</span></text><author><a class="comment-user" href="/users/1942/kevin" title="82,080 reputation">Kevin</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Two points come to mind:</p>
<ol>
<li><p>Security (but as long as you generate the string to be evaluated yourself, this might be a non-issue)</p></li>
<li><p>Performance: until the code to be executed is unknown, it cannot be optimized.  (about javascript and performance, certainly <a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html" rel="noreferrer">Steve Yegge's presentation</a>)</p></li>
</ol>
</div></text><author><a href="/users/6610/xtofl">xtofl</a></author><comments><comment><text><span class="comment-copy">Why security is an issue if client anyway could do with our code anything he/she wants ? Greasemonkey ?</span></text><author><a class="comment-user" href="/users/1364174/paul-brewczynski" title="1,290 reputation">Paul Brewczynski</a></author></comment><comment><text><span class="comment-copy">@PaulBrewczynski, the security problem appears when user A saves his part of code to be <code>eval</code>uated and then, that little piece of code runs on user's B browser</span></text><author><a class="comment-user" href="/users/2510678/felipe-pereira" title="3,003 reputation">Felipe Pereira</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Passing user input to eval() is a security risk, but also each invocation of eval() creates a new instance of the JavaScript interpreter. This can be a resource hog.</p>
</div></text><author><a href="/users/11577/andrew-hedges">Andrew Hedges</a></author><comments><comment><text><span class="comment-copy">In the 3+ years since I answered this, my understanding of what happens has, let's say, deepened. What actually happens is a new execution context is created. See <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" rel="nofollow noreferrer">dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts</a></span></text><author><a class="comment-user" href="/users/11577/andrew-hedges" title="15,434 reputation">Andrew Hedges</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It's generally only an issue if you're passing eval user input.</p>
</div></text><author><a href="/users/305/mark-biek">Mark Biek</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Mainly, it's a lot harder to maintain and debug. It's like a <code>goto</code>. You can use it, but it makes it harder to find problems and harder on the people who may need to make changes later.</p>
</div></text><author><a href="/users/15901/brian">Brian</a></author><comments><comment><text><span class="comment-copy">Eval can be used to substitute missing metaprogramming features, like templates. I like compact generator way more than endless list of functions upon functions.</span></text><author><a class="comment-user" href="/users/2545917/nekavally" title="861 reputation">nekavally</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>One thing to keep in mind is that you can often use eval() to execute code in an otherwise restricted environment - social networking sites that block specific JavaScript functions can sometimes be fooled by breaking them up in an eval block -</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">eval</span><span class="pun">(</span><span class="str">'al'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'er'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'t(\''</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'hi there!'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'\')'</span><span class="pun">);</span></code></pre>
<p>So if you're looking to run some JavaScript code where it might not otherwise be allowed (<a href="http://en.wikipedia.org/wiki/Myspace" rel="nofollow noreferrer">Myspace</a>, I'm looking at you...) then eval() can be a useful trick.</p>
<p>However, for all the reasons mentioned above, you shouldn't use it for your own code, where you have complete control - it's just not necessary, and better-off relegated to the 'tricky JavaScript hacks' shelf.</p>
</div></text><author><a href="/users/14026/matt-lohkamp">matt lohkamp</a></author><comments><comment><text><span class="comment-copy">window["al" + "er" + "t"]("Can this be a trick too?")</span></text><author><a class="comment-user" href="/users/2378102/murplyx" title="1,402 reputation">Murplyx</a></author></comment><comment><text><span class="comment-copy">Just updating the above code..  --hi there!-- needs to be in quotes as it is a string.  eval('al' + 'er' + 't(' + '"hi there!"' + ')');</span></text><author><a class="comment-user" href="/users/1161370/mahesh" title="1,160 reputation">Mahesh</a></author></comment><comment><text><span class="comment-copy"><code>[]["con"+"struc"+"tor"]["con"+"struc"+"tor"]('al' + 'er' + 't(\'' + 'hi there!' + '\')')()</code></span></text><author><a class="comment-user" href="/users/736054/xfix" title="5,220 reputation">xfix</a></author></comment><comment><text><span class="comment-copy">Yikes, there were social networking sites that restricted alert() but allowed eval()?!</span></text><author><a class="comment-user" href="/users/555139/joshden" title="123 reputation">joshden</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Unless you let eval() a dynamic content (through cgi or input), it is as safe and solid as all other JavaScript in your page.</p>
</div></text><author><a href="/users/8559/thevs">Thevs</a></author><comments><comment><text><span class="comment-copy">While this is true -- if your content <i>isn't</i> dynamic, what reason is there to use eval for it at all? You could just put the code in a function and call it, instead!</span></text><author><a class="comment-user" href="/users/6768080/periata-breatta" title="172 reputation">Periata Breatta</a></author></comment><comment><text><span class="comment-copy">Just for example - to parse returning value (JSON like, server defined strings, etc.) that came from Ajax call.</span></text><author><a class="comment-user" href="/users/8559/thevs" title="2,326 reputation">Thevs</a></author></comment><comment><text><span class="comment-copy">Oh, I see.  I would call those dynamic because the client doesn't know ahead of time what they are, but I see what you mean now.</span></text><author><a class="comment-user" href="/users/6768080/periata-breatta" title="172 reputation">Periata Breatta</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Along with the rest of the answers, I don't think eval statements can have advanced minimization.</p>
</div></text><author><a href="/users/29277/paul-mendoza">Paul Mendoza</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Unless you are 100% sure that the code being evaluated is from a trusted source (usually your own application) then it's a surefire way of exposing your system to a cross-site scripting attack.</p>
</div></text><author><a href="/users/1450/john-topley">John Topley</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>It greatly reduces your level of confidence about security.</p>
</div></text><author><a href="/users/16709/david-plumpton">David Plumpton</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>It is a possible security risk, it has a different scope of execution, and is quite inefficient, as it creates an entirely new scripting environment for the execution of the code. See here for some more info: <a href="http://userjs.org/help/tutorials/efficient-code#evalevil" rel="nofollow noreferrer">eval</a>.</p>
<p>It is quite useful, though, and used with moderation can add a lot of good functionality.</p>
</div></text><author><a href="/users/9618/tom">Tom</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>It's not necessarily that bad provided you know what context you're using it in.</p>
<p>If your application is using eval() to create an object from some JSON which has come back from an <a href="http://en.wikipedia.org/wiki/XMLHttpRequest" rel="nofollow noreferrer">XMLHttpRequest</a> to your own site, created by your trusted server-side code, it's probably not a problem.</p>
<p>Untrusted client-side JavaScript code can't do that much anyway. Provided the thing you're eval'ing has come from a reasonable source, you're fine.</p>
</div></text><author><a href="/users/13724/markr">MarkR</a></author><comments><comment><text><span class="comment-copy">Isn't using eval slower than just parsing the JSON?</span></text><author><a class="comment-user" href="/users/212555/brendan-long" title="34,222 reputation">Brendan Long</a></author></comment><comment><text><span class="comment-copy"><a href="http://jsperf.com/json-parse-vs-eval/6" rel="nofollow noreferrer">Yes it is.</a> By a lot.</span></text><author><a class="comment-user" href="/users/510036/qix" title="5,673 reputation">Qix</a></author></comment><comment><text><span class="comment-copy">@Qix - running that test on my browser (Chrome 53) shows <i>eval</i> as somewhat faster than <i>parse</i>.</span></text><author><a class="comment-user" href="/users/6768080/periata-breatta" title="172 reputation">Periata Breatta</a></author></comment><comment><text><span class="comment-copy">@PeriataBreatta Huh, strange. I wonder why. At the time I commented that wasn't the case. However, it's not unheard of for Chrome to get strange performance boosts in certain areas of the runtime from version to version.</span></text><author><a class="comment-user" href="/users/510036/qix" title="5,673 reputation">Qix</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you want the user to input some logical functions and evaluate for AND the OR then the JavaScript eval function is perfect. I can accept two strings and <code>eval(uate) string1 === string2</code>, etc.</p>
</div></text><author><a href="/users/289724/ian">Ian</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I know this discussion is old, but I really like <a href="http://www.youtube.com/watch?feature=player_detailpage&amp;v=6EJ801el-I8#t=1729s" rel="nofollow">this</a> approach by Google and wanted to share that feeling with others ;)</p>
<p>The other thing is that the better You get the more You try to understand and finally You just don't believe that something is good or bad just because someone said so :) 
This is a very inspirational <a href="http://www.youtube.com/watch?v=MFtijdklZDo" rel="nofollow">video</a> that helped me to think more by myself :) GOOD PRACTICES are good, but don't use them mindelessly :)</p>
</div></text><author><a href="/users/1595495/op1ekun">op1ekun</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Besides the possible security issues if you are executing user-submitted code, most of the time there's a better way that doesn't involve re-parsing the code every time it's executed. Anonymous functions or object properties can replace most uses of eval and are much safer and faster.</p>
</div></text><author><a href="/users/2214/matthew-crumley">Matthew Crumley</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This may become more of an issue as the next generation of browsers come out with some flavor of a JavaScript compiler. Code executed via Eval may not perform as well as the rest of your JavaScript against these newer browsers. Someone should do some profiling.</p>
</div></text><author><a href="/users/2831/brian">brian</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This is one of good articles talking about eval and how it is not an evil:
<a href="http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/" rel="nofollow">http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/</a></p>
<blockquote>
<p>I’m not saying you should go run out and start using eval()
  everywhere. In fact, there are very few good use cases for running
  eval() at all. There are definitely concerns with code clarity,
  debugability, and certainly performance that should not be overlooked.
  But you shouldn’t be afraid to use it when you have a case where
  eval() makes sense. Try not using it first, but don’t let anyone scare
  you into thinking your code is more fragile or less secure when eval()
  is used appropriately.</p>
</blockquote>
</div></text><author><a href="/users/20126/amr-elgarhy">Amr Elgarhy</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>eval() is very powerful and can be used to execute a JS statement or evaluate an expression. But the question isn't about the uses of eval() but lets just say some how the string you running with eval() is affected by a malicious party. At the end you will be running malicious code. With power comes great responsibility. So use it wisely is you are using it. 
 This isn't related much to eval() function but this article has pretty good information:
 <a href="http://blogs.popart.com/2009/07/javascript-injection-attacks/" rel="nofollow">http://blogs.popart.com/2009/07/javascript-injection-attacks/</a>
If you are looking for the basics of eval() look here: 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" rel="nofollow">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval</a></p>
</div></text><author><a href="/users/3817256/genius">genius</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The JavaScript Engine has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.</p>
<p>But if the Engine finds an eval(..) in the code, it essentially has to assume that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to eval(..) to modify the lexical scope, or the contents of the object you may pass to with to create a new lexical scope to be consulted.</p>
<p>In other words, in the pessimistic sense, most of those optimizations it would make are pointless if eval(..) is present, so it simply doesn't perform the optimizations at all.</p>
<p>This explains it all.</p>
<p>Reference :</p>
<p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#eval" rel="nofollow">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#eval</a></p>
<p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#performance" rel="nofollow">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#performance</a></p>
</div></text><author><a href="/users/458831/hkasera">hkasera</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>It's not always a bad idea. Take for example, code generation. I recently wrote a library called <a href="https://github.com/vincentracine/hyperbars" rel="nofollow noreferrer">Hyperbars</a> which bridges the gap between <a href="https://github.com/Matt-Esch/virtual-dom" rel="nofollow noreferrer">virtual-dom</a> and <a href="http://handlebarsjs.com/" rel="nofollow noreferrer">handlebars</a>. It does this by parsing a handlebars template and converting it to <a href="https://github.com/dominictarr/hyperscript" rel="nofollow noreferrer">hyperscript</a> which is subsequently used by virtual-dom. The hyperscript is generated as a string first and before returning it, <code>eval()</code> it to turn it into executable code. I have found <code>eval()</code> in this particular situation the exact opposite of evil. </p>
<p>Basically from</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;div&gt;</span><span class="pln">
    {{#each names}}
        </span><span class="tag">&lt;span&gt;</span><span class="pln">{{this}}</span><span class="tag">&lt;/span&gt;</span><span class="pln">
    {{/each}}
</span><span class="tag">&lt;/div&gt;</span></code></pre>
<p>To this</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">state</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">Runtime</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Hyperbars</span><span class="pun">.</span><span class="typ">Runtime</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> state</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> h</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{},</span><span class="pln"> </span><span class="pun">[</span><span class="typ">Runtime</span><span class="pun">.</span><span class="pln">each</span><span class="pun">(</span><span class="pln">context</span><span class="pun">[</span><span class="str">'names'</span><span class="pun">],</span><span class="pln"> context</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">context</span><span class="pun">,</span><span class="pln"> parent</span><span class="pun">,</span><span class="pln"> options</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">[</span><span class="pln">h</span><span class="pun">(</span><span class="str">'span'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{},</span><span class="pln"> </span><span class="pun">[</span><span class="pln">options</span><span class="pun">[</span><span class="str">'@index'</span><span class="pun">],</span><span class="pln"> context</span><span class="pun">])]</span><span class="pln">
    </span><span class="pun">})])</span><span class="pln">
</span><span class="pun">}.</span><span class="pln">bind</span><span class="pun">({}))</span></code></pre>
<p>The performance of <code>eval()</code> isn't an issue in a situation like this because you only need to interpret the generated string once and then reuse the executable output many times over.</p>
<p>You can see how the code generation was achieved if you're curious <a href="https://github.com/vincentracine/hyperbars/blob/master/src/hyperbars.js#L131" rel="nofollow noreferrer">here</a>.</p>
</div></text><author><a href="/users/5678694/wikened">Wikened</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I won't attempt to refute anything said heretofore, but i will offer this use of eval() that (as far as I know) can't be done any other way.  There's probably other ways to code this, and probably ways to optimize it, but this is done longhand and without any bells and whistles for clarity sake to illustrate a use of eval that really doesn't have any other alternatives.  That is: dynamical (or more accurately) programmically-created object names (as opposed to values).</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="com">//Place this in a common/global JS lib:</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> NS </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="kwd">namespace</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> namespaceParts </span><span class="pun">=</span><span class="pln"> </span><span class="typ">String</span><span class="pun">(</span><span class="kwd">namespace</span><span class="pun">).</span><span class="pln">split</span><span class="pun">(</span><span class="str">"."</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> namespaceToTest </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> namespaceParts</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><span class="pln">
        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">i </span><span class="pun">===</span><span class="pln"> </span><span class="lit">0</span><span class="pun">){</span><span class="pln">
            namespaceToTest </span><span class="pun">=</span><span class="pln"> namespaceParts</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">else</span><span class="pun">{</span><span class="pln">
            namespaceToTest </span><span class="pun">=</span><span class="pln"> namespaceToTest </span><span class="pun">+</span><span class="pln"> </span><span class="str">"."</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> namespaceParts</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="kwd">if</span><span class="pun">(</span><span class="kwd">eval</span><span class="pun">(</span><span class="str">'typeof '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> namespaceToTest</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="str">"undefined"</span><span class="pun">){</span><span class="pln">
            </span><span class="kwd">eval</span><span class="pun">(</span><span class="pln">namespaceToTest </span><span class="pun">+</span><span class="pln"> </span><span class="str">' = {}'</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">eval</span><span class="pun">(</span><span class="kwd">namespace</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">


</span><span class="com">//Then, use this in your class definition libs:</span><span class="pln">
NS</span><span class="pun">(</span><span class="str">'Root.Namespace'</span><span class="pun">).</span><span class="typ">Class</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">settings</span><span class="pun">){</span><span class="pln">
  </span><span class="com">//Class constructor code here</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">//some generic method:</span><span class="pln">
</span><span class="typ">Root</span><span class="pun">.</span><span class="typ">Namespace</span><span class="pun">.</span><span class="typ">Class</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="typ">Method</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">args</span><span class="pun">){</span><span class="pln">
    </span><span class="com">//Code goes here</span><span class="pln">
    </span><span class="com">//this.MyOtherMethod("foo"));  // =&gt; "foo"</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">


</span><span class="com">//Then, in your applications, use this to instantiate an instance of your class:</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> anInstanceOfClass </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Root</span><span class="pun">.</span><span class="typ">Namespace</span><span class="pun">.</span><span class="typ">Class</span><span class="pun">(</span><span class="pln">settings</span><span class="pun">);</span></code></pre>
<p>EDIT:  by the way, I wouldn't suggest (for all the security reasons pointed out heretofore) that you base you object names on user input.  I can't imagine any good reason you'd want to do that though.  Still, thought I'd point it out that it wouldn't be a good idea :)</p>
</div></text><author><a href="/users/1553283/carnix">Carnix</a></author><comments><comment><text><span class="comment-copy">this can be done with <code>namespaceToTest[namespaceParts[i]]</code>, no need for eval here, so the <code>if(typeof namespaceToTest[namespaceParts[i]] === 'undefined') { namespaceToTest[namespaceParts[i]] = {};</code> the only difference for the <code>else namespaceToTest = namespaceToTest[namespaceParts[i]];</code></span></text><author><a class="comment-user" href="/users/2144406/user2144406" title="65 reputation">user2144406</a></author></comment></comments></answer></answers></post>