<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Why is it common to put CSRF prevention tokens in cookies? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm trying to understand the whole issue with CSRF and appropriate ways to prevent it. (Resources I've read, understand, and agree with: <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP CSRF Prevention CHeat Sheet</a>, <a href="http://stackoverflow.com/questions/9632262/questions-about-csrf">Questions about CSRF</a>.)</p>
<p>As I understand it, the vulnerability around CSRF is introduced by the assumption that (from the webserver's point of view) a valid session cookie in an incoming HTTP request reflects the wishes of an authenticated user. But all cookies for the origin domain are magically attached to the request by the browser, so really all the server can infer from the presence of a valid session cookie in a request is that the request comes from a browser which has an authenticated session; it cannot further assume anything about the <em>code</em> running in that browser, or whether it really reflects user wishes. The way to prevent this is to include additional authentication information (the "CSRF token") in the request, carried by some means other than the browser's automatic cookie handling. Loosely speaking, then, the session cookie authenticates the user/browser and the CSRF token authenticates the code running in the browser.</p>
<p>So in a nutshell, if you're using a session cookie to authenticate users of your web application, you should also add a CSRF token to each response, and require a matching CSRF token in each (mutating) request. The CSRF token then makes a roundtrip from server to browser back to server, proving to the server that the page making the request is approved by (generated by, even) that server.</p>
<p>On to my question, which is about the specific transport method used for that CSRF token on that roundtrip.</p>
<p>It seems common (e.g. in <a href="http://docs.angularjs.org/api/ng.%24http">AngularJS</a>, <a href="https://docs.djangoproject.com/en/dev/ref/contrib/csrf/">Django</a>, <a href="http://guides.rubyonrails.org/security.html#csrf-countermeasures">Rails</a>) to send the CSRF token from server to client as a cookie (i.e. in a Set-Cookie header), and then have Javascript in the client scrape it out of the cookie and attach it as a separate XSRF-TOKEN header to send back to the server.</p>
<p>(An alternate method is the one recommended by e.g. <a href="http://dailyjs.com/2012/09/13/express-3-csrf-tutorial/">Express</a>, where the CSRF token generated by the server is included in the response body via server-side template expansion, attached directly to the code/markup that will supply it back to the server, e.g. as a hidden form input. That example is a more web 1.0-ish way of doing things, but would generalize fine to a more JS-heavy client.)</p>
<p>Why is it so common to use Set-Cookie as the downstream transport for the CSRF token / why is this a good idea? I imagine the authors of all these frameworks considered their options carefully and didn't get this wrong. But at first glance, using cookies to work around what's essentially a design limitation on cookies seems daft. In fact, if you used cookies as the roundtrip transport (Set-Cookie: header downstream for the server to tell the browser the CSRF token, and Cookie: header upstream for the browser to return it to the server) you would reintroduce the vulnerability you are trying to fix.</p>
<p>I realize that the frameworks above don't use cookies for the whole roundtrip for the CSRF token; they use Set-Cookie downstream, then something else (e.g. a X-CSRF-Token header) upstream, and this does close off the vulnerability. But even using Set-Cookie as the downstream transport is potentially misleading and dangerous; the browser will now attach the CSRF token to every request including genuine malicious XSRF requests; at best that makes the request bigger than it needs to be and at worst some well-meaning but misguided piece of server code might actually try to use it, which would be really bad. And further, since the actual intended recipient of the CSRF token is client-side Javascript, that means this cookie can't be protected with http-only. So sending the CSRF token downstream in a Set-Cookie header seems pretty suboptimal to me.</p>
</div></text><author><a href="/users/918959/antti-haapala">Antti Haapala</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>A good reason, which you have sort of touched on, is that once the CSRF cookie has been received, it is then available for use throughout the application in client script for use in both regular forms and AJAX POSTs. This will make sense in a JavaScript heavy application such as one employed by AngularJS (using AngularJS doesn't require that the application will be a single page app, so it would be useful where state needs to flow between different page requests where the CSRF value cannot normally persist in the browser).</p>
<p>Consider the following scenarios and processes in a typical application for some pros and cons of each approach you describe. These are based on the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern">Synchronizer Token Pattern</a>.</p>
<h1>Request Body Approach</h1>
<ol>
<li>User successfully logs in.</li>
<li>Server issues auth cookie.</li>
<li>User clicks to navigate to a form.</li>
<li>If not yet generated for this session, server generates CSRF token, stores it against the user session and outputs it to a hidden field.</li>
<li>User submits form.</li>
<li>Server checks hidden field matches session stored token.</li>
</ol>
<h2>Advantages</h2>
<ul>
<li>Simple to implement.</li>
<li>Works with AJAX.</li>
<li>Works with forms.</li>
<li>Cookie can actually be <a href="https://www.owasp.org/index.php/HttpOnly">HTTP Only</a>.</li>
</ul>
<h2>Disadvantages</h2>
<ul>
<li>All forms must output the hidden field in HTML.</li>
<li>Any AJAX POSTs must also include the value.</li>
<li>The page must know in advance that it requires the CSRF token so it can include it in the page content so all pages must contain the token value somewhere, which could make it time consuming to implement for a large site.</li>
</ul>
<h1>Custom HTTP Header (downstream)</h1>
<ol>
<li>User successfully logs in.</li>
<li>Server issues auth cookie.</li>
<li>User clicks to navigate to a form. </li>
<li>Page loads in browser, then an AJAX request is made to retrieve the CSRF token. </li>
<li>Server generates CSRF token (if not already generated for session), stores it against the user session and outputs it to a
header. </li>
<li>User submits form (token is sent via hidden field). </li>
<li>Server checks hidden field matches session stored token.</li>
</ol>
<h2>Advantages</h2>
<ul>
<li>Works with AJAX.</li>
<li>Cookie can be <a href="https://www.owasp.org/index.php/HttpOnly">HTTP Only</a>.</li>
</ul>
<h2>Disadvantages</h2>
<ul>
<li>Doesn't work without an AJAX request to get the header value.</li>
<li>All forms must have the value added to its HTML dynamically.</li>
<li>Any AJAX POSTs must also include the value.</li>
<li>The page must make an AJAX request first to get the CSRF token, so it will mean an extra round trip each time.</li>
<li>Might as well have simply output the token to the page which would save the extra request.</li>
</ul>
<h1>Custom HTTP Header (upstream)</h1>
<ol>
<li>User successfully logs in.</li>
<li>Server issues auth cookie.</li>
<li>User clicks to navigate to a form. </li>
<li>If not yet generated for this session, server generates CSRF token, stores it against the user session and outputs it in the page content somewhere.</li>
<li>User submits form via AJAX (token is sent via header). </li>
<li>Server checks custom header matches session stored token.</li>
</ol>
<h2>Advantages</h2>
<ul>
<li>Works with AJAX.</li>
<li>Cookie can be <a href="https://www.owasp.org/index.php/HttpOnly">HTTP Only</a>.</li>
</ul>
<h2>Disadvantages</h2>
<ul>
<li>Doesn't work with forms.</li>
<li>All AJAX POSTs must include the header.</li>
</ul>
<h1>Custom HTTP Header (upstream &amp; downstream)</h1>
<ol>
<li>User successfully logs in.</li>
<li>Server issues auth cookie.</li>
<li>User clicks to navigate to a form. </li>
<li>Page loads in browser, then an AJAX request is made to retrieve the CSRF token. </li>
<li>Server generates CSRF token (if not already generated for session), stores it against the user session and outputs it to a
header. </li>
<li>User submits form via AJAX (token is sent via header) . </li>
<li>Server checks custom header matches session stored token.</li>
</ol>
<h2>Advantages</h2>
<ul>
<li>Works with AJAX.</li>
<li>Cookie can be <a href="https://www.owasp.org/index.php/HttpOnly">HTTP Only</a>.</li>
</ul>
<h2>Disadvantages</h2>
<ul>
<li>Doesn't work with forms.</li>
<li>All AJAX POSTs must also include the value.</li>
<li>The page must make an AJAX request first to get the CRSF token, so it will mean an extra round trip each time.</li>
</ul>
<h1>Set-Cookie</h1>
<ol>
<li>User successfully logs in.</li>
<li>Server issues auth cookie.</li>
<li>User clicks to navigate to a form.</li>
<li>Server generates CSRF token, stores it against the user session and outputs it to a cookie.</li>
<li>User submits form via AJAX or via HTML form.</li>
<li>Server checks custom header (or hidden form field) matches session stored token.</li>
<li>Cookie is available in browser for use in additional AJAX and form requests without additional requests to server to retrieve the CSRF token.</li>
</ol>
<h2>Advantages</h2>
<ul>
<li>Simple to implement.</li>
<li>Works with AJAX.</li>
<li>Works with forms.</li>
<li>Doesn't necessarily require an AJAX request to get the cookie value. Any HTTP request can retrieve it and it can be appended to all forms/AJAX requests via JavaScript.</li>
<li>Once the CSRF token has been retrieved, as it is stored in a cookie the value can be reused without additional requests.</li>
</ul>
<h2>Disadvantages</h2>
<ul>
<li>All forms must have the value added to its HTML dynamically.</li>
<li>Any AJAX POSTs must also include the value.</li>
<li>The cookie will be submitted for <em>every</em> request (i.e. all GETs for images, CSS, JS, etc, that are not involved in the CSRF process) increasing request size.</li>
<li>Cookie cannot be <a href="https://www.owasp.org/index.php/HttpOnly">HTTP Only</a>.</li>
</ul>
<p>So the cookie approach is fairly dynamic offering an easy way to retrieve the cookie value (any HTTP request) and to use it (JS can add the value to any form automatically and it can be employed in AJAX requests either as a header or as a form value). Once the CSRF token has been received for the session, there is no need to regenerate it as an attacker employing a CSRF exploit has no method of retrieving this token. If a malicious user tries to read the user's CSRF token in any of the above methods then this will be prevented by the <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same Origin Policy</a>. If a malicious user tries to retrieve the CSRF token server side (e.g. via <code>curl</code>) then this token will not be associated to the same user account as the victim's auth session cookie will be missing from the request (it would be the attacker's - therefore it won't be associated server side with the victim's session).</p>
<p>As well as the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern">Synchronizer Token Pattern</a> there is also the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookie">Double Submit Cookie</a> CSRF prevention method, which of course uses cookies to store a type of CSRF token. This is easier to implement as it does not require any server side state for the CSRF token. The CSRF token in fact could be the standard authentication cookie when using this method, and this value is submitted via cookies as usual with the request, but the value is also repeated in either a hidden field or header, of which an attacker cannot replicate as they cannot read the value in the first place. It would be recommended to choose another cookie however, other than the authentication cookie so that the authentication cookie can be secured by being marked HttpOnly. So this is another common reason why you'd find CSRF prevention using a cookie based method.</p>
</div></text><author><a href="/users/413180/silverlightfox">SilverlightFox</a></author><comments><comment><text><span class="comment-copy">Thanks for the detailed answer. The point about the cookie remaining valid past the lifetime of the initial page load, for apps that are not single-page apps, is a good one.</span></text><author><a class="comment-user owner" href="/users/275581/metamatt" title="6,249 reputation">metamatt</a></author></comment><comment><text><span class="comment-copy">I'm not sure I understand how "AJAX request is made to retrieve the CSRF token" (step 4 in both "custom header: downstream" sections) can be done securely; since this is a separate request, the server doesn't know who it's coming from; how does it know it's safe to divulge the CSRF token? It seems to me if you can't get the token out of the initial page load, you lose (which makes the custom downstream response header a nonstarter, unfortunately).</span></text><author><a class="comment-user owner" href="/users/275581/metamatt" title="6,249 reputation">metamatt</a></author></comment><comment><text><span class="comment-copy">It would be done in such a way that the Same Origin Policy protects the response from being read by a different domain (e.g. AJAX POST).</span></text><author><a class="comment-user" href="/users/413180/silverlightfox" title="17,301 reputation">SilverlightFox</a></author></comment><comment><text><span class="comment-copy">What I mean is, what stops someone else (a would-be CSRF forger) from making the request back to the server (including the session cookie)? This forger doesn't have to steal it from the client (which is what Same Origin Policy would prevent); the forger can just ask the server nicely and the server would supply it. So I still don't see how the server can safely supply the CSRF token <i>in a separate request from the main page load</i>.</span></text><author><a class="comment-user owner" href="/users/275581/metamatt" title="6,249 reputation">metamatt</a></author></comment><comment><text><span class="comment-copy">Because the forger won't have the session cookie. They might have their own session cookie, but as the CSRF token is associated to a session, their CSRF token won't match the victim's.</span></text><author><a class="comment-user" href="/users/413180/silverlightfox" title="17,301 reputation">SilverlightFox</a></author></comment><comment><text><span class="comment-copy">In my understanding of the CSRF attack, the forger does have <i>my</i> session cookie. Well, they don't actually get to <i>see</i> the cookie, but they have the ability to provide it in their forged requests, because the requests are coming from my browser and my browser supplies my session cookie. So from the server's point of view, the session cookie alone can't distinguish a legitimate request from a forged request. This is in fact the attack we're trying to prevent.  BTW thanks for your patience in talking this through, especially if I'm confused about this.</span></text><author><a class="comment-user owner" href="/users/275581/metamatt" title="6,249 reputation">metamatt</a></author></comment><comment><text><span class="comment-copy">They have the ability to supply the auth cookie, but they cannot read the response that contains the CSRF token.</span></text><author><a class="comment-user" href="/users/413180/silverlightfox" title="17,301 reputation">SilverlightFox</a></author></comment><comment><text><span class="comment-copy">Please update the answer to mention that any approach that uses cookies is vulnerable to sub-domain attacks: <a href="http://security.stackexchange.com/q/33851/5002">security.stackexchange.com/q/33851/5002</a> -- If you control all sub-domains you should be fine.</span></text><author><a class="comment-user" href="/users/14731/gili" title="30,064 reputation">Gili</a></author></comment><comment><text><span class="comment-copy">For the <code>Set-Cookie</code> method, I recommend merging steps 2 and 4 (so the CSRF token is generated once); otherwise people (like myself) might make the mistake of trying to generate a new token per form. See <a href="http://stackoverflow.com/q/24225682/14731">stackoverflow.com/q/24225682/14731</a>.</span></text><author><a class="comment-user" href="/users/14731/gili" title="30,064 reputation">Gili</a></author></comment><comment><text><span class="comment-copy">You have 'Any AJAX POSTs must also include the value.' listed as a disadvantage in all cases. I would say this is not a disadvantage of any one method, but a requirement of CSRF protection in general.</span></text><author><a class="comment-user" href="/users/770606/ali-gangji" title="1,148 reputation">Ali Gangji</a></author></comment><comment><text><span class="comment-copy">@AliGangji: Not necessarily, but certainly with the methods the OP mentions. CSRF protection that does not require a token value include checking <a href="http://stackoverflow.com/a/22533680/413180"><code>X-Requested-With</code></a> or checking the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#CSRF_Prevention_without_a_Synchronizer_Token" rel="nofollow noreferrer"><code>Referer or Origin</code></a> headers.</span></text><author><a class="comment-user" href="/users/413180/silverlightfox" title="17,301 reputation">SilverlightFox</a></author></comment><comment><text><span class="comment-copy">@SilverlightFox: Yup, you are correct. I should say it's requirement of any token based method.</span></text><author><a class="comment-user" href="/users/770606/ali-gangji" title="1,148 reputation">Ali Gangji</a></author></comment><comment><text><span class="comment-copy">I went with the Cookie approach as the headers were being wiped out by a middle system that our application was going through. Excellent Post. Thank you</span></text><author><a class="comment-user" href="/users/3361529/rami-stefanidis" title="660 reputation">Rami Stefanidis</a></author></comment><comment><text><span class="comment-copy">@metamatt Sorry for the necro, but I'll do it for people that wander in. In my understanding the attacker doesn't typically have access to the response. CSRF is primarily used to <i>cause side effects</i>, rather than directly gathering data. For example, a CSRF attack script might force a privileged user to escalate the privileges of the attacker, disable a security setting, or force a logged-in paypal user to send a transfer to a specific email address. In none of these cases does the attacker care about the response, which is still sent to the victim's browser; only the outcome of the attack.</span></text><author><a class="comment-user" href="/users/1760387/jonathanbruder" title="81 reputation">jonathanbruder</a></author></comment><comment><text><span class="comment-copy">"If a malicious user tries to read the user's CSRF token in any of the above methods then this will be prevented by the Same Origin Policy"  What happens if you have an XSS lurking on your application's views ?</span></text><author><a class="comment-user" href="/users/1627311/mak" title="423 reputation">mak</a></author></comment><comment><text><span class="comment-copy">@mak If an attacker has XSS ability then they don't need CSRF. XSS almost always has a greater impact.</span></text><author><a class="comment-user" href="/users/413180/silverlightfox" title="17,301 reputation">SilverlightFox</a></author></comment><comment><text><span class="comment-copy">There's one fairly big disadvantage to using Set-Cookie downstream approach -- it makes it way harder to implement XSRF protection in clients other than browser (mobile applications that use the same HTTP endpoints, desktop applications e.g. Electron). Cookies are often handled separately, and are not as easily available as a custom downstream header.</span></text><author><a class="comment-user" href="/users/246376/dzmitry-lazerka" title="621 reputation">Dzmitry Lazerka</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Using a cookie to hold a CSRF token does not allow a successful attack because the attacker cannot read the value of the cookie and therefore cannot put into the place the server-side CSRF validation requires it to be.</p>
<p>The attacker will be able to cause a request to the server with both the auth token cookie and the CSRF cookie in the request headers.  But the server is not looking for the CSRF token as a cookie in the request headers, it's looking in the payload of the request.  And even if the attacker knows where to put the CSRF token in the payload, they would have to read its value to put it there.  But the browser's cross-origin policy prevents reading any cookie value from the target website.</p>
<p>The same logic does not apply to the auth token cookie, because the server is expects it in the request headers and the attacker does not have to do anything special to put it there.</p>
</div></text><author><a href="/users/1754168/tongfa">Tongfa</a></author><comments><comment><text><span class="comment-copy">This is the answer I was looking for. Thanks.</span></text><author><a class="comment-user" href="/users/4400989/manh-tai" title="66 reputation">Manh Tai</a></author></comment><comment><text><span class="comment-copy">Surely though, an attacker does not need to read the cookie in the first place. They can just insert an image on the hacked site with <code>src='bank.com/transfer?to=hacker&amp;amount=1000</code> which the browser will request, complete with the associated cookies for that site (<code>bank.com</code>)?</span></text><author><a class="comment-user" href="/users/2822450/developius" title="358 reputation">developius</a></author></comment><comment><text><span class="comment-copy">CSRF is for validating the user on the client side, and not for protecting the site generally from a server side compromise as you suggest.</span></text><author><a class="comment-user" href="/users/1754168/tongfa" title="374 reputation">Tongfa</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>My best guess as to the answer: Consider these 3 options for how to get the CSRF token down from the server to the browser.</p>
<ol>
<li>In the request body (not an HTTP header).</li>
<li>In a custom HTTP header, not Set-Cookie.</li>
<li>As a cookie, in a Set-Cookie header.</li>
</ol>
<p>I think the 1st one, request body (while demonstrated by <a href="http://dailyjs.com/2012/09/13/express-3-csrf-tutorial/" rel="nofollow">the Express tutorial I linked in the question</a>), is not as portable to a wide variety of situations; not everyone is generating every HTTP response dynamically; where you end up needing to put the token in the generated response might vary widely (in a hidden form input; in a fragment of JS code or a variable accessible by other JS code; maybe even in a URL though that seems generally a bad place to put CSRF tokens). So while workable with some customization, #1 is a hard place to do a one-size-fits-all approach.</p>
<p>The second one, custom header, is attractive but doesn't actually work, because <a href="http://stackoverflow.com/a/220233/275581">while JS can get the headers for an XHR it invoked, it can't get the headers for the page it loaded from</a>.</p>
<p>That leaves the third one, a cookie carried by a Set-Cookie header, as an approach that is easy to use in all situations (anyone's server will be able to set per-request cookie headers, and it doesn't matter what kind of data is in the request body). So despite its downsides, it was the easiest method for frameworks to implement widely.</p>
</div></text><author><a href="/users/275581/metamatt">metamatt</a></author><comments><comment><text><span class="comment-copy">I might be stating the obvious, this does mean that cookie can not be httponly correct?</span></text><author><a class="comment-user" href="/users/497617/photon" title="116 reputation">Photon</a></author></comment></comments></answer></answers></post>