<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How are Software License Keys generated? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>License Keys are the defacto-standard as an anti-piracy measure. To be honest this strikes me as <a href="http://en.wikipedia.org/wiki/Security_through_obscurity" rel="noreferrer">(in)Security Through Obscurity</a>, although I really have no idea how License Keys are generated. What is a good (secure) example of License Key generation? What cryptographic primitive (if any) are they using? Is it a message digest? If so what data would they be hashing? What methods do developers employ to make it difficult for crackers to build their own key generators? How are key generators made?</p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments><comment><text><span class="comment-copy">+1 interesting question, maybe an answerer can post links to some good resources on this topic for further reading? please :)</span></text><author><a class="comment-user" href="/users/336855/jacob" title="867 reputation">Jacob</a></author></comment><comment><text><span class="comment-copy">All DRM schemes are essentially obscurity schemes, since all the code and data necessary for the program to run has been supplied to the user.  The scheme can be made arbitrarily obfuscated to make patching difficult, but it's a certainty that the code can be patched to avoid any check.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">CD keys are indeed security through obscurity. There are several ways to build them, but all necessarily rely on embedding some secret in the program that is required to verify the key.</span></text><author><a class="comment-user" href="/users/12030/nick-johnson" title="90,861 reputation">Nick Johnson</a></author></comment><comment><text><span class="comment-copy">I think its not a big secret, just some ordinary math, sure different for each software..</span></text><author><a class="comment-user" href="/users/287316/tom-brito" title="8,789 reputation">Tom Brito</a></author></comment><comment><text><span class="comment-copy">They're called <i>product</i> keys or <i>license</i> keys now, since most software that uses them is more likely to be delivered online than by cd.</span></text><author><a class="comment-user" href="/users/3043/joel-coehoorn" title="262,375 reputation">Joel Coehoorn</a></author></comment><comment><text><span class="comment-copy">Also, this answer and it's links are worth your time: <a href="http://stackoverflow.com/questions/2364148/is-there-any-good-method-to-encrypt-the-c-desktop-application/2364250#2364250" title="is there any good method to encrypt the c desktop application">stackoverflow.com/questions/2364148/…</a></span></text><author><a class="comment-user" href="/users/3043/joel-coehoorn" title="262,375 reputation">Joel Coehoorn</a></author></comment><comment><text><span class="comment-copy">I'd like to make an app someday where I'd have to worry about this, childhood dream of sorts. Web apps just don't cut it.</span></text><author><a class="comment-user" href="/users/138023/znarkus" title="8,904 reputation">Znarkus</a></author></comment><comment><text><span class="comment-copy">@caf Preventing key generators can be done securely. What relies on obscurity is preventing cracks where the attacker modifies the executable to disable the verification.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment><comment><text><span class="comment-copy">I just use the invoice number as the license key.</span></text><author><a class="comment-user" href="/users/3427520/zwcloud" title="1,704 reputation">zwcloud</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>For old-school CD keys, it was just a matter of making up an algorithm for which CD keys (which could be any string) are easy to generate and easy to verify, but the ratio of valid-CD-keys to invalid-CD-keys is so small that randomly guessing CD keys is unlikely to get you a valid one.</p>
<h3>INCORRECT WAY TO DO IT:</h3>
<p><strong>Starcraft</strong> and <strong>Half-life</strong> both used the same checksum, where the 13th digit verified the first 12.  Thus, you could enter anything for the first 12 digits, and guess the 13th (there's only 10 possibilities), leading to the infamous <code>1234-56789-1234</code></p>
<p>The algorithm for verifying is public, and looks something like this:</p>
<pre><code>x = 3;
for(int i = 0; i &lt; 12; i++)
{
    x += (2 * x) ^ digit[i];
}
lastDigit = x % 10;
</code></pre>
<h3>CORRECT WAY TO DO IT</h3>
<p><strong>Windows XP</strong> takes quite a bit of information, encrypts it, and puts the letter/number encoding on a sticker.  This allowed MS to both verify your key <em>and</em> obtain the product-type (Home, Professional, etc.) at the same time.  Additionally, it requires online activation.<br/>
The full algorithm is rather complex, but outlined nicely in <a href="http://www.licenturion.com/xp/fully-licensed-wpa.txt" rel="noreferrer">this</a> (completely legal!) paper, published in Germany.</p>
<p>Of course, no matter what you do, unless you are offering an online service (like <strong>World of Warcraft</strong>), any type of copy protection is just a stall:  unfortunately, if it's any game worth value, someone will break <em>(or at least circumvent)</em> the CD-key algorithm, and all other copyright protections.</p>
<h3><em>REAL</em> CORRECT WAY TO DO IT:</h3>
<p>For online-services, life is a bit simpler, since even with the binary file you need to authenticate with their servers to make any use of it (eg. have a WoW account).  The CD-key algorithm for World of Warcraft - used, for instance, when buying playtime cards - probably looks something like this:</p>
<blockquote>
<ol>
<li>Generate a very large cryptographically-secure random number.  </li>
<li>Store it in our database and print it on the card.<br/><br/>
  Then, when someone enters a playtime-card number, check if it's in the database, and if it is, associate that number with the current user so it can never be used again.</li>
</ol>
</blockquote>
<p>For online services, there is no reason <strong>not</strong> to use the above scheme; using anything else can <a href="http://www.joystiq.com/2011/03/10/ms-point-scam-cost-microsoft-over-1-million/" rel="noreferrer">lead to problems</a>.</p>
</div></text><author><a href="/users/238419/blueraja-danny-pflughoeft">BlueRaja - Danny Pflughoeft</a></author><comments><comment><text><span class="comment-copy">Mathematica has an interesting process.  The product comes with a unique key, and the installation file generates a second unique key (based off your hardware).  Both of these keys must be entered into an online form with your name and registration information, and then they send you the real key based off those two keys which actually unlocks the software, but only for that specific product key and on your specific hardware.</span></text><author><a class="comment-user" href="/users/110797/dan" title="4,478 reputation">Dan</a></author></comment><comment><text><span class="comment-copy">Heh, I never knew about the <code>1234-56789-1234</code> Starcraft key, but I remember that it only took about five minutes to "brute force" the verifier by mashing on the keypad and trying again.</span></text><author><a class="comment-user" href="/users/103225/fmark" title="25,887 reputation">fmark</a></author></comment><comment><text><span class="comment-copy">I also remember some Microsoft products in the past allowing you to use 111-1111111 as a valid cdkey (Visual Studio 6.0)</span></text><author><a class="comment-user" href="/users/109070/hannson" title="2,865 reputation">hannson</a></author></comment><comment><text><span class="comment-copy">@Dan If what you say is true, it looks like Mathematica's method is simply a fancier version of client-side verification, since a keygen could generate the same "real key" given the two keys you're supposed to send in.</span></text><author><a class="comment-user" href="/users/140827/erjiang" title="27,541 reputation">erjiang</a></author></comment><comment><text><span class="comment-copy">Isn't <i>any</i> cryptography algorithm really just a stall? A "safe" algorithm is just one that "stalls" until after the heat death of the universe, given current and near-future computing performance. +1 for mentioning Starcraft.</span></text><author><a class="comment-user" href="/users/166850/rmorrisey" title="5,119 reputation">RMorrisey</a></author></comment><comment><text><span class="comment-copy">Never knew about 1234-56789-1234. Instead, we used thirteen threes! 3333333333333</span></text><author><a class="comment-user" href="/users/225360/eriktj" title="839 reputation">ErikTJ</a></author></comment><comment><text><span class="comment-copy">@Mazin, not necessarily. Mathematica could keep an unpredictable mapping of product-key to random numbers in a db. Still, a lot of software cracks boil down to switching a <code>JZ</code> to a <code>JNZ</code> somewhere.</span></text><author><a class="comment-user" href="/users/81804/kibibu" title="3,484 reputation">kibibu</a></author></comment><comment><text><span class="comment-copy">@kibibu: Then there would be <i>no</i> way of activating the product without Internet, which many companies are historically hesitant to do (though computers without Internet are rare enough now that we are seeing a few companies do it) - these programs cannot be keygenned, but they can still just as easily be cracked.  Mathematica just verifies a code, making it possible to activate over the phone (and possible to keygen).</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">The problem with online activation is that we are all screwed if/when the publisher goes out of business.  Please don't do this.  This happens, and can/will happen to even Microsoft some day.</span></text><author><a class="comment-user" href="/users/362536/brad" title="93,479 reputation">Brad</a></author></comment><comment><text><span class="comment-copy">Starcraft also allowed 0000000000003.</span></text><author><a class="comment-user" href="/users/403390/tim" title="9,023 reputation">Tim</a></author></comment><comment><text><span class="comment-copy">@Hannson microsoft used to just check that the number entered was divisible by 17 (or something) hence the 111-1111111 key</span></text><author><a class="comment-user" href="/users/10897/martin-beckett" title="72,448 reputation">Martin Beckett</a></author></comment><comment><text><span class="comment-copy">Before online authorization were CD keys recycled given the inherent limit? Or were new binaries and discs stamped to support a new set of unused keys?</span></text><author><a class="comment-user" href="/users/250190/chris-wagner" title="15,790 reputation">Chris Wagner</a></author></comment><comment><text><span class="comment-copy">@ChrisWagner: Even just 12 digits gives you 1 trillion possibilities; that's over 150x the population of Earth.  They had plenty of CD keys to hand out.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">Duh, that makes sense, I guess I was thinking the subset that were valid was pretty small, but even 1% of a trillion offers 10 billion valid keys.</span></text><author><a class="comment-user" href="/users/250190/chris-wagner" title="15,790 reputation">Chris Wagner</a></author></comment><comment><text><span class="comment-copy">Q3A allowed a long line of Ls</span></text><author><a class="comment-user" href="/users/958689/hiergiltdiestfu" title="1,661 reputation">hiergiltdiestfu</a></author></comment><comment><text><span class="comment-copy">I was so impressed when my Starcraft key unlocked my Half Life game.</span></text><author><a class="comment-user" href="/users/3536236/martin" title="8,017 reputation">Martin</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>When I originally wrote this answer it was under an assumption that the question was regarding 'offline' validation of licence keys.  Most of the other answers address online verification, which is significantly easier to handle (most of the logic can be done server side).</p>
<p>With offline verification the most difficult thing is ensuring that you can generate a huge number of unique licence keys, and still maintain a strong algorithm that isnt easily compromised (such as a simple check digit)</p>
<p>I'm not very well versed in mathematics, but it struck me that one way to do this is to use a <a href="http://en.wikipedia.org/wiki/Graph_of_a_function" rel="noreferrer">mathematical function</a> that plots a graph</p>
<p>The plotted line can have (if you use a fine enough frequency) thousands of unique points, so you can generate keys by picking random points on that graph and encoding the values in some way</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/t6SeY.png"/></p>
<p>As an example, we'll plot this graph, pick four points and encode into a string as "0,-500;100,-300;200,-100;100,600"</p>
<p>We'll encrypt the string with a known and fixed key (horribly weak, but it serves a purpose), then convert the resulting bytes through <a href="http://en.wikipedia.org/wiki/Base32" rel="noreferrer">Base32</a> to generate the final key</p>
<p>The application can then reverse this process (base32 to real number, decrypt, decode the points) and then check each of those points is on our secret graph.</p>
<p>Its a fairly small amount of code which would allow for a huge number of unique and valid keys to be generated</p>
<p>It is however very much security by obscurity. Anyone taking the time to disassemble the code would be able to find the graphing function and encryption keys, then mock up a key generator, but its probably quite useful for slowing down casual piracy.</p>
</div></text><author><a href="/users/141661/paulg">PaulG</a></author><comments><comment><text><span class="comment-copy">Wouldn't this fail because of floating point numbers?</span></text><author><a class="comment-user" href="/users/225360/eriktj" title="839 reputation">ErikTJ</a></author></comment><comment><text><span class="comment-copy">No, Erik it would not. X is an integer and Y is the floor of the function.</span></text><author><a class="comment-user" href="/users/14768/joshua" title="19,685 reputation">Joshua</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Check tis article on <a href="http://www.brandonstaggs.com/2007/07/26/implementing-a-partial-serial-number-verification-system-in-delphi/" rel="noreferrer">Partial Key Verification</a> which covers the following requirements:</p>
<ul>
<li><p>License keys must be easy enough to type in.</p></li>
<li><p>We must be able to blacklist (revoke) a license key in the case of chargebacks or purchases with stolen credit cards.</p></li>
<li><p>No “phoning home” to test keys.  Although this practice is becoming more and more prevalent, I still do not appreciate it as a user, so will not ask my users to put up with it.</p></li>
<li><p>It should not be possible for a cracker to disassemble our released application and produce a working “keygen” from it. This means that our application will not fully test a key for verification. Only some of the key is to be tested. Further, each release of the application should test a different portion of the key, so that a phony key based on an earlier release will not work on a later release of our software.</p></li>
<li><p>Important: it should not be possible for a legitimate user to accidentally type in an invalid key that will appear to work but fail on a future version due to a typographical error.</p></li>
</ul>
</div></text><author><a href="/users/413910/the-surrican">The Surrican</a></author><comments><comment><text><span class="comment-copy">+1 for the link to the paper.  Thanks!</span></text><author><a class="comment-user" href="/users/1466970/richard-chambers" title="6,925 reputation">Richard Chambers</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I've not got any experience with what people actually do to generate CD keys, but (assuming you're not wanting to go down the road of online activation) here are a few ways one could make a key:</p>
<ul>
<li><p>Require that the number be divisible by (say) 17.  Trivial to guess, if you have access to many keys, but the majority of potential strings will be invalid.  Similar would be requiring that the checksum of the key match a known value.</p></li>
<li><p>Require that the first half of the key, when concatenated with a known value, hashes down to the second half of the key.  Better, but the program still contains all the information needed to generate keys as well as to validate them.</p></li>
<li><p>Generate keys by encrypting (with a private key) a known value + nonce.  This can be verified by decrypting using the corresponding public key and verifying the known value.  The program now has enough information to verify the key without being able to generate keys.</p></li>
</ul>
<p>These are still all open to attack: the program is still there and can be patched to bypass the check.  Cleverer might be to encrypt part of the program using the known value from my third method, rather than storing the value in the program.  That way you'd have to find a copy of the key before you could decrypt the program, but it's still vulnerable to being copied once decrypted and to having one person take their legit copy and use it to enable everyone else to access the software.</p>
</div></text><author><a href="/users/24762/andrew-aylett">Andrew Aylett</a></author><comments><comment><text><span class="comment-copy">I really wish whoever had come up with the 'number used once' thing had not chosen Nonce as the name, given the <i>ahem</i> negative connotations that make me giggle every time someone suggests encrypting one.</span></text><author><a class="comment-user" href="/users/70847/ed-james" title="6,246 reputation">Ed James</a></author></comment><comment><text><span class="comment-copy">Note that the third option doesn't work with symmetric key cyphers as the attacker could just revers engineer the test on the plain text, generate something that passes and then encrypt it with the (known) key and (known) cypher. Using a home brew cypher is no solution because if you can do it right on your own, you should get a job at the NSA.</span></text><author><a class="comment-user" href="/users/1343/bcs" title="27,490 reputation">BCS</a></author></comment><comment><text><span class="comment-copy">@BCS: Sorry, I should have been clearer about using public-key crypto.</span></text><author><a class="comment-user" href="/users/24762/andrew-aylett" title="26,102 reputation">Andrew Aylett</a></author></comment><comment><text><span class="comment-copy">Use a signature scheme, not an encryption scheme for the public-key version. (RSA signature looks a bit like "encryption with the public key", but it is not totally the same thing. There are other signature schemes which don't have an associated encryption scheme, like DSA.)</span></text><author><a class="comment-user" href="/users/600500/pa%c5%adlo-ebermann" title="51,688 reputation">Paŭlo Ebermann</a></author></comment><comment><text><span class="comment-copy">The problem with public-key crypto is keys (and hence serials) must be long.  A 512-bit RSA keypair is not hard to crack these days.  Compare with WinXP's keys (5 groups of 5 alphanumeric characters) which have only 128 bits of entropy but still a pain to type in.</span></text><author><a class="comment-user" href="/users/12048/finnw" title="33,780 reputation">finnw</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>CD-Keys aren't much of a security for any non-networked stuff, so technically they don't need to be securely generated. If you're on .net, you can almost go with Guid.NewGuid().</p>
<p>Their main use nowadays is for the Multiplayer component, where a server can verify the CD Key. For that, it's unimportant how securely it was generated as it boils down to "Lookup whatever is passed in and check if someone else is already using it".</p>
<p>That being said, you may want to use an algorhithm to achieve two goals:</p>
<ul>
<li>Have a checksum of some sort. That allows your Installer to display "Key doesn't seem valid" message, solely to detect typos (Adding such a check in the installer actually means that writing a Key Generator is trivial as the hacker has all the code he needs. Not having the check and solely relying on server-side validation disables that check, at the risk of annoying your legal customers who don't understand why the server doesn't accept their CD Key as they aren't aware of the typo)</li>
<li>Work with a limited subset of characters. Trying to type in a CD Key and guessing "Is this an 8 or a B? a 1 or an I? a Q or an O or a 0?" - by using a subset of non-ambigous chars/digits you eliminate that confusion.</li>
</ul>
<p>That being said, you still want a large distribution and some randomness to avoid a pirate simply guessing a valid key (that's valid in your database but still in a box on a store shelf) and screwing over a legitimate customer who happens to buy that box.</p>
</div></text><author><a href="/users/91/michael-stum">Michael Stum</a></author><comments><comment><text><span class="comment-copy">easily solved by good customer service - Box shot + Proof of Purchase = Lock Illegal user, Give Second User Access.</span></text><author><a class="comment-user" href="/users/136173/alexanderpas" title="2,015 reputation">alexanderpas</a></author></comment><comment><text><span class="comment-copy">here are a few extra thoughts on CD keys <a href="http://www.codinghorror.com/blog/2007/12/software-registration-keys.html" rel="nofollow noreferrer">codinghorror.com/blog/2007/12/software-registration-keys.htm‌​l</a></span></text><author><a class="comment-user" href="/users/1466970/richard-chambers" title="6,925 reputation">Richard Chambers</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you aren't particularly concerned with the length of the key, a pretty tried and true method is the use of public and private key encryption.</p>
<p>Essentially have some kind of nonce and a fixed signature.</p>
<p>For example:
0001-123456789</p>
<p>Where 0001 is your nonce and 123456789 is your fixed signature.</p>
<p>Then encrypt this using your private key to get your CD key which is something like:
ABCDEF9876543210</p>
<p>Then distribute the public key with your application. The public key can be used to decrypt the CD key "ABCDEF9876543210", which you then verify the fixed signature portion of.</p>
<p>This then prevents someone from guessing what the CD key is for the nonce 0002 because they don't have the private key.</p>
<p>The only major down side is that your CD keys will be quite long when using private / public keys 1024-bit in size. You also need to choose a nonce long enough so you aren't encrypting a trivial amount of information.</p>
<p>The up side is that this method will work without "activation" and you can use things like an email address or licensee name as the nonce.</p>
</div></text><author><a href="/users/207657/userx">userx</a></author><comments><comment><text><span class="comment-copy">Please note that my example grossly underestimates the length your key would be. These schemes typically require base64 encoding and copy / paste deployment, but allow for near impossible to guess keys that aren't tied to a machine and don't require activation (two things very important for many types of customers)</span></text><author><a class="comment-user" href="/users/207657/userx" title="3,033 reputation">userx</a></author></comment><comment><text><span class="comment-copy">Instead of using RSA, you can use Elliptic curves. They use shorter keys, and their block length is smaller. Reading the Wiki, it seems that a 256 bit ECC is as secure as AES 128.</span></text><author><a class="comment-user" href="/users/613130/xanatos" title="73,472 reputation">xanatos</a></author></comment><comment><text><span class="comment-copy">Please note that digital signatures and "encryption by private key" are not the same thing. In RSA they look similar (though they are not, due to different padding schemes), other signature schemes don't even have a corresponding encryption scheme.</span></text><author><a class="comment-user" href="/users/600500/pa%c5%adlo-ebermann" title="51,688 reputation">Paŭlo Ebermann</a></author></comment><comment><text><span class="comment-copy">@xanatos, 256 bits is still too long to type in by hand.  Consider the 25-character keys used by WinXP - they have only 128 bits of entropy.</span></text><author><a class="comment-user" href="/users/12048/finnw" title="33,780 reputation">finnw</a></author></comment><comment><text><span class="comment-copy">@finnw You could use a 128 bits elliptic curve. It would be as secure as DES. Unless your sw is very expensive it is secure enough.</span></text><author><a class="comment-user" href="/users/613130/xanatos" title="73,472 reputation">xanatos</a></author></comment><comment><text><span class="comment-copy">Any tips on how to "encrypt with a private key" using openssl?  Everything I've found describes how to encrypt with the public key, and decrypt with the private key.  You can "sign" with private, but I haven't figured out how to "encrypt" with the private key...?</span></text><author><a class="comment-user" href="/users/420059/mark" title="180 reputation">Mark</a></author></comment><comment><text><span class="comment-copy">@Mark - A signature is typically just an encrypted hash. You can use encryption or signing, my method works the same. You're just trying to create a license key which can't easily be generated without the private key and can be verified by the public key. This could be the entire message encrypted (and you verify that part of its contents matches something magic) or simply a signed message (and you verify that the signature is valid). It's up to your implementation.</span></text><author><a class="comment-user" href="/users/207657/userx" title="3,033 reputation">userx</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The key system must have several properties:</p>
<ul>
<li>very few keys must be valid</li>
<li>valid keys must not be derivable even given everything the user has.</li>
<li>a valid key on one system is not a valid key on another.</li>
<li>others</li>
</ul>
<p>One solution that should give you these would be to use a <a href="http://en.wikipedia.org/wiki/Digital_signature" rel="noreferrer">public key signing scheme</a>. Start with a "system hash" (say grab the macs on any NICs, sorted, and the CPU-ID info, plus some other stuff, concatenate it all together and take an MD5 of the result (you really don't want to be handling <a href="http://en.wikipedia.org/wiki/Personally_identifiable_information#United_States_of_America" rel="noreferrer">personally identifiable information</a> if you don't have to)) append the CD's serial number and refuse to boot unless some registry key (or some datafile) has a valid signature for the blob. The user activates the program by shipping the blob to you and you ship back the signature.</p>
<p>Potential issues include that you are offering to sign practically anything so you need to assume someone will run a <a href="http://en.wikipedia.org/wiki/Chosen-plaintext_attack" rel="noreferrer">chosen plain text</a> and/or <a href="http://en.wikipedia.org/wiki/Chosen-ciphertext_attack" rel="noreferrer">chosen ciphertext</a> attacks. That can be mitigated by checking the serial number provided and refusing to handle request from invalid ones as well as refusing to handle more than a given number of queries from a given s/n in an interval (say 2 per year)</p>
<p>I should point out a few things: First, a skilled and determined attacker will be able to bypass any and all security in the parts that they have unrestricted access to (<em>i.e.</em> everything on the CD), the best you can do on that account is make it harder to get illegitimate access than it is to get legitimate access. Second, I'm no expert so there could be serious flaws in this proposed scheme. </p>
</div></text><author><a href="/users/1343/bcs">BCS</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>All of the CD only copy protection algorithms inconvience honest users while providing no protection against piracy whatsoever.</p>
<p>The "pirate" only need to have access to one legitimate cd and its access code, he can then make n copies and distribute them.</p>
<p>It does not matter how cryptographically secure you make the code, you need to supply this with the CD in plain text or an legitimate user cannot activite the software.</p>
<p>Most secure schemes involve either the user providing the software supplier with some details of the machine which will run the software (cpu serial numbers, mac addresses, Ip address etc.), or, require online access to register the software on the suppliers website and in return receive an activitation token. The first option requires a lot of manual administration and is only worth it for very high value software, the, second option can be spoofed and is absolutly infuriating if you have limited network access or you are stuck behind a firewall.</p>
<p>On the whole its much easier to establish a trust relationship with your customers!</p>
</div></text><author><a href="/users/38207/james-anderson">James Anderson</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are also DRM behaviors that incorporate multiple steps to the process.  One of the most well known examples is one of Adobe's methods for verifying an installation of their Creative Suite.  The traditional CD Key method discussed here is used, then Adobe's support line is called.  The CD key is given to the Adobe representative and they give back an activation number to be used by the user.</p>
<p>However, despite being broken up into steps, this falls prey to the same methods of cracking used for the normal process.  The process used to create an activation key that is checked against the original CD key was quickly discovered, and generators that incorporate both of the keys were made.</p>
<p>However, this method still exists as a way for users with no internet connection to verify the product.  Going forward, it's easy to see how these methods would be eliminated as internet access becomes ubiquitous.</p>
</div></text><author><a href="/users/144121/sean">Sean</a></author><comments/></answer></answers></post>