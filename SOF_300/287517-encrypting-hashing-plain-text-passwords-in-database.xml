<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Encrypting/Hashing plain text passwords in database - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I've <strong>inherited</strong> a web app that I've just discovered stores over 300,000 usernames/passwords in plain text in a SQL Server database.  I realize that this is a Very Bad Thing™.</p>
<p>Knowing that I'll have to update the login and password update processes to encrypt/decrypt, and with the smallest impact on the rest of the system, what would you recommend as the best way to remove the plain text passwords from the database?</p>
<p>Any help is appreciated.</p>
<p><strong>Edit: Sorry if I was unclear, I meant to ask what would be your procedure to encrypt/hash the passwords, not specific encryption/hashing methods.</strong> </p>
<p>Should I just:</p>
<ol>
<li>Make a backup of the DB</li>
<li>Update login/update password code</li>
<li>After hours, go through all records in the users table hashing the password and replacing each one</li>
<li>Test to ensure users can still login/update passwords</li>
</ol>
<p>I guess my concern is more from the sheer number of users so I want to make sure I'm doing this correctly.</p>
</div></text><author><a href="/users/2034/jonathan-s">Jonathan S.</a></author><comments><comment><text><span class="comment-copy">Very Bad Thing(tm) :)</span></text><author><a class="comment-user" href="/users/15667/xan" title="5,981 reputation">xan</a></author></comment><comment><text><span class="comment-copy">I don't think that you've worked your question well. You want to know how to get data out of a relational database? That would be a select statement.</span></text><author><a class="comment-user" href="/users/25191/glenn" title="5,356 reputation">Glenn</a></author></comment><comment><text><span class="comment-copy">I know how to retrieve records, this is more of a procedural question... Sorry if that was unclear.</span></text><author><a class="comment-user owner" href="/users/2034/jonathan-s" title="3,716 reputation">Jonathan S.</a></author></comment><comment><text><span class="comment-copy">Have you got hold of the Reddit user DB? ;-)</span></text><author><a class="comment-user" href="/users/1450/john-topley" title="76,619 reputation">John Topley</a></author></comment><comment><text><span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/1841595/secure-password-hashing">Secure Password Hashing</a></span></text><author><a class="comment-user" href="/users/387076/gilles" title="60,399 reputation">Gilles</a></author></comment><comment><text><span class="comment-copy">@Gilles - I'm not sure how this 7 year old question with over 34,000 views is a duplicate of a 6 year old question with under 5,000 views but apparently you think it is.  I agree that I wouldn't ask this as a new question on SO today, but this was asked before all of the other Programming-related Stack Exchange sites existed.  The question itself is more about the process of migrating from plain-text to more secure passwords, not the specific implementation of encryption/hashing methods.</span></text><author><a class="comment-user owner" href="/users/2034/jonathan-s" title="3,716 reputation">Jonathan S.</a></author></comment><comment><text><span class="comment-copy">@JonathanS. Just because we've let duplicates stick around for a few years doesn't mean we should keep them open when we find them. And I don't see how the existence of other SE sites is relevant.</span></text><author><a class="comment-user" href="/users/387076/gilles" title="60,399 reputation">Gilles</a></author></comment><comment><text><span class="comment-copy">Also, since you're still around, I suggest switching the accepted answer to a good one — not one that claims that passwords are “encrypted”, or that MD5 is a decent choice for a password hash. <a href="http://stackoverflow.com/a/287883">stackoverflow.com/a/287883</a> and <a href="http://stackoverflow.com/a/287738">stackoverflow.com/a/287738</a> are better answers as they let on that a password hash must be salted and slow.</span></text><author><a class="comment-user" href="/users/387076/gilles" title="60,399 reputation">Gilles</a></author></comment><comment><text><span class="comment-copy">@Gilles - My mention of other SE sites was to reiterate that this was more of a process/procedure question that I would have likely asked on programmers.stackexchange.com, had it existed when I originally asked.  I still don't believe this is a duplicate as I wasn't asking which hashing algorithm should be used. The current accepted answer was the best answer at the time that actually discussed a process for migrating from plain-text passwords to a more secure implementation.</span></text><author><a class="comment-user owner" href="/users/2034/jonathan-s" title="3,716 reputation">Jonathan S.</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I would imagine you will have to add a column to the database for the encrypted password then run a batch job over all records which gets the current password, encrypts it (as others have mentiond a hash like md5 is pretty standard <strong>edit: but should not be used on its own - see other answers for good discussions</strong>), stores it in the new column and checks it all happened smoothly.</p>
<p>Then you will need to update your front-end to hash the user-entered password at login time and verify that vs the stored hash, rather than checking plaintext-vs-plaintext.</p>
<p>It would seem prudent to me to leave both columns in place for a little while to ensure that nothing hinky has gone on, before eventually removing the plaintext passwords all-together.</p>
<p>Don't forget also that anytime the password is acessed the code will have to change, such as password change / reminder requests. You will of course lose the ability to email out forgotten passwords, but this is no bad thing. You will have to use a password reset system instead.</p>
<p>Edit:
One final point, you might want to consider avoiding the error I made on my first attempt at a test-bed secure login website:</p>
<p>When processing the user password, consider where the hashing takes place. In my case the hash was calculated by the PHP code running on the webserver, but the password was transmitted to the page from the user's machine in plaintext! This was ok(ish) in the environment I was working in, as it was inside an https system anyway (uni network). But, in the real world I imagine you would want to hash the password before it leaves the user system, using javascript etc. and then transmit the hash to your site.</p>
</div></text><author><a href="/users/15667/xan">xan</a></author><comments><comment><text><span class="comment-copy">Thanks, while I don't like keeping the passwords around, they have already been around for years...  The system sends out several emails that include passwords so I'll have to look at those before deciding on using a hash.</span></text><author><a class="comment-user owner" href="/users/2034/jonathan-s" title="3,716 reputation">Jonathan S.</a></author></comment><comment><text><span class="comment-copy">What happens if they have javascript turned off?</span></text><author><a class="comment-user" href="/users/12243/malfist" title="14,149 reputation">Malfist</a></author></comment><comment><text><span class="comment-copy">You can't hash the password on the user's machine. The hashing has to be done by a trusted system. (Otherwise anyone that's stolen a copy of the password table can just send you the hash; the hash has become the password.) But, yes, this does require a secure transport like HTTPS from the user.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">@Malfist: That is quickly turning into a historical concern. Very, very few people disable js. In that case, though, I would send the unhashed pass to the server and accommodate for that in server-side code. It would simply be a less-ideal fallback.</span></text><author><a class="comment-user" href="/users/6726/lucas-oman" title="11,797 reputation">Lucas Oman</a></author></comment><comment><text><span class="comment-copy">@erickson: for those who are particularly paranoid, you can store the pass double-hashed in the DB and accept a single-hashed pass from the client.</span></text><author><a class="comment-user" href="/users/6726/lucas-oman" title="11,797 reputation">Lucas Oman</a></author></comment><comment><text><span class="comment-copy">Either hash or don't hash. Hashing on the client is pointless. The threat model you're addressing with a hash is exposure of the password database. If that's not a concern, don't hash at all. Otherwise, you can't authenticate using a hash produced by the user (or read from a stolen database copy).</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">It may be uber-paranoid, I was just mentioning something that I didn't address properly at the time. As I said, I don't have real-world, active experiance of best practice in this area but it is somethingworth considering.</span></text><author><a class="comment-user" href="/users/15667/xan" title="5,981 reputation">xan</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>EDIT (2016): use <a href="https://en.wikipedia.org/wiki/Argon2" rel="nofollow noreferrer">Argon2</a>, <a href="https://en.wikipedia.org/wiki/Scrypt" rel="nofollow noreferrer">scrypt</a>, <a href="https://en.wikipedia.org/wiki/Bcrypt" rel="nofollow noreferrer">bcrypt</a>, or <a href="https://en.wikipedia.org/wiki/PBKDF2" rel="nofollow noreferrer">PBKDF2</a>, in that order of preference. Use as large a slowdown factor as is feasible for your situation. Use a vetted existing implementation. Make sure you use a proper salt (although the libraries you're using should be making sure of this for you).</p>
<hr/>
<p>When you hash the passwords use <strong>DO NOT USE PLAIN MD5</strong>.</p>
<p>Use <a href="http://tools.ietf.org/html/rfc2898#section-5.2" rel="nofollow noreferrer">PBKDF2</a>, which basically means using a random salt to prevent <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="nofollow noreferrer">rainbow table</a> attacks, and iterating (re-hashing) enough times to slow the hashing down - not so much that your application takes too long, but enough that an attacker brute-forcing a large number of different password will notice</p>
<p>From the document:</p>
<ul>
<li>Iterate at least 1000 times, preferably more  - time your implementation to see how many iterations are feasible for you.</li>
<li>8 bytes (64 bits) of salt are sufficient, and the random doesn't need to be secure (the salt is unencrypted, we're not worried someone will guess it).</li>
<li>A good way to apply the salt when hashing is to use HMAC with your favorite hash algorithm, using the password as the HMAC key and the salt as the text to hash (see <a href="http://tools.ietf.org/html/rfc2898#appendix-B.1" rel="nofollow noreferrer">this section</a> of the document).</li>
</ul>
<p>Example implementation in Python, using SHA-256 as the secure hash:</p>
<p><strong>EDIT</strong>: as mentioned by Eli Collins this is not a PBKDF2 implementation. You should prefer implementations which stick to the standard, such as <a href="http://packages.python.org/passlib/" rel="nofollow noreferrer">PassLib</a>.</p>
<pre><code>from hashlib import sha256
from hmac import HMAC
import random

def random_bytes(num_bytes):
  return "".join(chr(random.randrange(256)) for i in xrange(num_bytes))

def pbkdf_sha256(password, salt, iterations):
  result = password
  for i in xrange(iterations):
    result = HMAC(result, salt, sha256).digest() # use HMAC to apply the salt
  return result

NUM_ITERATIONS = 5000
def hash_password(plain_password):
  salt = random_bytes(8) # 64 bits

  hashed_password = pbkdf_sha256(plain_password, salt, NUM_ITERATIONS)

  # return the salt and hashed password, encoded in base64 and split with ","
  return salt.encode("base64").strip() + "," + hashed_password.encode("base64").strip()

def check_password(saved_password_entry, plain_password):
  salt, hashed_password = saved_password_entry.split(",")
  salt = salt.decode("base64")
  hashed_password = hashed_password.decode("base64")

  return hashed_password == pbkdf_sha256(plain_password, salt, NUM_ITERATIONS)

password_entry = hash_password("mysecret")
print password_entry # will print, for example: 8Y1ZO8Y1pi4=,r7Acg5iRiZ/x4QwFLhPMjASESxesoIcdJRSDkqWYfaA=
check_password(password_entry, "mysecret") # returns True
</code></pre>
</div></text><author><a href="/users/37020/orip">orip</a></author><comments><comment><text><span class="comment-copy">I've always understood that hashing a hash is not something you should do, as the possibility of hash collision increase with each iteration. But does this hash(salt+hash) circumvent this? The amount of characters aren't all that many, after all...</span></text><author><a class="comment-user" href="/users/2238/henrik-paul" title="37,050 reputation">Henrik Paul</a></author></comment><comment><text><span class="comment-copy">You're right, re-hashing may reduce the search space (salt doesn't help), but this is irrelevant for password-based cryptography.  To reach the 256-bit search space of this hash you'd need a completely random password, 40 characters long, from all available keyboard characters (log2(94^40)).</span></text><author><a class="comment-user" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">People should be aware that this code does NOT implement the PBKDF2 algorithm; but rather is a non-standard variation of the older PBKDF1 function, modified to use a PRF (HMAC-SHA256 in this case). See <a href="http://tools.ietf.org/html/rfc2898#page-9" rel="nofollow noreferrer">rfc2898</a> for the reference implementation of both kdfs. While this algorithm is probably not insecure, it's not byte-compatible with either PBKDF1 or PBKDF2, nor has it's exact behavior been given the same security review - I'm concerned with the fact that it applies HMAC to a fixed salt, and varys the password instead - this may weaken HMAC.</span></text><author><a class="comment-user" href="/users/681277/eli-collins" title="5,219 reputation">Eli Collins</a></author></comment><comment><text><span class="comment-copy">@Eli: Not completely disagreeing, since PBKDF2 creates keys of arbitrary length and this code doesn't. This has no meaning, of course, in a password-security scheme. But the &lt;a href="<a href="http://tools.ietf.org/html/rfc2898#appendix-B.1.1%22%3Etext" rel="nofollow noreferrer">tools.ietf.org/html/rfc2898#appendix-B.1.1"&gt;text</a> in the rfc you linked to&lt;/a&gt; explicitly mentions using the password as HMAC's "key" and the salt as HMAC's "text", which is - by intention - what this example code does.</span></text><author><a class="comment-user" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">@orip: Cryptography is not something where <i>close enough</i> is usually a good idea; especially if people mistake this for a PBKDF2 implementation, only to find out later that the output doesn't match existing code/data. It's true, if code's the salt/password flaw were fixed, it would be more in line with the appendix, but that's only describing how to use HMAC <i>in</i> PBKDF2; not how PBKDf2 works. Aside from omitting the variable-keylen portion, the most important issue is that the code above completely omits the XOR part of the F() function in PBKDF2 - which is central to it's preimage resistance.</span></text><author><a class="comment-user" href="/users/681277/eli-collins" title="5,219 reputation">Eli Collins</a></author></comment><comment><text><span class="comment-copy">Just to add - for most algorithm discussions, individual implementations can vary, so long as they achieve the desired effect. But PBKDf2 is a carefully designed algorithm, with <a href="http://tools.ietf.org/html/rfc6070" rel="nofollow noreferrer">test vectors</a> specifying the exact behavior; and it's in a problem space where slight changes can mean serious decreases in security. In most other cases, I wouldn't have thought any of this even worth mentioning :)</span></text><author><a class="comment-user" href="/users/681277/eli-collins" title="5,219 reputation">Eli Collins</a></author></comment><comment><text><span class="comment-copy">@Eli - I agree.</span></text><author><a class="comment-user" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The basic strategy is to use a key derivation function to "hash" the password with some salt. The salt and the hash result are stored in the database. When a user inputs a password, the salt and their input are hashed in the same way and compared to the stored value. If they match, the user is authenticated.</p>
<p>The devil is in the details. First, a lot depends on the hash algorithm that is chosen. A key derivation algorithm like PBKDF2, based on a hash-based message authentication code, makes it "computationally infeasible" to find an input (in this case, a password) that will produce a given output (what an attacker has found in the database). </p>
<p>A pre-computed dictionary attack uses pre-computed index, or dictionary, from hash outputs to passwords. Hashing is slow (or it's supposed to be, anyway), so the attacker hashes all of the likely passwords once, and stores the result indexed in such a way that given a hash, he can lookup a corresponding password. This is a classic tradeoff of space for time. Since password lists can be huge, there are ways to tune the tradeoff (like rainbow tables), so that an attacker can give up a little speed to save a lot of space.</p>
<p>Pre-computation attacks are thwarted by using "cryptographic salt". This is some data that is hashed with the password. <strong>It doesn't need to be a secret,</strong> it just needs to be unpredictable for a given password. For each value of salt, an attacker would need a new dictionary. If you use one byte of salt, an attacker needs 256 copies of their dictionary, each generated with a different salt. First, he'd use the salt to lookup the correct dictionary, then he'd use the hash output to look up a usable password. But what if you add 4 bytes? Now he needs 4 billion copies of the the dictionary. By using a large enough salt, a dictionary attack is precluded. In practice, 8 to 16 bytes of data from a cryptographic quality random number generator makes a good salt.</p>
<p>With pre-computation off the table, an attacker has compute the hash on each attempt. How long it takes to find a password now depends entirely on how long it takes to hash a candidate. This time is increased by iteration of the hash function. The number iterations is generally a parameter of the key derivation function; today, a lot of mobile devices use 10,000 to 20,000 iterations, while a server might use 100,000 or more. (The bcrypt algorithm uses the term "cost factor", which is a logarithmic measure of the time required.)</p>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">As far as hash generation supposed to be slow - that depends on the use of the hash.  For password storage, thats a desirable quality.  For message authentication, it may not be (particularly if the messages being authenticated are network packets).</span></text><author><a class="comment-user" href="/users/12711/michael-burr" title="252,148 reputation">Michael Burr</a></author></comment><comment><text><span class="comment-copy">Good point; slowness is important for protecting against an offline attack. In a network protocol, a man-in-the-middle probably wouldn't have time to find a collision even with a very fast hash, as long as it wasn't broken.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">A well-worded explanation of password encryption and terms, thanks.</span></text><author><a class="comment-user" href="/users/161052/jyelton" title="21,424 reputation">JYelton</a></author></comment><comment><text><span class="comment-copy">+1 for bcrypt...</span></text><author><a class="comment-user" href="/users/69993/kzqai" title="12,386 reputation">Kzqai</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Follow <a href="http://stackoverflow.com/questions/287517/encrypting-plain-text-passwords-in-database#287538">Xan's advice</a> of keeping the current password column around for a while so if things go bad, you can rollback quick-n-easy.</p>
<p>As far as encrypting your passwords:</p>
<ul>
<li>use a salt</li>
<li>use a hash algorithm that's meant for passwords (ie., - it's <em>slow</em>)</li>
</ul>
<p>See Thomas Ptacek's <a href="http://www.securityfocus.com/blogs/262" rel="nofollow noreferrer">Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</a> for some details.</p>
</div></text><author><a href="/users/12711/michael-burr">Michael Burr</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I think you should do the following:</p>
<ol>
<li>Create a new column called HASHED_PASSWORD or something similar.</li>
<li>Modify your code so that it checks for both columns.</li>
<li>Gradually migrate passwords from the non-hashed table to the hashed one. For example, when a user logs in, migrate his or her password automatically to the hashed column and remove the unhashed version. All newly registered users will have hashed passwords.</li>
<li>After hours, you can run a script which migrates n users a time</li>
<li>When you have no more unhashed passwords left, you can remove your old password column (you may not be able to do so, depends on the database you are using). Also, you can remove the code to handle the old passwords.</li>
<li>You're done!</li>
</ol>
</div></text><author><a href="/users/8954/tamas-czinege">Tamas Czinege</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>That was a problem of mine couple of weeks ago.
We were deploying a large MIS project to 975 different geographical locations where our own user credential store will be used as an authenticator for different set of already implemented and in-use applications. We already provided both REST and SOAP based authentication service but customer insisted to be able to reach the user credential store from other applications with just a a DB connection to read-only view of related table or view. Sigh... <em>(this highly coupled bad design decision is a subject of another question).</em></p>
<p>That forced us to sit and convert our salted and iteratively hashed password storage scheme to a specification and provide some different language implementations for easy integration.</p>
<p>We called it Fairly Secure Hashed Passwords or <a href="http://github.com/bdd/fshp" rel="nofollow noreferrer">FSHP</a> in short.
Implemented it in Python, Ruby, PHP5 and released it to Public Domain. Available to be consumed, forked, flamed or spit on GitHub at <a href="http://github.com/bdd/fshp" rel="nofollow noreferrer">http://github.com/bdd/fshp</a></p>
<p>FSHP is a salted, iteratively hashed password hashing implementation.</p>
<p>Design principle is similar with <a href="http://www.faqs.org/rfcs/rfc2898.html" rel="nofollow noreferrer">PBKDF1</a> specification in RFC 2898 
<em>(a.k.a: PKCS #5: Password-Based Cryptography Specification Version 2.0.)</em>
FSHP allows choosing the salt length, number of iterations and the
underlying cryptographic hash function among SHA-1 and SHA-2 (256, 384, 512).
Self defining meta prefix at the beginning of every output makes it portable while letting the consumer to choose its own password storage security baseline.</p>
<p><strong>SECURITY</strong>:</p>
<p>Default FSHP1 uses 8 byte salts, with 4096 iterations of SHA-256 hashing.
  - 8 byte salt renders rainbow table attacks impractical by multiplying the
    required space with 2^64.
  - 4096 iterations causes brute force attacks to be fairly expensive.
  - There are no known attacks against SHA-256 to find collisions with
    a computational effort of fewer than 2^128 operations at the time of
    this release.</p>
<p><strong>IMPLEMENTATIONS:</strong></p>
<ul>
<li>Python: Tested with 2.3.5 (w/ hashlib), 2.5.1, 2.6.1</li>
<li>Ruby  : Tested with 1.8.6</li>
<li>PHP5  : Tested with 5.2.6</li>
</ul>
<p>Everyone is more than welcome to create missing language implementations or
polish the current ones.</p>
<p><strong>BASIC OPERATION <em>(with Python)</em>:</strong></p>
<pre><code>&gt;&gt;&gt; fsh = fshp.crypt('OrpheanBeholderScryDoubt')
&gt;&gt;&gt; print fsh
{FSHP1|8|4096}GVSUFDAjdh0vBosn1GUhzGLHP7BmkbCZVH/3TQqGIjADXpc+6NCg3g==
&gt;&gt;&gt; fshp.validate('OrpheanBeholderScryDoubt', fsh)
True
</code></pre>
<p><strong>CUSTOMIZING THE CRYPT:</strong></p>
<p>Let's weaken our password hashing scheme.
  - Decrease the salt length from default 8 to 2.
  - Decrease the iteration round from default 4096 to 10.
  - Select FSHP0 with SHA-1 as the underlying hash algorithm.</p>
<pre><code>&gt;&gt;&gt; fsh = fshp.crypt('ExecuteOrder66', saltlen=2, rounds=10, variant=0)
&gt;&gt;&gt; print fsh
{FSHP0|2|10}Nge7yRT/vueEGVFPIxcDjiaHQGFQaQ==
</code></pre>
</div></text><author><a href="/users/49709/berk-d-demir">Berk D. Demir</a></author><comments><comment><text><span class="comment-copy">That's pretty cool! It would be nice not to specify the variant as a magic number though.</span></text><author><a class="comment-user" href="/users/37020/orip" title="40,336 reputation">orip</a></author></comment><comment><text><span class="comment-copy">actually it's more than an algo map. at the time of this release, all variants are PBKDF1 implementations and only differ with hash algo (0:SHA1, 1:SHA256, 2:SHA384, 3:SHA512) but to be forward compatible, I picked it as an integer. so it's not a magic number but tastes like it. you're right.</span></text><author><a class="comment-user" href="/users/49709/berk-d-demir" title="3,837 reputation">Berk D. Demir</a></author></comment><comment><text><span class="comment-copy">I want to keep FSHP as a viable option and update it as the time mandates security wise. Maybe variants 4, 5 &amp; 6 will be PBKDF2 with SHA256,384,512 algorithms. That's an example of course. :)</span></text><author><a class="comment-user" href="/users/49709/berk-d-demir" title="3,837 reputation">Berk D. Demir</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As the others mentioned, you don't want to decrypt if you can help it. Standard best practice is to encrypt using a one-way hash, and then when the user logs in hash their password to compare it.</p>
<p>Otherwise you'll have to use a strong encryption to encrypt and then decrypt. I'd only recommend this if the political reasons are strong (for example, your users are used to being able to call the help desk to retrieve their password, and you have strong pressure from the top not to change that). In that case, I'd start with encryption and then start building a business case to move to hashing. </p>
</div></text><author><a href="/users/4083/cory-foy">Cory Foy</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>For authentication purposes you should avoid storing the passwords using reversible encryption, i.e. you should only store the password hash and check the hash of the user-supplied password against the hash you have stored. However, that approach has a drawback: it's vulnerable to <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="nofollow noreferrer">rainbow table</a> attacks, should an attacker get hold of your password store database.</p>
<p>What you should do is store the hashes of a pre-chosen (and secret) salt value + the password. I.e., concatenate the salt and the password, hash the result, and store this hash. When authenticating, do the same - concatenate your salt value and the user-supplied password, hash, then check for equality. This makes rainbow table attacks unfeasible.</p>
<p>Of course, if the user send passwords across the network (for example, if you're working on a web or client-server application), then you should not send the password in clear text across, so instead of storing hash(salt + password) you should store and check against hash(salt + hash(password)), and have your client pre-hash the user-supplied password and send that one across the network. This protects your user's password as well, should the user (as many do) re-use the same password for multiple purposes.</p>
</div></text><author><a href="/users/14444/mihai-limb%c4%83%c8%99an">Mihai Limbășan</a></author><comments><comment><text><span class="comment-copy">Salt does not need to be secret, and it's burdensome to keep its secrecy.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">Also, to be clear - the salt should be <i>different</i> and <i>random</i> for each instance.  Not pre-chosen once and used for all hashes.</span></text><author><a class="comment-user" href="/users/12711/michael-burr" title="252,148 reputation">Michael Burr</a></author></comment><comment><text><span class="comment-copy">Mike is of course right in principle, however it's not always possible to change the salt every time (depending on the app specifics), in which case the salt must be kept secret.</span></text><author><a class="comment-user" href="/users/14444/mihai-limb%c4%83%c8%99an" title="32,247 reputation">Mihai Limbășan</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<ul>
<li>Encrypt using something like MD5, encode it as a hex string</li>
<li>You need a salt; in your case, the username can be used as the salt (it has to be unique, the username should be the most unique value available ;-)</li>
<li>use the old password field to store the MD5, but tag the MD5 (i.e.g "MD5:687A878....") so that old (plain text) and new (MD5) passwords can co-exist</li>
<li>change the login procedure to verify against the MD5 if there is an MD5, and against the plain password otherwise</li>
<li>change the "change password" and "new user" functions to create MD5'ed passwords only</li>
<li>now you can run the conversion batch job, which might take as long as needed</li>
<li>after the conversion has been run, remove the legacy-support</li>
</ul>
</div></text><author><a href="/users/8015/mfx">mfx</a></author><comments><comment><text><span class="comment-copy">It's also common to use a random salt for each user and store it alongside the hashed password.</span></text><author><a class="comment-user" href="/users/29/michael-haren" title="63,779 reputation">Michael Haren</a></author></comment><comment><text><span class="comment-copy">Something that is unknown to the user would make a more secure salt.  Perhaps an internal userID or, as Michael suggested, a specially created salt value.  If you're using a publicly available unique salt, like username, you should probably also salt with a constant just for good measure.</span></text><author><a class="comment-user" href="/users/10861/rmeador" title="18,301 reputation">rmeador</a></author></comment><comment><text><span class="comment-copy">As i understand it, salting has the purpose to prevent dictionary attacks (pre-computing the hashes of a popular passwords and comparing users to them). The salt is always visible, it is not a secret. So why not use the user name, since it is already known, and guaranteed to be unique?</span></text><author><a class="comment-user" href="/users/8015/mfx" title="5,459 reputation">mfx</a></author></comment><comment><text><span class="comment-copy">User name is not a bad salt, if you consider a single system. But it would probably be worthwhile for attacker like a repressive government to make dictionaries for the most common user names to increase their chances of breaking into multiple sites. It's better to choose and store a random salt.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">-1 for the fast hash that is md5.</span></text><author><a class="comment-user" href="/users/69993/kzqai" title="12,386 reputation">Kzqai</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Step 1: Add encrypted field to database</p>
<p>Step 2: Change code so that when password is changed, it updates both fields but logging in still uses old field.</p>
<p>Step 3: Run script to populate all the new fields.</p>
<p>Step 4: Change code so that logging in uses new field and changing passwords stops updating old field.</p>
<p>Step 5: Remove unencrypted passwords from database.</p>
<p>This should allow you to accomplish the changeover without interruption to the end user.</p>
<p>Also: 
Something I would do is name the new database field something that is completely unrelated to password like "LastSessionID" or something similarly boring. Then instead of removing the password field, just populate with hashes of random data.  Then, if your database ever gets compromised, they can spend all the time they want trying to decrypt the "password" field.</p>
<p>This may not actually accomplish anything, but it's fun thinking about someone sitting there trying to figure out worthless information</p>
</div></text><author><a href="/users/19038/kevin">Kevin</a></author><comments><comment><text><span class="comment-copy">Good point about Step 2 being needed early in the process. I share your enjoyment of the dummy password field too :)</span></text><author><a class="comment-user" href="/users/65703/kristen" title="2,968 reputation">Kristen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As with all security decisions, there are tradeoffs.  If you hash the password, which is probably your easiest move, you can't offer a password retrieval function that returns the original password, nor can your staff look up a person's password in order to access their account.</p>
<p>You can use symmetric encryption, which has its own security drawbacks.  (If your server is compromised, the symmetric encryption key may be compromised also).</p>
<p>You can use public-key encryption, and run password retrieval/customer service on a separate machine which stores the private key in isolation from the web application.  This is the most secure, but requires a two-machine architecture, and probably a firewall in between.</p>
</div></text><author><a href="/users/36754/davidcl">davidcl</a></author><comments><comment><text><span class="comment-copy">Inability of staff to look up a user's password is a feature, not a drawback. Support of password retrieval isn't a tradeoff, it's a surrender.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">I think that's an unfortunately absolutist position to take on this.  It really depends on the security value of the information protected by that password.</span></text><author><a class="comment-user" href="/users/36754/davidcl" title="924 reputation">davidcl</a></author></comment><comment><text><span class="comment-copy">It also depends further on the size and trustworthiness of the staff in question.  Password lookup makes much more sense in a small organization than in a large one.</span></text><author><a class="comment-user" href="/users/36754/davidcl" title="924 reputation">davidcl</a></author></comment><comment><text><span class="comment-copy">You never know what a given password protects; expect users to reuse passwords for their bank on your toy web app. Even if your staff is trustworthy (even if it's just YOU), you can't rule out the possibility of an external attacker getting at your password database.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">If staff has a legitimate need to access another user's account, that capability should be built into the system without the staff needing to log in as the user.  And the perceived need for a 'password retrieval' system can be replaced by a 'password reset' system.</span></text><author><a class="comment-user" href="/users/12711/michael-burr" title="252,148 reputation">Michael Burr</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm not a security expert, but i htink the current recommendation is to use bcrypt/blowfish or a SHA-2 variant, not MD5 / SHA1.  </p>
<p>Probably you need to think in terms of a full security audit, too</p>
</div></text><author><a href="/users/413049/gene-t">Gene T</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>MD5 and SHA1 have shown a bit of weakness (two words can result in the same hash) so using SHA256-SHA512 / iterative hashes is recommended to hash the password.</p>
<p>I would write a small program in the language that the application is written in that goes and generates a random salt that is unique for each user and a hash of the password. The reason I tend to use the same language as the verification is that different crypto libraries can do things slightly differently (i.e. padding) so using the same library to generate the hash and verify it eliminates that risk. This application could also then verify the login after the table has been updated if you want as it knows the plain text password still. </p>
<ol>
<li>Don't use MD5/SHA1</li>
<li>Generate a good random salt (many crypto libraries have a salt generator)</li>
<li>An iterative hash algorithm as orip recommended</li>
<li>Ensure that the passwords are not transmitted in plain text over the wire</li>
</ol>
</div></text><author><a href="/users/37723/kudos2u2">Kudos2u2</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would like to suggest one improvement to <a href="http://stackoverflow.com/questions/287517/encrypting-hashing-plain-text-passwords-in-database/287883#287883">the great python example posted by Orip</a>. I would redefine the <code>random_bytes</code> function to be:</p>
<pre><code>def random_bytes(num_bytes):
    return os.urandom(num_bytes)
</code></pre>
<p>Of course, you would have to import the <code>os</code> module. The <code>os.urandom</code> function provides a random sequence of bytes that can be safely used in cryptographic applications. See <a href="http://docs.python.org/library/os.html#os.urandom" rel="nofollow noreferrer">the reference help of this function</a> for further details.</p>
</div></text><author><a href="/users/94484/sergio">Sergio</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>To hash the password you can use the <a href="http://msdn.microsoft.com/en-us/library/ms174415.aspx" rel="nofollow noreferrer">HashBytes</a> function. Returns a varbinary, so you'd have to create a new column and then delete the old varchar one.</p>
<p>Like</p>
<pre><code>ALTER TABLE users ADD COLUMN hashedPassword varbinary(max);
ALTER TABLE users ADD COLUMN salt char(10);
--Generate random salts and update the column, after that
UPDATE users SET hashedPassword = HashBytes('SHA1',salt + '|' + password);
</code></pre>
<p>Then you modify the code to validate the password, using a query like</p>
<pre><code>SELECT count(*) from users WHERE hashedPassword = 
HashBytes('SHA1',salt + '|' + &lt;password&gt;)
</code></pre>
<p>where &lt;password&gt; is the value entered by the user.</p>
</div></text><author><a href="/users/5190/vinko-vrsalovic">Vinko Vrsalovic</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>hash them with md5. that's what is usually done with passwords.</p>
</div></text><author><a href="/users/31345/mladen-prajdic">Mladen Prajdic</a></author><comments><comment><text><span class="comment-copy">md5 &amp; sha-1 have both been proven broken and should not be used</span></text><author><a class="comment-user" href="/users/33226/gavin-miller" title="30,401 reputation">Gavin Miller</a></author></comment><comment><text><span class="comment-copy">The problem with MD5 and SHA1 for hashing passwords is not that they're 'broken' - it's that they hash too fast: <a href="http://www.securityfocus.com/blogs/262" rel="nofollow noreferrer">securityfocus.com/blogs/262</a></span></text><author><a class="comment-user" href="/users/12711/michael-burr" title="252,148 reputation">Michael Burr</a></author></comment><comment><text><span class="comment-copy">@Mike - No they're actually broken.  It's been proven that collisions can be generated with either algorithm: <a href="http://www.schneier.com/blog/archives/2005/06/more_md5_collis.html" rel="nofollow noreferrer">schneier.com/blog/archives/2005/06/more_md5_collis.html</a> <a href="http://www.schneier.com/blog/archives/2005/02/sha1_broken.html" rel="nofollow noreferrer">schneier.com/blog/archives/2005/02/sha1_broken.html</a></span></text><author><a class="comment-user" href="/users/33226/gavin-miller" title="30,401 reputation">Gavin Miller</a></author></comment><comment><text><span class="comment-copy">Those collisions don't really reduce the security of the password scheme, particularly given that one will be using a salt.</span></text><author><a class="comment-user" href="/users/21640/marcin" title="31,583 reputation">Marcin</a></author></comment></comments></answer></answers></post>