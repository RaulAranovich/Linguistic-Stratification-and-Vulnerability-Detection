<?xml version="1.0" encoding="utf-8"?>
<post><title>php - How to hash long passwords (&gt;72 characters) with blowfish - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>The last week I read a lot articles about password hashing and Blowfish seems to be (one of) the best hashing algorithm right now - but that's not the topic of this question!</p>
<h1>The 72 character limit</h1>
<p>Blowfish only consider the first 72 characters in the entered password:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
$password </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Wow. This is a super secret and super, super long password. Let's add some special ch4r4ct3rs a#d everything is fine :)"</span><span class="pun">;</span><span class="pln">
$hash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> PASSWORD_BCRYPT</span><span class="pun">);</span><span class="pln">
var_dump</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">);</span><span class="pln">

$input </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">72</span><span class="pun">);</span><span class="pln">
var_dump</span><span class="pun">(</span><span class="pln">$input</span><span class="pun">);</span><span class="pln">

var_dump</span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="pln">$input</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">));</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
<p>The output is:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">string</span><span class="pun">(</span><span class="lit">119</span><span class="pun">)</span><span class="pln"> </span><span class="str">"Wow. This is a super secret and super, super long password. Let's add some special ch4r4ct3rs a#d everything is fine :)"</span><span class="pln">
</span><span class="kwd">string</span><span class="pun">(</span><span class="lit">72</span><span class="pun">)</span><span class="pln"> </span><span class="str">"Wow. This is a super secret and super, super long password. Let's add so"</span><span class="pln">
</span><span class="kwd">bool</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span></code></pre>
<p>As you can see only the first 72 characters matter. Twitter is using blowfish aka bcrypt to store their passwords (<a href="https://shouldichangemypassword.com/twitter-hacked.php" rel="nofollow noreferrer">https://shouldichangemypassword.com/twitter-hacked.php</a>) and guess what: change your twitter password to a long password with more than 72 characters and you can login to your account by entering only the first 72 characters.</p>
<h1>Blowfish and Pepper</h1>
<p>There are a lot different opinions about "peppering" passwords. Some people say it's unnecessary, because you have to assume that the secret pepper-string is also known/published so it doesn't enhance the hash. I have a separate database server so it's quite possible that only the database is leaked and not the constant pepper.</p>
<p>In this case (pepper not leaked) you make an attack based on a dictionary more difficult (correct me if this isn't right). If your pepper-string is also leaked: not that bad - you still have the salt and it's as good protected as a hash without pepper.  </p>
<p>So I think peppering the password is at least no bad choice.</p>
<h1>Suggestion</h1>
<p>My suggestion to get a Blowfish hash for a password with more than 72 characters (and pepper) is:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
$pepper </span><span class="pun">=</span><span class="pln"> </span><span class="str">"foIwUVmkKGrGucNJMOkxkvcQ79iPNzP5OKlbIdGPCMTjJcDYnR"</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Generate Hash</span><span class="pln">
$password </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Wow. This is a super secret and super, super long password. Let's add some special ch4r4ct3rs a#d everything is fine :)"</span><span class="pun">;</span><span class="pln">
$password_peppered </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">,</span><span class="pln"> $pepper</span><span class="pun">);</span><span class="pln">
$hash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$password_peppered</span><span class="pun">,</span><span class="pln"> PASSWORD_BCRYPT</span><span class="pun">);</span><span class="pln">

</span><span class="com">// Check</span><span class="pln">
$input </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">72</span><span class="pun">);</span><span class="pln">
$input_peppered </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $input</span><span class="pun">,</span><span class="pln"> $pepper</span><span class="pun">);</span><span class="pln">

var_dump</span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="pln">$input_peppered</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">));</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
<p>This is based on <a href="https://security.stackexchange.com/questions/21263/how-to-apply-a-pepper-correctly-to-bcrypt">this question</a>: <code>password_verify</code> return <code>false</code>.  </p>
<h1>The Question</h1>
<p>What is the safer way? Getting an SHA-256 hash first (which returns 64 characters) or consider only the first 72 characters of the password?  </p>
<h2>Pros</h2>
<ul>
<li>The user can't login by entering just the first 72 characters</li>
<li>You can add the pepper without exceeding the character-limit</li>
<li>The output of hash_hmac would probably have more entropy than the password itself</li>
<li>The password is hashed by two different functions</li>
</ul>
<h2>Cons</h2>
<ul>
<li>Only 64 characters are used to build the blowfish hash</li>
</ul>
<p><br/></p>
<p><strong>Edit 1:</strong> This question adresses only the PHP integration of blowfish/bcrypt. Thank's for the comments!</p>
</div></text><author><a href="/users/-1/community">Community</a></author><comments><comment><text><span class="comment-copy">Blowfish is not the only one that truncates the password, misleading people to think it's safer than it actually is. Here's an <a href="http://security.stackexchange.com/questions/33470/what-technical-reasons-are-there-to-have-low-maximum-password-lengths">interesting history of the 8-character limit.</a></span></text><author><a class="comment-user" href="/users/27637/dok" title="25,814 reputation">DOK</a></author></comment><comment><text><span class="comment-copy">Is the 72-character truncation fundamental to the Blowfish algorithm, or just the PHP implementation? IIRC Blowfish is also used on (at least some) 'nixes to encrypt the user passwords.</span></text><author><a class="comment-user" href="/users/1655144/douglas-b-staple" title="4,438 reputation">Douglas B. Staple</a></author></comment><comment><text><span class="comment-copy">The issue is with Bcrypt, not Blowfish. I can reproduce this problem with Python and Bcrypt alone.</span></text><author><a class="comment-user" href="/users/464744/blender" title="165,758 reputation">Blender</a></author></comment><comment><text><span class="comment-copy">@Blender: Thank's for your comment and your work on it. I couldn't find different functions in php for blowfish and bcrypt and though they are the same. But does't it make any difference for me in php? I would prefer to use the standard php function.</span></text><author><a class="comment-user owner" href="/users/555274/frederik-kammer" title="1,431 reputation">Frederik Kammer</a></author></comment><comment><text><span class="comment-copy">Douglas, yes, the 72-character limit is fundamental to BCrypt. You could extend it (Extended DES crypt do this vs. Standard DES for instance) but it would be nonstandard.</span></text><author><a class="comment-user" href="/users/585271/zer" title="1,479 reputation">Zer</a></author></comment><comment><text><span class="comment-copy">Also see Openwall's <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">PHP password hashing framework</a> (PHPass). Its portable and hardened against a number of common attacks on user passwords. The guy who wrote the framework (SolarDesigner) is the same guy who wrote <a href="http://www.openwall.com/john/" rel="nofollow noreferrer">John The Ripper</a> and sits as a judge in the <a href="http://password-hashing.net/" rel="nofollow noreferrer">Password Hashing Competition</a>. So he knows a thing or two about attacks on passwords.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">Bcrypt uses the Blowfish algorithm to hash passwords.  Therefore you can't use bcrypt in isolation of Blowfish.</span></text><author><a class="comment-user" href="/users/5048621/phil" title="387 reputation">Phil</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The problem here is basically a problem of entropy. So let's start looking there:</p>
<h2>Entropy Per Character</h2>
<p>The number of bits of entropy per byte are:</p>
<ul>
<li><em>Hex Characters</em>
<ul>
<li>Bits:   4</li>
<li>Values: 16</li>
<li>Entropy In 72 Chars: 288 bits</li>
</ul></li>
<li><em>Alpha-Numeric</em>
<ul>
<li>Bits: 6</li>
<li>Values: 62</li>
<li>Entropy In 72 Chars: 432 bits</li>
</ul></li>
<li><em>"Common" Symbols</em>
<ul>
<li>Bits: 6.5</li>
<li>Values: 94</li>
<li>Entropy In 72 Chars: 468 bits</li>
</ul></li>
<li><em>Full Bytes</em>
<ul>
<li>Bits: 8</li>
<li>Values: 255</li>
<li>Entropy In 72 Chars: 576 bits</li>
</ul></li>
</ul>
<p>So, how we act depends on what type of characters we expect.</p>
<h2>The First Problem</h2>
<p>The first problem with your code, is that your <em>"pepper"</em> hash step is outputting hex characters (since the fourth parameter to <code>hash_hmac()</code> is not set). </p>
<p>Therefore, by hashing your pepper in, you're effectively cutting the maximum entropy available to the password by a factor of 2 (from 576 to 288 <em>possible</em> bits).</p>
<h2>The Second Problem</h2>
<p>However, <code>sha256</code> only provides <code>256</code> bits of entropy in the first place. So you're effectively cutting a possible 576 bits down to 256 bits. Your hash step * immediately*, by very definition loses 
<strong>at least</strong> 50% of the <em>possible</em> entropy in the password. </p>
<p>You could partially solve this by switching to <code>SHA512</code>, where you'd only reduce the available entropy by about 12%. But that's still a not-insignificant difference. That 12% reduces the number of permutations by a factor of <code>1.8e19</code>. That's a big number... And that's the <strong>factor</strong> it reduces it by... </p>
<h1>The Underlying Issue</h1>
<p>The underlying issue is that there are three types of passwords over 72 characters. The impact that this style system has on them will be very different:</p>
<p>Note: from here on out I'm assuming we're comparing to a pepper system which uses <code>SHA512</code> with raw output (not hex).</p>
<ul>
<li><p>High entropy random passwords</p>
<p>These are your users using password generators which generate what amount to large keys for passwords. They are random (generated, not human chosen), and have high entropy per character. These types are using high-bytes (characters &gt; 127) and some control characters.</p>
<p>For this group, your hashing function will <strong>significantly</strong> reduce their available entropy into <code>bcrypt</code>. </p>
<p>Let me say that again. For users who are using high entropy, long passwords, your solution <em>significantly</em> reduces the strength of their password by a measurable amount. (62 bits of entropy lost for a 72 character password, and more for longer passwords)</p></li>
<li><p>Medium entropy random passwords</p>
<p>This group is using passwords containing common symbols, but no high bytes or control characters. These are your typable passwords.</p>
<p>For this group, you are going to <em>slightly</em> unlock more entropy (not create it, but allow more entropy to fit into the bcrypt password).  When I say slightly, I mean slightly. The break-even occurs when you max out the 512 bits that SHA512 has. Therefore, the peak is at 78 characters. </p>
<p>Let me say that again. For this class of passwords, you can only store an additional 6 characters before you run out of entropy.</p></li>
<li><p>Low entropy non-random passwords</p>
<p>This is the group who are using alpha-numeric characters that are probably not randomly generated. Something like a bible quote or such. These phrases have approximately 2.3 bits of entropy per character. </p>
<p>For this group, you can significantly unlock more entropy (not create it, but allow more to fit into the bcrypt password input) by hashing. The breakeven is around 223 characters before you run out of entropy.</p>
<p>Let's say that again. For this class of passwords, pre-hashing definitely increases security significantly.</p></li>
</ul>
<h1>Back To The Real World</h1>
<p>These kinds of entropy calculations don't really matter much in the real world. What matters is guessing entropy. That's what directly effects what attackers can do. That's what you want to maximize.</p>
<p>While there's little research that's gone into guessing entropy, there are some points that I'd like to point out.</p>
<p>The chances of randomly guessing 72 correct characters in a row are <strong>extremely</strong> low. You're more likely to win the Powerball lottery 21 times, than to have this collision... That's how big of a number we're talking about.</p>
<p>But we may not stumble on it statistically. In the case of phrases the chance of the first 72 characters being the same is a whole lot higher than for a random password. But it's still trivially low (you're more likely to win the Powerball lottery 5 times, based on 2.3 bits per character).</p>
<h1>Practically</h1>
<p>Practically, it doesn't really matter. The chances of someone guessing the first 72 characters right, where the latter ones make a significant difference are so low that it's not worth worrying about. Why?</p>
<p>Well, let's say you're taking a phrase. If the person can get the first 72 characters right, they are either <strong>really</strong> lucky (not likely), or it's a common phrase. If it's a common phrase, the only variable is how long to make it. </p>
<p>Let's take an example. Let's take a quote from the bible (just because it's a common source of long text, not for any other reason):</p>
<blockquote>
<p>You shall not covet your neighbor’s house. You shall not covet your neighbor’s wife, or his manservant or maidservant, his ox or donkey, or anything that belongs to your neighbor.</p>
</blockquote>
<p>That's 180 characters. The 73rd character is the <code>g</code> in <code>neighbor's</code>. If you guessed that much, you're likely not stopping at <code>nei</code>, but continuing with the rest of the verse (since that's how the password is likely to be used). Therefore, your "hash" didn't add much.</p>
<p>BTW: I am ABSOLUTELY NOT advocating using a bible quote. In fact, the exact opposite.</p>
<h1>Conclusion</h1>
<p>You're not really going to help people much who use long passwords by hashing first. Some groups you can definitely help. Some you can definitely hurt. </p>
<p>But in the end, none of it is overly significant. The numbers we are dealing with are just <strong>WAY</strong> too high. The difference in entropy isn't going to be much.</p>
<p>You're better off leaving bcrypt as it is. You're more likely to screw up the hashing (literally, you've done it already, and you're not the first, or last to make that mistake) than the attack you're trying to prevent is going to happen. </p>
<p>Focus on securing the rest of the site. And add a password entropy meter to the password box on registration to indicate password strength (and indicate if a password is overlong that the user may wish to change it)...</p>
<p>That's my $0.02 at least (or possibly way more than $0.02)...</p>
<h1>As Far As Using A "Secret" Pepper:</h1>
<p>There is literally no research into feeding one hash function into bcrypt. Therefore, it's unclear at best if feeding a "peppered" hash into bcrypt will ever cause unknown vulnerabilities (we know doing <code>hash1(hash2($value))</code> can expose significant vulnerabilities around collision resistance and preimage attacks). </p>
<p>Considering that you're already considering storing a secret key (the "pepper"), why not use it in a way that's well studied and understood? Why not encrypt the hash prior to storing it?</p>
<p>Basically, after you hash the password, feed the entire hash output into a strong encryption algorithm. Then store the encrypted result. </p>
<p>Now, an SQL-Injection attack will not leak anything useful, because they don't have the cipher key. And if the key is leaked, the attackers are no better off than if you used a plain hash (which is provable, something with the pepper "pre-hash" doesn't provide).</p>
<p>Note: if you choose to do this, use a library. For PHP, I <strong>strongly</strong> recommend Zend Framework 2's <code>Zend\Crypt</code> package. It's actually the only one I'd recommend at this current point in time. It's been strongly reviewed, and it makes all the decisions for you (which is a very good thing)...</p>
<p>Something like:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">use</span><span class="pln"> </span><span class="typ">Zend</span><span class="pln">\Crypt\BlockCipher</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> createHash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $hash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> PASSWORD_BCRYPT</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="str">"cost"</span><span class="pun">=&gt;</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cost</span><span class="pun">]);</span><span class="pln">

    $blockCipher </span><span class="pun">=</span><span class="pln"> </span><span class="typ">BlockCipher</span><span class="pun">::</span><span class="pln">factory</span><span class="pun">(</span><span class="str">'mcrypt'</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="str">'algo'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">'aes'</span><span class="pun">));</span><span class="pln">
    $blockCipher</span><span class="pun">-&gt;</span><span class="pln">setKey</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">key</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $blockCipher</span><span class="pun">-&gt;</span><span class="pln">encrypt</span><span class="pun">(</span><span class="pln">$hash</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> verifyHash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $blockCipher </span><span class="pun">=</span><span class="pln"> </span><span class="typ">BlockCipher</span><span class="pun">::</span><span class="pln">factory</span><span class="pun">(</span><span class="str">'mcrypt'</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="str">'algo'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">'aes'</span><span class="pun">));</span><span class="pln">
    $blockCipher</span><span class="pun">-&gt;</span><span class="pln">setKey</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">key</span><span class="pun">);</span><span class="pln">
    $hash </span><span class="pun">=</span><span class="pln"> $blockCipher</span><span class="pun">-&gt;</span><span class="pln">decrypt</span><span class="pun">(</span><span class="pln">$hash</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> password_verify</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>And it's beneficial because you're using all of the algorithms in ways that are well understood and well studied (relatively at least). Remember:</p>
<blockquote>
<p>Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can't break.</p>
</blockquote>
<ul>
<li><a href="http://www.schneier.com/blog/archives/2011/04/schneiers_law.html" rel="noreferrer">Bruce Schneier</a></li>
</ul>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">Thank you very, very much for this detailed answer. This really helps me!</span></text><author><a class="comment-user owner" href="/users/555274/frederik-kammer" title="1,431 reputation">Frederik Kammer</a></author></comment><comment><text><span class="comment-copy">My compliment for this answer. One little nit-pick though, it's the big majority of users, that use very weak passwords, words and derivates contained in a dictionary for cracking passwords, a pepper would protect them independend of entrophy questions. To avoid loosing entrophy, you could just concatenate password and pepper. However your suggestion about encrypting the hash-value is probably the best solution to add a server-side secret.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli: My issue with the concept of <i>pepper</i> is not in the value of it. It's in that the application of the "pepper" goes into uncharted territory in terms of the cryptographic algorithms. That's not a good thing. Instead, I believe that cryptographic primitives should be combined in a way that they were designed to go together. Basically, the core concept of a pepper sounds to me in my ears like some people who knew nothing about cryptography said <i>"More hashes are better! We have salt, pepper is good too!"</i>. I'd just rather have a simpler, more tested and more straight forward impl</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell - Yes, i know your point of view and i agree, as long as the hash-values will be encrypted afterwards. If you do not take this additional step, a dictionary attack will simply reveal too many weak passwords, even with a good hash algorithm.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli: I disagree there. Storing of secrets is not a trivial thing to do. Instead, if you use bcrypt with a good cost (12 today), all but the weakest class of passwords are safe (dictionary, and trivial passwords are the weak ones). So I would rather recommend people focus on educating the user with <a href="http://arstechnica.com/security/2013/05/its-official-password-strength-meters-arent-security-theater/" rel="nofollow noreferrer">strength meters</a> and getting them to use better passwords in the first place...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell - The weakest class of passwords is not the rarest one. To judge whether a password would be cracked in a real dictionary attack, a strength meter would require a dictionary on its own. A leaking database is a real threat (SQL-injection, thrown away backups, discarded servers...), so adding a server-side secret is not an academic step, it helps even if the key is stored hardcoded somewhere. Your solution with encrypting the hash-value would have another advantage, it allows to exchange the key if necessary, i like this idea.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">I think you have to account for the possibility someone might need more than 72 characters. What if they to use the contents as a file for a key (grandma.jpg) and only the file header gets used? What if someones password gets compromised and (s)he only changes the last part of it? It would be better to throw an error if you don't want to support long passwords than to make silent assumptions like this.</span></text><author><a class="comment-user" href="/users/1547147/daan-bakker" title="3,154 reputation">Daan Bakker</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Peppering passwords is surely a good thing to do, but let's see why.</p>
<p>First we should answer the question when exactly a pepper helps. The pepper only protects the passwords, as long as it stays secret, so if an attacker has access to the server itself, it is of no use. A much easier attack though is SQL-injection, which allows read-access to the database (to our hash-values), i prepared a <a href="http://www.martinstoeckli.ch/hash/en/hash_sqlinjection.php" rel="nofollow">demo of SQL-injection</a> to show how easy it can be (click the next arrow to get a prepared input).</p>
<p>Then what does the pepper actually help? As long as the pepper stays secret, it protects weak passwords from a dictionary attack. The password <code>1234</code> would then become something like <code>1234-p*deDIUZeRweretWy+.O</code>. This password is not only much longer, it contains also special characters and will never be part of any dictionary.</p>
<p>Now we can estimate what passwords our users will use, probably more users will enter weak passwords, as there are users with passwords between 64-72 characters (actually this will be very rare).</p>
<p>Another point is the range for brute-forcing. The sha256 hash function will return 256 bits output or 1.2E77 combinations, that's ways too much for brute-forcing, even for GPU's (if i calculated correctly, this would need about <a href="http://hashcat.net/oclhashcat-lite/#performance" rel="nofollow">2E61 years</a> on a GPU in 2013). So we do not get a real disadvantage applying the pepper. Because the hash-values are not systematic you cannot speed up brute-forcing with common patterns.</p>
<p>P.S. As far as i know, the 72 character limit is specific to the algorithm of BCrypt itself. The best answer i found is <a href="http://stackoverflow.com/a/4772058/575765">this</a>.</p>
<p>P.P.S I think your example is flawed, you cannot generate the hash with the full password length, and verify it with a truncated one. You probably meant to apply the pepper the same way for generating the hash and for verification of the hash.</p>
</div></text><author><a href="/users/575765/martinstoeckli">martinstoeckli</a></author><comments><comment><text><span class="comment-copy">Regarding your P.P.S, i can just say: Yes, he can verify the truncated password with the hash of the non-truncated one and still get <code>true</code>. That's what this question is all about. Have a look yourself: <a href="http://viper-7.com/RLKFnB" rel="nofollow noreferrer">viper-7.com/RLKFnB</a></span></text><author><a class="comment-user" href="/users/1114320/sliq" title="7,257 reputation">Sliq</a></author></comment><comment><text><span class="comment-copy">@Panique - The problem is not the calculation of the BCrypt hash, it's the HMAC before. For generating the SHA hash, the OP uses the full length password and uses the result as input for BCrypt. For verification, he truncates the password before calculating the SHA hash, then uses this completely different result as input for BCrypt. The HMAC accepts input of any length.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Bcrypt uses an algorithm based on the expensive Blowfish key setup algorithm.</p>
<p>The recommended 56 byte password limit (including null termination byte) for bcrypt relates to the 448 bit limit of the Blowfish key.  Any bytes beyond that limit are not fully mixed into the resulting hash.  The 72 byte absolute limit on bcrypt passwords is therefore less relevant, when you consider the actual effect on the resulting hash by those bytes.</p>
<p>If you think your users would normally choose passwords over 55 bytes in length, remember you can always increase the rounds of password stretching instead, to increase security in the case of a password table breach (although this has to be a lot compared with adding extra characters).  If the access rights of users are so critical that users would normally require a massively long password, then the password expiry should also be short, like 2 weeks.  This means that a password is much less likely to be remain valid while a hacker invests their resources in defeating the work factor involved in testing each trial password to see if it will produce a matching hash.</p>
<p>Of course, in the case of the password table not being breached, we should only allow hackers, at most, ten attempts to guess a user's 55 byte password, before locking the user's account out ;)</p>
<p>If you do decide to pre-hash a password that is longer than 55 bytes, then you should use SHA-384, as it has the largest output without going over the limit.</p>
</div></text><author><a href="/users/5048621/phil">Phil</a></author><comments><comment><text><span class="comment-copy">"the password expiry should also be short, like 2 weeks" of "massively long password"s, really, why bother even saving the password then, just use password reset every time. Seriously, that is the wrong solution, move to two factor authentication with a token.</span></text><author><a class="comment-user" href="/users/451475/zaph" title="83,978 reputation">zaph</a></author></comment><comment><text><span class="comment-copy">Thanks @zaph.  Are you able to point me to an example of that? It sounds interesting.</span></text><author><a class="comment-user" href="/users/5048621/phil" title="387 reputation">Phil</a></author></comment><comment><text><span class="comment-copy">[DRAFT NIST Special Publication 800-63B Digital Authentication Guideline]( <a href="https://pages.nist.gov/800-63-3/sp800-63b.html" rel="nofollow noreferrer">pages.nist.gov/800-63-3/sp800-63b.html</a>), 5.1.1.2. Memorized Secret Verifiers: <i>Verifiers SHOULD NOT require memorized secrets to be changed arbitrarily (e.g., periodically)</i>. Also see <a href="http://www.slideshare.net/jim_fenton/toward-better-password-requirements" rel="nofollow noreferrer">Toward Better Password Requirements</a> by Jim Fenton.</span></text><author><a class="comment-user" href="/users/451475/zaph" title="83,978 reputation">zaph</a></author></comment><comment><text><span class="comment-copy">The thing is that the more often a user is required to change a password the worst the password choices become thus reducing security. User have a limited amount of good memorizable passwords and they run out, either choosing really bad passwords or writing them on post-it notes stuck to the bottom of the keyboard, etc.</span></text><author><a class="comment-user" href="/users/451475/zaph" title="83,978 reputation">zaph</a></author></comment><comment><text><span class="comment-copy">@zaph  Thank you.  That's very useful information.</span></text><author><a class="comment-user" href="/users/5048621/phil" title="387 reputation">Phil</a></author></comment></comments></answer></answers></post>