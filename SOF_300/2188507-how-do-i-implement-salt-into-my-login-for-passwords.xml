<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How do I implement salt into my login for passwords? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I want to implement a salt into my login system but am a bit confused on how this is supposed to work. I can't understand the logic behind it. I understand md5 is a one-way algorithm and all of the functions that I have come across seem to hash everything together. If this is the case, how does one get the password back out for comparison? My biggest question is, how is salting a users' password safer than just hashing the password? If a database was ever to be compromised, the hash along with the salt is in the database. Isn't this all that a hacker would need?</p>
<p>I also found another post here on SO where another developer said :</p>
<blockquote>
<p>"Ensure your salt and algorithm are
  stored <strong>separately from</strong> the database"</p>
</blockquote>
<p>I would like to store the salt in the database. Is this really a problem if I do?</p>
<p>I'm looking for some help on understanding how this works and also what the best practice might be. Any help is greatly appreciated.</p>
<hr/>
<p>EDIT:
I want to thank everyone for their responses and ideas. Even though I may be more confused now, it has certainly been a learning experience for me. Thanks again guys.</p>
</div></text><author><a href="/users/1558269/jabberwockydecompiler">JabberwockyDecompiler</a></author><comments><comment><text><span class="comment-copy">Welcome to SO. Great first question.</span></text><author><a class="comment-user" href="/users/187606/pekka-%ec%9b%83" title="317,852 reputation">Pekka 웃</a></author></comment><comment><text><span class="comment-copy">Thanks Pekka. :)</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy"><a href="http://stackoverflow.com/questions/873403/net-impl-of-bcrypt">stackoverflow.com/questions/873403/net-impl-of-bcrypt</a></span></text><author><a class="comment-user" href="/users/131926/steven-sudit" title="16,297 reputation">Steven Sudit</a></author></comment><comment><text><span class="comment-copy">Related read: <a href="http://blog.ircmaxell.com/2011/08/rainbow-table-is-dead.html" rel="nofollow noreferrer">The Rainbow Table Is Dead</a></span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,311 reputation">ircmaxell</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>An hash function always return the same value for the same input string. Let's say my user (Alice) has the password <code>secret</code>. Hashing <code>secret</code> using <a href="http://php.net/md5" rel="nofollow noreferrer"><code>md5()</code></a> leads to the following hash</p>
<pre><code>5ebe2294ecd0e0f08eab7690d2a6ee69
</code></pre>
<p>Using a dictionary (a list of common words and password) or one of the various sites that offer you that service, the attacker (Mallory) can easily find out the password is secret when he sees in his dictionary that <code>5ebe2294ecd0e0f08eab7690d2a6ee69 = secret</code>.</p>
<p>The process of salting before hashing makes it harder to use a dictionary attack without knowing your salt. Consider the following:</p>
<pre><code>&lt;?php
$salt = '@!#%$@#$@SADLkwod,sdaDwqksjaoidjwq@#@!';
$hash = md5($salt . 'secret');
</code></pre>
<p>The resulting hash is now <code>b58ad809eece17322de5024d79299f8a</code> but Alice's password is still <code>secret</code>. Now if Mallory gets her hands on the salted hash, chances are she will not find the answer in her dictionary. If she does, the dictionary will give her the wrong answer.</p>
<p>Never store a static salt in your database. Preferably store it with your application's configuration (which by the way should not be available from the web).</p>
<p>If you are going to use a dynamic salt, you are going to need to use the database. Use a non-null column of existing valid data to build your salt on (blowfish-encrypted string of username based on a secret encryption key is usually cryptographically secure). Do not use a separate column for the salt. If you cannot use an existing column, incorporate your salt in the same column than your hash. For example, use the first 32 characters for your 128-bits salt and then the last 40 for your 160-bits hash. The following function will generate such an hash:</p>
<pre><code>function seeded_sha1($string, $seed_bits) {
    if(($seed_bits % 8) != 0) {
        throw new Exception('bits must be divisible by 8');
    }

    $salt = '';
    for($i = 0; $i &lt; $seed_bits; $i+=8) {
        $salt .= pack('c', mt_rand());
    }

    $hexsalt = unpack('h*hex', $salt);

    return $hexsalt['hex'] . sha1($salt . $string);
}

function compare_seeded_sha1($plain, $hash) {
    $sha1 = substr($hash, -40);
    $salt = pack('h*', substr($hash, 0, -40));

    $plain_hash = sha1($salt . $plain);
    return ($plain_hash == $sha1);
}
</code></pre>
<p>If an attacker gets in your database using SQL injection, at least the hashes he/she retrieves won't be useful since he/she won't have access to your application configuration. If your server gets rooted, it's pretty much game-over no matter what you do.</p>
<p><strong>Note:</strong> There are other types of attack possible on <a href="http://php.net/md5" rel="nofollow noreferrer"><code>md5()</code></a> which is why you use more secure hashing algorithm, <a href="http://php.net/sha1" rel="nofollow noreferrer"><code>sha1()</code></a> for example. Or, even better, use the <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">Portable PHP password hashing framework</a>, which has been designed with security in mind and is backwards compatible with pretty much any PHP version.</p>
<pre><code>require('PasswordHash.php');

$pwdHasher = new PasswordHash(8, FALSE);

// $hash is what you would store in your database
$hash = $pwdHasher-&gt;HashPassword( $password );

// $hash would be the $hashed stored in your database for this user
$checked = $pwdHasher-&gt;CheckPassword($password, $hash);
if ($checked) {
    echo 'password correct';
} else {
    echo 'wrong credentials';
}
</code></pre>
</div></text><author><a href="/users/26210">Andrew Moore</a></author><comments><comment><text><span class="comment-copy">Fantastic, explanation Andrew. Thanks. Don't go anywhere. I want to ask you a few questions after I finish reading the rest of your post.</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">See <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">chargen.matasano.com/chargen/2007/9/7/…</a> on why SHA-1 (or SHA-2, or anything else) is <i>not</i> a "more secure hashing algorithm", for password hashing.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">Ok, see, here is what is screwing me up... Everyone is saying to generate a <b>random salt</b> and store it in the database. Seems fair to me. But, what I am understanding from your post is that I should <b>not</b> store the hash in the database but instead, in the application. If I store the salt in the application, it fails to be dynamic at that point. Can you see my confusion?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Chris: The same approach could be taken with <code>bcrypt</code>. Dictionaries do exist for it as well. They are just less available. I'm sorry to say, dictionaries is a weakness that no hashing algorithm may solve.  If I can't crack your <code>bcrypt</code> hash in enough time with one machine, I'll get a cluster. If it still isn't fast enough, I'll rent a bot net. And you don't know how fast we'll be able to hash a <code>bcrypt</code> hash in a year. Its supposed security through slowness is already broken I'm afraid.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Andrew: No, security through slowness <i>is</i> the best defence you have; you've got to slow down the brute force cracking as much as you can. If you say it's no defence, then that's equivalent to saying that any encryption is useless too, because people can brute-force it. :-P</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Timmay: having a dynamic salt will only slow-down your attacker. If you still want to have a dynamic salt, don't make it obvious to your attacker and use a field in your row that is NON-NULL to build your salt on. The worst thing you can do is have a field with seemingly random that or worst, a field called <code>salt</code>.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Chris: The day an hashing function takes more than 2 seconds to compute, I'll consider it safe on that account. Till then, I can just parallelize my brute-forcing as much as I want to get the answer I want quickly.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">I was working for the state making an application and had to use their computers and network. They had an extremely secure password algorithm to lock down passwords. No dictionary words, 2 uppercase letters 3 numbers, 16 characters that had to be changed every 20 days. I was running around the office looking for serial numbers off of the HP printers to use.</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Andrew: You clearly haven't read up on bcrypt, then. bcrypt's win is that it's <i>tunable</i>. At the moment, if you use, say, 12 log-rounds, you can later up it to, say, 15 log-rounds. Each extra log-round doubles the amount of rounds used to compute a password trial. And I can bet you that right now, a 15-log-round salt will take <i>far longer</i> than 2 seconds to try.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Andrew. What is more secure? A random salt or a static salt? If you say static, then that is the way I will go. Would you recommend bcrypt?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">-1: Bad answer. The correct way to use a salt is to generate a random salt for each user and store it in the database. Trying to keep it separate or obscure the field name is amateurish nonsense. And using an artificially slow hash function is very much an accepted good practice.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@Timmay: Use a random salt. You will (marginally) increase security that way, for most algorithms. In the specific case of bcrypt, the number of log-rounds used is coded into the salt, so by using a different salt for each password, you can incrementally upgrade to stronger and stronger hashing.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Michael: Edited my answer to what I meant originally. For dynamic salts, you do need to store it in the database, but don't add a field for it. Use an existing field of valid data, and encrypt it based on a static private secret key. That will yield a cryptographically secure hash.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Michael. I don't claim to be an expert and is why I'm here but it seems to me that if I had a static key (salt) and I was the ONLY person in control of that salt then a hacker would not be able to crack the hashes. I mean, it seems logical to me anyway. Could you please explain how storing a random salt is safer than a static salt?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Timmay: If a the salt becomes known, it is easy to rebuild a dictionary as you only have one to build. Having a dynamic salt makes it harder as you need to build X dictionaries, one for every row.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Timmay: The risk is that your attacker can access <i>all</i> your site's code as well as <i>all</i> the tables in the database. If you think of security from a "worst case scenario" point of view, then you've got everything covered (as well as possible, anyway).</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Andrew. What do you mean by store the dynamic salt in "an existing field of valid data"? Should I store the salt in with say, the email address or user name? Also... You are now talking about using a static private key. Is there a code snippet that I can look at so that maybe I can understand this a bit more? Admittedly, I'm more lost now than when I came in here. :)</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Timmay: If you use bcrypt, the salt is stored with the hashed password. The library takes care of all that for you automatically.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Chris Jester-Young you cannot use random salt, how yould you check for user password, if you didn't have last generated random salt?</span></text><author><a class="comment-user" href="/users/179542/juraj-blahunka" title="9,101 reputation">Juraj Blahunka</a></author></comment><comment><text><span class="comment-copy">@Timmay: No, but you can use, say, an encrypted version of the email address. That way, you are using existing data, but it is no apparent while looking at the table layout.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Michael Borgwardt you don't have to generate unique salts for each user, just use already accessible columns as i pointed out in my answer <a href="http://stackoverflow.com/questions/2188507/help-with-salt-and-passwords/2188569#2188569" title="help with salt and passwords">stackoverflow.com/questions/2188507/…</a></span></text><author><a class="comment-user" href="/users/179542/juraj-blahunka" title="9,101 reputation">Juraj Blahunka</a></author></comment><comment><text><span class="comment-copy">@juraj: The random salt is stored (in the clear) <i>with</i> the hashed password. The salt doesn't really need to be kept secret, if it's unique per password.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Andrew: Security by obscurity won't help you. Assume that your attacker can download a full copy of your source code, then decide if using "encrypted email address" is any better than just storing a random salt in the clear with your hashed password.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Chris: As I stated, once you are rooted, it's pretty much game over. But having access to the source code, I can think of a bunch of easier way to get access to the password, with a quicker return than processing hashes. If the hash isn't apparent in the database, it will make it that much harder for an attacker with access to the database only.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Chris: But why use another salt, if you already have persistent, not changing columns, which you can use as a salt with combination of a static salt?</span></text><author><a class="comment-user" href="/users/179542/juraj-blahunka" title="9,101 reputation">Juraj Blahunka</a></author></comment><comment><text><span class="comment-copy">@Andrew.. That makes complete sense to me as well.</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Andrew: There are ways to obtain a web application's source code that doesn't involve getting full "game-over" root access, or even access to modify said code (which would, like you say, admit much easier attacks like logging all the passwords entered).</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Timmay: look at my answer for an explanation re "static key". @juraj: a generated salt has the advantage that you can ensure its length and quality more easily - and it prevents you from having to explain to the customer that it's impossible to change some fields because your <i>security concept</i> depends on them being fixed.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@Chris: if you have access to source code (root or any other type), it is pretty <code>totally</code> game over, from source code you can study all injections and breakdowns you can performs, that DB stays pretty unprotected :-)</span></text><author><a class="comment-user" href="/users/179542/juraj-blahunka" title="9,101 reputation">Juraj Blahunka</a></author></comment><comment><text><span class="comment-copy">@juraj: Wrong. Secure software does not depend on the secrecy of its source code for its security. Its security comes from being well-coded in the first place. You know, people can reverse-engineer all aspects of closed-source products; where do you think all the Microsoft security advisories come from? (Hint: IDA Pro.)</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@chris: reverse engineering of a simple task like user login/logout, which is performed on the server side is pretty much impossible (as you said, if well coded).. hovewer getting user info, with help of compromised source code is much easier.. to sum up, I think, that this comment sections is pretty long and it starting to be controversial:-D</span></text><author><a class="comment-user" href="/users/179542/juraj-blahunka" title="9,101 reputation">Juraj Blahunka</a></author></comment><comment><text><span class="comment-copy">@Michael, I commented in your post below, asking you for your opinion on how you might go about locking down passwords if it were up to you. I'd like to leave here with something. :)</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">-1 for <i>"Never store the salt in your database."</i> There is no reason not to store the salts in the database; however, they should be <b>unique for each user</b> or it is useless. And of course, there is no problem with using a unique database-field for the salts either, since <b>the salt is not considered a secret</b>.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">@BlueRaja: You obviously stop reading in the middle of the post. And while the salt is not considered a secret, if only your database is compromised, basing your salt on an existing field will considerably hamper the ability of an attacker to be able to gain access to a particular account. If the salt is clear in the database and the attacker is only interested in one particular account, it is considerably easier for him to build a dictionary to try and find the password (if that said password is not secure).</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy"><i>"basing your salt on an existing field will considerably hamper the ability of an attacker to be able to gain access to a particular account"</i> - now why in the world would you think that?  I hope you're not going to argue that it's "security by obscurity"? :)</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">@BlueRaja: Lets assume that the attacker has access to only your database. If you base your salt on a blowfish-encrypted version of your email address (for example), the attacker as absolutely no way of finding out the salt and cannot build a dictionary for a particular account. He doesn't have your key, and he doesn't even have the encryption method used. Simply using a field as it is doesn't have any value since its "security by obscurity", but applying an operation to it (such as encryption) does prevent an attacker with only DB access from doing anything with your hashes.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">Chris Jester-Young has been correct on every point so far.</span></text><author><a class="comment-user" href="/users/131926/steven-sudit" title="16,297 reputation">Steven Sudit</a></author></comment><comment><text><span class="comment-copy">Amazing discussion, and <i>very</i> informing. Thanks everyone. And there should be a SO badge for having the <i>very first question</i> skyrocket this far. :)</span></text><author><a class="comment-user" href="/users/187606/pekka-%ec%9b%83" title="317,852 reputation">Pekka 웃</a></author></comment><comment><text><span class="comment-copy">@Chris: That's beside the point. People reverse-engineer because they have access to the binaries. When you don't have access to neither the source nor the binaries, you'll agree that reverse-engineering gets a lot harder (not impossible, harder).</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">-1 for "Use a non-null column of existing valid data to build your salt on". This would tie the encrypted password to some other data, which is bad. Use a secure random number generator to generate the salt for each password. Or use a library that does salting and hashing for you and store all its data including salt as the hashed password.</span></text><author><a class="comment-user" href="/users/49246/starblue" title="39,841 reputation">starblue</a></author></comment><comment><text><span class="comment-copy">Last code-example is copied from: <a href="http://stackoverflow.com/questions/1581610/help-me-make-my-password-storage-safe/1581919#1581919" title="help me make my password storage safe">stackoverflow.com/questions/1581610/…</a></span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@Jacco: Last code example is copied from the PHP Password Hashing Documentation. Please get your references straight.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Andrew Moore: then please link to the URL containing this code-example and I will stand corrected. (Google can't find it and I can clearly remember writing exactly this example.)</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@Jacco: See <code>test.php</code> from the 0.1 distribution of phppass.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">@Andrew Moore: All revisions of <code>test.php</code> are here: <a href="http://cvsweb.openwall.com/cgi/cvsweb.cgi/projects/phpass/" rel="nofollow noreferrer">cvsweb.openwall.com/cgi/cvsweb.cgi/projects/phpass</a> The code-block is not in there. So I stand by my original claim.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The point of a salt is to prevent attackers from amortizing the cost of a brute force attack across sites (or better yet, when using a different salt for each user: all users of a site) through precomputed <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="noreferrer">rainbow tables</a>. </p>
<p>With plain hashing, an attacker can compute such a table once (a very long, costly operation) and then use it to quickly find passwords for any site. When a site uses one fixed salt, the attacker has to compute a new table specifically for that site. When a site uses a different salt for each user, the attacker can stop bothering with rainbow tables - he'll have to brute-force each single password separately.</p>
<p>Storing the salts separately is not necessary to gain this advantage. In theory it would be even more secure because it would neutralize the weakness of dictionary or short passwords. In practice, it's not worth bothering with because at the end of the day, you need access to the salts <em>somewhere</em> to check passwords. Also, trying to separate them would lead to more complex systems - and the more complex a system is, the more opportunities for security holes there are.</p>
<p><strong>Edit:</strong> My concrete recommendations:</p>
<ul>
<li>Generate long pseudorandom salt for each user and store in in the DB</li>
<li>Use a bcrypt-based hash</li>
<li>ideally, don't implement it yourself, use an <a href="http://www.openwall.com/phpass/" rel="noreferrer">existing library</a> instead</li>
</ul>
</div></text><author><a href="/users/16883/michael-borgwardt">Michael Borgwardt</a></author><comments><comment><text><span class="comment-copy">Thanks Mike. So, it's like 6 to 1, half a dozen to another... If it were you, how would you do this? What is the best practice in your own mind?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">Thanks Michael. I'm sure your probably tired of this thread by now but would you mind answering a couple more questions? I'm on 5.3 currently and crypt is part of the distro. When you say use an existing lib, is using PHPs crypt function ok or not?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">+1 great final advice. @Timmay This deserves the big green checkmark :)</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">@Timmay: It's OK but the phpass library I linked to would be even better. It would probably save you some work and has automatic fallbacks that will be used when the system has to run on an older PHP version.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">Exactly as Michael Borgwardt said and this cannot be understated seen the level of misinformation in many answers.  Michael is right on spot: "storing salts separately is not necessary to gain this advantage".  The whole point of salts is to prevent rainbow tables attack.  A salt, even in the clear, pefectly serves that purpose.</span></text><author><a class="comment-user" href="/users/257356/syntaxt3rr0r" title="14,660 reputation">SyntaxT3rr0r</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Forget about using salts (partly for the reason you mention), use bcrypt instead:</p>
<p>For a good explanation see: <a href="http://codahale.com/how-to-safely-store-a-password/" rel="noreferrer">http://codahale.com/how-to-safely-store-a-password/</a></p>
</div></text><author><a href="/users/114658/rich">Rich</a></author><comments><comment><text><span class="comment-copy">And the great thing about bcrypt? It contradicts silly assertions like storing the salt separately from the hash.... :-P (+1 for mentioning bcrypt; I 100% agree.)</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">lol.. I like the author's sense of humor. It is a great read. Thanks. :)</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">Well, if bcrypt is a better way to go, then that's what I will use.</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Timmay: Yes, bcrypt is the best way to go. Don't use MD5 or SHA1; that sort of advice is outdated by at least 20 years (so to speak). See: <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="nofollow noreferrer">chargen.matasano.com/chargen/2007/9/7/…</a></span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy"><code>bcrypt</code> is the best way to go until proven broken. Any hashing algorithm, by the pure definition of an hashing algorithm, means one input = one output. The speed doesn't give any security (who knows at what speeds we will be able to compute in a year). And if one computer isn't enough to brute-force your <code>bcrypt</code> hash, well I'll run my software on a freaking botnet to get the result. My point being that <code>bcrypt</code> isn't more secure than any salt+hash around.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">Ok, so PHP's crypt extension can use Blowfish, but you still need to pass a 16 char salt - you're back where you started, no?</span></text><author><a class="comment-user" href="/users/94695/bdl" title="1,325 reputation">bdl</a></author></comment><comment><text><span class="comment-copy">@Andrew: If it means your attacker has to employ 1000x more botnet nodes to crack the password, that just upped the ante quite a lot. (And the 1000x refers just to PHK's algorithm, which is 1000 iterations of MD5; bcrypt is even slower than that.)</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">From what I got from quickly reading through that link was that blowfish is ultra slow thereby making it harder and much longer to gain access to the password.</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Timmay: Yes, exactly, and that's where the win is.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">Thanks Chris. I'm all about logic and making something so slow seems to be the ticket. Do I need to install anything special or recompile PHP to use bcrypt?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">@Timmay: According to the link that Rich posted, this is a reasonable implementation of bcrypt in PHP (if below 5.3.0): <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">openwall.com/phpass</a> (They say that 5.3.0+ already have it builtin.)</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">Ah, cool. I am already on 5.3 so I guess it is already there then. :) At least <b>something</b> is tipping in my favor today.</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">-1 bcrypt is a great tool for this job, but you should still be using salts (for reasons mentioned by Andrew) - the salt solves a different problem than the hash. The author of that article is wrong.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">Where's NBcrypt?</span></text><author><a class="comment-user" href="/users/1228/will" title="100,617 reputation">Will</a></author></comment><comment><text><span class="comment-copy">@BlueRaja, you are completely wrong! <code>bcrypt</code> has the unique per password salt included in the final hash. It takes care of everything, so everything is correct with it.</span></text><author><a class="comment-user" href="/users/374476/rihards" title="4,067 reputation">Rihards</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The other answers are good, so I'll just throw in a minor point that nobody else has mentioned.  You don't want to use the same salt for every password because then if two people have the same password, they'll have the same hash.  That's exposing information that an attacker can exploit.</p>
<p>You could use the same salt for every user along with Juraj's good idea to combine the password with other non-changing database fields (unique to a user).  But watch out because this information gets tied to the password.  If you were to hash the username + password together to guarantee a unique hash, you wouldn't be able to change the username without creating a new user and requiring them to set a new password.</p>
<p>As an example of having a unique salt per user and storing it alongside the password hash, I'll point out <a href="http://en.wikipedia.org/wiki/Shadow_password" rel="noreferrer">/etc/shadow</a> on your typical Linux system.</p>
<pre><code>root@linux:/root# cat /etc/shadow | grep root
root:$1$oL5TTZxL$RhfGUZSbFwQN6jnX5D.Ck/:12139:0:99999:7:::
</code></pre>
<p>Here, the <strong>oL5TTZxL</strong> is the salt and <strong>RhfGUZSbFwQN6jnX5D.Ck/</strong> is the hash.  The plain-text password is <em>root</em> in this case, and the hash algorithm my system uses is the MD5-based BSD password algorithm.  (newer systems than mine have better hash algorithms)</p>
</div></text><author><a href="/users/19719/indiv">indiv</a></author><comments><comment><text><span class="comment-copy">Indiv, thanks.. That make perfect sense. So I really need to think about what I want to hash. What about hashing the users' password along with a static key that only I know? A key that resides in my application?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">A static key would provide an additional level of obfuscation, but it's proper when evaluating security to assume that an attacker has all knowledge of your system, including source code.  In this case, your static key is just a static salt, and doesn't significantly increase the security of your system.</span></text><author><a class="comment-user" href="/users/19719/indiv" title="11,285 reputation">indiv</a></author></comment><comment><text><span class="comment-copy">And I think it should be pointed out that Linux's security track record could be considered quite good and they are obviously storing the salt in the clear in the 'DB'.  The whole point of salt is to prevent rainbow tables attack.  Note brute force attacks.  Having a salt in the clear is not an issue at all because it fully full fills its purpose: defeating rainbow tables attack.  Storing a salt in the clear is not only common but normal: it doesn't make your security more vulnerable to a brute force attack.  Saying that the salt shouldn't be stored in the clear is silly.</span></text><author><a class="comment-user" href="/users/257356/syntaxt3rr0r" title="14,660 reputation">SyntaxT3rr0r</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You don't get the password out for comparison.  You encrypt the password when they attempt a login and compare the stored value with the newly encrypted value.</p>
</div></text><author><a href="/users/210118/brian">brian</a></author><comments><comment><text><span class="comment-copy">Yeah, because hashing a value is going to get the same hash every time, you simply compare the two hashes.</span></text><author><a class="comment-user" href="/users/58088/tyler-carter" title="42,111 reputation">Tyler Carter</a></author></comment><comment><text><span class="comment-copy">Ok, that much I get. I was doing this before but now that I want to use a salt, I don't understand. I guess what I am having a hard time understanding is how salting a password is any safer than not salting. The salt is in the database along side the hash. If a hacker had the database, how is this any safer?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">A better approach might be to inhibit dictionary attacks altogether.  You can have a maximum login attempt count or increase the time between login attempts (e.g. by a power of n) by implementing a delay.  This makes it very difficult to try more than a few passwords in a reasonable amount of time.</span></text><author><a class="comment-user" href="/users/210118/brian" title="874 reputation">brian</a></author></comment><comment><text><span class="comment-copy">@unknown: If you're talking about maximum login trials, you're looking at the wrong threat model. The right threat model is that a cracker has just downloaded your whole user/password table, and wants to crack as many passwords as they can.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment><comment><text><span class="comment-copy">@Chris any preventive approach in isolation is essentially useless.  I wasn't suggesting it as an all-encompassing fool proof approach.</span></text><author><a class="comment-user" href="/users/210118/brian" title="874 reputation">brian</a></author></comment><comment><text><span class="comment-copy">@unknown: Perhaps. But all this talk about maximum trials is <i>completely orthogonal</i> to the purpose of using salted password hashing (which is the OP's question); the former is aimed at online password guessing attacks, whereas the latter is aimed at offline cracking attacks.</span></text><author><a class="comment-user" href="/users/13/chris-jester-young" title="159,598 reputation">Chris Jester-Young</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As you mentioned, hashing algorithms work only one-way (or only if they are strong enough :-D)</p>
<p>For your question about salting I would recommend to hash a password with a <strong>static salt string</strong> and some <strong>dynamic data from database</strong>, which should <strong>not change</strong> after once created</p>
<p>This is a very secure way of storing passwords, as even if database is compromised, hackers/crackers still need to get your static string hash and need to guess how you applied all the salting..</p>
<p>For example let's say you have a <code>users</code> table with these columns:</p>
<pre><code>id
username
password
created_at
</code></pre>
<p>columns <strong>id</strong> and <strong>created_at</strong> after once filled should never be changed..</p>
<p>so when you are hashing user's password you can do as simple as:</p>
<pre><code>&lt;?php
    $staticSalt = '!241@kadl;ap][';
    $userPass = 'my new pass';
    // assuming $user variable is already populated with DB data
    // we will generate new hash from columns and static salt:
    $genPass = sha1($user['id'] . $userPass . $user['created_at'] . $staticSalt);
?&gt;
</code></pre>
<p>I hope this one helps :) cheers</p>
</div></text><author><a href="/users/179542/juraj-blahunka">Juraj Blahunka</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Hashing passwords is meant to keep those passwords secret from your own administrator(s).  </p>
<p>1) Keeping plain text passwords in your database would be fine except your passwords may be used by the administrator to gain access to some other system.  </p>
<p>2) You can use a single global salt, which is combined with the passwords (by prepending or XORing them) and then hashing for storage in the database.  But that is vulnerable to a malicious administrator AND a rainbow table designed for that one salt.</p>
<p>3) You can have a separate salt for each user:  The database will be used to store the salt, and the hash derived from the password/salt combination.  This will prevent a rainbow attack, but brute force attacks will still be possible.</p>
<p>4) Finally, you can keep your hash function a secret by using a velocity-limited hardware hashing solution.</p>
<p>That is as good as you can do.  Because of human nature, passwords have a limited domain and are vulnerable to brute force attacks.  We are trying to prevent administrators getting a hold of user passwords, and then using them on other systems they should not have access to.</p>
<p>Some other notes:</p>
<p>a) You can use bcrypt on the password/salt combination to slow down the attacker’s brute force attack.  But since we are assuming administrators, they can be patient.</p>
<p>b) Keeping the salt separate from the password hash is not an effective defense, we are assuming administrators after all.  </p>
<p>c) Using existing data as a salt is a little better, but I doubt existing data has as much entropy a random salt has.    </p>
</div></text><author><a href="/users/214460/kyle-lahnakoski">Kyle Lahnakoski</a></author><comments><comment><text><span class="comment-copy">Thanks Kyle.. I'm still here trying to figure out how to use bcrypt. Have you used it before as part of PHPs distro?</span></text><author><a class="comment-user owner" href="/users/264826/timmay" title="266 reputation">Timmay</a></author></comment><comment><text><span class="comment-copy">The "administrator" could also be someone who has found a SQL-injection hole in your site and has dumped out your DB schema and the contents of your user table.</span></text><author><a class="comment-user" href="/users/20122/geofftnz" title="7,258 reputation">geofftnz</a></author></comment><comment><text><span class="comment-copy">Good point about the administrators. I'm proud to say that even I, as the designer of our password system, could not figure out any user's password without a brute force attack. If I can't do it, how is someone with less knowledge about the system going to?</span></text><author><a class="comment-user" href="/users/37236/amish-programmer" title="1,166 reputation">Amish Programmer</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Salting a user's password is possibly safer than just hashing the password because it can protect against precomputation attacks.</p>
<p>For instance, if a hacker gets access to your database, and the passwords are not salted, then he can look up the hashes in his database of hashes (see <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Rainbow_table</a>) to get the original passwords.</p>
</div></text><author><a href="/users/187377/sam-hartsfield">Sam Hartsfield</a></author><comments/></answer></answers></post>