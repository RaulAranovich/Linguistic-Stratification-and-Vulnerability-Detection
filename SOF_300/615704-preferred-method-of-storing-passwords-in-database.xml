<?xml version="1.0" encoding="utf-8"?>
<post><title>sql server - Preferred Method of Storing Passwords In Database - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>What is your preferred method/datatype for storing passwords in a database (preferably SQL Server 2005). The way I have been doing it in several of our applications is to first use the .NET encryption libraries and then store them in the database as binary(16). Is this the preferred method or should I be using a different datatype or allocating more space than 16?</p>
</div></text><author><a href="/users/2831/brian">brian</a></author><comments><comment><text><span class="comment-copy">I have a feeling this may be a dupe but what I thought may be a dupe of it turned out to be concerning the actual DB logins and not just storing application/site logins.</span></text><author><a class="comment-user owner" href="/users/22164/thetxi" title="29,960 reputation">TheTXI</a></author></comment><comment><text><span class="comment-copy">Could you please clarify your question to explain whether you are using "encryption" or "hashing" functions? I think you mean the latter, but the difference is very significant.</span></text><author><a class="comment-user" href="/users/4965/ine" title="11,497 reputation">ine</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I store the salted hash equivalent of the password in the database and never the password itself, then always compare the hash to the generated one of what the user passed in.</p>
<p>It's too dangerous to ever store the literal password data anywhere.  This makes recovery impossible, but when someone forgets or loses a password you can run through some checks and create a new password.</p>
</div></text><author><a href="/users/12707/quintin-robinson">Quintin Robinson</a></author><comments><comment><text><span class="comment-copy">@Quinton: That is pretty much what I do. With the .net encryption libraries it will hash up the password and then I pass that into the DB and store as a binary. I can only compare passwords by hashing user input and comparing it to what is stored.</span></text><author><a class="comment-user owner" href="/users/22164/thetxi" title="29,960 reputation">TheTXI</a></author></comment><comment><text><span class="comment-copy">It sounds like you are on the right track then.</span></text><author><a class="comment-user" href="/users/12707/quintin-robinson" title="59,850 reputation">Quintin Robinson</a></author></comment><comment><text><span class="comment-copy">I recommend jbcrypt if you are working with java. Extremly simple to use</span></text><author><a class="comment-user" href="/users/66686/jens-schauder" title="35,477 reputation">Jens Schauder</a></author></comment><comment><text><span class="comment-copy">We store salted passwords too. In our case we convert the 160-bit has to base64, and store it in a varchar - it just makes things easier (strings are easier to read/write/look at). In addition to a global salt, we pre-salt with the the user's id (sid or guid), so that two users with the same password do not give the same hash. This makes dictionary attacks more difficult (more CPU cost), and prevents you from discovering the password for multiple at the same time, when everyone chooses the same password.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment><comment><text><span class="comment-copy">@IanBoyd , in case you haven't changed the salt method, you are doing it wrong. It should be random, with enough entropy and user-specific, in which case you only comply with the latter.</span></text><author><a class="comment-user" href="/users/938236/francisco-presencia" title="5,484 reputation">Francisco Presencia</a></author></comment><comment><text><span class="comment-copy">@FranciscoPresencia Since then i've switched to bcrypt. The canonical bcrypt implementation generates random salt for each hash. The canonical implementation also converts the 22-byte hash into base64, suitable for easily storing in a <code>varchar</code> database column. The final bit of good thinking of their part is defining a format of their hash string, where the salt is included in the string.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>THE preferred method: never store passwords in your DB. Only hashes thereof. Add salt to taste.</p>
</div></text><author><a href="/users/11208/assaf-lavie">Assaf Lavie</a></author><comments><comment><text><span class="comment-copy">mod up, had to do it, just for the salt joke ;)</span></text><author><a class="comment-user" href="/users/158014/jakub" title="16,022 reputation">Jakub</a></author></comment><comment><text><span class="comment-copy">i grinned at it as well.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I do the same thing you've described, except it is stored as a String.  I Base64 encode the encrypted binary value.  The amount of space to allocate depends on the encryption algorithm/cipher strength.</p>
<p>I think you are doing it right (given that you use a <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noreferrer">Salt</a>).</p>
</div></text><author><a href="/users/54420/josh-stodola">Josh Stodola</a></author><comments><comment><text><span class="comment-copy">+1 for addressing the real question here.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Since the result of a hash function is a series of byte in the range 0 to 255 (or -128 to 127, depending the signed-ness of your 8-bit data type), storing it as a raw binary field makes the most sense, as it is the most compact representation and requires no additional encoding and decoding steps.</p>
<p>Some databases or drivers don't have great support for binary data types, or sometimes developers just aren't familiar enough with them to feel comfortable. In that case, using a binary-to-text encoding like Base-64 or Base-85, and storing the resulting text in a character field is acceptable.</p>
<p>The size of the field necessary is determined by the hash function that you use. MD5 always outputs 16 bytes, SHA-1 always outputs 20 bytes. Once you select a hash function, you are usually stuck with it, as changing requires a reset of all existing passwords. So, using a variable-size field doesn't buy you anything.</p>
<hr/>
<p>Regarding the "best" way to perform the hashing, I've tried to provide many answers to other SO questions on that topic:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/287517/encrypting-hashing-plain-text-passwords-in-database#287738">Encrypting passwords</a></li>
<li><a href="http://stackoverflow.com/questions/116684/what-algorithm-should-i-use-to-hash-passwords-into-my-database">Encrypting passwords</a></li>
<li><a href="http://stackoverflow.com/questions/312088/what-is-the-easiest-way-to-create-and-compare-a-salted-password-in-net#312159">Encrypting passwords in .NET</a></li>
<li><a href="http://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904">Salt</a></li>
<li><a href="http://stackoverflow.com/questions/213380/the-necessity-of-hiding-the-salt-for-a-hash#215165">Salt: Secret or public?</a></li>
<li><a href="http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/348140#348140">Hash iterations</a></li>
</ul>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">If you read my question a little bit more closely, you'd see I am focused more along the actual storage in terms of datatype and space allocated for the field.</span></text><author><a class="comment-user owner" href="/users/22164/thetxi" title="29,960 reputation">TheTXI</a></author></comment><comment><text><span class="comment-copy">But +1 for providing extra information to others who may come along later.</span></text><author><a class="comment-user owner" href="/users/22164/thetxi" title="29,960 reputation">TheTXI</a></author></comment><comment><text><span class="comment-copy">Right on. It looks like I'm not the only one missing that ;)</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<ol>
<li>store the hash of the salted-password, such as bcrypt(nounce+pwd).  You may prefer bcrypt over SHA1 or MD5 because it can be tuned to be CPU-intensive, therefore making a brute force attack way longer.</li>
<li>add a captcha to the login form after a few login errors (to avoid brute-force attacks)</li>
<li>if your application has a "forgot my password" link, make sure it does not send the new password by email, but instead it should send a link to a (secured) page allowing the user to define a new password (possibly only after confirmation of some personal information, such as the user's birth date, for example).  Also, if your application allows the user to define a new password, make sure you require the user to confirm the current password.</li>
<li>and obviously, secure the login form (typically with HTTPS) and the servers themselves</li>
</ol>
<p>With these measures, your user's passwords will be fairly well protected against:</p>
<ol>
<li>=&gt; offline dictionary attacks</li>
<li>=&gt; live dictionary attacks</li>
<li>=&gt; denial of service attacks</li>
<li>=&gt; all sorts of attacks!</li>
</ol>
</div></text><author><a href="/users/38626/miniquark">MiniQuark</a></author><comments><comment><text><span class="comment-copy">All these measures can be quickly implemented and packs quite a punch for minimal effort! +1 =)</span></text><author><a class="comment-user" href="/users/56190/luke-antins" title="1,642 reputation">Luke Antins</a></author></comment><comment><text><span class="comment-copy">Are DOS attacks related to password security?</span></text><author><a class="comment-user" href="/users/737641/arj" title="940 reputation">Arj</a></author></comment><comment><text><span class="comment-copy">@a12jun: if you have a "forgot my password" link on your web site with a simple "login" input, and a "please generate a new password and send it to me by email" button, then anyone who knows your login can force you to change your password.  If he automates this to run every 10 seconds, then he can deny you access to your account.  If he runs this against thousands of users, he can probably get a lot of them to dislike your service. Guideline #3 can protect you against this, that's what I meant (it was not very clear, I must admit).  Security = Confidentiality, Integrity, <b><i>Availability</i></b>.</span></text><author><a class="comment-user" href="/users/38626/miniquark" title="15,437 reputation">MiniQuark</a></author></comment><comment><text><span class="comment-copy">@MiniQuark: good explanation, I hadn't thought of that!</span></text><author><a class="comment-user" href="/users/737641/arj" title="940 reputation">Arj</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A simple hash of the password, or even (salt + password) is not generally adequate.</p>
<p>see:</p>
<p><a href="http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/" rel="nofollow noreferrer">http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/</a></p>
<p>and</p>
<p><a href="http://gom-jabbar.org/articles/2008/12/03/why-you-should-use-bcrypt-to-store-your-passwords" rel="nofollow noreferrer">http://gom-jabbar.org/articles/2008/12/03/why-you-should-use-bcrypt-to-store-your-passwords</a></p>
<p>Both recommend the bcrypt algorithms.  Free implementations can be found online for most popular languages.</p>
</div></text><author><a href="/users/12048/finnw">finnw</a></author><comments><comment><text><span class="comment-copy">Great links that go beyond the superficial security concerns.  For deliberately slow algorithms, would it be important to have the hashes computed on the client side so as not to overload the (possibly already quite busy) server?</span></text><author><a class="comment-user" href="/users/113082/cheduardo" title="3,874 reputation">cheduardo</a></author></comment><comment><text><span class="comment-copy">Not really.  The goal is simply to make it "Slightly" slower.  Just to give you an idea.  I can SHA1 hash about 200K passwords per second on quad core system.  I doubt anyone needs to handle 200K simultaneous logins ever second....  So you use a function like PBKDF2 or bcrypt to slow it down to say only 100 hashes per second (increases the brute force timeline by a factor of 200).</span></text><author><a class="comment-user" href="/users/498612/gerald-davis" title="3,187 reputation">Gerald Davis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I use the sha hash of the username, a guid in the web config, and the password, stored as a varchar(40). If they want to brute force / dictionary they'll need to hack the web server for the guid as well. The username breaks creating a rainbow table across the whole database if they do find the password. If a user wants to change their username, I just reset the password at the same time.</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">System</span><span class="pun">.</span><span class="pln">Web</span><span class="pun">.</span><span class="pln">Security</span><span class="pun">.</span><span class="pln">FormsAuthentication</span><span class="pun">.</span><span class="pln">HashPasswordForStoringInConfigFile</span><span class="pun">(</span><span class="pln">
    username</span><span class="pun">.</span><span class="pln">ToLower</span><span class="pun">().</span><span class="pln">Trim</span><span class="pun">(),</span><span class="pln">
    ConfigurationManager</span><span class="pun">.</span><span class="pln">AppSettings</span><span class="pun">(</span><span class="str">"salt"</span><span class="pun">),</span><span class="pln">
    password
</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/26/shawn">Shawn</a></author><comments><comment><text><span class="comment-copy">i used to use the username as added salt. But then we were unable to rename a user. We switched to using salt with is the users's id, guid, sid, or something other surrogate key.</span></text><author><a class="comment-user" href="/users/12597/ian-boyd" title="94,195 reputation">Ian Boyd</a></author></comment><comment><text><span class="comment-copy">tru, good call. this way you dont have to reset the password when you rename a user</span></text><author><a class="comment-user" href="/users/26/shawn" title="10,515 reputation">Shawn</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can use multiple hashes in your database, it just requires a little bit of extra effort.  It's well worth it though if you think there's the remotest chance you'll need to support additional formats in the future.  I'll often use password entries like</p>
<p>{hashId}${salt}${hashed password}</p>
<p>where "hashId" is just some number I use internally to recognize that, e.g., I'm using SHA1 with a specific hash pattern; "salt" is a base64-encoded random salt; and "hashed password" is a base64-encoded hash.  If you need to migrate hashes you can intercept people with an old password format and make them change their password the next time they log in.</p>
<p>As others have mentioned you want to be careful with your hashes since it's easy to do something that's not really secure, e.g., H(salt,password) is far weaker than H(password,salt), but at the same time you want to balance the effort put into this with the value of the site content.  I'll often use H(H(password,salt),password).</p>
<p>Finally, the cost of using base64-encoded passwords is modest when compared to the benefits of being able to use various tools that expect text data.  Yeah, they should be more flexible, but are you ready to tell your boss that he can't use his favorite third party tool because you want to save a few bytes per record? :-)</p>
<p>Edited to add one other comment: if I suggested deliberately using an algorithm that burned even a 1/10th of a second hashing each password I would be lucky to just be laughed out of my boss's office.  (Not so lucky?  He would jot something down to discuss at my next annual review.)   Burning that time isn't a problem when you have dozens, or even hundreds, of users.  If you're pushing 100k users you'll usually have multiple people logging in at the same time.  You need something fast and strong, not slow and strong.  The "but what about the credit card information?" is disingenuous at best since stored credit card information shouldn't be anywhere near your regular database, and would be encrypted by the application anyway, not individual users.</p>
</div></text><author><a href="/users/81502/bgiles">bgiles</a></author><comments><comment><text><span class="comment-copy">There is no such thing as fast &amp; strong when it comes to hashing.  Sorry.  If it is fast for you it is fast for a brute force attacker.  Using a key derivation function is a valid method for password strengthening.</span></text><author><a class="comment-user" href="/users/498612/gerald-davis" title="3,187 reputation">Gerald Davis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you are working with ASP.Net you can use the built in membership API.</p>
<p>It supports many types of storage options, inlcuding; one way hash, two way encryption, md5 + salt. <a href="http://www.asp.net/learn/security" rel="nofollow noreferrer">http://www.asp.net/learn/security</a> for more info.</p>
<p>If you dont need anything too fancy, this is great for websites.</p>
<p>If you are not using ASP.Net here is a good link to a few articles from 4guys and codeproject</p>
<p><a href="http://aspnet.4guysfromrolla.com/articles/081705-1.aspx" rel="nofollow noreferrer">http://aspnet.4guysfromrolla.com/articles/081705-1.aspx</a>
<a href="http://aspnet.4guysfromrolla.com/articles/103002-1.aspx" rel="nofollow noreferrer">http://aspnet.4guysfromrolla.com/articles/103002-1.aspx</a>
<a href="http://www.codeproject.com/KB/security/SimpleEncryption.aspx" rel="nofollow noreferrer">http://www.codeproject.com/KB/security/SimpleEncryption.aspx</a></p>
</div></text><author><a href="/users/72453/sruly">Sruly</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Since your question is about storage method &amp; size I will address that.</p>
<p>Storage type can be either binary or text representation (base64 is the most common). Binary is smaller but I find working with text easier.  If you are doing per user salting (different salt per password) then it is easier to store salt+hash as a single combined string.  </p>
<p>The size is hash algorithm dependent.  The output of MD5 is always 16 bytes, SHA1 is always 20 bytes.  SHA-256 &amp; SHA-512 are 32 &amp; 64 bytes respectively.  If you are using text encoding you will need slightly more storage depending on the encoding method.  I tend to use Base64 because storage is relatively cheap.  Base64 is going to require roughly 33% larger field.</p>
<p>If you have per user salting you will need space for the hash also. Putting it all together 64bit salt + SHA1 hash (160 bit) base64 encoded takes 40 characters so I store it as char(40). </p>
<p>Lastly if you want to do it right you shouldn't be using a single hash but a key derivation function like RBKDF2. SHA1 and MD5 hashes are insanely fast.  Even a single threaded application can hash about 30K to 50K passwords per second thats up to 200K passwords per second on quad core machine.  GPUs can hash 100x to 1000x as many passwords per second.With speeds like that brute force attacking becomes an acceptable intrusion method.  RBKDF2 allows you to specify the number of iterations to fine tune how "slow" your hashing is.  The point isn' to bring the system to its knees but to pick a number of iterations so that you cap upper limit on hash throughput (say 500 hashes per second).  A future proof method would be to include the number of iterations in the password field (iterations + salt + hash).  This would allow increasing iterations in the future to keep pace with more powerful processors.  To be even more flexible use varchar to allow potentially larger/alternative hashes in the future.</p>
<p>The .Net implementation is RFC2892DeriveBytes
<a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx</a></p>
</div></text><author><a href="/users/498612/gerald-davis">Gerald Davis</a></author><comments/></answer></answers></post>