<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Best Practices: Salting &amp; peppering passwords? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I came across a discussion in which I learned that what I'd been doing wasn't in fact salting passwords but peppering them, and I've since begun doing both with a function like:</p>
<pre><code>hash_function($salt.hash_function($pepper.$password)) [multiple iterations]
</code></pre>
<p>Ignoring the chosen hash algorithm (I want this to be a discussion of salts &amp; peppers and not specific algorithms but I'm using a secure one), is this a secure option or should I be doing something different? For those unfamiliar with the terms:</p>
<ul>
<li><p>A <strong>salt</strong> is a randomly generated value usually stored with the string in the database designed to make it impossible to use hash tables to crack passwords. As each password has its own salt, they must all be brute-forced individually in order to crack them; however, as the salt is stored in the database with the password hash, a database compromise means losing both.</p></li>
<li><p>A <strong>pepper</strong> is a site-wide static value stored separately from the database (usually hard-coded in the application's source code) which is intended to be secret. It is used so that a compromise of the database would not cause the entire application's password table to be brute-forceable.</p></li>
</ul>
<p>Is there anything I'm missing and is salting &amp; peppering my passwords the best option to protect my user's security? Is there any potential security flaw to doing it this way?</p>
<p><em>Note: Assume for the purpose of the discussion that the application &amp; database are stored on separate machines, do not share passwords etc. so a breach of the database server does not automatically mean a breach of the application server.</em></p>
</div></text><author><a href="/users/168868/charles">Charles</a></author><comments><comment><text><span class="comment-copy">Not <i>quite</i> a duplicate, but <i>extremely</i> related: <a href="http://stackoverflow.com/questions/16594613/how-to-hash-long-passwords-72-characters-with-blowfish/16597402#16597402" title="how to hash long passwords 72 characters with blowfish">stackoverflow.com/questions/16594613/â€¦</a></span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Ok. Seeing as I need to write about this <a href="http://stackoverflow.com/a/16597402/338665">over</a> and <a href="http://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html" rel="noreferrer">over</a>, I'll do one last canonical answer on pepper alone.</p>
<h1>The Apparent Upside Of Peppers</h1>
<p>It seems quite obvious that peppers should make hash functions more secure. I mean, if the attacker only gets your database, then your users passwords should be secure, right? Seems logical, right?</p>
<p>That's why so many people believe that peppers are a good idea. It "makes sense". </p>
<h1>The Reality Of Peppers</h1>
<p>In the security and cryptography realms, "make sense" isn't enough. Something has to be provable <strong>and</strong> make sense in order for it to be considered secure. Additionally, it has to be implementable in a maintainable way. The most secure system that can't be maintained is considered insecure (because if any part of that security breaks down, the entire system falls apart).</p>
<p>And peppers fit neither the provable or the maintainable models...</p>
<h1>Theoretical Problems With Peppers</h1>
<p>Now that we've set the stage, let's look at what's wrong with peppers.</p>
<ul>
<li><p><strong>Feeding one hash into another can be dangerous.</strong></p>
<p>In your example, you do <code>hash_function($salt . hash_function($pepper . $password))</code>.</p>
<p>We know from past experience that "just feeding" one hash result into another hash function can decrease the overall security. The reason is that both hash functions can become a target of attack. </p>
<p>That's why algorithms like <a href="http://en.wikipedia.org/wiki/PBKDF2" rel="noreferrer">PBKDF2</a> use special operations to combine them (hmac in that case).</p>
<p>The point is that while it's not a big deal, it is also not a trivial thing to just throw around. Crypto systems are designed to avoid "should work" cases, and instead focus on "designed to work" cases.</p>
<p>While this may seem purely theoretical, it's in fact not. For example, <a href="http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html" rel="noreferrer">Bcrypt cannot accept arbitrary passwords</a>. So passing <code>bcrypt(hash(pw), salt)</code> can indeed result in a far weaker hash than <code>bcrypt(pw, salt)</code> if <code>hash()</code> returns a binary string.</p></li>
<li><p><strong>Working Against Design</strong></p>
<p>The way bcrypt (and other password hashing algorithms) were designed is to work with a salt. The concept of a pepper was never introduced. This may seem like a triviality, but it's not. The reason is that a salt is not a secret. It is just a value that can be known to an attacker. A pepper on the other hand, by very definition is a cryptographic secret.</p>
<p>The current password hashing algorithms (bcrypt, pbkdf2, etc) all are designed to only take in one secret value (the password). Adding in another secret into the algorithm hasn't been studied at all.</p>
<p>That doesn't mean it is not safe. It means we don't know if it is safe. And the general recommendation with security and cryptography is that if we don't know, it isn't.</p>
<p>So until algorithms are designed and vetted by cryptographers for use with secret values (peppers), current algorithms shouldn't be used with them.</p></li>
<li><p><strong>Complexity Is The Enemy Of Security</strong></p>
<p>Believe it or not, <a href="http://www.schneier.com/news-038.html" rel="noreferrer">Complexity Is The Enemy Of Security</a>. Making an algorithm that looks complex may be secure, or it may be not. But the chances are quite significant that it's not secure. </p></li>
</ul>
<h1>Significant Problems With Peppers</h1>
<ul>
<li><p><strong>It's Not Maintainable</strong></p>
<p>Your implementation of peppers precludes the ability to rotate the pepper key. Since the pepper is used at the input to the one way function, you can never change the pepper for the lifetime of the value. This means that you'd need to come up with some wonky hacks to get it to support key rotation.</p>
<p>This is <strong>extremely</strong> important as it's required whenever you store cryptographic secrets. Not having a mechanism to rotate keys (periodically, and after a breach) is a huge security vulnerability.</p>
<p>And your current pepper approach would require every user to either have their password completely invalidated by a rotation, or wait until their next login to rotate (which may be never)...</p>
<p>Which basically makes your approach an immediate no-go.</p></li>
<li><p><strong>It Requires You To Roll Your Own Crypto</strong></p>
<p>Since no current algorithm supports the concept of a pepper, it requires you to either compose algorithms or invent new ones to support a pepper. And if you can't immediately see why that's a really bad thing:</p>
<blockquote>
<p>Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can't break.</p>
</blockquote>
<ul>
<li><a href="http://www.schneier.com/blog/archives/2011/04/schneiers_law.html" rel="noreferrer">Bruce Schneier</a></li>
</ul>
<p><strong>NEVER</strong> roll your own crypto...</p></li>
</ul>
<h1>The Better Way</h1>
<p>So, out of all the problems detailed above, there are two ways of handling the situation. </p>
<ul>
<li><p><strong>Just Use The Algorithms As They Exist</strong></p>
<p>If you use bcrypt or scrypt correctly (with a high cost), all but the weakest dictionary passwords should be statistically safe. The current record for hashing bcrypt at cost 5 is 71k hashes per second. At that rate even a 6 character random password would take years to crack. And considering my minimum recommended cost is 10, that reduces the hashes per second by a factor of 32. So we'd be talking only about 2200 hashes per second. At that rate, even some dictionary phrases or modificaitons may be safe.</p>
<p>Additionally, we should be checking for those weak classes of passwords at the door and not allowing them in. As password cracking gets more advanced, so should password quality requirements. It's still a statistical game, but with a proper storage technique, and strong passwords, everyone should be practically very safe...</p></li>
<li><p><strong>Encrypt The Output Hash Prior To Storage</strong></p>
<p>There exists in the security realm an algorithm designed to handle everything we've said above. It's a block cipher. It's good, because it's reversible, so we can rotate keys (yay! maintainability!). It's good because it's being used as designed. It's good because it gives the user no information.</p>
<p>Let's look at that line again. Let's say that an attacker knows your algorithm (which is required for security, otherwise it's security through obscurity). With a traditional pepper approach, the attacker can create a sentinel password, and since he knows the salt and the output, he can brute force the pepper. Ok, that's a long shot, but it's possible. With a cipher, the attacker gets nothing. And since the salt is randomized, a sentinel password won't even help him/her. So the best they are left with is to attack the encrypted form. Which means that they first have to attack your encrypted hash to recover the encryption key, and then attack the hashes. But there's a <strong>lot</strong> of research into the attacking of ciphers, so we want to rely on that.</p></li>
</ul>
<h1>TL/DR</h1>
<p>Don't use peppers. There are a host of problems with them, and there are two better ways: not using any server-side secret (yes, it's ok) and encrypting the output hash using a block cipher prior to storage.</p>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">Thank you for this very complete answer.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">Thanks for including that last part of encrypting the hash-value, this is an answer i can fully agree with. If the encryption would become part of your <a href="http://www.php.net/manual/de/function.password-hash.php" rel="nofollow noreferrer">password api</a>, there would be no reason not to use it, so maybe... (i would love to write the documentation for it)</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli: I would not agree to add the encryption step to the simplified hashing API. The reason is that the storage of secrets (keys) is a lot harder than people realize, and it's quite easy to shoot yourself in the foot. For 99.9% of the users out there, raw bcrypt is more than sufficient for all but the simplest passwords...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell - On the other side, you would loose nothing. In the worst case, when the key becomes known, an attacker must still crack the BCrypt hash (same situation as without encryption). This is not the same as storing a key for encrypting data, this is about adding a server-side secret. Even a hardcoded key would protect those weak passwords, as long as the attacker has no control over the server/code. This situation is not uncommon: aside from SQL-injection, also thrown away backups, discarded serversâ€¦ can lead to this situation. A lot of PHP users work on hosted servers.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli I would have to agree with ircmaxwell here, I dont think that encryption belongs in the password api. Although, it could be noted that for maximum security encrypting your hashes is an additional provision that can be used.</span></text><author><a class="comment-user" href="/users/896075/foochow" title="392 reputation">foochow</a></author></comment><comment><text><span class="comment-copy">I have a question regarding the encryption of output prior to storage. If I'm not mistaken, encryption keys are generally used to encrypt messages uniquely, or transiently. If however you have 200,000 user passwords all encrypted with the same key and stored together, doesn't that make it easier to attack the key? You now have 200,000 messages, compared to just 1 or 2.</span></text><author><a class="comment-user" href="/users/945775/agmlauncher" title="3,349 reputation">AgmLauncher</a></author></comment><comment><text><span class="comment-copy">Can't tell if "modificaitons" is intentional...</span></text><author><a class="comment-user" href="/users/601779/pricechild" title="313 reputation">PriceChild</a></author></comment><comment><text><span class="comment-copy">"""We know from past experience that "just feeding" one hash result into another hash function can decrease the overall security.""" - Tell me just one real world attack that is remotely relevant to the case described by Suhosin. Of course, doing stuff like Sha256(MD5(m)) basically nulls its collision resistance, but for password hashing even that would not be a problem. Regarding "Working Against Design": While it might be good to refer to bcrypt and scrypt, because that is what people are likely using, you ignore the original question.</span></text><author><a class="comment-user" href="/users/371137/perseids" title="5,020 reputation">Perseids</a></author></comment><comment><text><span class="comment-copy">Suhosin's <code>hash_function</code> only had one input and Suhosin referred to it as a secure hash function, which implies something like Sha256. And for secure hash function onewayness <i>is</i> an explicit design goal. You won't get a formal reduction proof, but it is absurd to believe that <code>$password |-&gt; hash_function($salt.hash_function($pepper.$password))</code> would be any less oneway than <code>password |-&gt; hash_function($salt.$password)</code>. And, referring to authority, Cryptography Engineering advises the use of Sha256(Sha256(m)) instead of a single application to counter the length extension property.</span></text><author><a class="comment-user" href="/users/371137/perseids" title="5,020 reputation">Perseids</a></author></comment><comment><text><span class="comment-copy">I do much like your argument, though, that encryption is better for the job, because it  allows easier management and is a tool that was simply made for the task of keeping data confidential. Also, for the case of password hashing, you have to try really hard to apply the encryption primitive wrongly. Even ECB mode would be fine. Regarding your complexity argument: I would still argue that statically prepending pepper to the password in e.g. a PHP 5.5 <code>password_hash</code> has <i>much</i> less complexity than using a  library like mcrypt to encrypt the password afterwards.</span></text><author><a class="comment-user" href="/users/371137/perseids" title="5,020 reputation">Perseids</a></author></comment><comment><text><span class="comment-copy">@Perseids I edited in a reference to a very real-world and practical attack from combining hash functions (specifically bcrypt(hash()) when hash() returns raw bytes). I'm definitely not saying you can never safely combine hash functions. I'm saying you shoudn't do it willy-nilly without research. As far as prepending a pepper to the password, that can cause issues (both with null bytes, and reducing available password space since bcrypt is limited to 72 character passwords). Why not just encrypt and be done with it rather than rolling more custom schemes?</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">Oh, silly me, I recognized that you call bcrypt a hash function for the purpose of this article in the very next bullet point, but didn't realize its use there. It's unfortunate that we call bcrypt a "password hash function" while it bears next to no resemblance to a cryptographic hash function (no arbitrary input values, no arbitrary input length). Again (like in "Working Against Design"), it's probably better to leave the paragraph like it is because many readers are quite likely to confuse bcrypt with a secure hash function. And with the added link the rest knows what you are talking about.</span></text><author><a class="comment-user" href="/users/371137/perseids" title="5,020 reputation">Perseids</a></author></comment><comment><text><span class="comment-copy">Re why not just use encryption: Because with encryption people are as likely to roll their own custom schemes (not in the sense of inventing their own cipher, but in the sense of plugging together components they know nothing about). While we would like to think encryption should be just as easy as password hashing, the dire reality is that most libraries are horrible. I've already alluded to PHP's mcrypt, but even the Java documentation is outright dangerous: <a href="http://docs.oracle.com/javase/7/docs/api/javax/crypto/CipherSpi.html" rel="nofollow noreferrer">Cipher.getInstance("DES/CBC/PKCS5Padding");</a></span></text><author><a class="comment-user" href="/users/371137/perseids" title="5,020 reputation">Perseids</a></author></comment><comment><text><span class="comment-copy">Now, as I've said above, encrypting hashed passwords is especially forgiving. But if it wasn't for bcrypts 72 bytes limit, I would gladly suggest prepending pepper to the password as the least complex (and thus more secure) <i>and</i> theoretically sound solution. And yes, I know you probably do not agree that preventing key rollover is worth the lessened complexity. I for one, are more afraid of all the ways the encryption code can go wrong than of the threat of a disclosed pepper.</span></text><author><a class="comment-user" href="/users/371137/perseids" title="5,020 reputation">Perseids</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Fist we should talk about the <strong>exact advantage of a pepper</strong>:</p>
<ul>
<li>The pepper can protect weak passwords from a dictionary attack, in the special case, where the attacker has read-access to the database (containing the hashes) but does not have access to the source code with the pepper.</li>
</ul>
<p>A typical scenario would be SQL-injection, thrown away backups, discarded servers... These situations are not as uncommon as it sounds, and often not under your control (server-hosting). If you use...</p>
<ul>
<li>A unique salt per password</li>
<li>A slow hashing algorithm like BCrypt</li>
</ul>
<p>...strong passwords are well protected. It's nearly impossible to brute force a strong password under those conditions, even when the salt is known. The problem are the weak passwords, that are part of a brute-force dictionary or are derivations of them. A dictionary attack will reveal those very fast, because you test only the most common passwords.</p>
<p>The second question is <strong>how to apply the pepper</strong> ?</p>
<p>An often recommended way to apply a pepper, is to combine the password and the pepper before passing it to the hash function:</p>
<pre><code>$pepperedPassword = hash_hmac('sha512', $password, $pepper);
$passwordHash = bcrypt($pepperedPassword);
</code></pre>
<p>There is another even better way though:</p>
<pre><code>$passwordHash = bcrypt($password);
$encryptedHash = encrypt($passwordHash, $serverSideKey);
</code></pre>
<p>This not only allows to add a server side secret, it also allows to exchange the $serverSideKey, should this be necessary. This method involves a bit more work, but if the code once exists (library) there is no reason not to use it.</p>
</div></text><author><a href="/users/575765/martinstoeckli">martinstoeckli</a></author><comments><comment><text><span class="comment-copy">So you'd say a pepper does add security over just a salt, in short? Thanks for the help on how to implement.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">@LightningDust - Yes it does, for weak passwords, as long as the pepper stays secret. It mitigates some well defined types of threats.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">Will probably accept this answer but I'll wait to see what else is posted. Have upvoted.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli definitely a good way to implement this. Good to see that someone with some security experience supports this method. Would a MySQL <code>AES_ENCRYPT($passwordHash, $serverSideKey)</code> call also be an appropriate way of implementing this?</span></text><author><a class="comment-user" href="/users/896075/foochow" title="392 reputation">foochow</a></author></comment><comment><text><span class="comment-copy">@Foo_Chow - I don't know the implementation of the MySQL function, but it seems that they used the EBC mode, to avoid the IV-vector. Together with the known plaintext (hash-values always start with the same characters), this could be a problem. On my <a href="http://www.martinstoeckli.ch/php/php.html#bcrypt" rel="nofollow noreferrer">homepage</a> i published an example implementation, that handles this encryption.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">@martinstoeckli interesting, not too familiar with the concepts; however seems like an IV would be desirable for the most robust results. Doesnt seem to add much overhead for the added benefit.</span></text><author><a class="comment-user" href="/users/896075/foochow" title="392 reputation">foochow</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The point of salt and pepper is to increase the cost of a pre-computed password lookup, called a rainbow table.</p>
<p>In general trying to find a collision for a single hash is hard (assuming the hash is secure). However, with short hashes, it is possible to use computer to generate all possible hashes into a lookup onto a hard disk. This is called a Rainbow Table. If you create a rainbow table you can then go out into the world and quickly find plausable passwords for any (unsalted unpeppered) hash.</p>
<p>The point of a pepper is to make the rainbow table needed to hack your password list unique. Thus wasting more time on the attacker to construct the rainbow table.</p>
<p>The point of the salt however is to make the rainbow table for each user be unique to the user, further increasing the complexity of the attack.</p>
<p>Really the point of computer security is almost never to make it (mathematically) impossible, just mathematically and physically impractical (for example in secure systems it would take all the entropy in the universe (and more) to compute a single user's password).</p>
</div></text><author><a href="/users/1808494/aron">Aron</a></author><comments><comment><text><span class="comment-copy">So does a salt+pepper offer any more security than just a salt? Or would I be better off dropping the pepper and running more iterations of scrypt?</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">The main thing about a rainbow table is that you don't create one for a specific attack, you download a pre-existing one.  There are lengthy rainbow tables available for popular hash algorithms just a google away!</span></text><author><a class="comment-user" href="/users/163495/richard" title="19,201 reputation">Richard</a></author></comment><comment><text><span class="comment-copy">@LightningDust I can't think of any reason myself. However Richard in the other thread came up with one. You can hide the pepper in your source code, which means another place your attacker needs to get access to, just to get a rainbow table together.</span></text><author><a class="comment-user" href="/users/1808494/aron" title="11,201 reputation">Aron</a></author></comment><comment><text><span class="comment-copy">@Aron - Well that's what I thought, since we have application servers separate from database servers (that is, if you get <code>root</code> on our db server, you still have no access to our application server), that hiding pepper in the source code (in our config file) would provide additional security.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Can't see storing a hardcoded value in your source code as having any security relevance. It's security through obscurity. </p>
<p>If a hacker acquires your database, he will be able to start brute forcing your user passwords. It won't take long for that hacker to identify your pepper if he manages to crack a few passwords.</p>
</div></text><author><a href="/users/1434613/sven">Sven</a></author><comments><comment><text><span class="comment-copy">It would make a precomputed rainbow table for an unsalted password table useless. In short, even if the attacker knew your pepper he would need to create a new rainbow table.</span></text><author><a class="comment-user" href="/users/1808494/aron" title="11,201 reputation">Aron</a></author></comment><comment><text><span class="comment-copy">It strengthens the hash based on data not available in the database, which is a good thing.  Things in the database can be potentially revealed in vulnerabilities - it's less likely that a value in the code will be accessed in the same way.</span></text><author><a class="comment-user" href="/users/163495/richard" title="19,201 reputation">Richard</a></author></comment><comment><text><span class="comment-copy">Salts are one way functions, even successfully brute-forcing a password would only give you that password, and would not help you to get the pepper value itself.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">MD5 example here using <code>md5($pepper.$password)</code> (note: I know not to use MD5 on a live site, this is for example purposes), my password is <code>cat</code>, my hash is <code>2d1ec2609e8265e64f2dbf6a697ebbfe</code>. What is my pepper? At very best here, all you can do is try to brute force my (typically 64-character) pepper.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">@LightningDust I think you mean "Hashes are trapdoor functions". Yes it is impossible to figure out your salt and/or pepper from a secure hash (in fact that is the definition of a secure hash).</span></text><author><a class="comment-user" href="/users/1808494/aron" title="11,201 reputation">Aron</a></author></comment><comment><text><span class="comment-copy">Interesting discussion. Never did suggest you could gather the password from the hash though. I think peppers generate more complexity, but not more security.</span></text><author><a class="comment-user" href="/users/1434613/sven" title="1,195 reputation">Sven</a></author></comment><comment><text><span class="comment-copy">@SvenAndersRobbestad - You did say "won't take long for that hacker to identify your pepper", which I believe to be factually incorrect. Even with 100 correct passwords and their resulting hashes, you wouldn't be left with any idea what the pepper is.</span></text><author><a class="comment-user owner" href="/users/2294775/glitch-desire" title="8,755 reputation">Glitch Desire</a></author></comment><comment><text><span class="comment-copy">@SvenAndersRobbestad actually complexity is security. We are talking about huge complexity numbers here. When all is said and done, with a good salt and a good pepper, even if you could magically convert every single proton in the universe into a hard disk, you couldn't store the resultant rainbow table.</span></text><author><a class="comment-user" href="/users/1808494/aron" title="11,201 reputation">Aron</a></author></comment><comment><text><span class="comment-copy">@SvenAndersRobbestad actually I think you are misunderstanding a key piece of security advise (security through obscurity is bad). This advise is not the whole truth. The correct workings is that all obscurity should be concentrated into a key and it is then a problem of securing your key. In this case a pepper is in a sense a cryptography key.</span></text><author><a class="comment-user" href="/users/1808494/aron" title="11,201 reputation">Aron</a></author></comment><comment><text><span class="comment-copy">@Aron Security Through Obscurity can be a valid technique used as a layer of defense. The point is that it should <b>never</b> be relied upon as a defense, but instead used to "slow an attacker down". If that was not the case, something like a honeypot would not be used. Instead, we can effectively make use of security through obscurity to help slow attackers down, as long as we're not relying on it for the security of our application.</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment></comments></answer></answers></post>