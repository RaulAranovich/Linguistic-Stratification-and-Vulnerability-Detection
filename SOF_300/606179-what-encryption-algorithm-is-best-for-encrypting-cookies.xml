<?xml version="1.0" encoding="utf-8"?>
<post><title>php - What encryption algorithm is best for encrypting cookies? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<blockquote>
<p>Since this question is rather popular, I thought it useful to give it an update.</p>
<p>Let me emphasise <strong>the correct answer</strong> as given by <a href="https://security.stackexchange.com/users/33/avid">AviD</a> to this question:
  <br/></p>
<p><strong>You should not store any data that needs encrypting in your cookie.</strong> Instead, store a good sized (128 bits/16 bytes) random key in the cookie and store the information you want to keep secure on the server, identified by the cookie's key.</p>
</blockquote>
<p><br/></p>
<hr/>
<p>I'm looking for information about 'the best' encryption algorithm for encrypting cookies.</p>
<p>I hava the following requirements:</p>
<ul>
<li><p>It must be fast<br/>
encrypting and decrypting the data will be done for (nearly) every request</p></li>
<li><p>It will operate on small data sets, typically strings of around 100 character or less</p></li>
<li><p>It must be secure, but it's not like we're securing banking transactions</p></li>
<li><p>We need to be able to decrypt the information so SHA1 and the like are out.</p></li>
</ul>
<p>Now I've read that Blowfish is fast and secure, and I've read that AES is fast and secure.
With Blowfish having a smaller block size. </p>
<p>I think that both algorithms provide more than adequate security? so the speed would then become the decisive factor.
But I really have no idea if those algorithm are suited for small character string and if there are maybe better suited algorithm for encrypting cookies.</p>
<p><strong>So my question is:</strong><br/>
What encryption algorithm is best for encrypting cookie data?</p>
<p><strong>Update</strong><br/>
To be more precise, we want to encrypt 2 cookie: one with session information and the other with 'remeber me' information.</p>
<p>The platform is PHP as apache module on Linux on a VPS.</p>
<p><strong>Update 2</strong><br/>
I agree with <a href="http://stackoverflow.com/users/18393/cletus">cletus</a> that storing any information in a cookie is insecure.</p>
<p>However, we have a requirement to implement a 'remeber me' feature. The accepted way to go about this is by setting a cookie. If the client presents this cookie, he or she is allowed access the system with (almost) equal rights as if he/she presented the valid username password combination.</p>
<p>So we at least want to encrypt all data in the cookie so that it:<br/>
<strong>a)</strong> malicious users can't read it's contents,<br/>
<strong>b)</strong> malicious users can't fabricate their own cookie or tamper with it.</p>
<p>(All data from cookies is sanitized and checked for validity before we do anything with it, but that's another story)</p>
<p>The session cookie contains a sessionId/timestamp nothing more. It could probably be used without encryption, but I see no harm in encrypting it? (other than computation time).</p>
<p><em>So given that we have to store some data on in a cookie, what is the best way to encrypt it?</em></p>
<p><strong>Update 3</strong><br/>
The responses to this question made me reconsider the chosen approach. I can indeed do the same without the need for encryption. Instead of encrypting the data, I should only send out data that is meaningless without it's context <em>and cannot be guessed</em>.</p>
<p><em>However, I'm also at a loss:</em><br/>
I thought that encryption enabled us send data out in to the BigBadWorld™, and still be (fairly) sure that nobody could read or tamper with the it...<br/>
Wasn't that the whole point of encryption?  </p>
<p>But the reactions below push toward: Do not trust encryption to accomplish security. </p>
<p><em>What am I missing??</em></p>
</div></text><author><a href="/users/-1/community">Community</a></author><comments><comment><text><span class="comment-copy">Regarding your Update 3 - Indeed, you <i>can</i> rely on encryption to protect the secrecy of your data, if you must...</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">However, note those two caveats: <i>IF</i> you must (but if you dont need to, dont bother with that <i>tiny</i> risk - if you need it you can still sleep safely...), and this only protects <i>secrecy</i>. As noted, there are still many other aspects to consider when regarding security.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>No real reason not to go with <a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noreferrer">AES</a> with 256 bits.  Make sure to use this in <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29" rel="noreferrer">CBC mode</a>, and PKCS#7 padding.
As you said, fast and secure. </p>
<p>I have read (not tested) that Blowfish may be marginally faster... However Blowfish has a major drawback of long setup time, which would make it bad for your situation. Also, AES is more "proven".  </p>
<p>This assumes that it really <em>is</em> necessary to symmetrically encrypt your cookie data. As others have noted, it really shouldnt be necessary, and there are only a few edge cases where there's no other choice but to do so. Commonly, it would better suit you to change the design, and go back to either random session identifiers, or if necessary one-way hashes (using SHA-256).<br/>
In your case, besides the "regular" random session identifier, your issue is the "remember me" feature - this should also be implemented as either:</p>
<ul>
<li>a long random number, stored in the database and mapped to a user account;</li>
<li>or a keyed hash (e.g. HMAC) containing e.g. the username, timestamp, mebbe a salt, AND a secret server key. This can of course all be verified server-side...</li>
</ul>
<p>Seems like we've gotten a little off topic of your original, specific question - and changed the basis of your question by changing the design....<br/>
So as long as we're doing that, I would also STRONGLY recommend <em>AGAINST</em> this feature of persistent "remember me", for several reasons, the biggest among them:</p>
<ul>
<li>Makes it much more likely that someone may steal that user's remember key, allowing them to spoof the user's identity (and then probably change his password);</li>
<li><a href="http://www.cgisecurity.com/csrf-faq.html" rel="noreferrer">CSRF</a> - <a href="http://www.owasp.org/index.php/Cross-Site_Request_Forgery" rel="noreferrer">Cross Site Request Forgery</a>. Your feature will effectively allow an anonymous attacker to cause unknowing users to submit "authenticated" requests to your application, even without being actually logged in.</li>
</ul>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">I'm aware of the dangers of the remember me feature, account damaging actions or password changes are not allowed without entering the password. also there is (some) CSRF protection as well, but other people using the same computer for example can login. We try to warn/educate our user about that.</span></text><author><a class="comment-user owner" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">In the end, no-one cares about privacy or security. That is why every large site from gmail to amazon has a "remember me" checkbox. People would rather lose data or be hacked than enter their passwords. So, give them what they want because all the people you are competing with already do.</span></text><author><a class="comment-user" href="/users/99923/xeoncross" title="22,901 reputation">Xeoncross</a></author></comment><comment><text><span class="comment-copy">+1 for info on how to encrypt.  However, I disagree that only edge cases require cookies to be encrypted.  More often than not it is advantageous to ensure the user hasn't modified some cookie value.  Encrypting the cookie is one way to ensure it hasn't been changed.  Now, being capture and the values used by a non-authorized person is an entirely different thing.</span></text><author><a class="comment-user" href="/users/2424/notme" title="71,002 reputation">NotMe</a></author></comment><comment><text><span class="comment-copy">@Chris, encryption does <i>not</i> ensure the cookie data has not been changed, encryption only protects <i>confidentiality</i> (secrecy), not <i>integrity</i>. For that, you're better off going with digital signatures, or more likely an HMAC.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">It would seem to me that if the cookie was modified then it would likely not be able to be decrypted by the server.  Or, if decrypted, the values would not make sense.  Correct?</span></text><author><a class="comment-user" href="/users/2424/notme" title="71,002 reputation">NotMe</a></author></comment><comment><text><span class="comment-copy">Actually, Bruce Schneier has a reason to not use 256. He recommends 128, instead. <a href="http://www.schneier.com/blog/archives/2009/07/another_new_aes.html" rel="nofollow noreferrer">schneier.com/blog/archives/2009/07/another_new_aes.html</a></span></text><author><a class="comment-user" href="/users/356016/n13" title="2,087 reputation">N13</a></author></comment><comment><text><span class="comment-copy">It's essential to add HMAC (encrypt-then-MAC). Else padding oracles will likely break confidentiality of AES-CBC. | @N13 As long as you use good random keys(as you should) there is no reason why AES-256 would be weaker than AES-128.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment><comment><text><span class="comment-copy">You did not mention anything about the advantages of "remember me": 1. You don't have to type your password again (everytime you type your password, there is a security risk) and 2. you don't have to send your password (in any form or shape, encrypted, zipped or whatever) again. If anyone intercepts any traffic, you are screwed either way. At least they won't be able to guess your password. -- What about making a minor client-side adjustment to the cookie every time you send it (and the server knowing of that protocol)? This way, simple spoofing won't work anymore.</span></text><author><a class="comment-user" href="/users/2228771/domi" title="7,187 reputation">Domi</a></author></comment><comment><text><span class="comment-copy">@CodesInChaos I've provided an answer that provides authenticated encryption :)</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>This is touching on two separate issues.</p>
<p>Firstly, <strong>session hijacking</strong>.  This is where a third party discovers, say, an authenticated cookie and gains access to someone else's details.</p>
<p>Secondly, there is <strong>session data security</strong>.  By this I mean that you store data in the cookie (such as the username).  This is not a good idea.  Any such data is fundamentally untrustworthy just like HTML form data is untrustworthy (irrespective of what Javascript validation and/or HTML length restrictions you use, if any) because a client is free to submit what they want.</p>
<p>You'll often find people (rightly) advocating sanitizing HTML form data but cookie data will be blindly accepted on face value.  Big mistake.  In fact, I never store any information in the cookie.  I view it as a session key and that's all.</p>
<p><strong>If you intend to store data in a cookie I strongly advise you to reconsider.</strong></p>
<p>Encryption of this data does not make the information any more trustworth because symmetric encryption is susceptible to brute-force attack.  Obviously AES-256 is better than, say, DES (heh) but 256-bits of security doesn't necessarily mean as much as you think it does.</p>
<p>For one thing, SALTs are typically generated according to an algorithm or are otherwise susceptible to attack.</p>
<p>For another, cookie data is a prime candidate for <a href="http://en.wikipedia.org/wiki/Crib_%28cryptanalysis%29" rel="noreferrer">crib</a> attacks.  If it is known or suspected that a username is in the encrypted data will hey, there's your crib.</p>
<p>This brings us back to the first point: hijacking.</p>
<p>It should be pointed out that on shared-hosting environments in PHP (as one example) your session data is simply stored on the filesystem and is readable by anyone else on that same host although they don't necessarily know which site it is for.  So never store plaintext passwords, credit card numbers, extensive personal details or anything that might otherwise be deemed as sensitive in session data in such environments without some form of encryption or, better yet, just storing a key in the session and storing the actual sensitive data in a database.</p>
<p><strong>Note:</strong> the above is not unique to PHP.</p>
<p>But that's server side encryption.</p>
<p>Now you could argue that encrypting a session with some extra data will make it more secure from hijacking.  A common example is the user's IP address.  Problem is many people use the same PC/laptop at many different locations (eg Wifi hotspots, work, home).  Also many environments will use a variety of IP addresses as the source address, particularly in corporate environments.</p>
<p>You might also use the user agent but that's guessable.</p>
<p>So really, as far as I can tell, there's no real reason to use cookie encryption at all.  I never did think there was but in light of this question I went looking to be proven either right or wrong.  I found a few threads about people suggesting ways to encrypt cookie data, transparently do it with Apache modules, and so on but these all seemed motivated by protecting data stored in a cookie (which imho you shouldn't do).</p>
<p>I've yet to see a security argument for encrypting a cookie that represents nothing more than a session key.</p>
<p>I will happily be proven wrong if someone can point out something to the contrary.</p>
</div></text><author><a href="/users/18393/cletus">cletus</a></author><comments><comment><text><span class="comment-copy">see update; 1 cookie with session information and 1 'remember me' cookie</span></text><author><a class="comment-user owner" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">256 bits provides a LOT of protection, plenty for most uses, more than enough for this situation. That's assuming, of course, that we're talking about 256 bits of RANDOM data... nobody's gonna be cracking that any century soon.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">Secondly, neither salts (which ARE supposed to be random) nor "crib" (aka known plaintext) attacks are (currently) relevant to AES.    Overall, there is NO reason to assume or consider that your AES-encrypted data will be decrypted, unless this is an implementation problem (which IS likely ;-) )</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">That all said (and I really think 300 chars is too short for comments ;-) ), I agree with the point that it shouldnt need to be encrypted in the first place.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Security Warning</strong>: These two functions are not secure. They're using <a href="https://blog.filippo.io/the-ecb-penguin/" rel="nofollow">ECB mode</a> and fail to <a href="https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly" rel="nofollow">authenticate the ciphertext</a>. See <a href="http://stackoverflow.com/a/30189841/2224584">this answer</a> for a better way forward.</p>
</blockquote>
<p>For those reading through wanting to use this method in PHP scripts. Here is a working example using 256bit Rijndael (not AES).</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> encrypt</span><span class="pun">(</span><span class="pln">$text</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">)</span><span class="pln"> 
</span><span class="pun">{</span><span class="pln"> 
    </span><span class="kwd">return</span><span class="pln"> trim</span><span class="pun">(</span><span class="pln">base64_encode</span><span class="pun">(</span><span class="pln">mcrypt_encrypt</span><span class="pun">(</span><span class="pln">MCRYPT_RIJNDAEL_256</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">,</span><span class="pln"> $text</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">,</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="pln">mcrypt_get_iv_size</span><span class="pun">(</span><span class="pln">MCRYPT_RIJNDAEL_256</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">),</span><span class="pln"> MCRYPT_RAND</span><span class="pun">))));</span><span class="pln"> 
</span><span class="pun">}</span><span class="pln"> 

</span><span class="kwd">function</span><span class="pln"> decrypt</span><span class="pun">(</span><span class="pln">$text</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">)</span><span class="pln"> 
</span><span class="pun">{</span><span class="pln"> 
    </span><span class="kwd">return</span><span class="pln"> trim</span><span class="pun">(</span><span class="pln">mcrypt_decrypt</span><span class="pun">(</span><span class="pln">MCRYPT_RIJNDAEL_256</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">,</span><span class="pln"> base64_decode</span><span class="pun">(</span><span class="pln">$text</span><span class="pun">),</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">,</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="pln">mcrypt_get_iv_size</span><span class="pun">(</span><span class="pln">MCRYPT_RIJNDAEL_256</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">),</span><span class="pln"> MCRYPT_RAND</span><span class="pun">)));</span><span class="pln"> 
</span><span class="pun">}</span></code></pre>
<p>Then to save the cookie</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">setcookie</span><span class="pun">(</span><span class="str">"PHPSESSION"</span><span class="pun">,</span><span class="pln"> encrypt</span><span class="pun">(</span><span class="str">'thecookiedata'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'longsecretsalt'</span><span class="pun">));</span></code></pre>
<p>and to read on the next page:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$data </span><span class="pun">=</span><span class="pln"> decrypt</span><span class="pun">(</span><span class="pln">$_COOKIE</span><span class="pun">[</span><span class="str">'PHPSESSION'</span><span class="pun">],</span><span class="pln"> </span><span class="str">'longsecretsalt'</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/99923/xeoncross">Xeoncross</a></author><comments><comment><text><span class="comment-copy"><b>Update: use CBC mode instead of ECB!</b> Google to see why!</span></text><author><a class="comment-user" href="/users/99923/xeoncross" title="22,901 reputation">Xeoncross</a></author></comment><comment><text><span class="comment-copy">The proposed function is vulnerable to manipulation, as it has no ciphertext integrity protection. See <a href="http://ipsec.pl/node/1085" rel="nofollow noreferrer">ipsec.pl/node/1085</a> for details.</span></text><author><a class="comment-user" href="/users/1274149/kravietz" title="3,496 reputation">kravietz</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can achieve what you want securely by using AES in EAX mode.  The ciphertext will be larger than the plaintext; that's normal for secure encryption.</p>
<p>The attacker will of course know the length of your plaintext from the ciphertext, but they shouldn't be able to determine anything else.</p>
<p>Generate AES keys randomly.</p>
<p>Be sure and use a fresh nonce for each encryption, and use the "associated data" field to ensure that a thing you encrypted for one purpose isn't presented as being for another (so things like the user name and cookie name could go in there)</p>
<blockquote>
<p>the reactions below push toward: Do
  not trust encryption to accomplish
  security.</p>
</blockquote>
<p>More "if you're not an encryption expert you'll underestimate how easy it is to get wrong".  For example, AFAICT no-one else in this thread has discussed chaining modes or message integrity, which covers two common beginner's mistakes.</p>
</div></text><author><a href="/users/123045/paul-crowley">Paul Crowley</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<h2>Fast, Encrypted Cookies with Libsodium</h2>
<p>If you need fast, secure encrypted cookies in PHP, check out how <a href="https://github.com/paragonie/halite" rel="nofollow">Halite</a> implements them. Halite relies on <a href="https://pecl.php.net/package/libsodium" rel="nofollow">the libsodium PECL extension</a> to provide secure cryptography.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
</span><span class="kwd">use</span><span class="pln"> \ParagonIE\Halite\Cookie</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">use</span><span class="pln"> \ParagonIE\Halite\Symmetric\Key</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">use</span><span class="pln"> \ParagonIE\Halite\Symmetric\SecretKey</span><span class="pun">;</span><span class="pln">

</span><span class="com">// You can also use Key::deriveFromPassword($password, $salt, Key::CRYPTO_SECRETBOX);</span><span class="pln">
$encryption_key </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SecretKey</span><span class="pun">(</span><span class="pln">$some_constant_32byte_string_here</span><span class="pun">);</span><span class="pln">

$cookie </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Cookie</span><span class="pun">(</span><span class="pln">$encryption_key</span><span class="pun">);</span><span class="pln">

$cookie</span><span class="pun">-&gt;</span><span class="pln">store</span><span class="pun">(</span><span class="str">'index'</span><span class="pun">,</span><span class="pln"> $any_value</span><span class="pun">);</span><span class="pln">
$some_value </span><span class="pun">=</span><span class="pln"> $cookie</span><span class="pun">-&gt;</span><span class="pln">fetch</span><span class="pun">(</span><span class="str">'other_index'</span><span class="pun">);</span></code></pre>
<p>If you cannot install PECL extensions, ask your sysadmin or hosting provider to do it for you. If they refuse, you still have options.</p>
<hr/>
<h2>Secure Encrypted Cookies in PHP, Hold the Salt Please</h2>
<p>The other answers instruct you to encrypt your data with openssl or mcrypt, but they're missing a crucial step. If you want to <a href="https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly" rel="nofollow">safely encrypt data in PHP</a>, you <em>must</em> authenticate your messages.</p>
<p>Using the OpenSSL extension, the process you would need to follow looks like this:</p>
<hr/>
<h3>Preamble</h3>
<ul>
<li><p>(Before you even think about encryption) Generate a 128-bit, 192-bit, or 256-bit random string. This will be your <strong>master key</strong>. </p>
<p><strong>Do not use a human-readable password.</strong> If you, for some reason, <em>must</em> use a human-readable password, ask <a href="http://crypto.stackexchange.com">Cryptography SE</a> for guidance.</p>
<p>If you need special attention, my employer offers <a href="https://paragonie.com/service/technology-consulting" rel="nofollow">technology consulting services</a>, including development of cryptography features.</p></li>
</ul>
<h3>Encryption</h3>
<ol>
<li>Generate a random Initialization Vector (IV) or nonce. e.g. <code>random_bytes(openssl_cipher_iv_length('aes-256-cbc'))</code></li>
<li>Use <a href="https://github.com/defuse/php-encryption/blob/d2c33279e31d5f3d4b74a82139b6ce56d551965b/src/Crypto.php#L331-L397" rel="nofollow">HKDF</a> or a similar algorithm for splitting your master key  into two keys:

<ol>
<li>An encryption key (<code>$eKey</code>)</li>
<li>An authentication key (<code>$aKey</code>)</li>
</ol></li>
<li>Encrypt your string with <code>openssl_encrypt()</code> with your IV and an appropriate modate (e.g. <code>aes-256-ctr</code>) using your encryption key (<code>$eKey</code>) from step 2.</li>
<li>Compute an authentication tag of your ciphertext from step 3, using a keyed hash function such as HMAC-SHA256. e.g. <code>hash_hmac('sha256', $iv.$ciphertext, $aKey)</code>. <strong>It's very important to authenticate after encryption, and to encapsulate the IV/nonce as well.</strong></li>
<li>Package the authentication tag, IV or nonce, and ciphertext together and optionally encode it with <code>bin2hex()</code> or <code>base64_encode()</code>. (Warning: This approach <em>might</em> leak cache-timing information.)</li>
</ol>
<h3>Decryption</h3>
<ol>
<li>Split your key, as per step 2 in encryption. We need the same two keys during decryption!</li>
<li>(Optionally, decode and) unpack the MAC, IV, and ciphertext from the packed message.</li>
<li>Verify the authentication tag by recalculating the HMAC of the IV/nonce and ciphertext with the user-provided HMAC by using <a href="https://secure.php.net/hash_equals" rel="nofollow"><code>hash_equals()</code></a>.</li>
<li>If and only if step 3 passes, decrypt the ciphertext using <code>$eKey</code>.</li>
</ol>
<p>If you want to see how this all looks together, see <a href="http://stackoverflow.com/a/30189841/2224584">this answer which has sample code</a>.</p>
<p>If this sounds like too much work, use <a href="https://github.com/defuse/php-encryption" rel="nofollow">defuse/php-encryption</a> or <a href="https://github.com/zendframework/zend-crypt" rel="nofollow">zend-crypt</a> and call it a day.</p>
<hr/>
<h2>Remember Me Cookies</h2>
<blockquote>
<p>However, we have a requirement to implement a 'remeber me' feature. The accepted way to go about this is by setting a cookie. If the client presents this cookie, he or she is allowed access the system with (almost) equal rights as if he/she presented the valid username password combination.</p>
</blockquote>
<p>Encryption is actually not the correct tool for this job. You want to follow this process for <a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2" rel="nofollow">secure remember me cookies in PHP</a>:</p>
<h3>Generating a Remember Me Token</h3>
<ol>
<li>Generate two random strings:

<ol>
<li>A <code>selector</code> which will be used for database lookups. (The purpose of a random selector instead of just a sequential ID is to <em>not</em> leak how many active users are on your website. If you're comfortable leaking this information, feel free to just use a sequential ID.)</li>
<li>A <code>validator</code> which will be used to authenticate the user automatically.</li>
</ol></li>
<li>Calculate a hash of <code>validator</code> (a simple SHA-256 hash will suffice).</li>
<li>Store the <code>selector</code> and the hash of the <code>validator</code> in a database table reserved for automatic logins.</li>
<li>Store the <code>selector</code> and <code>validator</code> in a cookie on the client.</li>
</ol>
<h3>Redeeming a Remember Me Token</h3>
<ol>
<li>Split the incoming cookie into the <code>selector</code> and <code>validator</code>.</li>
<li>Perform a database lookup (use <a href="http://stackoverflow.com/a/60496/2224584">prepared statements</a>!) based on <code>selector</code>.</li>
<li>If a row is found, calculate a hash of the <code>validator</code>.</li>
<li>Compare the hash calculated in step 3 with the hash stored in the database, once again using <a href="https://secure.php.net/hash_equals" rel="nofollow"><code>hash_equals()</code></a>.</li>
<li>If step 4 returns true, log the user in to the appropriate account.</li>
</ol>
<p>This is the strategy that <a href="https://github.com/psecio/gatekeeper" rel="nofollow">Gatekeeper</a> adopted for long-term user authentication and it is the most secure strategy proposed to date for satisfying this requirement.</p>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>While both a very strong ones, AES is a standard. </p>
<p>As for security of small chunks of data: the smaller - the better. The less encrypted data is exposed, the longer you can use the key. There is always a theoretical limit of how much data can be encrypted within one key of given algorithm without exposing system to risks.</p>
</div></text><author><a href="/users/69802/inazaruk">inazaruk</a></author><comments><comment><text><span class="comment-copy">For AES that limit is around 2^68 bytes, so there is little reason to worry with realistic amounts of data. And even those weaknesses are pretty small.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Why do you want to encrypt the cookie?</p>
<p>As I see it, there are two cases: either you give the client the key, or you don't.</p>
<p>If you don't give the key to the client, then why are you giving them the data?  Unless you're playing some weird game with breaking weak encryption (which you're explicitly not), you might as well store the data on the server.</p>
<p>If you <em>do</em> hand the client the key, then why do you encrypt it in the first place?  If you don't encrypt the communication of the key, then encrypting the cookie is moot: a MITM can look at the cookie and send you any cookie he wants.  If you use an encrypted channel to the client, why the extra overhead of encrypting the stored data?</p>
<p>If you're worried about other users on the client's machine reading the cookie, give up and assume the browser sets good permission bits :)</p>
</div></text><author><a href="/users/58668/jonas-k%c3%b6lker">Jonas Kölker</a></author><comments><comment><text><span class="comment-copy">"give up and assume the browser sets good permission bits" I've given up on making any assumptions about correct browser behaviour.</span></text><author><a class="comment-user owner" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">point taken :D  What I think I meant was: that's not your responsibility.  Defer it to those whom it belongs to.  It feels like taking on that responsibility would be adding crap to work around other crap.  I'd rather see a world with less crap :D  <i>sigh</i>...  I hate software right now ;)</span></text><author><a class="comment-user" href="/users/58668/jonas-k%c3%b6lker" title="5,417 reputation">Jonas Kölker</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you encrypt the cookie, the  server still has to decode  it to read it (to check for same key), therefore any encrypted cookie is pointless, because if stolen (and un-edited) it will still lead the hacker right to your account. Its just as unsafe as no encrypted at all. </p>
<p>I believe the real issue of someone stealing your cookie is the connection between the server and client. Use SSL connection provided by your host. </p>
<p>As for your cookie, you need to  make a long random id per user in the database, (have it change every log on) and just set that as the cookie or session. The cookie that contains the key can be checked via php and if it is equal to an account or table in your database, dump the data on the web page like normal.</p>
</div></text><author><a href="/users/188490/mike">mike</a></author><comments><comment><text><span class="comment-copy">Yes, but the contents of that cookie is still secure.</span></text><author><a class="comment-user owner" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As pointed out a few times in previous comments, you <strong>must</strong> apply <strong>integrity protection</strong> to any ciphertext that you send out to the user and accept back. Otherwise the protected data can be modified, or the encryption key recovered. </p>
<p>Especially the PHP world is full of bad examples that ignore this (see <a href="http://ipsec.pl/node/1085" rel="nofollow">PHP cryptography - proceed with care</a>) but this does apply to any language. </p>
<p>One of few good examples I've seen is <a href="https://github.com/ircmaxell/PHP-CryptLib" rel="nofollow">PHP-CryptLib</a> which uses combined encryption-authentication mode to do the job. For Python <a href="http://ipsec.pl/node/732" rel="nofollow">pyOCB</a> offers similar functionality.</p>
</div></text><author><a href="/users/1274149/kravietz">kravietz</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>AES (also known as Rijndael) is the most popular. The block size is 128-bits, that's only 16-bytes, and you're talking "around 100 characters".</p>
</div></text><author><a href="/users/60711/vartec">vartec</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I think that "giving away" any data even encrypted when it is about username and password is not good ...
There are many JS that can sniff it ...
I suggest you create in users DB table a field cookie_auth or whatever ...</p>
<p>after first login gather : current: browser, IP,ans some own salt key, plus your hostname var ...</p>
<p>create a hash and store in that field ...
set a cookie ...
when cookie "responds" compare all of these with the stored hash and done ...</p>
<p>even if someone "steal" a cookie they won't be able to use it :-)</p>
<p>Hope this helps :-)</p>
<p>feha
vision.to</p>
</div></text><author><a href="/users/168817/feha">Feha</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>In addition, I have tried the <code>mcrypt_encrypt</code> and one thing please keep in mind.  If you do <code>base64_encode(mcrypt_encrypt(...))</code>. </p>
<p>and then later, you do <code>base64_decode</code>  and output the encrypted data (<code>echo</code>).  You probably will be screwed and not seeing anything.  However, if you do    <code>mcrypt_decrypt( ... base64_decode($value) )</code>.  You will see the original data. </p>
</div></text><author><a href="/users/196874/murvinlai">murvinlai</a></author><comments/></answer></answers></post>