<?xml version="1.0" encoding="utf-8"?>
<post><title>javascript - Is JSON Hijacking still an issue in modern browsers? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am using Backbone.js and the Tornado web server.  The standard behavior for receiving collection data in Backbone is to send as a JSON Array.</p>
<p>On the other hand, Tornado's standard behavior is to not allow JSON Array's due to the following vulnerability:</p>
<p><a href="http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx">http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx</a></p>
<p>A related one is:
<a href="http://haacked.com/archive/2009/06/25/json-hijacking.aspx">http://haacked.com/archive/2009/06/25/json-hijacking.aspx</a></p>
<p>It feels more natural for me to not have to wrap up my JSON in an object when it really is a list of objects.</p>
<p>I was unable to reproduce these attacks in modern browsers (i.e. current Chrome, Firefox, Safari, and IE9).  At the same time I was unable to confirm anywhere that modern browsers had addressed these issues.</p>
<p>To ensure that I am not mislead by any possible poor programming-skills nor poor googling-skills:</p>
<p><strong>Are these JSON Hijacking attacks still an issue today in modern browsers?</strong></p>
<p>(Note:  Sorry for the possible duplicate to: <a href="http://stackoverflow.com/questions/8587567/is-it-possible-to-do-json-hijacking-on-modern-browser">Is it possible to do 'JSON hijacking' on modern browser?</a>  but since the accepted answer does not seem to answer the question - I thought it was time to ask it again and get some clearer explanations.)</p>
</div></text><author><a href="/users/707111/ryan">Ryan</a></author><comments><comment><text><span class="comment-copy">using eval ? then possible otherwise No. If nothing has been altered or changed in way backbone parses response then you should be safe</span></text><author><a class="comment-user" href="/users/571507/deeptechtons" title="5,424 reputation">Deeptechtons</a></author></comment><comment><text><span class="comment-copy">Generally speaking, you should never approach web security with the assumption that someone is going to be using a "modern" browser.</span></text><author><a class="comment-user" href="/users/875758/luke" title="486 reputation">Luke</a></author></comment><comment><text><span class="comment-copy">@Luke - See below comment to Reid.  Great point in general - but I'm not asking a general security question. (My users will only be able to authenticate if they are using a modern browser in the first place.)</span></text><author><a class="comment-user owner" href="/users/670654/rocketman" title="1,209 reputation">Rocketman</a></author></comment><comment><text><span class="comment-copy">These vulnerabilities were found already in 2006 when gmail was hacked: <a href="http://jeremiahgrossman.blogspot.se/2006/01/advanced-web-attack-techniques-using.html" rel="nofollow noreferrer">jeremiahgrossman.blogspot.se/2006/01/…</a></span></text><author><a class="comment-user" href="/users/306139/mikewse" title="177 reputation">mikewse</a></author></comment><comment><text><span class="comment-copy">@Luke, sometimes we have to move on and allow us to develop with modern patterns (such as REST in this case : obtaining data is a GET operation and should not be something else) without protecting against old threats if they now appear to apply only to a small audience. So this question is really valuable, to allow one to evaluate whether he can ignore this threat or not for his application case. At some point, user with very obsolete software are quite likely to have other kind of threats (malware) from which we will not be able to protect them anyway.</span></text><author><a class="comment-user" href="/users/1178314/fr%c3%a9d%c3%a9ric" title="4,289 reputation">Frédéric</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>No, it is no longer possible to capture values passed to the <code>[]</code> or <code>{}</code> constructors in Firefox 21, Chrome 27, or IE 10. Here's a little test page, based on the main attacks described in <a href="http://www.thespanner.co.uk/2011/05/30/json-hijacking/">http://www.thespanner.co.uk/2011/05/30/json-hijacking/</a>:</p>
<p><a href="http://jsfiddle.net/ph3Uv/2/">http://jsfiddle.net/ph3Uv/2/</a></p>
<p>It overrides <code>window.Array</code> and adds a setter to <code>Object.prototype.foo</code> and tests initializing arrays and objects via the short and long forms.</p>
<p>The <a href="http://www.ecmascript.org/es4/spec/incompatibilities.pdf">ES4 spec</a>, in section 1.5, "requires the global, standard bindings of Object and Array to be used to construct new objects for object and array initializers" and notes in Implementation Precedent that "Internet Explorer 6, Opera 9.20, and Safari 3 do not respect either local or global rebindings of Object and Array, but use the original Object and Array constructors." This is retained in <a href="http://ecma-international.org/ecma-262/5.1/#sec-11.1.4">ES5, section 11.1.4</a>.</p>
<p><a href="https://mail.mozilla.org/pipermail/es-discuss/2010-December/012494.html">Allen Wirfs-Brock explained</a> that ES5 also specifies that object initialization should not trigger setters, as it uses DefineOwnProperty. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects?redirectlocale=en-US&amp;redirectslug=JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters">MDN: Working with Objects</a> notes that "Starting in JavaScript 1.8.1, setters are no longer called when setting properties in object and array initializers." This was addressed in <a href="http://code.google.com/p/v8/issues/detail?id=1015">V8 issue 1015</a>.</p>
</div></text><author><a>NONE</a></author><comments><comment><text><span class="comment-copy">Back in 2009 Brendan Eich suggested that browsers not evaluate scripts served as application/json (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=376957#c75" rel="nofollow noreferrer">bugzilla.mozilla.org/show_bug.cgi?id=376957#c75</a>), which still seems like a good idea to me.</span></text><author><span class="comment-user">user69173</span></author></comment><comment><text><span class="comment-copy">Note that blind POST CSRF is still possible using forms, particularly with the text/plain encoding, and needs to be defeated using tokens/nonces.</span></text><author><span class="comment-user">user69173</span></author></comment><comment><text><span class="comment-copy">Yes to the POST CSRF.  Thanks for all of your great info here.</span></text><author><a class="comment-user owner" href="/users/670654/rocketman" title="1,209 reputation">Rocketman</a></author></comment><comment><text><span class="comment-copy">What about IE8?</span></text><author><a class="comment-user" href="/users/2653/nick-retallack" title="9,739 reputation">Nick Retallack</a></author></comment><comment><text><span class="comment-copy">@NickRetallack : I believe that IE has always used the built-in bindings for {} and [], but I suggest you check my test page.</span></text><author><span class="comment-user">user69173</span></author></comment><comment><text><span class="comment-copy">Why did you reference the ES4 spec at all? ES4 was abandoned. We went directly from ES3.1 to ES5.</span></text><author><a class="comment-user" href="/users/11398/stimpy77" title="4,240 reputation">stimpy77</a></author></comment><comment><text><span class="comment-copy">Only because it was the chronological introduction of that requirement.</span></text><author><span class="comment-user">user69173</span></author></comment><comment><text><span class="comment-copy">Your statement is correct when it refers to only simply overwriting of the Array constructor. Microsofts IE and Edge are still vulnerable to the UTF-7 JSON Hijacking though. Tested it recently (and for fun today again), and it still works.</span></text><author><a class="comment-user" href="/users/857990/user857990" title="327 reputation">user857990</a></author></comment></comments></answer></answers></post>