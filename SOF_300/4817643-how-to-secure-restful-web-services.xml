<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How to secure RESTful web services? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I have to implement secure <a href="https://www.ibm.com/developerworks/webservices/library/ws-restful/" rel="noreferrer">RESTful web services</a>. I already did some research using Google but I'm stuck.</p>
<p>Options:</p>
<p>TLS (HTTPS) +</p>
<ul>
<li>HTTP Basic (pc1oad1etter)</li>
<li>HTTP Digest </li>
<li><a href="http://stackoverflow.com/questions/4239846/2-legged-oauth-and-rest">two-legged</a> <a href="https://github.com/Mashape/mashape-oauth/blob/master/FLOWS.md" rel="noreferrer">OAuth</a></li>
<li><a href="http://stackoverflow.com/questions/319530/restful-authentication">a Cookie-based approach</a></li>
<li>client certificates (Tom Ritter and <a href="http://stackoverflow.com/questions/1522368/solutions-to-web-service-client-certificates-auth-best-practices">here</a>)</li>
<li>Signed requests using <a href="http://en.wikipedia.org/wiki/HMAC" rel="noreferrer">HMAC</a> and <a href="http://s3.amazonaws.com/doc/s3-developer-guide/RESTAuthentication.html" rel="noreferrer">a limited lifetime</a></li>
</ul>
<p>Are there more possible options to consider? If OAuth then what version? Does it even matter? From what I've read so far <a href="http://tools.ietf.org/pdf/draft-ietf-oauth-v2-12.pdf" rel="noreferrer">OAuth 2.0</a> with bearer tokens (that is without signatures) seems to be <a href="http://hueniverse.com/2010/09/oauth-bearer-tokens-are-a-terrible-idea/" rel="noreferrer">insecure</a>.</p>
<p>I've found another very interesting article on <a href="http://www.berenddeboer.net/rest/authentication.html" rel="noreferrer">REST based authentication</a>.</p>
<p><a href="https://www.stormpath.com/blog/secure-your-rest-api-right-way" rel="noreferrer">Secure Your REST API... The Right Way</a></p>
</div></text><author><a href="/users/218471/jan-deinhard">Jan Deinhard</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>There's another, very secure method.  It's client certificates.  Know how servers present an SSL Cert when you contact them on https?  Well servers can request a cert from a client so they know the client is who they say they are.  Clients generate certs and give them to you over a secure channel (like coming into your office with a USB key - preferably a non-trojaned USB key).</p>
<p>You load the <strike>public key of the cert</strike> client certificates (and their signer's certificate(s), if necessary) into your web server, and the web server won't accept connections from anyone <em>except</em> the people who have the corresponding private keys for the certs it knows about.  It runs on the HTTPS layer, so you may even be able to completely skip application-level authentication like OAuth (depending on your requirements).  You can abstract a layer away and create a local Certificate Authority and sign Cert Requests from clients, allowing you to skip the 'make them come into the office' and 'load certs onto the server' steps.</p>
<p>Pain the neck?  Absolutely.  Good for everything? Nope.  Very secure? Yup.  </p>
<p>It does rely on clients keeping their certificates safe however (they can't post their private keys online), and it's usually used when you sell a service to clients rather then letting anyone register and connect.</p>
<p>Anyway, it may not be the solution you're looking for (it probably isn't to be honest), but it's another option.</p>
</div></text><author><a href="/users/8435/tom-ritter">Tom Ritter</a></author><comments><comment><text><span class="comment-copy">Okay, now I am confused which one is better, this approach or <a href="http://stackoverflow.com/a/4819214/1197317">another answer</a>. Could you elaborate? :D</span></text><author><a class="comment-user" href="/users/1197317/borntocode" title="1,033 reputation">BornToCode</a></author></comment><comment><text><span class="comment-copy">Your answer would be perfect for masters but its confusing for novice. Can you please provide some detail information or links to read upon?</span></text><author><a class="comment-user" href="/users/829194/rajan-rawal" title="2,979 reputation">Rajan Rawal</a></author></comment><comment><text><span class="comment-copy">If the certificates are self-signed, is it still "very secure"?</span></text><author><a class="comment-user" href="/users/804702/joyce" title="103 reputation">Joyce</a></author></comment><comment><text><span class="comment-copy">@Joyce I would think not.  Since you are not trusted (no offense), the certs that you sign (with your own cert) cannot be trusted.  I believe self signed certs are more useful for testing.</span></text><author><a class="comment-user" href="/users/3102471/mbmast" title="412 reputation">mbmast</a></author></comment><comment><text><span class="comment-copy">Given the end user (customer) has a client cert whose public key is shared with the server, doesn't the whole "very secure" thing fall apart if the customer's machine is hacked and their client cert stolen?</span></text><author><a class="comment-user" href="/users/3102471/mbmast" title="412 reputation">mbmast</a></author></comment><comment><text><span class="comment-copy">@Rajan Rawal: the Java tutorial gives a good explanation of authentication with client certificates, including mutual authentication with client certs (ie server authenticates client, client authenticates server). see: <a href="https://docs.oracle.com/cd/E19226-01/820-7627/bncbs/index.html" rel="nofollow noreferrer">Certificate authentication tutorial</a></span></text><author><a class="comment-user" href="/users/1197297/mangotang" title="1,096 reputation">mangotang</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>HTTP Basic + HTTPS is one common method.</p>
</div></text><author><a href="/users/525/pc1oad1etter">pc1oad1etter</a></author><comments><comment><text><span class="comment-copy">TLS is a must of course. Thanks for bringing this up!</span></text><author><a class="comment-user owner" href="/users/218471/jan-deinhard" title="7,477 reputation">Jan Deinhard</a></author></comment><comment><text><span class="comment-copy">I don't think that http digest is giving you anything over http basic if they are both over https.</span></text><author><a class="comment-user" href="/users/525/pc1oad1etter" title="4,827 reputation">pc1oad1etter</a></author></comment><comment><text><span class="comment-copy">You are welcome to add helpful information about HTTP digest's benefits without the tone, seriously.</span></text><author><a class="comment-user" href="/users/525/pc1oad1etter" title="4,827 reputation">pc1oad1etter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If choosing between OAuth versions, go with OAuth 2.0.</p>
<p>OAuth bearer tokens should only be used with a secure transport.</p>
<p>OAuth bearer tokens are only as secure or insecure as the transport that encrypts the conversation. HTTPS takes care of protecting against replay attacks, so it isn't necessary for the bearer token to also guard against replay.  </p>
<p>While it is true that if someone intercepts your bearer token they can impersonate you when calling the API, there are plenty of ways to mitigate that risk. If you give your tokens a long expiration period and expect your clients to store the tokens locally, you have a greater risk of tokens being intercepted and misused than if you give your tokens a short expiration, require clients to acquire new tokens for every session, and advise clients not to persist tokens.</p>
<p>If you need to secure payloads that pass through multiple participants, then you need something more than HTTPS/SSL, since HTTPS/SSL only encrypts one link of the graph. This is not a fault of OAuth.</p>
<p>Bearer tokens are easy to for clients to obtain, easy for clients to use for API calls and are widely used (with HTTPS) to secure public facing APIs from Google, Facebook, and many other services.</p>
</div></text><author><a href="/users/301152/dthorpe">dthorpe</a></author><comments/></answer></answers></post>