<?xml version="1.0" encoding="utf-8"?>
<post><title>security - What is currently the most secure one-way encryption algorithm? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>As many will know, one-way encryption is a handy way to encrypt user passwords in databases. That way, even the administrator of the database cannot know a user's password, but will have to take a password guess, encrypt that with the same algorithm and then compare the result with the encrypted password in the database. This means that the process of figuring out the password requires massive amounts of guesses and a lot of processing power.</p>
<p>Seeing that computers just keep getting faster and that mathematicians are still developing these algorithms, I'm wondering which one is the most secure considering modern computing power and encryption techniques.</p>
<p>I've been using MD5 almost exclusively for years now, and I'm wondering if there's something more I should be doing. Should I be contemplating a different algorithm?</p>
<p>Another related question: How long should a field typically be for such an encrypted password? I must admit that I know virtually nothing about encryption, but I'm assuming that an MD5 hash (as an example) can be longer and would presumably take more processing power to crack. Or does the length of the field not matter at all, provided that the encrypted password fits in it in the first place?</p>
</div></text><author><a href="/users/232220/teekin">Teekin</a></author><comments><comment><text><span class="comment-copy">Hash functions are not encryption functions. Encryption functions have inverse functions to decrypt an encrypted value to get the original value. But hashes cannot be decrypted. It is only possible to find collisions (input values that result in the same hash value).</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,791 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">Output from any given hash function/algorithm is always the same length. For MD5 it is always 128 bits regardless of the length of the input bits/bytes/string.</span></text><author><a class="comment-user" href="/users/2543/jared-updike" title="4,570 reputation">Jared Updike</a></author></comment><comment><text><span class="comment-copy">Don't worry about the length of the field.  In almost all cases, guessing passwords and hashing them will be far faster than brute-forcing a collision, and 128 bits is plenty big enough to resist brute-force attacks until the heat death of the Universe.</span></text><author><a class="comment-user" href="/users/14148/david-thornley" title="46,465 reputation">David Thornley</a></author></comment><comment><text><span class="comment-copy">To keep up to date on hash functions, check out the eHash Wiki, especially the Hash Function Zoo <a href="http://ehash.iaik.tugraz.at/wiki/The_Hash_Function_Zoo" rel="nofollow noreferrer">ehash.iaik.tugraz.at/wiki/The_Hash_Function_Zoo</a>.</span></text><author><a class="comment-user" href="/users/90527/outis" title="51,421 reputation">outis</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Warning:</strong> Since this post was written in 2010, GPUs have been widely deployed to brute-force password hashes. Moderately-priced GPUs
  can run <em>ten billion</em> MD5s per second. This means that even a
  completely-random 8-character alphanumeric password (62 possible
  characters) can be brute forced in 6 hours. SHA-1 is only slightly
  slower, it'd take one day. Your user's passwords are much weaker, and
  (even with salting) will fall at a rate of thousands of passwords per
  second. Hash functions are <em>designed to be fast</em>. You don't want this
  for passwords. Use scrypt, bcrypt, or PBKDF-2.</p>
</blockquote>
<p><strong>MD5</strong> was found to be weak back in 1996, and <a href="http://www.schneier.com/blog/archives/2008/12/forging_ssl_cer.html" rel="noreferrer">should not be used anymore</a> for cryptographic purposes. <strong>SHA-1</strong> is a commonly used replacement, but <a href="http://www.schneier.com/blog/archives/2005/02/sha1_broken.html" rel="noreferrer">has similar problems</a>. The <a href="http://en.wikipedia.org/wiki/SHA_hash_functions#SHA-2_family" rel="noreferrer"><strong>SHA-2</strong> family</a> of hash functions are the current <a href="http://csrc.nist.gov/groups/ST/hash/statement.html" rel="noreferrer">replacement</a> of SHA-1. The members of SHA-2 are individually referred to as SHA-224, SHA-256, SHA-384, and SHA-512.</p>
<p>At the moment, several hash functions <a href="http://en.wikipedia.org/wiki/NIST_hash_function_competition" rel="noreferrer">are competing to become <strong>SHA-3</strong></a>, the next standardised cryptographic hashing algorithm. A winner will be chosen in 2012. None of these should be used yet!</p>
<p><strong>For password hashing</strong>, you may also consider using something like <a href="http://en.wikipedia.org/wiki/Bcrypt" rel="noreferrer"><strong>bcrypt</strong></a>. It is designed to be slow enough to make large scale brute force attacks infeasible. You can tune the slowness yourself, so it can be made slower when computers are becoming faster. </p>
<p><strong>Warning:</strong> bcrypt is based on an older two-way encryption algorithm, Blowfish, for which better alternatives exist today. I do not think that the cryptographic hashing properties of bcrypt are completely understood. Someone correct me if I'm wrong; I have never found a reliable source that discusses bcrypt's properties (other than its slowness) from a cryptographic perspective.</p>
<p>It may be somewhat reassuring that the risk of collisions matters less for password hashing than it does for public-key cryptography or digital signatures. Using MD5 today is a <a href="http://news.cnet.com/8301-1009_3-10129693-83.html" rel="noreferrer">terrible idea</a> for SSL, but not equally disastrous for password hashing. But if you have the choice, simply pick a stronger one.</p>
<p>Using a good hash function is <a href="http://md5.rednoize.com/about/" rel="noreferrer">not enough</a> to secure your passwords. You should hash the passwords together with <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noreferrer"><strong>salts</strong></a> that are long and <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" rel="noreferrer">cryptographically random</a>. You should also help your users pick stronger passwords or pass phrases if possible. Longer always is better.</p>
</div></text><author><a href="/users/98038/molf">molf</a></author><comments><comment><text><span class="comment-copy">"Longer always is better". Not <i>necessarily</i> true. I've heard anecdotal claims that forcing users to choose longer passwords sometimes causes them to choose passwords with <i>less</i> entropy, so that they can remember them. Personally I can remember an 8-alphanum randomly-generated password if I'm using it daily. Longer than that and I'm going to resort to making up passwords myself, and I don't know what entropy those have.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">@Steve Attackers don't gradually move from low entropy password attempts to higher ones. They try the dictionary attack and then there's brute force. Thus, "ooGoo!ooooooo876" has lower entropy than "d!NA0sue732bnfuw", but it's no less secure.</span></text><author><a class="comment-user" href="/users/146752/lucas" title="3,888 reputation">Lucas</a></author></comment><comment><text><span class="comment-copy">For password hashing, MD5 should still be considered to be a reasonable option (as you've hinted), provided your passwords are strong and you use a salt (which would apply to any hash). The collision attacks are largely irrelevant for password hashing, in my understanding.</span></text><author><a class="comment-user" href="/users/13724/markr" title="48,079 reputation">MarkR</a></author></comment><comment><text><span class="comment-copy">@Lucas: neither "ooGoo!ooooooo876" nor "d!NA0sue732bnfuw" has any entropy in the relevant meaning, since they are constants not random variables. To be pedantic I should have said "choose passwords as outputs of a r.v with less entropy", not "choose passwords with less entropy". A low-entropy password generation scheme is more likely to generate passwords which fall in the early part of a dictionary/brute-force attack, assuming (as one should, for safety) that the attacker has some insight into how passwords are chosen and has designed his attack sensibly.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">@Steve: "that the attacker has some insight..." this is the point about using longer password. There is much difference between a 8-characters password (keyboard) and a 14 to 50 characters password (probably alpha num + punctuation and perhaps a few random chars). The latter has a much higher space. Even if it's likely to be composed of words, as you can tweak them (l33t speak, sms-style, ...), it still gives more entropy.</span></text><author><a class="comment-user" href="/users/147192/matthieu-m" title="164,106 reputation">Matthieu M.</a></author></comment><comment><text><span class="comment-copy">+1 for one word: <code>salt</code>. Without salt you're susceptible to rainbow-attacks. And I should point out that you want one salt for each password, not one for the whole lot of them!</span></text><author><a class="comment-user" href="/users/147192/matthieu-m" title="164,106 reputation">Matthieu M.</a></author></comment><comment><text><span class="comment-copy">A longer password has the potential for more entropy, of course. But molf said "longer is always better". This is false: a password consisting of 8 random alphanumeric characters is better than a password consisting of two random dictionary words. <i>If</i> you then introduce enough additional randomness to the two-word password generation scheme, then eventually it will be better. Whether or not users will actually do so when forced to choose longer passwords is a question in psychology, not information theory. I'm not confident enough of the answer to impose any but a tiny minimum length limit.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">Many user passwords are already quite simple. Passphrases are often just as easy to remember, while taking advantage of the additional strength of their length. I maintain that, <b>all other things equal</b>, longer always is better. But all things are not always equal, and you are quite right in questioning whether or not a <i>required minimum length</i> will weaken the passwords. Be careful in imposing strict minimum limits, and help users decide for themselves.</span></text><author><a class="comment-user" href="/users/98038/molf" title="51,140 reputation">molf</a></author></comment><comment><text><span class="comment-copy">@molf I've edited in a warning about how fast MD5, SHA-1, etc. can be brute-forced using GPUs, and how that means none of those are acceptable anymore for password storage. Please feel free to change/revert/etc.</span></text><author><a class="comment-user" href="/users/27727/derobert" title="34,422 reputation">derobert</a></author></comment><comment><text><span class="comment-copy">why not use smth like sha1(md5($password)) ?</span></text><author><a class="comment-user" href="/users/1298531/albi-patozi" title="463 reputation">Albi Patozi</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Great question!  <a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html" rel="noreferrer">This page</a> is a good read.  In particular, the author claims that MD5 is not appropriate for hashing passwords:</p>
<blockquote>
<p>The problem is that MD5 is fast. So are its modern competitors, like SHA1 and SHA256. Speed is a design goal of a modern secure hash, because hashes are a building block of almost every cryptosystem, and usually get demand-executed on a per-packet or per-message basis.</p>
<p><strong>Speed is exactly what you donâ€™t want in a password hash function.</strong></p>
</blockquote>
<p>The article then goes on to explain some alternatives, and recommends <a href="http://bcrypt.sourceforge.net/" rel="noreferrer">Bcrypt</a> as the "correct choice" (his words, not mine).</p>
<p>Disclaimer:  I have not tried Bcrypt at all.  Consider this a friendly recommendation but not something I can back up with my own technical experience.</p>
</div></text><author><a href="/users/6198/matt-solnit">Matt Solnit</a></author><comments><comment><text><span class="comment-copy">The author also recommends the password hashing scheme developed for FreeBSD, which uses MD5 at its core but iterates the hash function thousands of times.   There is a similar construction based on SHA-1 available in glibc.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">+1 for citing Matasano :)</span></text><author><a class="comment-user" href="/users/147192/matthieu-m" title="164,106 reputation">Matthieu M.</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To increase password strength you should use a wider variety of symbols.  If you have 8-10 characters in the password it becomes pretty hard to crack.  Although making it longer will make it more secure, only if you use numeric/alphabetic/other characters.</p>
<p>SHA1 is another hashing (one way encryption) algorithm, it is slower, but is has a longer digest. (encoded messsage)  (160 bit) where MD5 only has 128 bit.</p>
<p>Then SHA2 is even more secure, but it used less.</p>
</div></text><author><a href="/users/174614/tony-the-lion">Tony The Lion</a></author><comments><comment><text><span class="comment-copy">I will note that slower is actually a <i>benefit</i> when it comes to defending against brute-force attacks.</span></text><author><a class="comment-user" href="/users/224346/anon" title="36,478 reputation">Anon.</a></author></comment><comment><text><span class="comment-copy">@Anon: You're quite right! Thanks for mentioning it:)</span></text><author><a class="comment-user" href="/users/174614/tony-the-lion" title="35,572 reputation">Tony The Lion</a></author></comment><comment><text><span class="comment-copy">It's not so much "slower" as "difficult to make fast even with dedicated hardware/precomputed tables/mathematical analysis..." which is important. The rationale behind the NIST SHA-3 contest is that current crypto hash functions, while still as slow as before on general-purpose computers, have been weakened recently for various other reasons. Especially MD5 (see the MD5 Wikipedia page).</span></text><author><a class="comment-user" href="/users/139746/pascal-cuoq" title="61,246 reputation">Pascal Cuoq</a></author></comment><comment><text><span class="comment-copy">Putting any reliance on the speed with which the computer can create the hash is misplaced. The difference in speed between MD5 and SHA1 calculation will provide no discernible protection against brute force attacks. The only thing that should matter is the quality of the hash and that relates to its ability to protect against deducing the input from the hash and its ability to protect against falsely producing the same hash with different inputs.</span></text><author><a class="comment-user" href="/users/198643/thomas" title="51,345 reputation">Thomas</a></author></comment><comment><text><span class="comment-copy">You can still rainbow table SHA1. I've moved most of my new development up to SHA-256</span></text><author><a class="comment-user" href="/users/179328/xorlev" title="6,768 reputation">Xorlev</a></author></comment><comment><text><span class="comment-copy">This is not entirely correct. |a| ^ l is the equation that describes the number of possible values in the password, where a is the password alphabet, and l is the length of the password. It is more effective to increase l instead of |a|.</span></text><author><a class="comment-user" href="/users/26227/paul-nathan" title="26,625 reputation">Paul Nathan</a></author></comment><comment><text><span class="comment-copy">@Xorlev: that's what salt is for. There are good reasons to move from SHA-1 to SHA-256, but rainbow table attacks on hashed passwords aren't among them.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">@Steve Jessop, I salt all my SHA1, but considering that rainbow tables are really starting to show up, it doesn't really hurt me to use SHA-256. One can also do key hardening to increase time taken for brute-force attacks.</span></text><author><a class="comment-user" href="/users/179328/xorlev" title="6,768 reputation">Xorlev</a></author></comment><comment><text><span class="comment-copy">@Xorlev You can construct a rainbow table for <i>any</i> hash algorithm. The practicality of constructing a rainbow table is a function of how many possible inputs there are, not of the robustness of the algorithm.</span></text><author><a class="comment-user" href="/users/12030/nick-johnson" title="90,861 reputation">Nick Johnson</a></author></comment><comment><text><span class="comment-copy">@Nick Johnson, I'm aware, however as more and more tables show up I less and less want to use SHA-1.</span></text><author><a class="comment-user" href="/users/179328/xorlev" title="6,768 reputation">Xorlev</a></author></comment><comment><text><span class="comment-copy">@Xorlev: but why does it matter? With 64 bits of salt, how can anyone possibly have a rainbow table for SHA-1 <i>with the right salt value</i>? They could start generating it once they know the salt for the password they want to crack, but that's no different from a dictionary attack on SHA-1. The existence of rainbow tables for SHA-1 is not a threat to you. The existence of preimage attacks on SHA-1 might be a growing threat.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>Seeing that computers just keep getting faster and that mathematicians are still developing these algorithms </p>
</blockquote>
<p>RSA encryption is secure in that it relies on a really big number being <em>hard</em> to factor. Eventually, computers will get fast enough to factor the number in a reasonable amount of time. To stay ahead of the curve, you use a bigger number. </p>
<p>However, for most web sites, the purpose of hashing passwords is to make it <strong>inconvenient</strong> for someone with access to the database to read the password, not to provide security. For that purpose, MD5 is fine<sup>1</sup>.</p>
<p>The implication here is that if a malicious user gains access to your entire database, they don't need the password. (The lock on the front door won't stop me from coming in the window.)</p>
<hr/>
<p><sup>1</sup> Just because MD5 is "broken" doesn't mean you can just reverse it whenever you want.</p>
</div></text><author><a href="/users/65295/seth">Seth</a></author><comments><comment><text><span class="comment-copy">"However, for most web sites, the purpose of hashing passwords is to make it inconvenient for someone with access to the database to read the password, not to provide security." - this may be all that most sites <i>achieve</i>, but the purpose should be to make it impractical to reverse any of your users' stored passwords - and doing so is totally achievable.</span></text><author><a class="comment-user" href="/users/12030/nick-johnson" title="90,861 reputation">Nick Johnson</a></author></comment><comment><text><span class="comment-copy">Agreed, I have strongly tried to explain to my colleagues why the weaknesses in MD5 should not preclude its use for password hashing. Needless to say, using a salt and minimum password strength is still advisable</span></text><author><a class="comment-user" href="/users/13724/markr" title="48,079 reputation">MarkR</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>salting the password is always an extra level of defense</p>
<pre><code>$salt = 'asfasdfasdf0a8sdflkjasdfapsdufp';
$hashed = md5( $userPassword . $salt );
</code></pre>
</div></text><author><a href="/users/279558/david-morrow">David Morrow</a></author><comments><comment><text><span class="comment-copy">It is important that a fresh salt be generated each time a password is set, not be a fixed value.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">@caf: Wouldn't that still make the calculation take way more time if it were always the same, thus increasing the time it would take to brute force it? - If the salt is different every time, it would have to be stored in the same row as the password for the login mechanism to be able to compare the hashed attempt to the real password.</span></text><author><a class="comment-user owner" href="/users/232220/teekin" title="6,551 reputation">Teekin</a></author></comment><comment><text><span class="comment-copy">If the salt is always the same, the attacker can a) bruteforce all your passwords in parallel (each test hash can be compared against all your password hashes); and b) compute the hashes in advance of seeing your database.  Yes, the salt should be stored alongside the hash - that's exactly what UNIX-style password hashes do.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">Actually, while it is best to use a different salt each time, it turns that even using a fixed salt is useful, as long as not all systems in the world use the same fixed salt.  The point of salting is to prevent precomputed tables like the <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="nofollow noreferrer">rainbow tables</a> frequently used to crack Windows passwords.  So if your salt isn't the same as everyone else's, it's still useful.  See also <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="nofollow noreferrer">Wikipedia on salting</a>.</span></text><author><a class="comment-user" href="/users/123324/paul" title="831 reputation">Paul</a></author></comment><comment><text><span class="comment-copy">The main problem with not using a salt is if 10 users have the exact same password then $hashed for all 10 is exactly the same. So you just cracked 10 accounts (assuming you can see what's in the database.)</span></text><author><a class="comment-user" href="/users/212378/alexis-wilke" title="7,761 reputation">Alexis Wilke</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Besides being a cryptographically secure one-way function, a good hash function for password protection should be hard to brute force - i.e. slow by design. <a href="http://www.tarsnap.com/scrypt.html" rel="nofollow noreferrer">scrypt</a> is one of the best in that area. From the homepage:</p>
<blockquote>
<p>We estimate that on modern (2009) hardware, if 5 seconds are spent computing a derived key, the cost of a hardware brute-force attack against scrypt is roughly 4000 times greater than the cost of a similar attack against bcrypt (to find the same password), and 20000 times greater than a similar attack against PBKDF2.</p>
</blockquote>
<p>That said, from commonly available hash functions, doing a few thousand of iterations of anything from the SHA family is pretty reasonable protection for non-critical passwords.</p>
<p>Also, always add a salt to make it impossible to share effort for brute forcing many hashes at a time.</p>
</div></text><author><a href="/users/107366/ants-aasma">Ants Aasma</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>NIST is currently running a contest to select a new hashing algorith, just as they did to select the AES encryption algorithm. So the answer to this question will likely be different in a couple of years.</p>
<p>You can look up the submissions and study them for yourself to see if there's one that you'd like to use.</p>
</div></text><author><a href="/users/10174/jeffrey-l-whitledge">Jeffrey L Whitledge</a></author><comments/></answer></answers></post>