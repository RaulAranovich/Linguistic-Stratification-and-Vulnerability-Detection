<?xml version="1.0" encoding="utf-8"?>
<post><title>html - Cross Domain Form POSTing - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I've seen articles and posts all over (including SO) on this topic, and the prevailing commentary is that same-origin policy prevents a form POST across domains.  The only place I've seen someone suggest that same-origin policy does not apply to form posts, <a href="http://blog.stevensanderson.com/2008/09/01/prevent-cross-site-request-forgery-csrf-using-aspnet-mvcs-antiforgerytoken-helper/" rel="noreferrer">is here</a>.</p>
<p>I'd like to have an answer from a more "official" or formal source.  For example, does anyone know the RFC that addresses how same-origin does or does not affect a form POST?</p>
<p><strong>clarification</strong>: I am not asking if a GET or POST can be constructed and sent to any domain.  I am asking:</p>
<ol>
<li>if Chrome, IE, or Firefox will allow content from domain 'Y' to send a POST to domain 'X'</li>
<li>if the server receiving the POST will actually see any form values at all.  I say this because the majority of online discussion records testers saying the server received the post, but the form values were all empty / stripped out.</li>
<li>What official document (i.e. RFC) explains what the expected behavior is (regardless of what the browsers have currently implemented).</li>
</ol>
<p>Incidentally, if same-origin does not affect form POSTs - then it makes it somewhat more obvious of why anti-forgery tokens are necessary.  I say "somewhat" because it seems too easy to believe that an attacker could simply issue an HTTP GET to retrieve a form containing the anti-forgery token, and then make an illicit POST which contains that same token.  Comments?</p>
</div></text><author><a href="/users/284758/brent-arias">Brent Arias</a></author><comments><comment><text><span class="comment-copy">Yes, an attacker could do that... with an ordinary web browser.</span></text><author><a class="comment-user" href="/users/1068283/michael-hampton" title="4,877 reputation">Michael Hampton</a></author></comment><comment><text><span class="comment-copy">Perhaps there are no RFCs for the same reason why there are no RFCs that say: "don't post your password on your website". Web standards are only required when multiple parties must work together to achieve something: the same origin policy is more of a complex set of "security best practices" that prevent users from getting hacked.</span></text><author><a class="comment-user" href="/users/895245/ciro-santilli-709%e5%a4%a7%e6%8a%93%e6%8d%95-%e5%85%ad%e5%9b%9b%e4%ba%8b%e4%bb%b6-%e6%b3%95%e8%bd%ae%e5%8a%9f" title="73,089 reputation">Ciro Santilli 709大抓捕 六四事件 法轮功</a></author></comment><comment><text><span class="comment-copy">@Ciro Please say explicitly. The rules for cross-posting to other sites do not affect affect multiple parties. No need the foggy parlance.</span></text><author><a class="comment-user" href="/users/6267925/little-alien" title="1 reputation">Little Alien</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The same origin policy is applicable only for browser side programming languages. So if you try to post to a different server than the origin server using JavaScript, then the same origin policy comes into play but if you post directly from the form i.e. the  action points to a different server like:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;form</span><span class="pln"> </span><span class="atn">action</span><span class="pun">=</span><span class="atv">"http://someotherserver.com"</span><span class="tag">&gt;</span></code></pre>
<p>and there is no javascript involved in posting the form, then the same origin policy is not applicable. </p>
<p>See <a href="http://en.wikipedia.org/wiki/Same_origin_policy">wikipedia</a> for more information</p>
</div></text><author><a href="/users/69340/suresh-kumar">Suresh Kumar</a></author><comments><comment><text><span class="comment-copy">Sorry to drag up an old question, what would happen if the action was changed using JS but then the form was posted using a button? Would that allow for a successful cross-domain post?</span></text><author><a class="comment-user" href="/users/719718/chris" title="1,445 reputation">Chris</a></author></comment><comment><text><span class="comment-copy">AFAIK it shouldn't be a problem but I haven't tried it myself. Would be interesting to find out.</span></text><author><a class="comment-user" href="/users/69340/suresh-kumar" title="5,111 reputation">Suresh Kumar</a></author></comment><comment><text><span class="comment-copy">I'm of the same thought. I actually had worries about security, some third party JS/virus changing the action to post the form somewhere malicious, but realised this could be done on any payment receiving form cross domain or not and the outcome would be the same. Lesson here really: check any third party JS files ;)</span></text><author><a class="comment-user" href="/users/719718/chris" title="1,445 reputation">Chris</a></author></comment><comment><text><span class="comment-copy">In short: YES, cross-domain POSTing is allowed.</span></text><author><a class="comment-user" href="/users/12534/christian-dav%c3%a9n" title="7,831 reputation">Christian Davén</a></author></comment><comment><text><span class="comment-copy">I don't think it's really about javascript or not, rather if you want your page to end up on the target domain after the post. If not you need to look at CORS or mod_proxy like solutions.</span></text><author><a class="comment-user" href="/users/1255162/user1255162" title="549 reputation">user1255162</a></author></comment><comment><text><span class="comment-copy">-1 for: Same origin policy has nothing to do with sending request to another url (different protocol or domain or port), it is all about restricting access to (reading) response data from another url (and thereby preventing javascript to update document with forms that have security tokens from other url).</span></text><author><a class="comment-user" href="/users/1920246/mohsenme" title="644 reputation">Mohsenme</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It is possible to build an arbitrary GET or POST request and send it to <strong>any server</strong> accessible to a victims browser.  This includes devices on your local network,  such as Printers and Routers. </p>
<p>There are many ways of building a CSRF exploit.  <a href="http://www.exploit-db.com/exploits/18791/">A simple POST based CSRF attack</a> can be sent using <code>.submit()</code> method.   More complex attacks,  such as <a href="http://www.exploit-db.com/exploits/18766/">cross-site file upload CSRF attacks</a> will exploit <a href="http://blog.kotowicz.net/2011/05/cross-domain-arbitrary-file-upload.html">CORS use of the xhr.withCredentals behavior</a>.</p>
<p>CSRF does not violate the <a href="http://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy">Same-Origin Policy For JavaScrip</a>t because the SOP is concerned with JavaScript <strong><em>reading</em></strong> the server's response to a clients request.  CSRF attacks don't care about the response,  they care about a <strong>side-effect</strong>, or state change produced by the request,  such as adding an administrative user or executing arbitrary code on the server.</p>
<p>Make sure your requests are protected using one of the methods described in the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet">OWASP CSRF Prevention Cheat Sheet</a>.  For more information about CSRF consult the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">OWASP page on CSRF</a>.</p>
</div></text><author><a href="/users/1516204/mikey">Mikey</a></author><comments><comment><text><span class="comment-copy">I have updated my question to clarify.  Also, the WordPress link you gave involves exploits that were initiated from within same-origin X, rather than initiated from cross-domain Y...so it isn't the right scenario from what I see.</span></text><author><a class="comment-user owner" href="/users/284758/brent-arias" title="11,361 reputation">Brent Arias</a></author></comment><comment><text><span class="comment-copy">@Brent Arias yes,  what you are describing in 1 and 2 is exactly equal to what a CSRF attack performs,  perhaps you should try executing one of the CSRF exploits provided and sniffing the traffic.  I have updated my post,  you should read every link provided because it will answer these questions accurately.  The point of a "cross-site request forgery" (CSRF) attack is the request originates from another domain,  all exploits provided fully meet this fundamental requirement.</span></text><author><a class="comment-user" href="/users/1516204/mikey" title="504 reputation">Mikey</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Same origin policy has nothing to do with sending request to another url (different protocol or domain or port).</p>
<p>It is all about restricting access to (reading) response data from another url.
So JavaScript code within a page can post to arbitrary domain or submit forms within that page to anywhere (unless the form is in an iframe with different url).</p>
<p>But what makes these POST requests inefficient is that these requests lack antiforgery tokens, so are ignored by the other url. Moreover, if the JavaScript tries to get that security tokens, by sending AJAX request to the victim url, it is prevented to access that data by Same Origin Policy.</p>
<p>A good example: <a href="https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important#answer-72569">here</a></p>
<p>And a good documentation from Mozilla: <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" rel="nofollow noreferrer">here</a></p>
</div></text><author><a href="/users/1920246/mohsenme">Mohsenme</a></author><comments/></answer></answers></post>