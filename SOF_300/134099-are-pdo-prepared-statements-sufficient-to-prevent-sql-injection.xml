<?xml version="1.0" encoding="utf-8"?>
<post><title>php - Are PDO prepared statements sufficient to prevent SQL injection? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Let's say I have code like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$dbh </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">"blahblah"</span><span class="pun">);</span><span class="pln">

$stmt </span><span class="pun">=</span><span class="pln"> $dbh</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM users where username = :username'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln"> array</span><span class="pun">(</span><span class="str">':username'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $_REQUEST</span><span class="pun">[</span><span class="str">'username'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">);</span></code></pre>
<p>The PDO documentation says:</p>
<blockquote>
<p>The parameters to prepared statements don't need to be quoted; the driver handles it for you.</p>
</blockquote>
<p><strong>Is that truly all I need to do to avoid SQL injections?  Is it really that easy?</strong></p>
<p>You can assume MySQL if it makes a difference.  Also, I'm really only curious about the use of prepared statements against SQL injection.  In this context, I don't care about XSS or other possible vulnerabilities.</p>
</div></text><author><a href="/users/993547/patrick-hofman">Patrick Hofman</a></author><comments><comment><text><span class="comment-copy">better approach 7th number answer <a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection/12202218#12202218" title="are pdo prepared statements sufficient to prevent sql injection">stackoverflow.com/questions/134099/…</a></span></text><author><a class="comment-user" href="/users/1723893/nullpoi%d0%b8te%d1%8f" title="38,333 reputation">NullPoiиteя</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Prepared statements / parameterized queries are generally sufficient to prevent <em>1st order</em> injection on that statement<sup>*</sup>.  If you use un-checked dynamic sql anywhere else in your application you are still vulnerable to <em>2nd order</em> injection.</p>
<p>2nd order injection means data has been cycled through the database once before being included in a query, and is much harder to pull off.  AFAIK, you almost never see real engineered 2nd order attacks, as it is usually easier for attackers to social-engineer their way in, but you sometimes have 2nd order bugs crop up because of extra benign <code>'</code> characters or similar.</p>
<p>You can accomplish a 2nd order injection attack when you can cause a value to be stored in a database that is later used as a literal in a query. As an example, let's say you enter the following information as your new username when creating an account on a web site (assuming MySQL DB for this question):</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="str">' + (SELECT UserName + '</span><span class="pln">_</span><span class="str">' + Password FROM Users LIMIT 1) + '</span></code></pre>
<p>If there are no other restrictions on the username, a prepared statement would still make sure that the above embedded query doesn't execute at the time of insert, and store the value correctly in the database. However, imagine that later the application retrieves your username from the database, and uses string concatenation to include that value a new query. You might get to see someone else's password. Since the first few names in users table tend to be admins, you may have also just given away the farm. (Also note: this is one more reason not to store passwords in plain text!)</p>
<p>We see, then, that prepared statements are enough for a single query, but by themselves they are <strong>not</strong> sufficient to protect against sql injection attacks throughout an entire application, because they lack a mechanism to enforce that all access to a database within the application uses safe code. However, used as part of good application design — which may include practices such as code review or static analysis, or use of an ORM, data layer, or service layer that limits dynamic sql — <em><strong>prepared statements</strong></em><strong> are <em>the primary tool for solving the Sql Injection problem.</em></strong> If you follow good application design principles, such that your data access is separated from the rest of your program, it becomes easy to enforce or audit that every query correctly uses parameterization. In this case, sql injection (both first and second order) is completely prevented. </p>
<hr/>
<p><sub><sup>*</sup>It turns out that MySql/PHP is (okay, were) just dumb about handling parameters when wide characters are involved, and there is still a <em>rare</em> case outlined in the <a href="http://stackoverflow.com/a/12202218/3043">other highly-voted answer here</a> that can allow injection to slip through a parameterized query.</sub></p>
</div></text><author><a href="/users/3043/joel-coehoorn">Joel Coehoorn</a></author><comments><comment><text><span class="comment-copy">That's interesting.  I wasn't aware of 1st order vs. 2nd order.  Can you elaborate a little more on how 2nd order works?</span></text><author><a class="comment-user owner" href="/users/305/mark-biek" title="73,295 reputation">Mark Biek</a></author></comment><comment><text><span class="comment-copy">If ALL your queries are parametrized, you're also protected against 2nd order injection.  1st order injection is forgetting that user data is untrustworthy.  2nd order injection is forgetting that database data is untrustworthy (because it came from the user originally).</span></text><author><a class="comment-user" href="/users/8355/cjm" title="53,061 reputation">cjm</a></author></comment><comment><text><span class="comment-copy">Thanks cjm.  I also found this article helpful in explaining 2nd order injections:  <a href="http://www.codeproject.com/KB/database/SqlInjectionAttacks.aspx" rel="nofollow noreferrer">codeproject.com/KB/database/SqlInjectionAttacks.aspx</a></span></text><author><a class="comment-user owner" href="/users/305/mark-biek" title="73,295 reputation">Mark Biek</a></author></comment><comment><text><span class="comment-copy">Ah, yes. But what about <b>third order injection</b>. Have to be aware of those.</span></text><author><a class="comment-user" href="/users/18180/troelskn" title="77,344 reputation">troelskn</a></author></comment><comment><text><span class="comment-copy">Yes, except that PDO doesn't use real prepared statements by default ;-). See my answer below for a demonstration and explanation of an attack...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@troelskn that must be where the developer is the source of untrustworthy data</span></text><author><a class="comment-user" href="/users/510048/mikemurko" title="1,513 reputation">MikeMurko</a></author></comment><comment><text><span class="comment-copy">@JoelCoehoorn Think you'll find most are coming from here ;) <a href="http://www.google.com.au/search?q=pdo+prepared+statements" rel="nofollow noreferrer">google.com.au/search?q=pdo+prepared+statements</a></span></text><author><a class="comment-user" href="/users/1339896/jduncanator" title="1,110 reputation">jduncanator</a></author></comment><comment><text><span class="comment-copy">But if you use 100% static prepared statements in your whole program, I mean, all SQL hardcoded into prepared statements, then you avoid all levels of injection, right?</span></text><author><a class="comment-user" href="/users/739009/stormbyte" title="779 reputation">StormByte</a></author></comment><comment><text><span class="comment-copy">@StormByte Yes, you do, but you're simply avoiding client data.</span></text><author><a class="comment-user" href="/users/1261942/danredux" title="4,676 reputation">DanRedux</a></author></comment><comment><text><span class="comment-copy">I wasn't aware of the order thingy. Reading this I thought <i>What about 3rd and 4th and even more of 5th?? And 6th must be so deadly...</i></span></text><author><a class="comment-user" href="/users/3459110/awal-garg" title="4,722 reputation">Awal Garg</a></author></comment><comment><text><span class="comment-copy">@Pacerier Joel made an edit after my comment on March 8th, emphasizing a sentence in what he already wrote.  It's clear that the post has the content he intends.  I'm not going to edit someone's post to change the meaning of it, and other answers already answer the question.</span></text><author><a class="comment-user" href="/users/362536/brad" title="93,479 reputation">Brad</a></author></comment><comment><text><span class="comment-copy">@Pacerier I disagree with you there.  The system is set up in a way that we can edit everone's posts, yes, but it is good etiquette and rule to not drastically change the original meaning.</span></text><author><a class="comment-user" href="/users/362536/brad" title="93,479 reputation">Brad</a></author></comment><comment><text><span class="comment-copy">@Brad, That's provided the "original meaning" isn't wrong. If it's wrong, feel free to edit it to make it right.</span></text><author><a class="comment-user" href="/users/632951/pacerier" title="33,795 reputation">Pacerier</a></author></comment><comment><text><span class="comment-copy">And also in 2nd order injection the attacker have to put the names of tables and columns that bring the blind sql injection in... Well,What I do is this.. $username=strip_tags(mysqli_real_escape_string($con,$usernam‌​e)); after length verification.. and then i also use reg exp to verify and in end put it by PDO</span></text><author><a class="comment-user" href="/users/3343503/waqas" title="421 reputation">Waqas</a></author></comment><comment><text><span class="comment-copy">@Waqas Then you have all kinds of problems. What if those tags are valid and need to be stored in the DB? Why use reg exp <i>after</i> real_escape? User input shouldn't reach DB sanitisation <i>before</i> validation has passed. Why are you doing <code>mysqli_real_escape_string</code> and then PDO? Sure, your final PDO makes it secure <i>if</i> you use parametrised statements, but all the extra bits of (pointless) "security" you have added are more likely to introduce a security flaw away from DB security, or at the very least nightmare code which is terrible to understand and work with.</span></text><author><a class="comment-user" href="/users/2632129/james" title="2,706 reputation">James</a></author></comment><comment><text><span class="comment-copy">I don't want to allow the user to put tags in db and please can you tell me what means by "if those tags are valid...." and i have made all these things into one function called validate which i have in my own framework file of website that i use to make my code responsive and cool</span></text><author><a class="comment-user" href="/users/3343503/waqas" title="421 reputation">Waqas</a></author></comment><comment><text><span class="comment-copy">@Waqas don't validate input... <b>quarantine</b> it. That's what query parameters do. If you're trying to protect from something other than sql injection, you need to look in a different place.</span></text><author><a class="comment-user" href="/users/3043/joel-coehoorn" title="262,375 reputation">Joel Coehoorn</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The short answer is <strong>NO</strong>, PDO prepares will not defend you from all possible SQL-Injection attacks. For certain obscure edge-cases.</p>
<p>I'm adapting <a href="http://stackoverflow.com/a/12118602/338665">this answer</a> to talk about PDO...</p>
<p>The long answer isn't so easy. It's based off an attack <a href="http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string">demonstrated here</a>.</p>
<h1>The Attack</h1>
<p>So, let's start off by showing the attack...</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> </span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">;</span><span class="pln">
$query </span><span class="pun">=</span><span class="pln"> </span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">;</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="pln">$query</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="pln">$var</span><span class="pun">));</span></code></pre>
<p>In certain circumstances, that will return more than 1 row. Let's dissect what's going on here:</p>
<ol>
<li><p><strong>Selecting a Character Set</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span></code></pre>
<p>For this attack to work, we need the encoding that the server's expecting on the connection both to encode <code>'</code> as in ASCII i.e. <code>0x27</code> <em>and</em> to have some character whose final byte is an ASCII <code>\</code> i.e. <code>0x5c</code>.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: <code>big5</code>, <code>cp932</code>, <code>gb2312</code>, <code>gbk</code> and <code>sjis</code>.  We'll select <code>gbk</code> here.</p>
<p>Now, it's very important to note the use of <code>SET NAMES</code> here. This sets the character set <strong>ON THE SERVER</strong>. There is another way of doing it, but we'll get there soon enough.</p></li>
<li><p><strong>The Payload</strong></p>
<p>The payload we're going to use for this injection starts with the byte sequence <code>0xbf27</code>.  In <code>gbk</code>, that's an invalid multibyte character; in <code>latin1</code>, it's the string <code>¿'</code>.  Note that in <code>latin1</code> <strong>and</strong> <code>gbk</code>, <code>0x27</code> on its own is a literal <code>'</code> character. </p>
<p>We have chosen this payload because, if we called <code>addslashes()</code> on it, we'd insert an ASCII <code>\</code> i.e. <code>0x5c</code>, before the <code>'</code> character. So we'd wind up with <code>0xbf5c27</code>, which in <code>gbk</code> is a two character sequence: <code>0xbf5c</code> followed by <code>0x27</code>. Or in other words, a <em>valid</em> character followed by an unescaped <code>'</code>. But we're not using <code>addslashes()</code>. So on to the next step...</p></li>
<li><p><strong>$stmt-&gt;execute()</strong></p>
<p>The important thing to realize here is that PDO by default does <strong>NOT</strong> do true prepared statements. It emulates them (for MySQL). Therefore, PDO internally builds the query string, calling <code>mysql_real_escape_string()</code> (the MySQL C API function) on each bound string value.</p>
<p>The C API call to <code>mysql_real_escape_string()</code> differs from <code>addslashes()</code> in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we're still using <code>latin1</code> for the connection, because we never told it otherwise. We did tell the <em>server</em> we're using <code>gbk</code>, but the <em>client</em> still thinks it's <code>latin1</code>.</p>
<p>Therefore the call to <code>mysql_real_escape_string()</code> inserts the backslash, and we have a free hanging <code>'</code> character in our "escaped" content! In fact, if we were to look at <code>$var</code> in the <code>gbk</code> character set, we'd see:</p>
<pre>縗' OR 1=1 /*</pre>
<p>Which is exactly what the attack requires.</p></li>
<li><p><strong>The Query</strong></p>
<p>This part is just a formality, but here's the rendered query:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">SELECT</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">FROM</span><span class="pln"> test </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'縗'</span><span class="pln"> </span><span class="kwd">OR</span><span class="pln"> </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> </span><span class="com">/*' LIMIT 1</span></code></pre></li>
</ol>
<p>Congratulations, you just successfully attacked a program using PDO Prepared Statements...</p>
<h1>The Simple Fix</h1>
<p>Now, it's worth noting that you can prevent this by disabling emulated prepared statements:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>
<p>This will <em>usually</em> result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently <a href="https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210">fallback</a> to emulating statements that MySQL can't prepare natively: those that it can are <a href="http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html">listed</a> in the manual, but beware to select the appropriate server version).</p>
<h1>The Correct Fix</h1>
<p>The problem here is that we didn't call the C API's <code>mysql_set_charset()</code> instead of <code>SET NAMES</code>. If we did, we'd be fine provided we are using a MySQL release since 2006.</p>
<p>If you're using an earlier MySQL release, then a <a href="http://bugs.mysql.com/bug.php?id=8378">bug</a> in <code>mysql_real_escape_string()</code> meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes <em>even if the client had been correctly informed of the connection encoding</em> and so this attack would still succeed.  The bug was fixed in MySQL <a href="http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html">4.1.20</a>, <a href="http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html">5.0.22</a> and <a href="http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html">5.1.11</a>.</p>
<p>But the worst part is that <code>PDO</code> didn't expose the C API for <code>mysql_set_charset()</code> until 5.3.6, so in prior versions it <strong>cannot</strong> prevent this attack for every possible command!
 It's now exposed as a <a href="http://www.php.net/manual/en/ref.pdo-mysql.connection.php">DSN parameter</a>, which should be used <strong>instead of</strong> <code>SET NAMES</code>...</p>
<h1>The Saving Grace</h1>
<p>As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  <a href="http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html"><code>utf8mb4</code></a> is <em>not vulnerable</em> and yet can support <em>every</em> Unicode character: so you could elect to use that instead—but it has only been available since MySQL 5.5.3.  An alternative is <a href="http://dev.mysql.com/doc/en/charset-unicode-utf8.html"><code>utf8</code></a>, which is also <em>not vulnerable</em> and can support the whole of the Unicode <a href="http://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane">Basic Multilingual Plane</a>.</p>
<p>Alternatively, you can enable the <a href="http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes"><code>NO_BACKSLASH_ESCAPES</code></a> SQL mode, which (amongst other things) alters the operation of <code>mysql_real_escape_string()</code>.  With this mode enabled, <code>0x27</code> will be replaced with <code>0x2727</code> rather than <code>0x5c27</code> and thus the escaping process <em>cannot</em> create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. <code>0xbf27</code> is still <code>0xbf27</code> etc.)—so the server will still reject the string as invalid.  However, see <a href="http://stackoverflow.com/a/23277864/623041">@eggyal's answer</a> for a different vulnerability that can arise from using this SQL mode (albeit not with PDO).</p>
<h1>Safe Examples</h1>
<p>The following examples are safe:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">'SET NAMES utf8'</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = '$var' LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>Because the server's expecting <code>utf8</code>...</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">mysql_set_charset</span><span class="pun">(</span><span class="str">'gbk'</span><span class="pun">);</span><span class="pln">
$var </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"SELECT * FROM test WHERE name = '$var' LIMIT 1"</span><span class="pun">);</span></code></pre>
<p>Because we've properly set the character set so the client and the server match.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
$pdo</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">));</span></code></pre>
<p>Because we've turned off emulated prepared statements.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pdo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">'mysql:host=localhost;dbname=testdb;charset=gbk'</span><span class="pun">,</span><span class="pln"> $user</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">));</span></code></pre>
<p>Because we've set the character set properly.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$mysqli</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">'SET NAMES gbk'</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM test WHERE name = ? LIMIT 1'</span><span class="pun">);</span><span class="pln">
$param </span><span class="pun">=</span><span class="pln"> </span><span class="str">"\xbf\x27 OR 1=1 /*"</span><span class="pun">;</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">'s'</span><span class="pun">,</span><span class="pln"> $param</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<p>Because MySQLi does true prepared statements all the time.</p>
<h1>Wrapping Up</h1>
<p>If you:</p>
<ul>
<li>Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) <strong>AND</strong> PDO's DSN charset parameter (in PHP ≥ 5.3.6)</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>Don't use a vulnerable character set for connection encoding (you only use <code>utf8</code> / <code>latin1</code> / <code>ascii</code> / etc)</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>Enable <code>NO_BACKSLASH_ESCAPES</code> SQL mode</li>
</ul>
<p>You're 100% safe.</p>
<p>Otherwise, you're vulnerable <strong>even though you're using PDO Prepared Statements...</strong></p>
<h1>Addendum</h1>
<p>I've been slowly working on a patch to change the default to not emulate prepares for a future version of PHP. The problem that I'm running into is that a LOT of tests break when I do that. One problem is that emulated prepares will only throw syntax errors on execute, but true prepares will throw errors on prepare. So that can cause issues (and is part of the reason tests are borking).</p>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">This is the best answer that i found ..can you provide a link for more reference?</span></text><author><a class="comment-user" href="/users/1160198/staticvariable" title="4,572 reputation">StaticVariable</a></author></comment><comment><text><span class="comment-copy">I think "The Saving Grace" was this MySQL 5.0.22 fix: <a href="http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html" rel="nofollow noreferrer">dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html</a></span></text><author><a class="comment-user" href="/users/857958/nico-gawenda" title="2,066 reputation">nico gawenda</a></author></comment><comment><text><span class="comment-copy">@nicogawenda: that was a different bug. Prior to 5.0.22, <code>mysql_real_escape_string</code> wouldn't properly handle cases where the connection was properly set to BIG5/GBK. So actually even calling <code>mysql_set_charset()</code> on mysql &lt; 5.0.22 would be vulnerable to this bug! So no, this post is still applicable to 5.0.22 (because mysql_real_escape_string is only charset away to calls from <code>mysql_set_charset()</code>, which is what this post is talking about bypassing)...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell. Thanks, this is great stuff. One question left for me, concerning the setting the emulation to false. Do I need to have that $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); in every query or should it be enough once in a script? Thanks.</span></text><author><a class="comment-user" href="/users/2127381/bernarda" title="356 reputation">BernardA</a></author></comment><comment><text><span class="comment-copy">@ircmaxell Your solution also prevents XSS attacks?</span></text><author><a class="comment-user" href="/users/2604011/progfa" title="76 reputation">progfa</a></author></comment><comment><text><span class="comment-copy">@progfa Whether it does or not you should always validate your input on the server before doing anything with user data.</span></text><author><a class="comment-user" href="/users/174368/tek" title="792 reputation">Tek</a></author></comment><comment><text><span class="comment-copy">I am finding that the simple fix <code>PDO::ATTR_EMULATE_PREPARES = false</code> can cause dropped DB connections when preparing some SQL statements. I've not identified the exact circumstances yet (it happens to me when using lots of joins and selecting from a custom DB function) but it is something to be aware of when using this option.</span></text><author><a class="comment-user" href="/users/218208/jason" title="1,063 reputation">Jason</a></author></comment><comment><text><span class="comment-copy">Since I'm new in this field ( or kinda new... ) can someone explain how you set for example <code>$pdo-&gt;query('SET NAMES gbk');</code> in my script? If I'm originally have <code>$pdo-&gt;query('SET NAMES utf8');</code>?</span></text><author><span class="comment-user">user5035451</span></author></comment><comment><text><span class="comment-copy">Please note that <code>NO_BACKSLASH_ESCAPES</code> can also introduce new vulnerabilities : <a href="http://stackoverflow.com/a/23277864/1014813">stackoverflow.com/a/23277864/1014813</a></span></text><author><a class="comment-user" href="/users/1014813/lepix" title="3,398 reputation">lepix</a></author></comment><comment><text><span class="comment-copy">Can you clarify (and if possible add a reference for) your comment "but true prepares will throw errors on prepare" - did you mean even when the SQL is in fact valid - or only when invalid?</span></text><author><a class="comment-user" href="/users/180733/fooquency" title="923 reputation">fooquency</a></author></comment><comment><text><span class="comment-copy">Excellent answer.</span></text><author><a class="comment-user" href="/users/1068240/pbond" title="1,038 reputation">pbond</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>No, they are not always.</p>
<p>It depends on whether you allow user input to be placed within the query itself. For example:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$dbh </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">"blahblah"</span><span class="pun">);</span><span class="pln">

$tableToUse </span><span class="pun">=</span><span class="pln"> $_GET</span><span class="pun">[</span><span class="str">'userTable'</span><span class="pun">];</span><span class="pln">

$stmt </span><span class="pun">=</span><span class="pln"> $dbh</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM '</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $tableToUse </span><span class="pun">.</span><span class="pln"> </span><span class="str">' where username = :username'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln"> array</span><span class="pun">(</span><span class="str">':username'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $_REQUEST</span><span class="pun">[</span><span class="str">'username'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">);</span></code></pre>
<p>would be vulnerable to SQL injections and using prepared statements in this example won't work, because the user input is used as an identifier, not as data. The right answer here would be to use some sort of filtering/validation like:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$dbh </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">"blahblah"</span><span class="pun">);</span><span class="pln">

$tableToUse </span><span class="pun">=</span><span class="pln"> $_GET</span><span class="pun">[</span><span class="str">'userTable'</span><span class="pun">];</span><span class="pln">
$allowedTables </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">(</span><span class="str">'users'</span><span class="pun">,</span><span class="str">'admins'</span><span class="pun">,</span><span class="str">'moderators'</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">in_array</span><span class="pun">(</span><span class="pln">$tableToUse</span><span class="pun">,</span><span class="pln">$allowedTables</span><span class="pun">))</span><span class="pln">    
 $tableToUse </span><span class="pun">=</span><span class="pln"> </span><span class="str">'users'</span><span class="pun">;</span><span class="pln">

$stmt </span><span class="pun">=</span><span class="pln"> $dbh</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM '</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $tableToUse </span><span class="pun">.</span><span class="pln"> </span><span class="str">' where username = :username'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln"> array</span><span class="pun">(</span><span class="str">':username'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $_REQUEST</span><span class="pun">[</span><span class="str">'username'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">);</span></code></pre>
<p>Note: you can't use PDO to bind data that goes outside of DDL (Data Definition Language), i.e. this does not work:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $dbh</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM foo ORDER BY :userSuppliedData'</span><span class="pun">);</span></code></pre>
<p>The reason why the above does not work is because <code>DESC</code> and <code>ASC</code> are not <em>data</em>. PDO can only escape for <em>data</em>. Secondly, you can't even put <code>'</code> quotes around it. The only way to allow user chosen sorting is to manually filter and check that it's either <code>DESC</code> or <code>ASC</code>.</p>
</div></text><author><a href="/users/283055/tower">Tower</a></author><comments><comment><text><span class="comment-copy">Am I missing something here but isn't the whole point of prepared statements to avoid treating sql like a string? Wouldn't something like $dbh-&gt;prepare('SELECT * FROM :tableToUse where username = :username'); get around your problem?</span></text><author><a class="comment-user" href="/users/236755/rob-forrest" title="2,851 reputation">Rob Forrest</a></author></comment><comment><text><span class="comment-copy">@RobForrest yes you are missing :). The data you bind only works for DDL (Data Definition Language). You need those quotes and proper escaping. Placing quotes for other parts of the query breaks it with a high probability. For example, <code>SELECT * FROM 'table'</code> can be wrong as it should be <code>SELECT * FROM `table`</code> or without any backsticks. Then some things like <code>ORDER BY DESC</code> where <code>DESC</code> comes from the user can't be simply escaped. So, practical scenarios are rather unlimited.</span></text><author><a class="comment-user" href="/users/283055/tower" title="35,977 reputation">Tower</a></author></comment><comment><text><span class="comment-copy">I wonder how 6 people could upvote a comment proposing a plainly wrong use of a prepared statement. Had they even tried it once, they'd have discovered right away that using named parameter in place of a table name will not work.</span></text><author><a class="comment-user" href="/users/576767/f%c3%a9lix-gagnon-grenier" title="4,293 reputation">Félix Gagnon-Grenier</a></author></comment><comment><text><span class="comment-copy">Here is a great tutorial on PDO if you want to learn it. <a href="http://a2znotes.blogspot.in/2014/09/introduction-to-pdo.html" rel="nofollow noreferrer">a2znotes.blogspot.in/2014/09/introduction-to-pdo.html</a></span></text><author><a class="comment-user" href="/users/2995263/rn-kushwaha" title="1,126 reputation">RN Kushwaha</a></author></comment><comment><text><span class="comment-copy">You should never use a query string/POST body to pick the table to use. If you don't have models, at least use a <code>switch</code> to derive the table name.</span></text><author><a class="comment-user" href="/users/516229/ziggythehamster" title="692 reputation">ZiggyTheHamster</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Yes, it is sufficient. The way injection type attacks work, is by somehow getting an interpreter (The database) to evaluate something, that should have been data, as if it was code. This is only possible if you mix code and data in the same medium (Eg. when you construct a query as a string).</p>
<p>Parameterised queries work by sending the code and the data separately, so it would <em>never</em> be possible to find a hole in that.</p>
<p>You can still be vulnerable to other injection-type attacks though. For example, if you use the data in a HTML-page, you could be subject to XSS type attacks.</p>
</div></text><author><a href="/users/18180/troelskn">troelskn</a></author><comments><comment><text><span class="comment-copy">"Never" is <b>way</b> overstating it, to the point of being misleading.  If you are using prepared statements incorrectly, it's not much better than not using them at all.  (Of course, a "prepared statement" that has had user input injected into it defeats the purpose...but i've actually seen it done.  And prepared statements can't handle identifiers (table names etc) as parameters.)  Add to that, some of the PDO drivers <i>emulate</i> prepared statements, and there's room for them to do so incorrectly (for instance, by half-assedly parsing the SQL).  Short version: never assume it is that easy.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>No this is not enough (in some specific cases)! By default PDO uses emulated prepared statements when using MySQL as a database driver. You should always disable emulated prepared statements when using MySQL and PDO:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$dbh</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span></code></pre>
<p>Another thing that always should be done it set the correct encoding of the database:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$dbh </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">'mysql:dbname=dbtest;host=127.0.0.1;charset=utf8'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'user'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'pass'</span><span class="pun">);</span></code></pre>
<p>Also see this related question: <a href="http://stackoverflow.com/questions/60174/best-way-to-prevent-sql-injection-in-php/60496">Best way to prevent SQL Injection in PHP</a></p>
<p>Also note that that only is about the database side of the things you would still have to watch yourself when displaying the data. E.g. by using <code>htmlspecialchars()</code> again with the correct encoding and quoting style.</p>
</div></text><author><a href="/users/508666/peehaa">PeeHaa</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Personally I would always run some form of sanitation on the data first as you can never trust user input, however when using placeholders / parameter binding the inputted data is sent to the server separately to the sql statement and then binded together.  The key here is that this binds the provided data to a specific type and a specific use and eliminates any opportunity to change the logic of the SQL statement.</p>
</div></text><author><a href="/users/2083/jimmyj">JimmyJ</a></author><comments/></answer></answers></post>