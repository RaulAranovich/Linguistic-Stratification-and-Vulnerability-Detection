<?xml version="1.0" encoding="utf-8"?>
<post><title>c++ - How does the JPEG of Death vulnerability operate? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I’ve been reading about an older exploit against GDI+ on Windows XP and <a href="http://en.wikipedia.org/wiki/Windows_Server_2003">Windows Server 2003</a> called the JPEG of death for a project I’m working on.</p>
<p>The exploit is well explained in the following link:
<a href="http://www.infosecwriters.com/text_resources/pdf/JPEG.pdf">http://www.infosecwriters.com/text_resources/pdf/JPEG.pdf</a></p>
<p>Basically, a JPEG file contains a section called COM containing a (possibly empty) comment field, and a two byte value containing the size of COM. If there are no comments, the size is 2. The reader (GDI+) reads the size, subtracts two, and allocates a buffer of the appropriate size to copy the comments in the heap.
The attack involves placing a value of <code>0</code> in the field. GDI+ subtracts <code>2</code>, leading to a value of <code>-2 (0xFFFe)</code> which gets converted to the unsigned integer <code>0XFFFFFFFE</code> by <a href="http://en.cppreference.com/w/c/string/byte/memcpy"><code>memcpy</code></a>.</p>
<p>Sample code:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="kwd">unsigned</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> size</span><span class="pun">;</span><span class="pln">
size </span><span class="pun">=</span><span class="pln"> len </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">comment </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">malloc</span><span class="pun">(</span><span class="pln">size </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
memcpy</span><span class="pun">(</span><span class="pln">comment</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></pre>
<p>Observe that <code>malloc(0)</code> on the third line should return a pointer to unallocated memory on the heap. How can writing <code>0XFFFFFFFE</code> bytes (<code>4GB</code>!!!!) possibly not crash the program? Does this write beyond the heap area and into the space of other programs and the OS? What happens then?</p>
<p>As I understand <code>memcpy</code>, it simply copies <code>n</code> characters from the destination to the source. In this case, the source should be on the stack, the destination on the heap, and <code>n</code> is <code>4GB</code>.</p>
</div></text><author><a href="/users/132735/dr1ku">Dr1Ku</a></author><comments><comment><text><span class="comment-copy">malloc will allocate memory from the heap. i think the exploit was done before memcpy and after the memory was allocated</span></text><author><a class="comment-user" href="/users/1441826/iedoc" title="1,216 reputation">iedoc</a></author></comment><comment><text><span class="comment-copy">just as a side note: it's <i>not</i> memcpy what promotes the value to an unsigned integer (4 bytes), but rather the subtraction.</span></text><author><a class="comment-user" href="/users/3215056/rev" title="1,019 reputation">rev</a></author></comment><comment><text><span class="comment-copy">Updated my previous answer with a live example. The <code>malloc</code>ed size is only 2 bytes rather than <code>0xFFFFFFFE</code>. This enormous size is only used for the copy size, not for the allocation size.</span></text><author><a class="comment-user" href="/users/507028/neitsa" title="4,179 reputation">Neitsa</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>This vulnerability was definitely a <a href="https://en.wikipedia.org/wiki/Heap_overflow" rel="noreferrer">heap overflow</a>.</p>
<blockquote>
<p>How can writing 0XFFFFFFFE bytes (4 GB!!!!) possibly not crash the program?</p>
</blockquote>
<p>It probably will, but on some occasions you got time to exploit before the crash happens (sometimes, you can get the program back to its normal execution and avoid the crash).</p>
<p>When the memcpy() starts, the copy will overwrite either some other heap blocks or some parts of the heap management structure (e.g free list, busy list, etc.). </p>
<p>At some point the copy will encounter a non allocated page and trigger an AV (Access Violation) on write. GDI+ will then try to allocate a new block in the heap (see <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff552108%28v=vs.85%29.aspx" rel="noreferrer">ntdll!RtlAllocateHeap</a>) ... but the heap structures are now all messed up.</p>
<p>At that point, by carefully crafting your JPEG image you can overwrite the heap management structures with controlled data. When the system tries to allocate the new block, it will probably unlink a (free) block from the free list.</p>
<p>Block are managed with (notably) a flink (Forward link ; the next block in the list) and blink (Backward link; the previous block in the list) pointers. If you control both of the flink and blink, you might have a possible WRITE4 (write What/Where condition) where you control what you can write and where you can write.</p>
<p>At that point you can overwrite a function pointer (<a href="https://en.wikipedia.org/wiki/Microsoft-specific_exception_handling_mechanisms#Structured_Exception_Handling" rel="noreferrer">SEH [Structured Exception Handlers]</a> pointers were a target of choice at that time back in 2004) and gain code execution.</p>
<p>See blog post <em><a href="http://blogs.msdn.com/b/carlos/archive/2008/12/10/heap-corruption-a-case-study.aspx" rel="noreferrer">Heap Corruption: A Case Study</a></em>.</p>
<p>Note: although I wrote about the exploitation using the freelist, an attacker might choose another path using other heap metadata ("heap metadata" are structures used by the system to manage the heap ; flink and blink are part of the heap metadata), but the unlink exploitation is probably the "easiest" one. A google search for "heap exploitation" will return numerous studies about this.</p>
<blockquote>
<p>Does this write beyond the heap area and into the space of other
  programs and the OS?</p>
</blockquote>
<p>Never. Modern OS are based on the concept of virtual address space so each process on has its own virtual address space that enables addressing up to 4 gigabytes of memory on a 32-bit system (in practice you only got half of it in user-land, the rest is for the kernel).</p>
<p>In short, a process can't access the memory of another process (except if it asks the kernel for it through some service / API, but the kernel will check if the caller has the right to do so).</p>
<hr/>
<p>I decided to test this vulnerability this week-end, so we could get a good idea on what was going on rather than pure speculation.
The vulnerability is now 10 years old, so I thought it was OK to write about it, although I haven't explained the exploitation part in this answer.</p>
<p><strong>Planning</strong></p>
<p>The most difficult task was to find a Windows XP with only SP1, as it was in 2004 :)</p>
<p>Then, I downloaded a JPEG image composed only of a single pixel, as shown below (cut for brevity):</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="typ">File</span><span class="pln"> </span><span class="lit">1x1</span><span class="pln">_pixel</span><span class="pun">.</span><span class="pln">JPG
</span><span class="typ">Address</span><span class="pln">   </span><span class="typ">Hex</span><span class="pln"> dump                                         ASCII
</span><span class="lit">00000000</span><span class="pln">  FF D8 FF E0</span><span class="pun">|</span><span class="lit">00</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="lit">4A</span><span class="pln"> </span><span class="lit">46</span><span class="pun">|</span><span class="lit">49</span><span class="pln"> </span><span class="lit">46</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">01</span><span class="pun">|</span><span class="lit">01</span><span class="pln"> </span><span class="lit">01</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">60</span><span class="pun">|</span><span class="pln"> </span><span class="pun">ÿØÿà</span><span class="pln"> JFIF  </span><span class="pun">`</span><span class="pln">
</span><span class="lit">00000010</span><span class="pln">  </span><span class="lit">00</span><span class="pln"> </span><span class="lit">60</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pun">|</span><span class="pln">FF E1 </span><span class="lit">00</span><span class="pln"> </span><span class="lit">16</span><span class="pun">|</span><span class="lit">45</span><span class="pln"> </span><span class="lit">78</span><span class="pln"> </span><span class="lit">69</span><span class="pln"> </span><span class="lit">66</span><span class="pun">|</span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">49</span><span class="pln"> </span><span class="lit">49</span><span class="pun">|</span><span class="pln">  </span><span class="pun">`</span><span class="pln">  </span><span class="pun">ÿá</span><span class="pln"> </span><span class="typ">Exif</span><span class="pln">  II
</span><span class="lit">00000020</span><span class="pln">  </span><span class="lit">2A</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">08</span><span class="pln"> </span><span class="lit">00</span><span class="pun">|</span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pun">|</span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pun">|</span><span class="pln">FF DB </span><span class="lit">00</span><span class="pln"> </span><span class="lit">43</span><span class="pun">|</span><span class="pln"> </span><span class="pun">*</span><span class="pln">          </span><span class="pun">ÿÛ</span><span class="pln"> C
</span><span class="pun">[...]</span></code></pre>
<p>A JPEG picture is composed of binary markers (which intrduce segments). In the above image, <code>FF D8</code> is the SOI (Start Of Image) marker, while <code>FF E0</code>, for example, is an application marker. </p>
<p>The first parameter in a marker segment (except some markers like SOI) is a two-byte length parameter which encodes the number of bytes in the marker segment, including the length parameter and excluding the two-byte marker.</p>
<p>I simply added a COM marker (0x<code>FFFE</code>) right after the SOI, since markers have no strict order.</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="typ">File</span><span class="pln"> </span><span class="lit">1x1</span><span class="pln">_pixel_comment_mod1</span><span class="pun">.</span><span class="pln">JPG
</span><span class="typ">Address</span><span class="pln">   </span><span class="typ">Hex</span><span class="pln"> dump                                         ASCII
</span><span class="lit">00000000</span><span class="pln">  FF D8 FF FE</span><span class="pun">|</span><span class="lit">00</span><span class="pln"> </span><span class="lit">00</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">31</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="pln"> </span><span class="pun">ÿØÿþ</span><span class="pln">  </span><span class="lit">0000000100</span><span class="pln">
</span><span class="lit">00000010</span><span class="pln">  </span><span class="lit">30</span><span class="pln"> </span><span class="lit">32</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">33</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">34</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">35</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="pln"> </span><span class="lit">0200030004000500</span><span class="pln">
</span><span class="lit">00000020</span><span class="pln">  </span><span class="lit">30</span><span class="pln"> </span><span class="lit">36</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">37</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">38</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">39</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="pln"> </span><span class="lit">0600070008000900</span><span class="pln">
</span><span class="lit">00000030</span><span class="pln">  </span><span class="lit">30</span><span class="pln"> </span><span class="lit">61</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">62</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">63</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="lit">30</span><span class="pln"> </span><span class="lit">64</span><span class="pln"> </span><span class="lit">30</span><span class="pln"> </span><span class="lit">30</span><span class="pun">|</span><span class="pln"> </span><span class="lit">0a000b000c000d00</span><span class="pln">
</span><span class="pun">[...]</span></code></pre>
<p>The length of the COM segment is set to <code>00 00</code> to trigger the vulnerability. I also injected 0xFFFC bytes right after the COM marker with a recurring pattern, a 4 bytes number in hex, which will become handy when "exploiting" the vulnerability.</p>
<p><strong>Debugging</strong></p>
<p>Double clicking the image will immediately trigger the bug in the Windows shell (aka "explorer.exe"), somewhere in <code>gdiplus.dll</code>, in a function named <code>GpJpegDecoder::read_jpeg_marker()</code>.</p>
<p>This function is called for each marker in the picture, it simply: reads the marker segment size, allocates a buffer whose length is the segment size and copy the content of the segment into this newly allocated buffer.</p>
<p>Here the start of the function :</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199D5</span><span class="pln">  mov     ebx</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> ebx </span><span class="pun">=</span><span class="pln"> </span><span class="pun">*</span><span class="kwd">this</span><span class="pln"> </span><span class="pun">(</span><span class="typ">GpJpegDecoder</span><span class="pln"> instance</span><span class="pun">)</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199D8</span><span class="pln">  push    esi
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199D9</span><span class="pln">  mov     esi</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">ebx</span><span class="pun">+</span><span class="lit">18h</span><span class="pun">]</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199DC</span><span class="pln">  mov     eax</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">esi</span><span class="pun">]</span><span class="pln">      </span><span class="pun">;</span><span class="pln"> eax </span><span class="pun">=</span><span class="pln"> pointer to segment size
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199DE</span><span class="pln">  push    edi
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199DF</span><span class="pln">  mov     edi</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">esi</span><span class="pun">+</span><span class="lit">4</span><span class="pun">]</span><span class="pln">    </span><span class="pun">;</span><span class="pln"> edi </span><span class="pun">=</span><span class="pln"> bytes left to process in the image</span></code></pre>
<p><code>eax</code> register points to the segment size and <code>edi</code> is the number of bytes left in the image.</p>
<p>The code then proceeds to read the segment size, starting by the most significant byte (length is a 16-bits value):</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199F7</span><span class="pln">  xor     ecx</span><span class="pun">,</span><span class="pln"> ecx        </span><span class="pun">;</span><span class="pln"> segment_size </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199F9</span><span class="pln">  mov     ch</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eax</span><span class="pun">]</span><span class="pln">       </span><span class="pun">;</span><span class="pln"> get most significant byte from size </span><span class="pun">--&gt;</span><span class="pln"> CH </span><span class="pun">==</span><span class="pln"> </span><span class="lit">00</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199FB</span><span class="pln">  dec     edi             </span><span class="pun">;</span><span class="pln"> bytes_to_process </span><span class="pun">--</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199FC</span><span class="pln">  inc     eax             </span><span class="pun">;</span><span class="pln"> pointer</span><span class="pun">++</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199FD</span><span class="pln">  test    edi</span><span class="pun">,</span><span class="pln"> edi
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E199FF</span><span class="pln">  mov     </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_0</span><span class="pun">],</span><span class="pln"> ecx </span><span class="pun">;</span><span class="pln"> save segment_size</span></code></pre>
<p>And the least significant byte:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A15</span><span class="pln">  movzx   cx</span><span class="pun">,</span><span class="pln"> byte ptr </span><span class="pun">[</span><span class="pln">eax</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> get least significant byte from size </span><span class="pun">--&gt;</span><span class="pln"> CX </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A19</span><span class="pln">  add     </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_0</span><span class="pun">],</span><span class="pln"> ecx   </span><span class="pun">;</span><span class="pln"> save segment_size
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A1C</span><span class="pln">  mov     ecx</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">lpMem</span><span class="pun">]</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A1F</span><span class="pln">  inc     eax             </span><span class="pun">;</span><span class="pln"> pointer </span><span class="pun">++</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A20</span><span class="pln">  mov     </span><span class="pun">[</span><span class="pln">esi</span><span class="pun">],</span><span class="pln"> eax
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A22</span><span class="pln">  mov     eax</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> eax </span><span class="pun">=</span><span class="pln"> segment_size</span></code></pre>
<p>Once this is done, the segment size is used to allocate a buffer, following this calculation:</p>
<p>alloc_size = segment_size + 2</p>
<p>This is done by the code below:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A29</span><span class="pln">  movzx   esi</span><span class="pun">,</span><span class="pln"> word ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> esi </span><span class="pun">=</span><span class="pln"> segment size </span><span class="pun">(</span><span class="pln">cast from </span><span class="lit">16</span><span class="pun">-</span><span class="pln">bit to </span><span class="lit">32</span><span class="pun">-</span><span class="pln">bit</span><span class="pun">)</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A2D</span><span class="pln">  add     eax</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> 
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A30</span><span class="pln">  mov     </span><span class="pun">[</span><span class="pln">ecx</span><span class="pun">],</span><span class="pln"> ax 
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A33</span><span class="pln">  lea     eax</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">esi</span><span class="pun">+</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> alloc_size </span><span class="pun">=</span><span class="pln"> segment_size </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A36</span><span class="pln">  push    eax             </span><span class="pun">;</span><span class="pln"> dwBytes
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A37</span><span class="pln">  call    </span><span class="typ">_GpMalloc@4</span><span class="pln">     </span><span class="pun">;</span><span class="pln"> </span><span class="typ">GpMalloc</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span></code></pre>
<p>In our case, as the segment size is 0, <strong>the allocated size for the buffer is 2 bytes</strong>.</p>
<p>The vulnerability is right after the allocation:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A37</span><span class="pln">  call    </span><span class="typ">_GpMalloc@4</span><span class="pln">     </span><span class="pun">;</span><span class="pln"> </span><span class="typ">GpMalloc</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A3C</span><span class="pln">  test    eax</span><span class="pun">,</span><span class="pln"> eax
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A3E</span><span class="pln">  mov     </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">lpMem</span><span class="pun">],</span><span class="pln"> eax </span><span class="pun">;</span><span class="pln"> save pointer to allocation
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A41</span><span class="pln">  jz      loc_70E19AF1
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A47</span><span class="pln">  mov     cx</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_4</span><span class="pun">]</span><span class="pln">   </span><span class="pun">;</span><span class="pln"> low marker byte </span><span class="pun">(</span><span class="lit">0xFE</span><span class="pun">)</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A4B</span><span class="pln">  mov     </span><span class="pun">[</span><span class="pln">eax</span><span class="pun">],</span><span class="pln"> cx         </span><span class="pun">;</span><span class="pln"> save in alloc </span><span class="pun">(</span><span class="pln">offset </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
</span><span class="pun">;[...]</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A52</span><span class="pln">  lea     edx</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">esi</span><span class="pun">-</span><span class="lit">2</span><span class="pun">]</span><span class="pln">      </span><span class="pun">;</span><span class="pln"> edx </span><span class="pun">=</span><span class="pln"> segment_size </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0xFFFFFFFE</span><span class="pun">!!!</span><span class="pln">
</span><span class="pun">;[...]</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A61</span><span class="pln">  mov     </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_0</span><span class="pun">],</span><span class="pln"> edx</span></code></pre>
<p>The code simply subtracts the segment_size size (segment length is a 2 bytes value) from the whole segment size (0 in our case) and ends up with an integer underflow: <strong>0 - 2 = 0xFFFFFFFE</strong></p>
<p>The code then checks is there are bytes left to parse in the image (which is true), and then jumps to the copy:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A69</span><span class="pln">  mov     ecx</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eax</span><span class="pun">+</span><span class="lit">4</span><span class="pun">]</span><span class="pln">  </span><span class="pun">;</span><span class="pln"> ecx </span><span class="pun">=</span><span class="pln"> bytes left to parse </span><span class="pun">(</span><span class="lit">0x133</span><span class="pun">)</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A6C</span><span class="pln">  cmp     ecx</span><span class="pun">,</span><span class="pln"> edx      </span><span class="pun">;</span><span class="pln"> edx </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0xFFFFFFFE</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A6E</span><span class="pln">  jg      </span><span class="kwd">short</span><span class="pln"> loc_70E19AB4 </span><span class="pun">;</span><span class="pln"> take jump to copy
</span><span class="pun">;[...]</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19AB4</span><span class="pln">  mov     eax</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">ebx</span><span class="pun">+</span><span class="lit">18h</span><span class="pun">]</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19AB7</span><span class="pln">  mov     esi</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eax</span><span class="pun">]</span><span class="pln">      </span><span class="pun">;</span><span class="pln"> esi </span><span class="pun">=</span><span class="pln"> source </span><span class="pun">=</span><span class="pln"> points to segment content </span><span class="pun">(</span><span class="str">"0000000100020003..."</span><span class="pun">)</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19AB9</span><span class="pln">  mov     edi</span><span class="pun">,</span><span class="pln"> dword ptr </span><span class="pun">[</span><span class="pln">ebp</span><span class="pun">+</span><span class="pln">arg_4</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> edi </span><span class="pun">=</span><span class="pln"> destination buffer
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19ABC</span><span class="pln">  mov     ecx</span><span class="pun">,</span><span class="pln"> edx        </span><span class="pun">;</span><span class="pln"> ecx </span><span class="pun">=</span><span class="pln"> copy size </span><span class="pun">=</span><span class="pln"> segment content size </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0xFFFFFFFE</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19ABE</span><span class="pln">  mov     eax</span><span class="pun">,</span><span class="pln"> ecx
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19AC0</span><span class="pln">  shr     ecx</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln">          </span><span class="pun">;</span><span class="pln"> size </span><span class="pun">/</span><span class="pln"> </span><span class="lit">4</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19AC3</span><span class="pln">  rep movsd               </span><span class="pun">;</span><span class="pln"> copy segment content by </span><span class="lit">32</span><span class="pun">-</span><span class="pln">bit chunks</span></code></pre>
<p>The above snippet shows that copy size is 0xFFFFFFFE 32-bits chunks. The source buffer is controlled (content of the picture) and the destination is a buffer on the heap.</p>
<p><strong>Write condition</strong></p>
<p>The copy will trigger an access violation (AV) exception when it reaches the end of the memory page (this could be either from the source pointer or destination pointer). When the AV is triggered, the heap is already in a vulnerable state because the copy has already overwritten all following heap blocks until a non-mapped page was encountered.</p>
<p>What makes this bug exploitable is that 3 SEH (Structured Exception Handler; this is try / except at low level) are catching exceptions on this part of the code. More precisely, the 1st SEH will unwind the stack so it gets back to parse another JPEG marker, thus completely skipping the marker that triggered the exception.</p>
<p>Without an SEH the code would have just crashed the whole program. So the code skips the COM segment and parses another segment. So we get back to <code>GpJpegDecoder::read_jpeg_marker()</code> with a new segment and when the code allocates a new buffer:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A33</span><span class="pln">  lea     eax</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="pln">esi</span><span class="pun">+</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> alloc_size </span><span class="pun">=</span><span class="pln"> semgent_size </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln">
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A36</span><span class="pln">  push    eax             </span><span class="pun">;</span><span class="pln"> dwBytes
</span><span class="pun">.</span><span class="pln">text</span><span class="pun">:</span><span class="lit">70E19A37</span><span class="pln">  call    </span><span class="typ">_GpMalloc@4</span><span class="pln">     </span><span class="pun">;</span><span class="pln"> </span><span class="typ">GpMalloc</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span></code></pre>
<p>The system will unlink a block from the free list. It happens that metadata structures were overwritten by the content of the image; so we control the unlink with controlled metadata. The below code in somewhere in the system (ntdll) in the heap manager:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pln">CPU </span><span class="typ">Disasm</span><span class="pln">
</span><span class="typ">Address</span><span class="pln">   </span><span class="typ">Command</span><span class="pln">                                  </span><span class="typ">Comments</span><span class="pln">
</span><span class="lit">77F52CBF</span><span class="pln">  MOV ECX</span><span class="pun">,</span><span class="pln">DWORD PTR DS</span><span class="pun">:[</span><span class="pln">EAX</span><span class="pun">]</span><span class="pln">               </span><span class="pun">;</span><span class="pln"> eax points to </span><span class="str">'0003'</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> ecx </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x33303030</span><span class="pln">
</span><span class="lit">77F52CC1</span><span class="pln">  MOV DWORD PTR SS</span><span class="pun">:[</span><span class="pln">EBP</span><span class="pun">-</span><span class="lit">0B0</span><span class="pun">],</span><span class="pln">ECX           </span><span class="pun">;</span><span class="pln"> save ecx
</span><span class="lit">77F52CC7</span><span class="pln">  MOV EAX</span><span class="pun">,</span><span class="pln">DWORD PTR DS</span><span class="pun">:[</span><span class="pln">EAX</span><span class="pun">+</span><span class="lit">4</span><span class="pun">]</span><span class="pln">             </span><span class="pun">;</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eax</span><span class="pun">+</span><span class="lit">4</span><span class="pun">]</span><span class="pln"> points to </span><span class="str">'0004'</span><span class="pln"> </span><span class="pun">;</span><span class="pln"> eax </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x34303030</span><span class="pln">
</span><span class="lit">77F52CCA</span><span class="pln">  MOV DWORD PTR SS</span><span class="pun">:[</span><span class="pln">EBP</span><span class="pun">-</span><span class="lit">0B4</span><span class="pun">],</span><span class="pln">EAX
</span><span class="lit">77F52CD0</span><span class="pln">  MOV DWORD PTR DS</span><span class="pun">:[</span><span class="pln">EAX</span><span class="pun">],</span><span class="pln">ECX               </span><span class="pun">;</span><span class="pln"> write </span><span class="lit">0x33303030</span><span class="pln"> to </span><span class="lit">0x34303030</span><span class="pun">!!!</span></code></pre>
<p>Now we can write what we want, where we want...</p>
</div></text><author><a href="/users/507028/neitsa">Neitsa</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Since I don't know the code from GDI, what's below is just speculation.</p>
<p>Well, one thing that pops into mind is one behavior that I've noticed on some OSes (I don't know if Windows XP had this) was when allocating with new / <code>malloc</code>, you can actually allocate more than your RAM, as long as you don't write to that memory.</p>
<p>This is actually a behavior of the linux Kernel.</p>
<p>From www.kernel.org :</p>
<blockquote>
<p>Pages in the process linear address space are not necessarily resident in memory. For example, allocations made on behalf of a process are not satisfied immediately as the space is just reserved within the vm_area_struct.</p>
</blockquote>
<p>To get into resident memory a page fault must be triggered.</p>
<p>Basically you need to make the memory dirty before it actually gets allocated on the system:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pln">  </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> size</span><span class="pun">=-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> comment </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">[</span><span class="pln">size</span><span class="pun">];</span></code></pre>
<p>Sometimes it won't actually make a real allocation in RAM (your program will still not use 4 GB). I know I've seen this behavior on a Linux, but I cannot however replicate it now on my Windows 7 installation.</p>
<p>Starting from this behavior the following scenario is possible.</p>
<p>In order to make that memory existing in RAM you need to make it dirty (basically memset or some other write to it):</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pln">  memset</span><span class="pun">(</span><span class="pln">comment</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></pre>
<p>However the vulnerability exploits a buffer overflow, not an allocation failure.</p>
<p>In other words, if I'd were to have this:</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pln"> unsinged </span><span class="typ">int</span><span class="pln"> size </span><span class="pun">=-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
 </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">[</span><span class="pln">size</span><span class="pun">];</span><span class="pln"> </span><span class="com">// Will not crash here</span><span class="pln">
 memcpy</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span><span class="pln"> some_buffer</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></pre>
<p>This will lead to a write after buffer, because there's no such thing as a 4 GB segment of continuous memory.</p>
<p>You didn't put anything in p to make the whole 4 GB of memory dirty, and I don't know if <code>memcpy</code> makes memory dirty all at once, or just page by page (I think it's page by page).</p>
<p>Eventually it will end up overwriting the stack frame (Stack Buffer Overflow).</p>
<p>Another more possible vulnerability was if the picture was kept in memory as a byte array (read whole file into buffer), and the sizeof comments was used just to skip ahead non-vital information.</p>
<p>For example</p>
<pre class="lang-cpp prettyprint prettyprinted" style=""><code><span class="pln">     </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> commentsSize </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
     </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> wholePictureBytes</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Has size of file</span><span class="pln">
     </span><span class="pun">...</span><span class="pln">
     </span><span class="com">// Time to start processing the output color</span><span class="pln">
     </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> wholePictureButes</span><span class="pun">;</span><span class="pln">
     offset </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">short</span><span class="pun">)</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">COM_OFFSET</span><span class="pun">];</span><span class="pln">
     </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> dataP </span><span class="pun">=</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> offset</span><span class="pun">;</span><span class="pln">
     dataP</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">EvilHackerValue</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Vulnerability here</span></code></pre>
<p>As you mentioned, if the GDI didn't allocates that size, the program will never crash.</p>
</div></text><author><a href="/users/746569/michaelcms">MichaelCMS</a></author><comments><comment><text><span class="comment-copy">That could be with a 64-bit system, where 4GB is not a big deal (speaking about addess space). But in a 32-bit system, (they appear to be vulnerable too) you cannot reserve 4GB of address space, because that would be all there is! So a <code>malloc(-1U)</code> will surely fail, return <code>NULL</code> and <code>memcpy()</code> will crash.</span></text><author><a class="comment-user" href="/users/865874/rodrigo" title="53,031 reputation">rodrigo</a></author></comment><comment><text><span class="comment-copy">I don't think this line is true: "Eventually it will end up writing into another process address." Normally one process cannot access another's memory. See <a href="http://en.wikipedia.org/wiki/Memory_management_unit#Benefits" rel="nofollow noreferrer">MMU Benefits</a>.</span></text><author><a class="comment-user" href="/users/1822514/chue-x" title="15,050 reputation">chue x</a></author></comment><comment><text><span class="comment-copy">@MMU Benefits yes, you are right. I was meant to say that will go over the normal heap boundaries and start overwriting the stack frame. I will edit my answer, thanks for pointing it out.</span></text><author><a class="comment-user" href="/users/746569/michaelcms" title="3,581 reputation">MichaelCMS</a></author></comment></comments></answer></answers></post>