<?xml version="1.0" encoding="utf-8"?>
<post><title>security - What common web exploits should I know about? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm pretty green still when it comes to web programming, I've spent most of my time on client applications.  So I'm curious about the common exploits I should fear/test for in my site.</p>
</div></text><author><a href="/users/2134/chris">Chris</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p><a href="http://www.owasp.org/index.php/Main_Page" rel="noreferrer">OWASP</a> keeps a list of the <a href="http://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project" rel="noreferrer">Top 10</a> web attacks to watch our for, in addition to a ton of other useful security information for web development.</p>
</div></text><author><a href="/users/204/dragonmantank">dragonmantank</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm posting the <a href="http://www.owasp.org/index.php/Top_10_2007" rel="noreferrer">OWASP Top 2007 abbreviated list</a> here so people don't have to look through to another link and in case the source goes down.</p>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A1" rel="noreferrer">Cross Site Scripting (XSS)</a></h2>
<ul>
<li>XSS flaws occur whenever an application takes user supplied data and sends it to a web browser without first validating or encoding that content. XSS allows attackers to execute script in the victim's browser which can hijack user sessions, deface web sites, possibly introduce worms, etc.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A2" rel="noreferrer">Injection Flaws</a></h2>
<ul>
<li>Injection flaws, particularly SQL injection, are common in web applications. Injection occurs when user-supplied data is sent to an interpreter as part of a command or query. The attacker's hostile data tricks the interpreter into executing unintended commands or changing data.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A3" rel="noreferrer">Malicious File Execution</a></h2>
<ul>
<li>Code vulnerable to remote file inclusion (RFI) allows attackers to include hostile code and data, resulting in devastating attacks, such as total server compromise. Malicious file execution attacks affect PHP, XML and any framework which accepts filenames or files from users.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A4" rel="noreferrer">Insecure Direct Object Reference</a></h2>
<ul>
<li>A direct object reference occurs when a developer exposes a reference to an internal implementation object, such as a file, directory, database record, or key, as a URL or form parameter. Attackers can manipulate those references to access other objects without authorization.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A5" rel="noreferrer">Cross Site Request Forgery (CSRF)</a></h2>
<ul>
<li>A CSRF attack forces a logged-on victim's browser to send a pre-authenticated request to a vulnerable web application, which then forces the victim's browser to perform a hostile action to the benefit of the attacker. CSRF can be as powerful as the web application that it attacks.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A6" rel="noreferrer">Information Leakage and Improper Error Handling</a></h2>
<ul>
<li>Applications can unintentionally leak information about their configuration, internal workings, or violate privacy through a variety of application problems. Attackers use this weakness to steal sensitive data, or conduct more serious attacks.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A7" rel="noreferrer">Broken Authentication and Session Management</a></h2>
<ul>
<li>Account credentials and session tokens are often not properly protected. Attackers compromise passwords, keys, or authentication tokens to assume other users' identities.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A8" rel="noreferrer">Insecure Cryptographic Storage</a></h2>
<ul>
<li>Web applications rarely use cryptographic functions properly to protect data and credentials. Attackers use weakly protected data to conduct identity theft and other crimes, such as credit card fraud.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A9" rel="noreferrer">Insecure Communications</a></h2>
<ul>
<li>Applications frequently fail to encrypt network traffic when it is necessary to protect sensitive communications.</li>
</ul>
<h2><a href="http://www.owasp.org/index.php/Top_10_2007-A10" rel="noreferrer">Failure to Restrict URL Access</a></h2>
<ul>
<li>Frequently, an application only protects sensitive functionality by preventing the display of links or URLs to unauthorized users. Attackers can use this weakness to access and perform unauthorized operations by accessing those URLs directly.</li>
</ul>
<p><a href="http://www.owasp.org/index.php/OWASP:About" rel="noreferrer">The Open Web Application Security Project</a></p>
<p>-Adam</p>
</div></text><author><a href="/users/2915/adam-davis">Adam Davis</a></author><comments><comment><text><span class="comment-copy">The 2013 edition of the top ten list is here: <a href="https://www.owasp.org/index.php/Top_10_2013-Top_10" rel="nofollow noreferrer">owasp.org/index.php/Top_10_2013-Top_10</a></span></text><author><a class="comment-user" href="/users/2915/adam-davis" title="61,551 reputation">Adam Davis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>These three are the most important:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Cross_Site_Request_Forgery" rel="noreferrer">Cross Site Request Forgery</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cross-site_scripting" rel="noreferrer">Cross Site Scripting</a></li>
<li><a href="http://en.wikipedia.org/wiki/SQL_injection" rel="noreferrer">SQL injection</a></li>
</ul>
</div></text><author><a href="/users/429/patrick">Patrick</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<pre><code>bool UserCredentialsOK(User user)
{

if (user.Name == "modesty")
  return false;
else
 // perform other checks
}   
</code></pre>
<p>;)</p>
</div></text><author><a href="/users/832/rob-cooper">Rob Cooper</a></author><comments><comment><text><span class="comment-copy">+1 for funny, yet I don't wanna know how many times I found hard coded authentications in systems...</span></text><author><a class="comment-user" href="/users/16868/tekiegreg" title="784 reputation">tekiegreg</a></author></comment><comment><text><span class="comment-copy">In addition, this can open the door to time-based attacks where a valid username with an invalid password would take far less time than an invalid username. A hacker could then figure out a list of user names and work from there.</span></text><author><a class="comment-user" href="/users/1067337/nicolas-bouliane" title="668 reputation">Nicolas Bouliane</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Everyone's going to say "SQL Injection", because it's the scariest-sounding vulnerability and the easiest one to get your head around. Cross-Site Scripting (XSS) is going to come in second place, because it's also easy to understand. "Poor input validation" isn't a vulnerability, but rather an evaluation of a security best practice.</p>
<p>Let's try this from a different perspective. Here are features that, when implemented in a web application, are likely to mess you up:</p>
<ul>
<li><p>Dynamic SQL (for instance, UI query builders). By now, you probably know that the only reliably safe way to use SQL in a web app is to use parameterized queries, where you explicitly bind each parameter in the query to a variable. The places where I see web apps most frequently break this rule is when the malicious input isn't an obvious parameter (like a name), but rather a query attribute. An obvious example are the iTunes-like "Smart Playlist" query builders you see on search sites, where things like where-clause operators are passed directly to the backend. Another great rock to turn over are table column sorts, where you'll see things like DESC exposed in HTTP parameters.</p></li>
<li><p>File upload. File upload messes people up because file pathnames look suspiciously like URL pathnames, and because web servers make it easy to implement the "download" part just by aiming URLs at directories on the filesystem. 7 out of 10 upload handlers we test allow attackers to access arbitrary files on the server, because the app developers assumed the same permissions were applied to the filesystem "open()" call as are applied to queries.</p></li>
<li><p>Password storage. If your application can mail me back my raw password when I lose it, you fail. There's a single safe reliable answer for password storage, which is bcrypt; if you're using PHP, you probably want PHPpass.</p></li>
<li><p>Random number generation. A classic attack on web apps: reset another user's password, and, because the app is using the system's "rand()" function, which is not crypto-strong, the password is predictable. This also applies anywhere you're doing cryptography. Which, by the way, you shouldn't be doing: if you're relying on crypto anywhere, you're very likely vulnerable.</p></li>
<li><p>Dynamic output. People put too much faith in input validation. Your chances of scrubbing user inputs of all possible metacharacters, especially in the real world, where metacharacters are necessary parts of user input, are low. A much better approach is to have a consistent regime of filtering database outputs and transforming them into HTML entities, like quot, gt, and lt. Rails will do this for you automatically.</p></li>
<li><p>Email. Plenty of applications implement some sort of outbound mail capability that enable an attacker to either create an anonymous account, or use no account at all, to send attacker-controlled email to arbitrary email addresses. </p></li>
</ul>
<p>Beyond these features, the #1 mistake you are likely to make in your application is to expose a database row ID somewhere, so that user X can see data for user Y simply by changing a number from "5" to "6". </p>
</div></text><author><a href="/users/5674/tqbf">tqbf</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>SQL INJECTION ATTACKS. They are easy to avoid but all too common.</p>
<p>NEVER EVER EVER EVER (did I mention "ever"?) trust user information passed to you from form elements. If your data is not vetted before being passed into other logical layers of your application, you might as well give the keys to your site to a stranger on the street.</p>
<p>You do not mention what platform you are on but if on ASP.NET get a start with good ol' Scott Guthrie and his article "<a href="http://weblogs.asp.net/scottgu/archive/2006/09/30/Tip_2F00_Trick_3A00_-Guard-Against-SQL-Injection-Attacks.aspx" rel="nofollow noreferrer">Tip/Trick: Guard Against SQL Injection Attacks</a>".</p>
<p>After that you need to consider what type of data you will permit users to submit into and eventually out of your database. If you permit HTML to be inserted and then later presented you are wide-open for Cross Site Scripting attacks (known as XSS).</p>
<p>Those are the two that come to mind for me, but our very own Jeff Atwood had a good article at <a href="http://www.codinghorror.com/blog/archives/000841.html" rel="nofollow noreferrer">Coding Horror</a> with a review of the book "<a href="http://rads.stackoverflow.com/amzn/click/0072260858" rel="nofollow noreferrer">19 Deadly Sins of Software Security</a>".</p>
</div></text><author><a href="/users/2213/ian-patrick-hughes">Ian Patrick Hughes</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Most people here have mentioned SQL Injection and XSS, which is <em>kind of</em> correct, but don't be fooled - the most important things you need to worry about as a web developer is INPUT VALIDATION, which is where XSS and SQL Injection stem from.</p>
<p>For instance, if you have a form field that will only ever accept integers, make sure you're implementing something at both the client-side AND the server-side to sanitise the data. </p>
<p>Check and double check any input data especially if it's going to end up in an SQL query. I suggest building an escaper function and wrap it around anything going into a query. For instance:</p>
<pre><code>$query = "SELECT field1, field2 FROM table1 WHERE field1 = '" . myescapefunc($userinput) . "'";
</code></pre>
<p>Likewise, if you're going to display any user-inputted information onto a webpage, make sure you've stripped any &lt;script&gt; tags or anything else that might result in Javascript execution (such as onLoad= onMouseOver= etc. attributes on tags).</p>
</div></text><author><a href="/users/1693/steve-m">Steve M</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This is also a short little presentation on security by one of wordpress's core developers.</p>
<p><a href="http://markjaquith.wordpress.com/2008/08/16/secure-coding-with-wordpress-wordcamp-sf-2008-slides/" rel="nofollow noreferrer">Security in wordpress</a></p>
<p>it covers all of the basic security problems in web apps.</p>
</div></text><author><a href="/users/1063/icco">icco</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The most common are probably database injection attacks and cross-site scripting attacks; mainly because those are the easiest to accomplish (that's likely because those are the ones programmers are laziest about).</p>
</div></text><author><a href="/users/1975282/thesmurf">TheSmurf</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You can see even on this site that the most damaging things you'll be looking after involve code injection into your application, so XSS (Cross Site Scripting) and SQL injection (@Patrick's suggestions) are your biggest concerns.
Basically you're going to want to make sure that if your application allows for a user to inject any code whatsoever, it's regulated and tested to be sure that only things you're sure you want to allow (an html link, image, etc) are passed, and nothing else is executed.</p>
</div></text><author><a href="/users/2293/btw">btw</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>SQL Injection.  Cross Site Scripting.  </p>
</div></text><author><a href="/users/1862/kibbee">Kibbee</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Using stored procedures and/or parameterized queries will go a long way in protecting you from sql injection. Also do <em>NOT</em> have your web app access the database as sa or dbo - set a up a standard user account and set the permissions. </p>
<p>AS for XSS (cross site scripting) ASP.NET has some built in protections. The best thing is to filter input using validation controls and Regex.     </p>
</div></text><author><a href="/users/1433/booji-boy">Booji Boy</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm no expert, but from what I learned so far the golden rule is not to trust any user data (GET, POST, COOKIE). Common attack types and how to save yourself:</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/SQL_injection" rel="nofollow noreferrer">SQL Injection Attack</a>: Use prepared queries</li>
<li><a href="http://en.wikipedia.org/wiki/Cross-site_scripting" rel="nofollow noreferrer">Cross Site Scripting</a>: Send no user data to browser without filtering/escaping first. This also includes user data stored in database, which originally came from users.</li>
</ol>
</div></text><author><a href="/users/1897/imran">Imran</a></author><comments/></answer></answers></post>