<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Best way to secure Android app sensitive Data? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Yes this is a pretty general question but I'm trying to get a feel for the best way to handle an app that touches base w/ a webserver that distributes sensitive data to the app.  Any links, general information advice etc.. would be appreciated. </p>
<p>Since the app would store persistant data retreived from the database for a certain amount of time.. everything becomes somewhat touchy.  </p>
</div></text><author><a href="/users/445000/djplayer">DJPlayer</a></author><comments><comment><text><span class="comment-copy">isn't the db is a good choice for storing sensitive info?</span></text><author><span class="comment-user">user849998</span></author></comment><comment><text><span class="comment-copy">Secure against whom? The legitimate user of your app, a phone thief, a virus,...</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<h1>Storing sensitive data on the device</h1>
<p>That depends very much on your audience. Normally, the Android OS prohibits apps from accessing each other's files (i.e. databases, preference files, regular files stored in the app's private directory) through proven Linux file permissions. However, on rooted devices an application can obtain root access and read everything. A few things to think about:</p>
<ol>
<li>If you know your users won't have root (e.g. if you are not distributing the app through Android Market, but only in your company, or something like that), you can simply rely on Android's filesystem-based security.</li>
<li>If a user does get root access, he will be very careful what application he gives that priviledge to</li>
<li>If an app does get root access, it can wreak a lot of havoc. The information in your app could be the least of the user's worries.</li>
<li>Rooting leads to zero warranty. Including in apps. You can't be held responsible for leaking information on a rooted phone.</li>
</ol>
<p>To conclude, if your information is not super-duper sensitive (e.g. credit card information), I'd suggest just sticking with the default security provided by Android (i.e. save everything in plain text, knowing other apps can't access it).</p>
<p>Otherwise, encryption is the way to go. It's not 100% secure (a hacker could de-compile your app and figure out how to decrypt the data), but it's a major pain to crack and will stop most hackers. Especially if you obfuscate your code with something like <a href="http://developer.android.com/guide/developing/tools/proguard.html" rel="noreferrer">ProGuard</a>.</p>
<hr/>
<h1>Transferring sensitive data from the server to the device</h1>
<p>You have a few options here. First of all, always use HTTPS. After enabling HTTPS, here are two extra security measures I would propose:</p>
<ol>
<li>Use an API key system. Include this API key in all your requests and check it on the server side before sending any response back. Remember that since you're using HTTPS, an attacker would not be able to just use a network sniffer to find out your API key. However, this is pretty easy to figure out if someone decompiles your app, which is why you can obfuscate it even further (besides using ProGuard). For example, you can keep the API key broken up into pieces all around your code (for example as static members in two or three classes). Then, when you send a request, you just concatenate all those pieces. You can even apply some other sort of transformation (e.g. bit shifting) to make it even harder to figure out from the decompiled code.</li>
<li>You can generate a key every time you send a request. That key would be generated by using a bit of logic that only you know, so that you can implement it client- and server-side as well. For example, a request could include the following parameters:<br/>
<code>time=1321802432&amp;key=[generated-key]</code><br/>
where <code>generated-key</code> is generated from the <code>time</code> parameter. For example: <code>md5(time + salt)</code>. When the server receives this request, it can do two things:

<ol>
<li>Check that <code>key</code> is indeed equal to <code>md5(time + salt)</code> (note that only the client and the server know the salt and it can be obfuscated similarly to the API key above), and</li>
<li>Check that <code>time</code> is not too far back in the past (e.g. if it's more than 1-2 minutes in the past, consider the request invalid).</li>
</ol></li>
</ol>
<p>The second method is more useful if you are also doing plain HTTP requests, where everyone can see the parameters being sent. Also, it's much harder to figure out from decompiled code. Especially if you spread the key calculation logic across multiple classes.</p>
<p><strong>However</strong>, note that <strong>nothing</strong> makes it impossible to crack your app. You can obfuscate as much as you want, if a hacker is <strong>really</strong> determined to get to your data, he will be able to so by decompiling your application and spending many sleepless nights passing through your code and figuring out how the requests are formed. The only <strong>real</strong> way of securing your data is by asking your user for a password, besides doing all the work I wrote about above. You can't get a password that only exists in someone's (the user) head from decompiled code :).</p>
</div></text><author><a href="/users/180784/felix">Felix</a></author><comments><comment><text><span class="comment-copy">well I know I had something pretty complex in mind using tokens, and authentication vs. a server etc.. for a different mobile system.  Now what they're proposed for android was far more simple using API keys stored on the server side.  How you do you feel about security using static API keys? (this at least was the general idea that I heard 2nd hand).</span></text><author><a class="comment-user owner" href="/users/445000/djplayer" title="2,127 reputation">DJPlayer</a></author></comment><comment><text><span class="comment-copy">info on proguard is definatley beneficial .. will definatley have to review the documentation.</span></text><author><a class="comment-user owner" href="/users/445000/djplayer" title="2,127 reputation">DJPlayer</a></author></comment><comment><text><span class="comment-copy">Initially I only talked about how to securely store data on the device. I edited my answer now to talk about how to securely transfer data from the server to the device as well. Have a look :)</span></text><author><a class="comment-user" href="/users/180784/felix" title="55,143 reputation">Felix</a></author></comment><comment><text><span class="comment-copy">in generalities this looks pretty much what I was considering.. was definately going to use an md5 one way hashing alg.  Eventually we want to access numerous internal web based apps and use the same credentials to authenticate.  Token use would be nice.. that would allow the user to access numerous areas once logged in and allow a nice default timeout.  Unfortunately to start out we'd probably have to start w/ some a little more simplistic.  This is probably a pretty good start, we don't want the user to have to enter a pwd everytime the tablet hits onpause. thnx.</span></text><author><a class="comment-user owner" href="/users/445000/djplayer" title="2,127 reputation">DJPlayer</a></author></comment><comment><text><span class="comment-copy">@Felix Why not using what's already invented with <a href="https://github.com/Mashape/mashape-oauth/blob/master/FLOWS.md#oauth-10a-one-legged" rel="nofollow noreferrer">Oauth</a> for that?</span></text><author><a class="comment-user" href="/users/812598/goros" title="2,024 reputation">GoRoS</a></author></comment><comment><text><span class="comment-copy">Quick Question: You said "However, on rooted devices an application can obtain root access and read everything"... Does that also include that the user can write/change data?</span></text><author><a class="comment-user" href="/users/889792/georg" title="957 reputation">Georg</a></author></comment><comment><text><span class="comment-copy">Store the key in the C++ layer rather than using proguard - It makes it very difficult to read especially if you also store a dummy key.  Also the server should send the API key, but you can use HMAC as well.</span></text><author><a class="comment-user" href="/users/400320/serenskye" title="1,734 reputation">serenskye</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>(Came here thanks to a Google search)</p>
<p>I've been researching this a lot lately and this page has come up a lot thanks to Google and Bing searches. The widely-accepted procedure for storing data on the device securely has been to use a strong encryption algorithm like AES. The harder question is "AES requires a secure key. What do you do with the key?" </p>
<p>Google recently announced a cloud-based storage solution for apps, so you could consider storing the key there if the situation allows. Otherwise, its seems that getting the key outside the device, like on a server, is better. If you can make the user punch in a PIN, that would actually work the best. You can do password derivation in order to store the password, and you can redo the derivation to verify the password</p>
<p>Without the "user punching in a PIN" part, I haven't found a lot of good answers to that question. However, DO NOT HARD-CODE THE KEY IF YOU MUST STORE ONE WITH THE APP. At the minimum, generate a key using a secure password generator and/or a derivation function like PBKDF2 (Password-based derivation function 2). </p>
<p>If I read the posts correctly, Google did say that one approach is to generate a key once the app starts the first time, store the key via the MODE_PRIVATE flag to a lot of file I/O operations, and use that as the key. You can also derive other keys based on that master key, and the NIST actually suggests something along that lines. </p>
<p>Whether or not to trust the master-key method, I'll leave to you. This key would get exposed on a rooted device. I'll also admit that I'm still researching the issue</p>
</div></text><author><a href="/users/1524209/joe-plante">Joe Plante</a></author><comments><comment><text><span class="comment-copy">Any luck with this?</span></text><author><a class="comment-user" href="/users/3075340/micror" title="3,218 reputation">MicroR</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Use SSL on HTTPS to transfer data instead of HTTP you need to setup the certificates on the webserver not very sure how it works.. </p>
<p>If you are really concerned about the data then further encrypt it with a unique algorithm before sending and decrypt it when it reaches the app. I guess that's all about it.. Unless you need something really strong then develop your own protocol based on TCP and/or use another port.. maybe that'll help</p>
<p><a href="http://en.wikipedia.org/wiki/Secure_Sockets_Layer" rel="nofollow">http://en.wikipedia.org/wiki/Secure_Sockets_Layer</a>
http://developer.android.com/reference/javax/net/ssl/package-summary.html
<a href="http://blog.synyx.de/2010/06/android-and-self-signed-ssl-certificates/" rel="nofollow">http://blog.synyx.de/2010/06/android-and-self-signed-ssl-certificates/</a></p>
<p>As for storing data in the app what you can encrypt the data before storing or you can use another format other than SQLite for better security as you can view sqlite databases using the browser pretty easily. </p>
<p>Unless the phone is rooted there should not be a way to extract the data from it. </p>
</div></text><author><a href="/users/745270/rejinderi">Rejinderi</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If you want to pretty much ensure the user cannot see the data other than by looking at your app then encryption is really the only way. Even the "protected" storage is accessible to the user if a device is rooted.  Even encryption is not totally secure as you need to decrypt the data at some point in order to display it. You will dissuade the casual browser but not the determined hacker.</p>
</div></text><author><a href="/users/1027277/kuffs">Kuffs</a></author><comments><comment><text><span class="comment-copy">these devices are company owned.. so we can control the devices to a decent extent through a Mobile Device Manager.  On other devices our plan is to use tokens w/ authentication done on active server after passing through something like siteminer.  Unfortunately the keychain API is only part of 4.0.  Probably use a 1 way hasing algorithm to verify the user.</span></text><author><a class="comment-user owner" href="/users/445000/djplayer" title="2,127 reputation">DJPlayer</a></author></comment></comments></answer></answers></post>