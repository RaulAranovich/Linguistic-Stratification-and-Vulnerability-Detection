<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Is SecureString ever practical in a C# application? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Feel free to correct me if my assumptions are wrong here, but let me explain why I'm asking.</p>
<p>Taken from MSDN, a <code>SecureString</code>:</p>
<blockquote>
<p>Represents text that should be kept confidential. The text is encrypted for privacy when being used, and deleted from computer memory when no longer needed.</p>
</blockquote>
<p>I get this, it makes complete sense to store a password or other private information in a <code>SecureString</code> over a <code>System.String</code>, because you can control how and when it is actually stored in memory, because a <code>System.String</code>:</p>
<blockquote>
<p>is both immutable and, when no longer needed, cannot be programmatically scheduled for garbage collection; that is, the instance is read-only after it is created and it is not possible to predict when the instance will be deleted from computer memory. Consequently, if a String object contains sensitive information such as a password, credit card number, or personal data, there is a risk the information could be revealed after it is used because your application cannot delete the data from computer memory.</p>
</blockquote>
<p>However, in the case of a GUI application (for example, an ssh client), the <code>SecureString</code> <em>has to be built from a</em> <code>System.String</code>. All of the text controls <em>use a string as its underlying data type</em>.</p>
<p>So, this means that every time the user presses a key, the old string that was there is discarded, and a new string is built to represent what the value inside the text box is, even if using a password mask. <em>And we can't control when or if any of those values are discarded from memory</em>.</p>
<p>Now it's time to log in to the server. Guess what? <em>You need to pass a string over the connection for authentication</em>. So let's convert our <code>SecureString</code> into a <code>System.String</code>.... and now we have a string on the heap with no way to force it to go through garbage collection (or write 0's to its buffer).</p>
<p><strong>My point is</strong>: no matter what you do, somewhere along the line, that <code>SecureString</code> is <em>going</em> to be converted into a <code>System.String</code>, meaning it will at least exist on the heap at some point (without any guarantee of garbage collection).</p>
<p><strong>My point is not</strong>: whether there are ways of circumventing sending a string to an ssh connection, or circumventing having a control store a string (make a custom control). For this question, you can replace "ssh connection" with "login form", "registration form", "payment form", "foods-you-would-feed-your-puppy-but-not-your-children form", etc.</p>
<ul>
<li>So, at what point does using a <code>SecureString</code> actually become
practical?</li>
<li>Is it ever worth the extra development time to completely eradicate
the use of a <code>System.String</code> object?</li>
<li>Is the whole point of <code>SecureString</code> to simply reduce the amount of time a <code>System.String</code> is on the heap (reducing its risk of moving to a physical swap file)?</li>
<li>If an attacker already has the means for a heap inspection, then they most likely either (A) already have the means to read keystrokes, or (B) already <em>physically have the machine</em>... So would using a <code>SecureString</code> prevent them from getting to the data anyways?</li>
<li>Is this just "security through obscurity"?</li>
</ul>
<p>Sorry if I'm laying the questions on too thick, curiosity just got the better of me. Feel free to answer any or all of my questions (or tell me that my assumptions are completely wrong). :)</p>
</div></text><author><a href="/users/2990656/steven-jeffries">Steven Jeffries</a></author><comments><comment><text><span class="comment-copy">Keep in mind that <code>SecureString</code> isn't really a secure string. It's merely a way to decrease the time window in which someone can inspect your memory and successfully get the sensitive data. This isn't bulletproof and it wasn't intended to be. But the points you're raising are very valid. Related: <a href="http://stackoverflow.com/questions/14449579/safe-use-of-securestring-for-login-form" title="safe use of securestring for login form">stackoverflow.com/questions/14449579/…</a></span></text><author><a class="comment-user" href="/users/1892179/theodoros-chatzigiannakis" title="20,222 reputation">Theodoros Chatzigiannakis</a></author></comment><comment><text><span class="comment-copy">@TheodorosChatzigiannakis, yeah, that's pretty much what I figured. I just spent all day today racking my brain over trying to figure out a secure way to store a password for the lifespan of the application, and it just made me wonder, is it worth it?</span></text><author><a class="comment-user owner" href="/users/2990656/steven-jeffries" title="1,203 reputation">Steven Jeffries</a></author></comment><comment><text><span class="comment-copy">Probably not worth it. But then, again, you might be defending against an extreme scenario. Extreme not in the sense that it's unlikely for someone to gain this kind of access to your computer, but in the sense that if someone does gain this kind of access, the computer is considered (for all intents and purposes) compromised and I don't think there's any language or any technique you can use to defend against this completely.</span></text><author><a class="comment-user" href="/users/1892179/theodoros-chatzigiannakis" title="20,222 reputation">Theodoros Chatzigiannakis</a></author></comment><comment><text><span class="comment-copy">It protects against a password being visible for <i>years</i>, long after everybody stopped thinking there might be a problem.  On a discarded hard drive, stored in the paging file.  Scrubbing the memory so the odds for this are low is important, can't do that with System.String since it is immutable.  It requires infrastructure that few programs these days have access to, interop with native code so the Marshal.SecureStringXxx() methods are useful is getting rare.  Or a decent way to prompt the user for it :)</span></text><author><a class="comment-user" href="/users/17034/hans-passant" title="692,533 reputation">Hans Passant</a></author></comment><comment><text><span class="comment-copy">@TheodorosChatzigiannakis / Hans Passant: You should post your comments as an answer, because they appear to be the correct one (IMHO).</span></text><author><a class="comment-user" href="/users/240733/stakx" title="54,155 reputation">stakx</a></author></comment><comment><text><span class="comment-copy">SecureString is a security in-depth technique. The tradeoff between development cost and security gain is not favorable in most situations. There are very few good use cases for it.</span></text><author><a class="comment-user" href="/users/122718/usr" title="131,495 reputation">usr</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>There is actually very practical use of <code>SecureString</code>. </p>
<p>Do you know how many times I've seen such scenarios(answer is: many!):</p>
<ul>
<li>A password appears in a log file accidentally.</li>
<li>A password is being shown at somewhere - once a GUI did show a command line of application that was being run, and the command line consisted of password. <strong>Oops</strong>.</li>
<li>Using memory profiler to profile software with your colleague. Colleague sees your password in memory. Sounds unreal? Not at all.</li>
<li>I once used <code>RedGate</code> software that could capture the "value" of local variables in case of exceptions, amazingly useful. Though, I can imagine that it will log "string passwords" accidentally.</li>
<li>A crash dump that includes string password.</li>
</ul>
<p>Do you know how to avoid all these problems? <code>SecureString</code>. It generally makes sure you don't make silly mistakes as such. How does it avoid it? By making sure that password is encrypted in unmanaged memory and the real value can be only accessed when you are 90% sure what you're doing.</p>
<p>In the sense, <code>SecureString</code> works pretty easily:</p>
<p>1) Everything is encrypted</p>
<p>2) User calls <code>AppendChar</code></p>
<p>3) Decrypt everything in UNMANAGED MEMORY and add the character</p>
<p>4) Encrypt everything again in UNMANAGED MEMORY.</p>
<p>What if user has access to your computer? Would a virus be able to get access to all the <code>SecureStrings</code>? Yes. All you need to do is hook yourself into <code>RtlEncryptMemory</code> when the memory is being decrypted, you will get the location of the unencrypted memory address, and read it out. Voila! In fact, you could make a virus that will constantly scan for usage of <code>SecureString</code> and log all the activities with it. I am not saying it will be easy task, but it can be done. As you can see, the "powerfulness" of <code>SecureString</code> is completely gone once there's a user/virus in your system.</p>
<p>You have few points in your post. Sure, if you use some of the UI controls that hold "string password" internally, using actual <code>SecureString</code> is not that useful. Though, still, it can protect against some stupidity I've listed above. </p>
<p>Also, as others have noted, WPF supports PasswordBox which uses <code>SecureString</code> internally.</p>
<p>The bottom line is; if you have sensitive data(passwords, credit-cards, ..), use <code>SecureString</code>. This is what C# Framework is following. For example, <code>NetworkCredential</code> class stores password as <code>SecureString</code>. If you look <a href="http://referencesource.microsoft.com/#mscorlib/system/security/securestring.cs#77d68ea938f47705#references" rel="noreferrer">this</a>, you can see over ~80 different usages in .NET framework of <code>SecureString</code>.</p>
<p>There are many cases when you have to convert <code>SecureString</code> to string, because some API expects it. </p>
<p>The usual problem is either: </p>
<ol>
<li>The api is GENERIC. It does not know that there's a sensitive data. </li>
<li>The api knows that it's dealing with sensitive data and uses "string" - that's just bad design.</li>
</ol>
<p>You raised good point: what happens when <code>SecureString</code> is converted to <code>string</code>? This can only happen because of the first point. Eg the API does not know that it's sensitive data. I have personally not seen that happening. Getting string out of SecureString is not that simple. </p>
<p><strong>It's not simple for a simple reason</strong>; it was never intended to let the user convert SecureString to string, as you stated: GC will kick in. If you see yourself doing that, you need to step back and ask yourself: Why am I even doing this, or do I really need this, why?</p>
<p>There's one interesting case I saw. Namely, WinApi function LogonUser takes LPTSTR as a password, which means you need to call <code>SecureStringToGlobalAllocUnicode</code>. That basically gives you unencrypted password that lives in unmanaged memory. You need to get rid of that as soon as you're done. </p>
<p>You can always extend the <code>SecureString</code> class with an extension method, such as <code>ToEncryptedString(__SERVER__PUBLIC_KEY)</code>, which gives you a <code>string</code> instance of <code>SecureString</code> that is encrypted using server's public key. Only server can then decrypt it. Problem solved, GC will never see the "original" string, as you never expose it in managed memory. This is exactly what is being done in <a href="http://referencesource.microsoft.com/#System.Management.Automation/System/Management/Automation/Internal/PSRemotingCryptoHelper.cs" rel="noreferrer"><code>PSRemotingCryptoHelper</code></a> (<code>EncryptSecureStringCore(SecureString secureString)</code>).</p>
<p>And as something very almost-related: <strong>Mono SecureString does not encrypt at all</strong>. The implementation has been commented out because ..wait for it.. <a href="https://github.com/mono/mono/blob/master/mcs/class/corlib/System.Security/SecureString.cs#L259" rel="noreferrer">"It somehow causes nunit test breakage"</a>, which brings to my last point:</p>
<p><code>SecureString</code> is not supported in everywhere. If the platform/architecture does not support <code>SecureString</code>, you'll get exception. There's a list of platforms that are supported in the documentation. </p>
<p>My longest StackOverflow post and anyone who can count how many times I repeated <code>SecureString</code> will get +1 :-).</p>
</div></text><author><a href="/users/1936622/erti-chris-eelmaa">Erti-Chris Eelmaa</a></author><comments><comment><text><span class="comment-copy">+1, that is a solid answer demonstrating actual cases where a SecureString is practical.</span></text><author><a class="comment-user owner" href="/users/2990656/steven-jeffries" title="1,203 reputation">Steven Jeffries</a></author></comment><comment><text><span class="comment-copy">I would think <code>SecureString</code> would be a lot <i>more</i> practical if there were a mechanism for accessing individual characters thereof.  Efficiency for such a mechanism could be enhanced by having a struct type <code>SecureStringTempBuffer</code> without any public members, which could be passed by <code>ref</code> to the <code>SecureString</code> "read one character" method [if encryption/decryption is processed in 8-character chunks, such a structure could hold data for 8 characters and the location of the first of those characters within the <code>SecureString</code>].</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment><comment><text><span class="comment-copy">You "repeated" <code>SecureString</code> a 24 times for a total of 25 uses of the word :) Good answer though. I like the <code>.ToEncryptedString(__KEY)</code> idea.</span></text><author><a class="comment-user" href="/users/901156/rdev5" title="662 reputation">rdev5</a></author></comment><comment><text><span class="comment-copy">I flag this in every source code audit that I perform. It should also be repeated that if you use <code>SecureString</code> it needs to be used all the way through the stack.</span></text><author><a class="comment-user" href="/users/147373/casey" title="6,029 reputation">Casey</a></author></comment><comment><text><span class="comment-copy">I implemented the .ToEncryptedString() extension but by using certificate. Would you mind taking a look and let me know if I´m doing this all wrong. I´m hoping its secure engouhg <a href="https://gist.github.com/sturlath/99cfbfff26e0ebd12ea73316d0843330" rel="nofollow noreferrer">gist.github.com/sturlath/99cfbfff26e0ebd12ea73316d0843330</a></span></text><author><a class="comment-user" href="/users/1187583/sturla" title="407 reputation">Sturla</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The are few issue in your assumptions. </p>
<p>First of all the SecureString class does not have a String constructor. In order to create one you allocate an object and then append the chars. </p>
<p>In the case of a GUI or a console, you can very easily pass each pressed key to a secure string. </p>
<p>The class is designed in a way that you cannot, by mistake, access the value that is stored. This means that you can not obtain the <code>string</code> as a password directly from it. </p>
<p>So for using it, for example, to authenticate through the web, you will have to use proper classes that are also secure. </p>
<p>In the .NET framework you have a few classes that can use SecureString </p>
<ul>
<li>WPF's PasswordBox control keeps the password as a SecureString internally.</li>
<li>System.Diagnostics.ProcessInfo's Password property is a SecureString.</li>
<li>The constructor for X509Certificate2 takes a SecureString for the password. </li>
</ul>
<p><a href="http://stackoverflow.com/questions/141203/when-would-i-need-a-securestring-in-net/141393#141393">(more)</a></p>
<p>To conclude, the SecureString class can be useful, but requires more attention from the developer. </p>
<p>All this, with examples, is well described in MSDN's documentation of <a href="http://msdn.microsoft.com/library/System.Security.SecureString.aspx" rel="nofollow noreferrer">SecureString</a> </p>
</div></text><author><a href="/users/390695/damian-leszczy%c5%84ski-vash">Damian Leszczyński - Vash</a></author><comments><comment><text><span class="comment-copy">I don't quite understand the third-to-last paragraph of your answer. <i>How</i> would you transfer a <code>SecureString</code> over the network without serializing it into a <code>string</code>? I think the question's OP's point is that there comes a time when you want to actually <i>use</i> the value held safely in a <code>SecureString</code>, which means you have to get it out of there, and it's no longer safe. In all of the Framework Class Library, there are virtually no methods that accept a <code>SecureString</code> as input directly (as far as I can see), so what's the point of holding a value inside a <code>SecureString</code> in the first place?</span></text><author><a class="comment-user" href="/users/240733/stakx" title="54,155 reputation">stakx</a></author></comment><comment><text><span class="comment-copy">@DamianLeszczyński-Vash, I know that SecureString doesn't have a string constructor, but my point is that you either (A) create a SecureString and append each char from a string to it, or (B) at some point need to use the value stored in SecureString as a string in order to pass it to some API. That being said, you do bring up some good points, and I can see how in some very specific cases it can be useful.</span></text><author><a class="comment-user owner" href="/users/2990656/steven-jeffries" title="1,203 reputation">Steven Jeffries</a></author></comment><comment><text><span class="comment-copy">@stakx You would send it over the network by getting the <code>char[]</code> and sending each <code>char</code> over a socket - creating no garbage-collectable objects in the process.</span></text><author><a class="comment-user" href="/users/106104/immibis" title="29,452 reputation">immibis</a></author></comment><comment><text><span class="comment-copy">Char[] is collectable and is mutable, so it can be overwritten.</span></text><author><a class="comment-user" href="/users/5620/peter-ritchie" title="26,723 reputation">Peter Ritchie</a></author></comment><comment><text><span class="comment-copy">Of course, it's also easy to forget to overwrite that array.  Either way, any API you pass the chars to may also make a copy.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A SecureString is useful if:</p>
<ul>
<li><p>You build it character by character (e.g. from console input) or obtain it from an unmanaged API</p></li>
<li><p>You use it by passing it to an unmanaged API (SecureStringToBSTR).</p></li>
</ul>
<p>If you ever convert it to a managed string, you've defeated its purpose.</p>
<p><strong>UPDATE</strong> in response to comment</p>
<blockquote>
<p>... or BSTR like you mention, which doesn't seem any more secure</p>
</blockquote>
<p>After its been converted to a BSTR, the unmanaged component that consumes the BSTR can zero the memory.  Unmanaged memory is more secure in the sense that it can be reset in this way.</p>
<p>However, there are very few, APIs in the .NET Framework that support SecureString, so you're right to say that it's of very limited value today.</p>
<p>The main use case I would see is in a client application that requires the user to enter a highly sensitive code or password.  The user input could be used character by character to build a SecureString, then this could be passed to an unmanaged API, which zeroes the BSTR it receives after using it.  Any subsequent memory dump will not contain the sensitive string.</p>
<p>In a server application it's hard to see where it would be useful.</p>
<p><strong>UPDATE 2</strong></p>
<p>One example of a .NET API that accepts a SecureString is <a href="http://msdn.microsoft.com/en-us/library/ms148390%28v=vs.110%29.aspx" rel="nofollow">this constructor for the X509Certificate class</a>.  If you spelunk with ILSpy or similar, you'll see that the SecureString is internally converted to an unmanaged buffer (<code>Marshal.SecureStringToGlobalAllocUnicode</code>), which is then zeroed when finished with (<code>Marshal.ZeroFreeGlobalAllocUnicode</code>).  </p>
</div></text><author><a href="/users/13087/joe">Joe</a></author><comments><comment><text><span class="comment-copy">+1, but won't you always end up "defeating its purpose"? Given that almost no method in the Framework Class Library accepts a <code>SecureString</code> as input, what would be their use? You'd always have to convert back to <code>string</code> sooner or later (or <code>BSTR</code> like you mention, which doesn't seem any more secure). So why bother with <code>SecureString</code> at all?</span></text><author><a class="comment-user" href="/users/240733/stakx" title="54,155 reputation">stakx</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As you have correctly identified, <a href="http://msdn.microsoft.com/en-us/library/system.security.securestring%28v=vs.110%29.aspx" rel="nofollow"><code>SecureString</code></a> offers one specific advantage over <code>string</code>: deterministic erasure. There are two problems with this fact: </p>
<ol>
<li>As others have mentioned and as you have noticed by yourself, this isn't enough by itself. You have to make sure that every step of the process (including retrieval of input, construction of the string, usage, deletion, transportation, etc) happens without defeating the purpose of using <code>SecureString</code>. This means that you must be careful to never create a GC-managed immutable <code>string</code> or any other buffer that will store the sensitive information (or you'll have to keep track of <em>that</em> as well). In practice, this isn't always easy to achieve, because lots of APIs only offer a way to work with <code>string</code>, not <code>SecureString</code>. And even if you do manage to everything right... </li>
<li><code>SecureString</code> protects against very specific kinds of attack (and for some of them, it's not even that reliable). For example, <code>SecureString</code> does allow you to shrink the time window in which an attacker can dump the memory of your process and successfully extract the sensitive information (again, as you correctly pointed out), but hoping that the window is too small for the attacker to take a snapshot of your memory isn't considered security at all.</li>
</ol>
<p>So, when should you use it? Only when you're working with something that can allow you to work with <code>SecureString</code> for all your needs and even then you should still be mindful that this is secure only in specific circumstances.</p>
</div></text><author><a href="/users/1892179/theodoros-chatzigiannakis">Theodoros Chatzigiannakis</a></author><comments><comment><text><span class="comment-copy">You're assuming that an attacker is able to snapshot a process's memory at any particular time. That isn't necessarily the case. Consider a crash dump. If the crash happened after the application was done with the sensitive data, the crash dump should not contain the sensitive data.</span></text><author><a class="comment-user" href="/users/743382/hvd" title="93,540 reputation">hvd</a></author></comment><comment><text><span class="comment-copy">@hvd You're correct. I've rephrased a little.</span></text><author><a class="comment-user" href="/users/1892179/theodoros-chatzigiannakis" title="20,222 reputation">Theodoros Chatzigiannakis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'd like to address this point:</p>
<blockquote>
<p>If an attacker already has the means for a heap inspection, then they most likely either (A) already have the means to read keystrokes, or (B) already <em>physically have the machine</em>... So would using a <code>SecureString</code> prevent them from getting to the data anyways?</p>
</blockquote>
<p>An attacker may not have full access to the computer and the application, but can have means to access some parts of the memory of the process. It is usually caused by bugs like buffer overruns, when specially constructed input can cause the application to expose or overwrite some part of the memory.</p>
<p>Take Heartbleed for example. Specially constructed requests can cause the code to expose random parts of the memory of the process to the attacker. An attacker can extract SSL certificates from the memory, yet the only thing he needs is just to use a malformed request.</p>
<p>In the world of the managed code, buffer overruns become a problem mush less often. And in case of WinForms, data is already stored in insecure manner and you can't do anything about it. This renders the protection with <code>SecureString</code> pretty much useless.</p>
<p>However, GUI <em>can</em> be programmed to use <code>SecureString</code>, and in such case reducing the window of password availability in the memory can be worth it. For example, <a href="http://msdn.microsoft.com/library/system.windows.controls.passwordbox.securepassword.aspx" rel="nofollow">PasswordBox.SecurePassword</a> from WPF is of type <code>SecureString</code>.</p>
</div></text><author><a href="/users/293099/squidward">Squidward</a></author><comments><comment><text><span class="comment-copy">Hmm, definitely interesting to know. In all honesty, I'm not actually that worried about the type of attacks necessary to even get a System.String value out of my memory, I am just asking out of pure curiosity. However, thanks for the information! :)</span></text><author><a class="comment-user owner" href="/users/2990656/steven-jeffries" title="1,203 reputation">Steven Jeffries</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Below text is copied from HP Fortify static code analyzer</strong></p>
<p><strong>Abstract:</strong>
The method PassString() in PassGenerator.cs stores sensitive data in an insecure manner (i.e. in string), making it possible to extract
the data via inspecting the heap.</p>
<p><strong>Explanation:</strong>
Sensitive data (such as passwords, social security numbers, credit card numbers etc.) stored in memory can be leaked if it is
stored in a managed String object. String objects are not pinned, so the garbage collector can relocate these objects at will and
leave several copies in memory. These objects are not encrypted by default, so anyone that can read the process' memory will be
able to see the contents. Furthermore, if the process' memory gets swapped out to disk, the unencrypted contents of the string
will be written to a swap file. Lastly, since String objects are immutable, removing the value of a String from memory can only
be done by the CLR garbage collector. The garbage collector is not required to run unless the CLR is low on memory, so there is
no guarantee as to when garbage collection will take place. In the event of an application crash, a memory dump of the
application might reveal sensitive data.</p>
<p><strong>Recommendations:</strong>
Instead of storing sensitive data in objects like Strings, store them in a SecureString object. Each object stores its contents in an
encrypted format in memory at all times.</p>
</div></text><author><a href="/users/790282/vikrantx">vikrantx</a></author><comments/></answer></answers></post>