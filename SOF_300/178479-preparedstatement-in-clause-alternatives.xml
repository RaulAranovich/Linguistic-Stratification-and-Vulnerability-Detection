<?xml version="1.0" encoding="utf-8"?>
<post><title>java - PreparedStatement IN clause alternatives? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>What are the best workarounds for using a SQL <code>IN</code> clause with instances of <code>java.sql.PreparedStatement</code>, which is not supported for multiple values due to SQL injection attack security issues: One <code>?</code> placeholder represents one value, rather than a list of values.</p>
<p>Consider the following SQL statement:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">SELECT my_column FROM my_table where search_column IN </span><span class="pun">(?)</span></code></pre>
<p>Using <code>preparedStatement.setString( 1, "'A', 'B', 'C'" );</code> is essentially a non-working attempt at a workaround of the reasons for using <code>?</code> in the first place.  </p>
<p>What workarounds are available?</p>
</div></text><author><a href="/users/213269/jonas">Jonas</a></author><comments><comment><text><span class="comment-copy">@Chris: I was about to  ask the same. What approach did you use at the end?</span></text><author><a class="comment-user" href="/users/20654/oscarryz" title="121,832 reputation">OscarRyz</a></author></comment><comment><text><span class="comment-copy">Oscar, I think the dynamic generation of (?,?,....) is the simplest workaround if you need an IN clause, but I left it to individual calls since performance was sufficient in my specific case.</span></text><author><a class="comment-user owner" href="/users/15816/chris-mazzola" title="2,250 reputation">Chris Mazzola</a></author></comment><comment><text><span class="comment-copy">One of advantages of prepared statements is that sohuld can be compiled once for efficiency. By making the in clause dynamic this effectively negates the prepared statement.</span></text><author><span class="comment-user">user246585</span></author></comment><comment><text><span class="comment-copy">Actually, this works for MySQL (using setObject to set an array of String as the parameter value). What DB are you using?</span></text><author><a class="comment-user" href="/users/140707/frans" title="1,022 reputation">Frans</a></author></comment><comment><text><span class="comment-copy">Here's an <a href="http://stackoverflow.com/a/15302767/4265">Oracle specific answer</a></span></text><author><a class="comment-user" href="/users/4265/peter-hart" title="3,805 reputation">Peter Hart</a></author></comment><comment><text><span class="comment-copy">Here's a related question: <a href="http://stackoverflow.com/q/6956025/521799">stackoverflow.com/q/6956025/521799</a></span></text><author><a class="comment-user" href="/users/521799/lukas-eder" title="102,217 reputation">Lukas Eder</a></author></comment><comment><text><span class="comment-copy">@Frans it's not working for me.  It executes the query, but always has no results.</span></text><author><a class="comment-user" href="/users/192798/jayen" title="1,763 reputation">Jayen</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>An analysis of the various options available, and the pros and cons of each is available <a href="http://www.javaranch.com/journal/200510/Journal200510.jsp#a2" rel="noreferrer">here</a>.</p>
<p>The suggested options are:</p>
<ul>
<li>Prepare <code>SELECT my_column FROM my_table WHERE search_column = ?</code>, execute it for each value and UNION the results client-side. Requires only one prepared statement. Slow and painful.</li>
<li>Prepare <code>SELECT my_column FROM my_table WHERE search_column IN (?,?,?)</code> and execute it. Requires one prepared statement per size-of-IN-list. Fast and obvious.</li>
<li>Prepare <code>SELECT my_column FROM my_table WHERE search_column = ? ; SELECT my_column FROM my_table WHERE search_column = ? ; ...</code> and execute it. [Or use <code>UNION ALL</code> in place of those semicolons. --ed] Requires one prepared statement per size-of-IN-list. Stupidly slow, strictly worse than <code>WHERE search_column IN (?,?,?)</code>, so I don't know why the blogger even suggested it.</li>
<li>Use a stored procedure to construct the result set.</li>
<li>Prepare N different size-of-IN-list queries; say, with 2, 10, and 50 values. To search for an IN-list with 6 different values, populate the size-10 query so that it looks like <code>SELECT my_column FROM my_table WHERE search_column IN (1,2,3,4,5,6,6,6,6,6)</code>. Any decent server will optimize out the duplicate values before running the query.</li>
</ul>
<p>None of these options are super great, though.</p>
<p>Duplicate questions have been answered in these places with equally sane alternatives, still none of them super great:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/3107044/preparedstatement-with-list-of-parameters-in-a-in-clause">PreparedStatement with list of parameters in a IN clause</a></li>
<li><a href="http://stackoverflow.com/questions/1305240/how-to-set-list-of-parameters-on-prepared-statement">How to set list of parameters on prepared statement?</a></li>
</ul>
<p>The Right Answer, if you are using JDBC4 and a server that supports <code>x = ANY(y)</code>, is to use <code>PreparedStatement.setArray</code> as described here:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/178479/preparedstatement-in-clause-alternatives/10240302#10240302">PreparedStatement IN clause alternatives?</a></li>
</ul>
<p>There doesn't seem to be any way to make <code>setArray</code> work with IN-lists, though.</p>
</div></text><author><a href="/users/2648/d%c3%b3nal">DÃ³nal</a></author><comments><comment><text><span class="comment-copy">Past is read-only ;)</span></text><author><a class="comment-user" href="/users/1163802/vladimir-dyuzhev" title="14,307 reputation">Vladimir Dyuzhev</a></author></comment><comment><text><span class="comment-copy">This is a good analysis of the theoretical workarounds to not being able to pass in a list.  However, some databases allow you to pass in a list and a better answer would show how to actually do it, like Boris' answer.</span></text><author><a class="comment-user" href="/users/1649198/brandon" title="6,030 reputation">Brandon</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Solution for PostgreSQL:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">final</span><span class="pln"> </span><span class="typ">PreparedStatement</span><span class="pln"> statement </span><span class="pun">=</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">
        </span><span class="str">"SELECT my_column FROM my_table where search_column = ANY (?)"</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> values </span><span class="pun">=</span><span class="pln"> getValues</span><span class="pun">();</span><span class="pln">
statement</span><span class="pun">.</span><span class="pln">setArray</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">createArrayOf</span><span class="pun">(</span><span class="str">"text"</span><span class="pun">,</span><span class="pln"> values</span><span class="pun">));</span><span class="pln">
</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">ResultSet</span><span class="pln"> rs </span><span class="pun">=</span><span class="pln"> statement</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">rs</span><span class="pun">.</span><span class="pln">next</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// do some...</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">finally</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    rs</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>or</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">final</span><span class="pln"> </span><span class="typ">PreparedStatement</span><span class="pln"> statement </span><span class="pun">=</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">
        </span><span class="str">"SELECT my_column FROM my_table "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> 
        </span><span class="str">"where search_column IN (SELECT * FROM unnest(?))"</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> values </span><span class="pun">=</span><span class="pln"> getValues</span><span class="pun">();</span><span class="pln">
statement</span><span class="pun">.</span><span class="pln">setArray</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">createArrayOf</span><span class="pun">(</span><span class="str">"text"</span><span class="pun">,</span><span class="pln"> values</span><span class="pun">));</span><span class="pln">
</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">ResultSet</span><span class="pln"> rs </span><span class="pun">=</span><span class="pln"> statement</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">rs</span><span class="pun">.</span><span class="pln">next</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// do some...</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">finally</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    rs</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/1345608/boris">Boris</a></author><comments><comment><text><span class="comment-copy">looks good. what part of this code is PostreSQL specific? the "where search_column = ANY(?)"? or the connection.createArrayOf? or something else?</span></text><author><a class="comment-user" href="/users/280393/david-portabella" title="4,099 reputation">David Portabella</a></author></comment><comment><text><span class="comment-copy">I think it is more JDBC4-specific than PostgreSQL-specific, because of the <code>.createArrayOf()</code> part, but I am not sure the strict semantics for user's <code>Array</code>s are defined by JDBC specification.</span></text><author><a class="comment-user" href="/users/578749/lvella" title="5,384 reputation">lvella</a></author></comment><comment><text><span class="comment-copy">If <code>.createArrayOf</code> doesn't work, you can do your own manual creation of array literal like <code>String arrayLiteral = "{A,\"B \", C,D}"</code> <i>(note that "B " has a space while C doesn't)</i> and then <code>statement.setString(1,arrayLiteral)</code> where the prepared statement is <code>... IN (SELECT UNNEST(?::VARCHAR[]))</code> or <code>... IN (SELECT UNNEST(CAST(? AS VARCHAR[])))</code>. (PS: I don't think <code>ANY</code> works with a <code>SELECT</code>.)</span></text><author><a class="comment-user" href="/users/1134080/adtc" title="3,238 reputation">ADTC</a></author></comment><comment><text><span class="comment-copy">Great solution! Really saved the day for me. For integer array I used "int" in the first parameter of createArrayOf() and it's looking good. That first parameter appears DB-specific, based on the documentation though.</span></text><author><a class="comment-user" href="/users/516188/emmanuel-touzery" title="4,911 reputation">Emmanuel Touzery</a></author></comment><comment><text><span class="comment-copy">This seems the cleanest solution. If anyone is looking for the HSQLDB specific syntax: I managed to get this to work with IN(UNNEST(?))</span></text><author><a class="comment-user" href="/users/1568293/aureianimus" title="101 reputation">aureianimus</a></author></comment><comment><text><span class="comment-copy">A pity the JDBC feature doesn't have a wide support in DB drivers. Neither of the drivers for MSSQL I tried had it implemented. Still, I like it, if I ever make a PGSQL-specific code, this looks neat.</span></text><author><a class="comment-user" href="/users/1977151/vlasec" title="1,945 reputation">Vlasec</a></author></comment><comment><text><span class="comment-copy">When I implement this, I get: ERROR: argument of IN must not return a set</span></text><author><a class="comment-user" href="/users/3720611/eugene1832" title="400 reputation">eugene1832</a></author></comment><comment><text><span class="comment-copy">@Ivella If I understand the solution, what is PostgreSQL specific is the possibility of using the array parameter as a list of values. Generally array parameters are used for sql array types as shown here <a href="https://docs.oracle.com/javase/tutorial/jdbc/basics/array.html" rel="nofollow noreferrer">docs.oracle.com/javase/tutorial/jdbc/basics/array.html</a></span></text><author><a class="comment-user" href="/users/731548/cquezel" title="480 reputation">cquezel</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>No simple way AFAIK.
If the target is to keep statement cache ratio high (i.e to not create a statement per every parameter count), you may do the following:</p>
<ol>
<li><p>create a statement with a few (e.g. 10) parameters:</p>
<p>... WHERE A IN (?,?,?,?,?,?,?,?,?,?) ...</p></li>
<li><p>Bind all actuall parameters</p>
<p>setString(1,"foo");
setString(2,"bar");</p></li>
<li><p>Bind the rest as NULL</p>
<p>setNull(3,Types.VARCHAR)
...
setNull(10,Types.VARCHAR)</p></li>
</ol>
<p>NULL never matches anything, so it gets optimized out by the SQL plan builder.</p>
<p>The logic is easy to automate when you pass a List into a DAO function:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">while</span><span class="pun">(</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> param</span><span class="pun">.</span><span class="pln">size</span><span class="pun">()</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  ps</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="pln">param</span><span class="pun">.</span><span class="pln">get</span><span class="pun">(</span><span class="pln">i</span><span class="pun">));</span><span class="pln">
  i</span><span class="pun">++;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> MAX_PARAMS </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  ps</span><span class="pun">.</span><span class="pln">setNull</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="typ">Types</span><span class="pun">.</span><span class="pln">VARCHAR</span><span class="pun">);</span><span class="pln">
  i</span><span class="pun">++;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/1163802/vladimir-dyuzhev">Vladimir Dyuzhev</a></author><comments><comment><text><span class="comment-copy">"NULL never matches anything" â Would <code>NULL</code> in the query match a <code>NULL</code> value in the database?</span></text><author><a class="comment-user" href="/users/60075/craig-mcqueen" title="21,696 reputation">Craig McQueen</a></author></comment><comment><text><span class="comment-copy">@CraigMcQueen No it wouldn't.  Null doesn't even match null, according to the ANSI standard.</span></text><author><a class="comment-user" href="/users/1081110/dawood-ibn-kareem" title="42,228 reputation">Dawood ibn Kareem</a></author></comment><comment><text><span class="comment-copy">You can match NULL by using the IS NULL keyword. A nice way to detect rows which do not exist in the joined table is to use a LEFT JOIN together with the IS NULL. 'SELECT a.URL, b.URL FROM TABLE_A a LEFT JOIN TABLE_B b ON a_A.URL = b_B.URL WHERE b.URL IS NULL'  This will show all the rows in table A that have no match in table B.</span></text><author><a class="comment-user" href="/users/3976530/jens-tandstad" title="81 reputation">Jens Tandstad</a></author></comment><comment><text><span class="comment-copy">Be careful with this though.  <code>NOT IN</code> and <code>IN</code> do not handle nulls the same way.  Run this and see what happens: <code>select 'Matched' as did_it_match where 1 not in (5, null);</code>  Then remove the <code>null</code> and watch the magic.</span></text><author><a class="comment-user" href="/users/1649198/brandon" title="6,030 reputation">Brandon</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>An unpleasant work-around, but certainly feasible is to use a nested query. Create a temporary table MYVALUES with a column in it. Insert your list of values into the MYVALUES table. Then execute </p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">select my_column from my_table where search_column in </span><span class="pun">(</span><span class="pln"> SELECT value FROM MYVALUES </span><span class="pun">)</span></code></pre>
<p>Ugly, but a viable alternative if your list of values is very large.</p>
<p>This technique has the added advantage of potentially better query plans from the optimizer (check a page for multiple values, tablescan only once instead once per value, etc) may save on overhead if your database doesn't cache prepared statements. Your "INSERTS" would need to be done in batch and the MYVALUES table may need to be tweaked to have minimal locking or other high-overhead protections.</p>
</div></text><author><a href="/users/17871/james-schek">James Schek</a></author><comments><comment><text><span class="comment-copy">What advantages would that have over querying my_table one value at a time?</span></text><author><a class="comment-user" href="/users/3333/paul-tomblin" title="119,866 reputation">Paul Tomblin</a></author></comment><comment><text><span class="comment-copy">The query optimizer can reduce I/O load by retrieving all possible matches from a loaded page. Tablescans or index scans may be performed once instead of once per value. Overhead for inserting values can be reduced with batch operations and may be less than several queries.</span></text><author><a class="comment-user" href="/users/17871/james-schek" title="14,155 reputation">James Schek</a></author></comment><comment><text><span class="comment-copy">it looks good, but there could be problems with concurrency. does jdbc specification containt a way to create a temporal anonymous table in memory? or something like that, if possible not jdbc-vendor specific?</span></text><author><a class="comment-user" href="/users/280393/david-portabella" title="4,099 reputation">David Portabella</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I've never tried it, but would .setArray() do what you're looking for?</p>
<p><strong>Update</strong>: Evidently not.  setArray only seems to work with a java.sql.Array that comes from an ARRAY column that you've retrieved from a previous query, or a subquery with an ARRAY column.</p>
</div></text><author><a href="/users/3333/paul-tomblin">Paul Tomblin</a></author><comments><comment><text><span class="comment-copy">Doesn't work with all databases, but it's the "correct" approach.</span></text><author><a class="comment-user" href="/users/21234/skaffman" title="294,877 reputation">skaffman</a></author></comment><comment><text><span class="comment-copy">You mean all drivers. Some drivers have proprietary equivalents of this years old (last century?) standard. Another way is to bung a batch of values into a temporary table, but not all databases support that...</span></text><author><a class="comment-user" href="/users/4725/tom-hawtin-tackline" title="113,096 reputation">Tom Hawtin - tackline</a></author></comment><comment><text><span class="comment-copy"><a href="http://java.sun.com/j2se/1.3/docs/guide/jdbc/getstart/mapping.html#996857" rel="nofollow noreferrer">java.sun.com/j2se/1.3/docs/guide/jdbc/getstart/â¦</a> According to Sun, Array content [typically] remains on the server side and is pulled as needed. PreparedStatement.setArray() can send back an Array from a previous ResultSet, not create a new Array on the client side.</span></text><author><a class="comment-user owner" href="/users/15816/chris-mazzola" title="2,250 reputation">Chris Mazzola</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>My workaround is:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">create or replace type split_tbl as table of varchar</span><span class="pun">(</span><span class="lit">32767</span><span class="pun">);</span><span class="pln">
</span><span class="pun">/</span><span class="pln">

create or replace function split
</span><span class="pun">(</span><span class="pln">
  p_list varchar2</span><span class="pun">,</span><span class="pln">
  p_del varchar2 </span><span class="pun">:=</span><span class="pln"> </span><span class="str">','</span><span class="pln">
</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> split_tbl pipelined
is
  l_idx    pls_integer</span><span class="pun">;</span><span class="pln">
  l_list    varchar2</span><span class="pun">(</span><span class="lit">32767</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:=</span><span class="pln"> p_list</span><span class="pun">;</span><span class="pln">
  l_value    varchar2</span><span class="pun">(</span><span class="lit">32767</span><span class="pun">);</span><span class="pln">
begin
  loop
    l_idx </span><span class="pun">:=</span><span class="pln"> instr</span><span class="pun">(</span><span class="pln">l_list</span><span class="pun">,</span><span class="pln">p_del</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> l_idx </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> then
      pipe row</span><span class="pun">(</span><span class="pln">substr</span><span class="pun">(</span><span class="pln">l_list</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="pln">l_idx</span><span class="pun">-</span><span class="lit">1</span><span class="pun">));</span><span class="pln">
      l_list </span><span class="pun">:=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">l_list</span><span class="pun">,</span><span class="pln">l_idx</span><span class="pun">+</span><span class="pln">length</span><span class="pun">(</span><span class="pln">p_del</span><span class="pun">));</span><span class="pln">
    </span><span class="kwd">else</span><span class="pln">
      pipe row</span><span class="pun">(</span><span class="pln">l_list</span><span class="pun">);</span><span class="pln">
      exit</span><span class="pun">;</span><span class="pln">
    end </span><span class="kwd">if</span><span class="pun">;</span><span class="pln">
  end loop</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
end split</span><span class="pun">;</span><span class="pln">
</span><span class="pun">/</span></code></pre>
<p>Now you can use one variable to obtain some values in a table:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">select </span><span class="pun">*</span><span class="pln"> from table</span><span class="pun">(</span><span class="pln">split</span><span class="pun">(</span><span class="str">'one,two,three'</span><span class="pun">))</span><span class="pln">
  one
  two
  three

select </span><span class="pun">*</span><span class="pln"> from TABLE1 where COL1 in </span><span class="pun">(</span><span class="pln">select </span><span class="pun">*</span><span class="pln"> from table</span><span class="pun">(</span><span class="pln">split</span><span class="pun">(</span><span class="str">'value1,value2'</span><span class="pun">)))</span><span class="pln">
  value1 AAA
  value2 BBB</span></code></pre>
<p>So, the prepared statement could be:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">  </span><span class="str">"select * from TABLE where COL in (select * from table(split(?)))"</span></code></pre>
<p>Regards,</p>
<p>Javier Ibanez</p>
</div></text><author><a href="/users/632332/javier-ibanez">Javier Ibanez</a></author><comments><comment><text><span class="comment-copy">this is Oracle PLSQL? or does it work for other databases?</span></text><author><a class="comment-user" href="/users/280393/david-portabella" title="4,099 reputation">David Portabella</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h2>Limitations of the in() operator is the root of all evil.</h2>
<p>It works for trivial cases, and you can extend it with "automatic generation of the prepared statement" however it is always having its limits.</p>
<ul>
<li>if you're creating a statement with variable number of parameters, that will make an sql parse overhead at each call</li>
<li>on many platforms, the number of parameters of in() operator are limited </li>
<li>on all platforms, total SQL text size is limited, making impossible for sending down 2000 placeholders for the in params</li>
<li>sending down bind variables of 1000-10k is not possible, as the JDBC driver is having its limitations</li>
</ul>
<p>The in() approach can be good enough for some cases, but not rocket proof :)</p>
<p>The rocket-proof solution is to pass the arbitrary number of parameters in a separate call (by passing a clob of params, for example), and then have a view (or any other way) to represent them in SQL and use in your where criteria.</p>
<p>A brute-force variant is here <a href="http://tkyte.blogspot.hu/2006/06/varying-in-lists.html" rel="nofollow">http://tkyte.blogspot.hu/2006/06/varying-in-lists.html</a> </p>
<p>However if you can use PL/SQL, this mess can become pretty neat.</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">function getCustomers</span><span class="pun">(</span><span class="pln">in_customerIdList clob</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> sys_refcursor is 
begin
    aux_in_list</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">in_customerIdList</span><span class="pun">);</span><span class="pln">
    open res </span><span class="kwd">for</span><span class="pln">
        select </span><span class="pun">*</span><span class="pln"> 
        from   customer c</span><span class="pun">,</span><span class="pln">
               in_list v
        where  c</span><span class="pun">.</span><span class="pln">customer_id</span><span class="pun">=</span><span class="pln">v</span><span class="pun">.</span><span class="pln">token</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> res</span><span class="pun">;</span><span class="pln">
end</span><span class="pun">;</span></code></pre>
<p>Then you can pass arbitrary number of comma separated customer ids in the parameter, and:</p>
<ul>
<li>will get no parse delay, as the SQL for select is stable</li>
<li>no pipelined functions complexity - it is just one query</li>
<li>the SQL is using a simple join, instead of an IN operator, which is quite fast</li>
<li>after all, it is a good rule of thumb of <em>not</em> hitting the database with any plain select or DML, since it is Oracle, which offers lightyears of more than MySQL or similar simple database engines. PL/SQL allows you to hide the storage model from your application domain model in an effective way.</li>
</ul>
<p>The trick here is:</p>
<ul>
<li>we need a call which accepts the long string, and store somewhere where the db session can access to it (e.g. simple package variable, or dbms_session.set_context)</li>
<li>then we need a view which can parse this to rows</li>
<li>and then you have a view which contains the ids you're querying, so all you need is a simple join to the table queried.</li>
</ul>
<p>The view looks like:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">create or replace view in_list
as
select
    trim</span><span class="pun">(</span><span class="pln"> substr </span><span class="pun">(</span><span class="pln">txt</span><span class="pun">,</span><span class="pln">
          instr </span><span class="pun">(</span><span class="pln">txt</span><span class="pun">,</span><span class="pln"> </span><span class="str">','</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> level  </span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln">
          instr </span><span class="pun">(</span><span class="pln">txt</span><span class="pun">,</span><span class="pln"> </span><span class="str">','</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> level</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
             </span><span class="pun">-</span><span class="pln"> instr </span><span class="pun">(</span><span class="pln">txt</span><span class="pun">,</span><span class="pln"> </span><span class="str">','</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> level</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> as token
    from </span><span class="pun">(</span><span class="pln">select </span><span class="str">','</span><span class="pun">||</span><span class="pln">aux_in_list</span><span class="pun">.</span><span class="pln">getpayload</span><span class="pun">||</span><span class="str">','</span><span class="pln"> txt from dual</span><span class="pun">)</span><span class="pln">
connect by level </span><span class="pun">&lt;=</span><span class="pln"> length</span><span class="pun">(</span><span class="pln">aux_in_list</span><span class="pun">.</span><span class="pln">getpayload</span><span class="pun">)-</span><span class="pln">length</span><span class="pun">(</span><span class="pln">replace</span><span class="pun">(</span><span class="pln">aux_in_list</span><span class="pun">.</span><span class="pln">getpayload</span><span class="pun">,</span><span class="str">','</span><span class="pun">,</span><span class="str">''</span><span class="pun">))+</span><span class="lit">1</span></code></pre>
<p>where aux_in_list.getpayload refers to the original input string.</p>
<hr/>
<p>A possible approach would be to pass pl/sql arrays (supported by Oracle only), however you can't use those in pure SQL, therefore a conversion step is always needed. The conversion can not be done in SQL, so after all, passing a clob with all parameters in string and converting it witin a view is the most efficient solution.</p>
</div></text><author><a href="/users/5903395/gee-bee">Gee Bee</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I suppose you could (using basic string manipulation) generate the query string in the <code>PreparedStatement</code> to have a number of <code>?</code>'s matching the number of items in your list.  </p>
<p>Of course if you're doing that you're just a step away from generating a giant chained <code>OR</code> in your query, but without having the right number of <code>?</code> in the query string, I don't see how else you can work around this.</p>
</div></text><author><a href="/users/21632/adam-bellaire">Adam Bellaire</a></author><comments><comment><text><span class="comment-copy">Not really a solution for me since I want to send in a different number of ? each time I call the ps.  But don't think I hadn't considered it. :P</span></text><author><a class="comment-user owner" href="/users/15816/chris-mazzola" title="2,250 reputation">Chris Mazzola</a></author></comment><comment><text><span class="comment-copy">Another hack:  you can use a large number of parameter placeholders -- as many as the longest list of values you'll have -- and if your list of values is shorter, you can repeat values:  ...WHERE searchfield IN (?, ?, ?, ?, ?, ?, ?, ?) and then provide values: A, B, C, D, A, B, C, D</span></text><author><a class="comment-user" href="/users/20860/bill-karwin" title="305,545 reputation">Bill Karwin</a></author></comment><comment><text><span class="comment-copy">But overall I favor Adam's solution:  generate the SQL dynamically, and concatenate ? placeholders to match the number of values you have to pass.</span></text><author><a class="comment-user" href="/users/20860/bill-karwin" title="305,545 reputation">Bill Karwin</a></author></comment><comment><text><span class="comment-copy">Bill, that solution is workable if I don't want to reuse the PreparedStatement. Another solution is to make the single param call multiple times and accumulate the results on the client side. Likely it would be more efficient to build/execute a new Statement with custom number of ? each time though.</span></text><author><a class="comment-user owner" href="/users/15816/chris-mazzola" title="2,250 reputation">Chris Mazzola</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Here's how I solved it in my own application. Ideally, you should use a StringBuilder instead of using + for Strings.</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="typ">String</span><span class="pln"> inParenthesis </span><span class="pun">=</span><span class="pln"> </span><span class="str">"(?"</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">i </span><span class="pun">&lt;</span><span class="pln"> myList</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      inParenthesis </span><span class="pun">+=</span><span class="pln"> </span><span class="str">", ?"</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    inParenthesis </span><span class="pun">+=</span><span class="pln"> </span><span class="str">")"</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">try</span><span class="pun">(</span><span class="typ">PreparedStatement</span><span class="pln"> statement </span><span class="pun">=</span><span class="pln"> </span><span class="typ">SQLite</span><span class="pun">.</span><span class="pln">connection</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">
        </span><span class="typ">String</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="str">"UPDATE table SET value='WINNER' WHERE startTime=? AND name=? AND traderIdx=? AND someValue IN %s"</span><span class="pun">,</span><span class="pln"> inParenthesis</span><span class="pun">)))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
      statement</span><span class="pun">.</span><span class="pln">setLong</span><span class="pun">(</span><span class="pln">x</span><span class="pun">++,</span><span class="pln"> race</span><span class="pun">.</span><span class="pln">startTime</span><span class="pun">);</span><span class="pln">
      statement</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln">x</span><span class="pun">++,</span><span class="pln"> race</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
      statement</span><span class="pun">.</span><span class="pln">setInt</span><span class="pun">(</span><span class="pln">x</span><span class="pun">++,</span><span class="pln"> traderIdx</span><span class="pun">);</span><span class="pln">

      </span><span class="kwd">for</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> str </span><span class="pun">:</span><span class="pln"> race</span><span class="pun">.</span><span class="pln">betFair</span><span class="pun">.</span><span class="pln">winners</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        statement</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln">x</span><span class="pun">++,</span><span class="pln"> str</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">

      </span><span class="kwd">int</span><span class="pln"> effected </span><span class="pun">=</span><span class="pln"> statement</span><span class="pun">.</span><span class="pln">executeUpdate</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
<p>Using a variable like x above instead of concrete numbers helps a lot if you decide to change the query at a later time.</p>
</div></text><author><a href="/users/3353334/m-sabouri">m.sabouri</a></author><comments><comment><text><span class="comment-copy">this is a great simple solution that works for everything</span></text><author><a class="comment-user" href="/users/4624014/luke-murray" title="471 reputation">Luke Murray</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>try using the instr function?</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">select my_column from my_table where  instr</span><span class="pun">(?,</span><span class="pln"> </span><span class="str">','</span><span class="pun">||</span><span class="pln">search_column</span><span class="pun">||</span><span class="str">','</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span></code></pre>
<p>then</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">ps</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">",A,B,C,"</span><span class="pun">);</span><span class="pln"> </span></code></pre>
<p>Admittedly this is a bit of a dirty hack, but it does reduce the opportunities for sql injection. Works in oracle anyway.</p>
</div></text><author><a href="/users/2985/stjohnroe">stjohnroe</a></author><comments><comment><text><span class="comment-copy">Oh, and I am aware that it will not utilise indexes</span></text><author><a class="comment-user" href="/users/2985/stjohnroe" title="2,590 reputation">stjohnroe</a></author></comment><comment><text><span class="comment-copy">it wouldn't work for some strings, for instance, if the string contains a ','.</span></text><author><a class="comment-user" href="/users/280393/david-portabella" title="4,099 reputation">David Portabella</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><a href="http://www.sormula.org/" rel="nofollow">Sormula</a> supports SQL IN operator by allowing you to supply a java.util.Collection object as a parameter. It creates a prepared statement with a ? for each of the elements the collection. See <a href="http://www.sormula.org/example4/" rel="nofollow">Example 4</a> (SQL in example is a comment to clarify what is created but is not used by Sormula).</p>
</div></text><author><a href="/users/912813/jeff-miller">Jeff Miller</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I came across a number of limitations related to prepared statement:</p>
<ol>
<li>The prepared statements are cached only inside the same session (Postgres), so it will really work only with connection pooling</li>
<li>A lot of different prepared statements as proposed by @BalusC may cause the cache to overfill and previously cached statements will be dropped</li>
<li>The query has to be optimized and use indices. Sounds obvious, however e.g. the ANY(ARRAY...) statement proposed by @Boris in one of the top answers cannot use indices and query will be slow despite caching</li>
<li>The prepared statement caches the query plan as well and the actual values of any parameters specified in the statement are unavailable.</li>
</ol>
<p>Among the proposed solutions I would choose the one that doesn't decrease the query performance and makes the less number of queries. This will be the #4 (batching few queries) from the @Don link or specifying NULL values for unneeded '?' marks as proposed by @Vladimir Dyuzhev </p>
</div></text><author><a href="/users/1752358/alexander">Alexander</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Just for completeness: So long as the set of values is not too large, you <em>could</em> also simply string-construct a statement like</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pun">...</span><span class="pln"> WHERE tab</span><span class="pun">.</span><span class="pln">col </span><span class="pun">=</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> OR tab</span><span class="pun">.</span><span class="pln">col </span><span class="pun">=</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> OR tab</span><span class="pun">.</span><span class="pln">col </span><span class="pun">=</span><span class="pln"> </span><span class="pun">?</span></code></pre>
<p>which you could then pass to prepare(), and then use setXXX() in a loop to set all the values. This looks yucky, but many "big" commercial systems routinely do this kind of thing until they hit DB-specific limits, such as 32 KB (I think it is) for statements in Oracle.</p>
<p>Of course you need to ensure that the set will never be unreasonably large, or do error trapping in the event that it is.</p>
</div></text><author><a href="/users/172211/carl-smotricz">Carl Smotricz</a></author><comments><comment><text><span class="comment-copy">Yes, you're right.  My goal in this case was to reuse the PreparedStatement with different numbers of items each time.</span></text><author><a class="comment-user owner" href="/users/15816/chris-mazzola" title="2,250 reputation">Chris Mazzola</a></author></comment><comment><text><span class="comment-copy">Using "OR" would obfuscate the intent. Stick with "IN" as its easier to read and the intent is more clear. The only reason to switch is if the query plans were different.</span></text><author><a class="comment-user" href="/users/17871/james-schek" title="14,155 reputation">James Schek</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Following Adam's idea. Make your prepared statement sort of select my_column from my_table where search_column in (#)
Create a String x and fill it with a number of "?,?,?" depending on your list of values
Then just change the # in the query for your new String x an populate</p>
</div></text><author><a>NONE</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Generate the query string in the PreparedStatement to have a number of ?'s matching the number of items in your list.  Here's an example:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> myQuery</span><span class="pun">(</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;</span><span class="pln"> items</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> other</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="pun">...</span><span class="pln">
  </span><span class="typ">String</span><span class="pln"> q4in </span><span class="pun">=</span><span class="pln"> generateQsForIn</span><span class="pun">(</span><span class="pln">items</span><span class="pun">.</span><span class="pln">size</span><span class="pun">());</span><span class="pln">
  </span><span class="typ">String</span><span class="pln"> sql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"select * from stuff where foo in ( "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> q4in </span><span class="pun">+</span><span class="pln"> </span><span class="str">" ) and bar = ?"</span><span class="pun">;</span><span class="pln">
  </span><span class="typ">PreparedStatement</span><span class="pln"> ps </span><span class="pun">=</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">sql</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">String</span><span class="pln"> item </span><span class="pun">:</span><span class="pln"> items</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    ps</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln">i</span><span class="pun">++,</span><span class="pln"> item</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  ps</span><span class="pun">.</span><span class="pln">setInt</span><span class="pun">(</span><span class="pln">i</span><span class="pun">++,</span><span class="pln"> other</span><span class="pun">);</span><span class="pln">
  </span><span class="typ">ResultSet</span><span class="pln"> rs </span><span class="pun">=</span><span class="pln"> ps</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">private</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> generateQsForIn</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> numQs</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> items </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> numQs</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> items </span><span class="pun">+=</span><span class="pln"> </span><span class="str">", "</span><span class="pun">;</span><span class="pln">
        items </span><span class="pun">+=</span><span class="pln"> </span><span class="str">"?"</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> items</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/13365/neu242">neu242</a></author><comments><comment><text><span class="comment-copy">There's no need to use StringBuilder anymore.  The compiler converts the + signs to StringBuilder.append() anyway, so there is no performance hit.  Try yourself :)</span></text><author><a class="comment-user" href="/users/13365/neu242" title="7,224 reputation">neu242</a></author></comment><comment><text><span class="comment-copy">@neu242: Oh yes, the compiler uses <code>StringBuilder</code>. But not in the way you think. Decompiling <code>generateQsForIn</code> you can see that per loop iteration <b>two</b> new <code>StringBuilder</code> are allocated and <code>toString</code> is called on each. The <code>StringBuilder</code> optimization only catches stuff like <code>"x" + i+ "y" + j</code> but does not extend beyond one expression.</span></text><author><a class="comment-user" href="/users/947357/a-h" title="37,639 reputation">A.H.</a></author></comment><comment><text><span class="comment-copy">@neu242 Can't you use <code>ps.setObject(1,items)</code> instead of iterating over the list and then setting the <code>paramteres</code>?</span></text><author><a class="comment-user" href="/users/1407434/neha-choudhary" title="3,068 reputation">Neha Choudhary</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>instead of using</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">SELECT my_column FROM my_table where search_column IN </span><span class="pun">(?)</span></code></pre>
<p>use the Sql Statement as </p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">select id</span><span class="pun">,</span><span class="pln"> name from users where id in </span><span class="pun">(?,</span><span class="pln"> </span><span class="pun">?,</span><span class="pln"> </span><span class="pun">?)</span></code></pre>
<p>and</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">preparedStatement</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">'A'</span><span class="pun">);</span><span class="pln">
preparedStatement</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="str">'B'</span><span class="pun">);</span><span class="pln">
preparedStatement</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="str">'C'</span><span class="pun">);</span></code></pre>
<p>or use a stored procedure this would be the best solution, since the sql statements will be compiled and stored in DataBase server</p>
</div></text><author><a href="/users/2041542/kapil-das">kapil das</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are different alternative approaches that we can use for IN clause in PreparedStatement.</p>
<ol>
<li>Using Single Queries - slowest performance and resource intensive</li>
<li>Using StoredProcedure - Fastest but database specific</li>
<li>Creating dynamic query for PreparedStatement - Good Performance but doesn't get benefit of caching and PreparedStatement is recompiled every time.</li>
<li><p>Use NULL in PreparedStatement queries - Optimal performance, works great when you know the limit of IN clause arguments. If there is no limit, then you can execute queries in batch. 
Sample code snippet is;</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln">ids</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><span class="pln">
        ps</span><span class="pun">.</span><span class="pln">setInt</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> ids</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">//set null for remaining ones</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(;</span><span class="pln"> i</span><span class="pun">&lt;=</span><span class="pln">PARAM_SIZE</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++){</span><span class="pln">
        ps</span><span class="pun">.</span><span class="pln">setNull</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">sql</span><span class="pun">.</span><span class="typ">Types</span><span class="pun">.</span><span class="pln">INTEGER</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span></code></pre></li>
</ol>
<p>You can check more details about these alternative approaches <a href="http://www.journaldev.com/2521/jdbc-preparedstatement-in-clause-alternative-approaches" rel="nofollow">here</a>.</p>
</div></text><author><a href="/users/926520/pankaj">Pankaj</a></author><comments><comment><text><span class="comment-copy">"Creating dynamic query for PreparedStatement - Good Performance but doesn't get benefit of caching and PreparedStatement is recompiled every time." caching and avoiding recompiles is what makes a prepared statement perform well.  Therefore, I don't agree with your claim.  This will, however, prevent SQL injection since you are limiting the concatenated / dynamic input to a comma.</span></text><author><a class="comment-user" href="/users/1649198/brandon" title="6,030 reputation">Brandon</a></author></comment><comment><text><span class="comment-copy">I agree with you, however "Good Performance" here is for this specific scenario. It's better performing than approach 1, however approach 2 is fastest.</span></text><author><a class="comment-user" href="/users/926520/pankaj" title="2,243 reputation">Pankaj</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>For some situations regexp might help. 
Here is an example I've checked on Oracle, and it works. </p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">select </span><span class="pun">*</span><span class="pln"> from my_table where REGEXP_LIKE </span><span class="pun">(</span><span class="pln">search_column</span><span class="pun">,</span><span class="pln"> </span><span class="str">'value1|value2'</span><span class="pun">)</span></code></pre>
<p>But there is a number of drawbacks with it:</p>
<ol>
<li>Any column it applied should be converted to varchar/char, at least implicitly.</li>
<li>Need to be careful with special characters.</li>
<li>It can slow down performance - in my case IN version uses index and range scan, and REGEXP version do full scan.</li>
</ol>
</div></text><author><a href="/users/446098/vasili">Vasili</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>After examining various solutions in different forums and not finding a good solution, I feel the below hack I came up with, is the easiest to follow and code:</p>
<p>Example: Suppose you have multiple parameters to pass in the 'IN' clause. Just put a dummy String inside the 'IN' clause, say, "PARAM" do denote the list of parameters that will be coming in the place of this dummy String.</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">    select </span><span class="pun">*</span><span class="pln"> from TABLE_A where ATTR IN </span><span class="pun">(</span><span class="pln">PARAM</span><span class="pun">);</span></code></pre>
<p>You can collect all the parameters into a single String variable in your Java code. This can be done as follows:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="typ">String</span><span class="pln"> param1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">"X"</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> param2 </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Y"</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> param1 </span><span class="pun">=</span><span class="pln"> param1</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="str">","</span><span class="pun">).</span><span class="pln">append</span><span class="pun">(</span><span class="pln">param2</span><span class="pun">);</span></code></pre>
<p>You can append all your parameters separated by commas into a single String variable, 'param1', in our case.</p>
<p>After collecting all the parameters into a single String you can just replace the dummy text in your query, i.e., "PARAM" in this case, with the parameter String, i.e., param1. Here is what you need to do:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="typ">String</span><span class="pln"> query </span><span class="pun">=</span><span class="pln"> query</span><span class="pun">.</span><span class="pln">replaceFirst</span><span class="pun">(</span><span class="str">"PARAM"</span><span class="pun">,</span><span class="pln">param1</span><span class="pun">);</span><span class="pln"> where we have the value of query as 

    query </span><span class="pun">=</span><span class="pln"> </span><span class="str">"select * from TABLE_A where ATTR IN (PARAM)"</span><span class="pun">;</span></code></pre>
<p>You can now execute your query using the executeQuery() method. Just make sure that you don't have the word "PARAM" in your query anywhere. You can use a combination of special characters and alphabets instead of the word "PARAM" in order to make sure that there is no possibility of such a word coming in the query. Hope you got the solution.</p>
<p>Note: Though this is not a prepared query, it does the work that I wanted my code to do.</p>
</div></text><author><a href="/users/1666429/bnsk">bnsk</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Just for completeness and because I did not see anyone else suggest it:</p>
<p>Before implementing any of the complicated suggestions above consider if SQL injection is indeed a problem in your scenario.  </p>
<p>In many cases the value provided to IN (...) is a list of ids that have been generated in a way that you can be sure that no injection is possible... (e.g. the results of a previous select some_id from some_table where some_condition.)</p>
<p>If that is the case you might just concatenate this value and not use the services or the prepared statement for it or use them for other parameters of this query. </p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">query</span><span class="pun">=</span><span class="str">"select f1,f2 from t1 where f3=? and f2 in ("</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> sListOfIds </span><span class="pun">+</span><span class="pln"> </span><span class="str">");"</span><span class="pun">;</span></code></pre>
</div></text><author><a href="/users/25412/epeleg">epeleg</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Here's a complete solution in Java to create the prepared statement for you:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="com">/*usage:

Util u = new Util(500); //500 items per bracket. 
String sqlBefore  = "select * from myTable where (";
List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,4,5)); 
string sqlAfter = ") and foo = 'bar'"; 

PreparedStatement ps = u.prepareStatements(sqlBefore, values, sqlAfter, connection, "someId");
*/</span><span class="pln">



</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">sql</span><span class="pun">.</span><span class="typ">Connection</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">sql</span><span class="pun">.</span><span class="typ">PreparedStatement</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">sql</span><span class="pun">.</span><span class="typ">SQLException</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">util</span><span class="pun">.</span><span class="typ">ArrayList</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">util</span><span class="pun">.</span><span class="typ">List</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Util</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> numValuesInClause</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Util</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> numValuesInClause</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">super</span><span class="pun">();</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">numValuesInClause </span><span class="pun">=</span><span class="pln"> numValuesInClause</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> getNumValuesInClause</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> numValuesInClause</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setNumValuesInClause</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> numValuesInClause</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">numValuesInClause </span><span class="pun">=</span><span class="pln"> numValuesInClause</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/** Split a given list into a list of lists for the given size of numValuesInClause*/</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;&gt;</span><span class="pln"> splitList</span><span class="pun">(</span><span class="pln">
            </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> values</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">


        </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;&gt;</span><span class="pln"> newList </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ArrayList</span><span class="pun">&lt;</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;&gt;();</span><span class="pln"> 
        </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">values</span><span class="pun">.</span><span class="pln">size</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> numValuesInClause</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> sublist </span><span class="pun">=</span><span class="pln"> values</span><span class="pun">.</span><span class="pln">subList</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln">numValuesInClause</span><span class="pun">);</span><span class="pln">
            </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> values2 </span><span class="pun">=</span><span class="pln"> values</span><span class="pun">.</span><span class="pln">subList</span><span class="pun">(</span><span class="pln">numValuesInClause</span><span class="pun">,</span><span class="pln"> values</span><span class="pun">.</span><span class="pln">size</span><span class="pun">());</span><span class="pln">   
            values </span><span class="pun">=</span><span class="pln"> values2</span><span class="pun">;</span><span class="pln"> 

            newList</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln"> sublist</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        newList</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">values</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">return</span><span class="pln"> newList</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Generates a series of split out in clause statements. 
     * @param sqlBefore ""select * from dual where ("
     * @param values [1,2,3,4,5,6,7,8,9,10]
     * @param "sqlAfter ) and id = 5"
     * @return "select * from dual where (id in (1,2,3) or id in (4,5,6) or id in (7,8,9) or id in (10)"
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> genInClauseSql</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> sqlBefore</span><span class="pun">,</span><span class="pln"> </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> values</span><span class="pun">,</span><span class="pln">
            </span><span class="typ">String</span><span class="pln"> sqlAfter</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> identifier</span><span class="pun">)</span><span class="pln"> 
    </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;&gt;</span><span class="pln"> newLists </span><span class="pun">=</span><span class="pln"> splitList</span><span class="pun">(</span><span class="pln">values</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">String</span><span class="pln"> stmt </span><span class="pun">=</span><span class="pln"> sqlBefore</span><span class="pun">;</span><span class="pln">

        </span><span class="com">/* now generate the in clause for each list */</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="com">/* keep track of list:newLists index */</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> list </span><span class="pun">:</span><span class="pln"> newLists</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            stmt </span><span class="pun">=</span><span class="pln"> stmt </span><span class="pun">+</span><span class="pln"> identifier </span><span class="pun">+</span><span class="str">" in ("</span><span class="pun">;</span><span class="pln">
            </span><span class="typ">StringBuilder</span><span class="pln"> innerBuilder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StringBuilder</span><span class="pun">();</span><span class="pln">

            </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> list</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                innerBuilder</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="str">"?,"</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">



            </span><span class="typ">String</span><span class="pln"> inClause </span><span class="pun">=</span><span class="pln"> innerBuilder</span><span class="pun">.</span><span class="pln">deleteCharAt</span><span class="pun">(</span><span class="pln">
                    innerBuilder</span><span class="pun">.</span><span class="pln">length</span><span class="pun">()</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">).</span><span class="pln">toString</span><span class="pun">();</span><span class="pln">

            stmt </span><span class="pun">=</span><span class="pln"> stmt </span><span class="pun">+</span><span class="pln"> inClause</span><span class="pun">;</span><span class="pln">
            stmt </span><span class="pun">=</span><span class="pln"> stmt </span><span class="pun">+</span><span class="pln"> </span><span class="str">")"</span><span class="pun">;</span><span class="pln">


            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(++</span><span class="pln">j </span><span class="pun">&lt;</span><span class="pln"> newLists</span><span class="pun">.</span><span class="pln">size</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                stmt </span><span class="pun">=</span><span class="pln"> stmt </span><span class="pun">+</span><span class="pln"> </span><span class="str">" OR "</span><span class="pun">;</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">

        </span><span class="pun">}</span><span class="pln">

        stmt </span><span class="pun">=</span><span class="pln"> stmt </span><span class="pun">+</span><span class="pln"> sqlAfter</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> stmt</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Method to convert your SQL and a list of ID into a safe prepared
     * statements
     * 
     * @throws SQLException
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">PreparedStatement</span><span class="pln"> prepareStatements</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> sqlBefore</span><span class="pun">,</span><span class="pln">
            </span><span class="typ">ArrayList</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> values</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> sqlAfter</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Connection</span><span class="pln"> c</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> identifier</span><span class="pun">)</span><span class="pln">
            </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">SQLException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

        </span><span class="com">/* First split our potentially big list into lots of lists */</span><span class="pln">
        </span><span class="typ">String</span><span class="pln"> stmt </span><span class="pun">=</span><span class="pln"> genInClauseSql</span><span class="pun">(</span><span class="pln">sqlBefore</span><span class="pun">,</span><span class="pln"> values</span><span class="pun">,</span><span class="pln"> sqlAfter</span><span class="pun">,</span><span class="pln"> identifier</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">PreparedStatement</span><span class="pln"> ps </span><span class="pun">=</span><span class="pln"> c</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">stmt</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> val </span><span class="pun">:</span><span class="pln"> values</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">

            ps</span><span class="pun">.</span><span class="pln">setInt</span><span class="pun">(</span><span class="pln">i</span><span class="pun">++,</span><span class="pln"> val</span><span class="pun">);</span><span class="pln">

        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> ps</span><span class="pun">;</span><span class="pln">

    </span><span class="pun">}</span><span class="pln">

</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/1068446/dwjohnston">dwjohnston</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Spring allows <a href="http://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/jdbc.html#jdbc-in-clause" rel="nofollow">passing java.util.Lists to NamedParameterJdbcTemplate</a> , which automates the generation of (?, ?, ?, ..., ?), as appropriate for the number of arguments.</p>
<p>For Oracle, <a href="https://blogs.itemis.de/kloss/2009/03/05/arrays-preparedstatements-jdbc-and-oracle/" rel="nofollow">this blog posting</a> discusses the use of oracle.sql.ARRAY (Connection.createArrayOf doesn't work with Oracle). For this you have to modify your SQL statement:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">SELECT my_column FROM my_table where search_column IN </span><span class="pun">(</span><span class="pln">select COLUMN_VALUE from table</span><span class="pun">(?))</span></code></pre>
<p>The <a href="http://stevenfeuersteinonplsql.blogspot.de/2015/04/table-functions-introduction-and.html" rel="nofollow">oracle table function</a> transforms the passed array into a table like value usable in the <code>IN</code> statement.</p>
</div></text><author><a href="/users/21499/dr-hans-peter-st%c3%b6rr">Dr. Hans-Peter StÃ¶rr</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You could use setArray method as mentioned in <a href="http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html#setArray%28int,%20java.sql.Array%29" rel="nofollow">this javadoc</a>:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="typ">PreparedStatement</span><span class="pln"> statement </span><span class="pun">=</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="str">"Select * from emp where field in (?)"</span><span class="pun">);</span><span class="pln">
</span><span class="typ">Array</span><span class="pln"> array </span><span class="pun">=</span><span class="pln"> statement</span><span class="pun">.</span><span class="pln">getConnection</span><span class="pun">().</span><span class="pln">createArrayOf</span><span class="pun">(</span><span class="str">"VARCHAR"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">[]{</span><span class="str">"E1"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"E2"</span><span class="pun">,</span><span class="str">"E3"</span><span class="pun">});</span><span class="pln">
statement</span><span class="pun">.</span><span class="pln">setArray</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">);</span><span class="pln">
</span><span class="typ">ResultSet</span><span class="pln"> rs </span><span class="pun">=</span><span class="pln"> statement</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">();</span></code></pre>
</div></text><author><a href="/users/5882929/panky031">Panky031</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>My workaround (JavaScript)</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">    var s1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">" SELECT "</span><span class="pln">

 </span><span class="pun">+</span><span class="pln"> </span><span class="str">"FROM   table t "</span><span class="pln">

 </span><span class="pun">+</span><span class="pln"> </span><span class="str">"  where t.field in "</span><span class="pun">;</span><span class="pln">

  var s3 </span><span class="pun">=</span><span class="pln"> </span><span class="str">'('</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">var i </span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&lt;</span><span class="pln">searchTerms</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++)</span><span class="pln">
  </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> searchTerms</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
     s3  </span><span class="pun">=</span><span class="pln"> s3</span><span class="pun">+</span><span class="str">'?)'</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">else</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        s3  </span><span class="pun">=</span><span class="pln"> s3</span><span class="pun">+</span><span class="str">'?, '</span><span class="pln"> </span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
    var query </span><span class="pun">=</span><span class="pln"> s1</span><span class="pun">+</span><span class="pln">s3</span><span class="pun">;</span><span class="pln">

    var pstmt </span><span class="pun">=</span><span class="pln"> connection</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">query</span><span class="pun">);</span><span class="pln">

     </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">var i </span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&lt;</span><span class="pln">searchTerms</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        pstmt</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> searchTerms</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
<p><code>SearchTerms</code> is the array which contains your input/keys/fields etc</p>
</div></text><author><a href="/users/373466/smooth-smoothie">smooth_smoothie</a></author><comments/></answer></answers></post>