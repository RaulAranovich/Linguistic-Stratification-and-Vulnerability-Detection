<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Preventing Brute Force Logins on Websites - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>As a response to the recent <a href="http://blog.wired.com/27bstroke6/2009/01/professed-twitt.html" rel="noreferrer">Twitter hijackings</a> and <a href="http://www.codinghorror.com/blog/archives/001206.html" rel="noreferrer">Jeff's post on Dictionary Attacks</a>, what is the best way to secure your website against brute force login attacks?</p>
<p>Jeff's post suggests putting in an increasing delay for each attempted login, and a suggestion in the comments is to add a captcha after the 2nd failed attempt.</p>
<p>Both these seem like good ideas, but how do you know what "attempt number" it is?  You can't rely on a session ID (because an attacker could change it each time) or an IP address (better, but vulnerable to botnets).  Simply logging it against the username could, using the delay method, lock out a legitimate user (or at least make the login process very slow for them).</p>
<p>Thoughts? Suggestions?</p>
</div></text><author><a href="/users/24181/greg">Greg</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>I think database-persisted short lockout period for the given account (1-5 minutes) is the only way to handle this. Each <code>userid</code> in your database contains a <code>timeOfLastFailedLogin</code> and <code>numberOfFailedAttempts</code>. When <code>numbeOfFailedAttempts &gt; X</code> you lockout for some minutes.</p>
<p>This means you're locking the <code>userid</code> in question for some time, but not permanently. It also means you're updating the database for each login attempt (unless it is locked, of course), which may be causing other problems.</p>
<p>There is at least one whole country is NAT'ed in asia, so IP's cannot be used for anything.</p>
</div></text><author><a href="/users/23691/krosenvold">krosenvold</a></author><comments><comment><text><span class="comment-copy">I think this is the best solution.  If you lock out an account for 5 minutes after 5 invalid attempts, you can only guess 1440 passwords per day.  Yet you still don't have that much of a burden on the user if they forget their password, as they only have to wait 5 minutes.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment><comment><text><span class="comment-copy">You could also allow only 25 failure per day, after which they would have to call up and prove their identity, or request a password reset email.  This would basically stop any chance of a brute force attack.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment><comment><text><span class="comment-copy">@Kibbe But you can be attacked by botnets that simply want to lock out all your users. Personally I don't thinky any permanent lockdown is good. You could of course detect that you're being attacked and change sitewide behaviour</span></text><author><a class="comment-user" href="/users/23691/krosenvold" title="46,813 reputation">krosenvold</a></author></comment><comment><text><span class="comment-copy">@krosenvold True, but they would need to guess all the usernames, or even harder, all the email addresses to do that.</span></text><author><a class="comment-user" href="/users/297015/jonathan" title="8,197 reputation">Jonathan</a></author></comment><comment><text><span class="comment-copy">Possible DoS by creating a cronjob script that runs every 3/4 minuts that send the correct username en bad passsword x times. This will completely lock out the correct user... (oeps just saw the topic is made in 2009 keep the comment here because it's very usefull)</span></text><author><a class="comment-user" href="/users/2548147/raymond-nijland" title="2,294 reputation">Raymond Nijland</a></author></comment><comment><text><span class="comment-copy">This doesn't look really useful if you already have fail2ban installed for example.</span></text><author><a class="comment-user" href="/users/231664/david-%e5%a4%a9%e5%ae%87-wong" title="838 reputation">David 天宇 Wong</a></author></comment><comment><text><span class="comment-copy">This also doesn't really do much against the "broad sweep" attacks where someone tries just a few simple passwords on a very large number of accounts.</span></text><author><a class="comment-user" href="/users/134252/dolda2000" title="16,583 reputation">Dolda2000</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In my eyes there are several possibilities, each having cons and pros:</p>
<h2>Forcing secure passwords</h2>
<ul>
<li><strong>Pro</strong>: Will prevent dictionary attacks</li>
<li><strong>Con</strong>: Will also prevent popularity, since most users are not able to remember complex passwords, even if you explain to them, how to easy remember them. For example by remembering sentences: "I bought 1 Apple for 5 Cent in the Mall" leads to "Ib1Af5CitM".</li>
</ul>
<h2>Lockouts after several attempts</h2>
<ul>
<li><strong>Pro</strong>: Will slow down automated tests</li>
<li><strong>Con</strong>: It's easy to lock out users for third parties</li>
<li><strong>Con</strong>: Making them persistent in a database can result in a lot of write processes in such huge services as Twitter or comparables.</li>
</ul>
<h2>Captchas</h2>
<ul>
<li><strong>Pro</strong>: They prevent automated testing</li>
<li><strong>Con</strong>: They are consuming computing time</li>
<li><strong>Con</strong>: Will "slow down" the user experience</li>
<li><strong>HUGE CON</strong>: They are NOT barrier-free</li>
</ul>
<h2>Simple knowledge checks</h2>
<ul>
<li><strong>Pro</strong>: Will prevent automated testing</li>
<li><strong>Con</strong>: "Simple" is in the eye of the beholder.</li>
<li><strong>Con</strong>: Will "slow down" the user experience</li>
</ul>
<h2>Different login and username</h2>
<ul>
<li><strong>Pro</strong>: This is one technic, that is hardly seen, but in my eyes a pretty good start to prevent brute force attacks. </li>
<li><strong>Con</strong>: Depends on the users choice of the two names.</li>
</ul>
<h2>Use whole sentences as passwords</h2>
<ul>
<li><strong>Pro</strong>: Increases the size of the searchable space of possibilities.</li>
<li><strong>Pro</strong>: Are easier to remember for most users.</li>
<li><strong>Con</strong>: Depend on the users choice.</li>
</ul>
<p>As you can see, the "good" solutions all depend on the users choice, which again reveals the user as the weakest element of the chain.</p>
<p>Any other suggestions?</p>
</div></text><author><a href="/users/44293/bl4ckb0l7">bl4ckb0l7</a></author><comments><comment><text><span class="comment-copy">I like the idea of using the password as an Acronym (or is it an initialism?!) for a sentence. Very smart! It would be simple enough to write a generator for them too..</span></text><author><a class="comment-user" href="/users/106801/sgargan" title="3,865 reputation">sgargan</a></author></comment><comment><text><span class="comment-copy">Re: "Different login and username" - if you allow login with "username" + "password" and a users "username" is public (e.g. shown against comments) then you've given a hacker 1 piece of a 2 piece puzzle. They know the "username" now they just need to hack the "password". You would be better off ONLY supporting an "email" + "password" login ... provided your users "email" information is not public.</span></text><author><a class="comment-user" href="/users/114140/chris-jacob" title="6,487 reputation">Chris Jacob</a></author></comment><comment><text><span class="comment-copy">@Chris: That's just what I wanted to say.</span></text><author><a class="comment-user" href="/users/44293/bl4ckb0l7" title="1,731 reputation">bl4ckb0l7</a></author></comment><comment><text><span class="comment-copy">What about fail2ban ?</span></text><author><a class="comment-user" href="/users/231664/david-%e5%a4%a9%e5%ae%87-wong" title="838 reputation">David 天宇 Wong</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You could do what Google does. Which is after a certain number of trys they have a captacha show up. Than after a couple of times with the captacha you lock them out for a couple of minutes.</p>
</div></text><author><a href="/users/1231/donny-v">Donny V.</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I tend to agree with most of the other comments:</p>
<ul>
<li>Lock after X failed password attempts</li>
<li>Count failed attempts against username</li>
<li>Optionally use CAPTCHA (for example, attempts 1-2 are normal, attempts 3-5 are CAPTCHA'd, further attempts blocked for 15 minutes).</li>
<li>Optionally send an e-mail to the account owner to remove the block</li>
</ul>
<p>What I did want to point out is that you should be very careful about forcing "strong" passwords, as this often means they'll just be written on a post-it on the desk/attached to the monitor.  Also, some password policies lead to <strong>more</strong> predictable passwords.  For example:</p>
<p>If the password cannot be any previous used password and must include a number, there's a good chance that it'll be any common password with a sequential number after it.  If you have to change your password every 6 months, and a person has been there two years, chances are their password is something like <em>password4</em>.</p>
<p>Say you restrict it even more: must be at least 8 characters, cannot have any sequential letters, must have a letter, a number and a special character (this is a real password policy that many would consider secure).  Trying to break into John Quincy Smith's account?  Know he was born March 6th?  There's a good chance his password is something like <em>jqs0306!</em> (or maybe <em>jqs0306~</em>).</p>
<p>Now, I'm not saying that letting your users have the password <em>password</em> is a good idea either, just don't kid yourself thinking that your forced "secure" passwords are secure. </p>
</div></text><author><a href="/users/12549/inxilpro">inxilpro</a></author><comments><comment><text><span class="comment-copy">It's all about entropy, not length, whether it has special characters or not, etc. A password like <code>Password1!</code> might meet the guidelines for a "secure" password, but has half the entropy  of something like <code>my super secure password</code>, which would <i>not</i> be allowed by those guidelines.</span></text><author><a class="comment-user" href="/users/654031/chris-pratt" title="113,755 reputation">Chris Pratt</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h2>To elaborate on the best practice:</h2>
<p>What krosenvold said: log num_failed_logins and last_failed_time in the user table (except when the user is suspended), and once the number of failed logins reach a treshold, you suspend the user for 30 seconds or a minute. It is the best practice.</p>
<p>That method effectively eliminates single-account brute-force and dictionary attacks. However, it does not prevent an attacker from switching between user names - ie. keeping the password fixed and trying it with a large number of usernames. If your site has enough users, that kind of attack can be kept going for a long time before it runs out of unsuspended accounts to hit. Hopefully, he will be running this attack from a single IP (not likely though, as botnets are really becoming the tool of the trade these days) so you can detect that and block the IP, but <strong>if he is distributing the attack... well, that's another question (that I just posted here, so please check it out if you haven't)</strong>.</p>
<p>One additional thing to remember about the original idea is that you should of course still try to let the legitimate user through, even while the account is being attacked and suspended -- that is, IF you can tell the real user and the bot apart.</p>
<p>And you CAN, in at least two ways.</p>
<ol>
<li><p>If the user has a persistent login ("remember me") cookie, just let him pass through.</p></li>
<li><p>When you display the "I'm sorry, your account is suspended due to a large number of unsuccessful login attempts" message, include a link that says "<strong><em>secure backup login - HUMANS ONLY (bots: no lying)</em></strong>". Joke aside, when they click that link, give them a reCAPTCHA-authenticated login form that <strong>bypasses</strong> the account's suspend status. That way, IF they are human AND know the correct login+password (and are able to read CAPTCHAs), they will never be bothered by delays, and your site will be impervious to rapid-fire attacks.</p></li>
</ol>
<p>Only drawback: some people (such as the vision-impaired) cannot read CAPTCHAs, and they <em>MAY</em> still be affected by annoying bot-produced delays <em>IF</em> they're not using the autologin feature.</p>
<p>What ISN'T a drawback: that the autologin cookie doesn't have a similar security measure built-in. Why isn't this a drawback, you ask? Because as long as you've implemented it wisely, the secure token (the password equivalent) in your login cookie is twice as many bits (heck, make that ten times as many bits!) as your password, so brute-forcing it is effectively a <em>non-issue</em>. But if you're really paranoid, set up a one-second delay on the autologin feature as well, just for good measure.</p>
</div></text><author><a href="/users/57068/jens-roland">Jens Roland</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Do like most banks do, lockout the username/account after X login failures.  But I wouldn't be as strict as a bank in that you must call in to unlock your account.  I would just make a temporary lock out of 1-5 minutes.  Unless of course, the web application is as data sensitive as a bank. :)</p>
</div></text><author><a href="/users/396/bryan-denny">Bryan Denny</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You should implement a cache in the application <em>not</em> associated with your backend database for this purpose.</p>
<p>First and foremost delaying only legitimate usernames causes you to "give up" en-mass your valid customer base which can in itself be a problem even if username is not a closely guarded secret.</p>
<p>Second depending on your application you can be a little smarter with an application specific delay countermeasures than you might want to be with storing the data in a DB.</p>
<p>Its resistant to high speed attempts that would leak a DOS condition into your backend db.</p>
<p>Finally it is acceptable to make some decisions based on IP... If you see single attempts from one IP chances are its an honest mistake vs multiple IPs from god knows how many systems you may want to take other precautions or notify the end user of shady activity.</p>
<p>Its true large proxy federations can have massive numbers of IP addresses reserved for their use but most do make a reasonable effort to maintain your source address for a period of time for legacy purposes as some sites have a habbit of tieing cookie data to IP.</p>
</div></text><author><a href="/users/41898/einstein">Einstein</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I think you should log againt the username. This is the only constant (anything else can be spoofed). And yes it could lock out a legitimate user for a day. But if I must choose between an hacked account and a closed account (for a day) I definitely chose the lock.</p>
<p>By the way, after a third failed attempt (within a certain time) you can lock the account and send a release mail to the owner. The mail contains a link to unlock the account. This is a slight burden on the user but the cracker is blocked. And if even the mail account is hacked you could set a limit on the number of unlockings per day.</p>
</div></text><author><a href="/users/18061/toon-krijthe">Toon Krijthe</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>A lot of online message boards that I log into online give me 5 attempts at logging into an account, after those 5 attempts the account is locked for an hour or fifteen minutes. It may not be pretty, but this would certainly slow down a dictionary attack on one account. Now nothing is stopping a dictionary attack against multiple accounts at the same time. Ie try 5 times, switch to a different account, try another 5 times, then circle back. But it sure does slow down the attack.</p>
<p>The best defense against a dictionary attack is to make sure the passwords are not in a dictionary!!!  Basically set up some sort of password policy that checks a dictionary against the letters and requires a number or symbol in the password.  This is probably the best defense against a dictionary attack.</p>
</div></text><author><a href="/users/16219/cervo">Cervo</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You could add some form of CAPTCHA test.  But beware that most of them render access more difficult eye or earing impaired people.  An interesting form of CAPTCHA is asking a question, </p>
<blockquote>
<p>What is the sum of 2 and 2?</p>
</blockquote>
<p>And if you record the last login failure, you can skip the CAPTCHA if it is old enough.  Only do the CAPTCHA test if the last failure was during the last 10 minutes.</p>
</div></text><author><a href="/users/50902/kmkaplan">kmkaplan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>For .NET Environment </p>
<h2><a href="http://www.iis.net/download/DynamicIPRestrictions" rel="nofollow">Dynamic IP Restrictions</a></h2>
<p>The Dynamic IP Restrictions Extension for IIS provides IT Professionals and Hosters a configurable module that helps mitigate or block Denial of Service Attacks or cracking of passwords through Brute-force by temporarily blocking Internet Protocol (IP) addresses of HTTP clients who follow a pattern that could be conducive to one of such attacks. This module can be configured such that the analysis and blocking could be done at the Web Server or the Web Site level.</p>
<h2>Reduce the chances of a Denial of Service attack by dynamically blocking requests from malicious IP addresses</h2>
<p>Dynamic IP Restrictions for IIS allows you to reduce the probabilities of your Web Server being subject to a Denial of Service attack by inspecting the source IP of the requests and identifying patterns that could signal an attack. When an attack pattern is detected, the module will place the offending IP in a temporary deny list and will avoid responding to the requests for a predetermined amount of time.</p>
<h2>Minimize the possibilities of Brute-force-cracking of the passwords of your Web Server</h2>
<p>Dynamic IP Restrictions for IIS is able to detect requests patterns that indicate the passwords of the Web Server are attempted to be decoded. The module will place the offending IP on a list of servers that are denied access for a predetermined amount of time. In situations where the authentication is done against an Active Directory Services (ADS) the module is able to maintain the availability of the Web Server by avoiding having to issue authentication challenges to ADS.</p>
<h2>Features</h2>
<ul>
<li><p>Seamless integration into IIS 7.0 Manager.</p></li>
<li><p>Dynamically blocking of requests from IP address based on either of the following criteria:</p>
<ul>
<li><p>The number of concurrent requests.</p></li>
<li><p>The number of requests over a period of time.</p></li>
</ul></li>
<li><p>Support for list of IPs that are allowed to bypass Dynamic IP Restriction filtering.</p></li>
<li><p>Blocking of requests can be configurable at the Web Site or Web Server level.</p></li>
<li><p>Configurable deny actions allows IT Administrators to specify what response would be returned to the client. The module support return status codes 403, 404 or closing the connection.</p></li>
<li><p>Support for IPv6 addresses.</p></li>
<li><p>Support for web servers behind a proxy or firewall that may modify the client IP address.</p></li>
</ul>
<p><a href="http://www.iis.net/download/DynamicIPRestrictions" rel="nofollow">http://www.iis.net/download/DynamicIPRestrictions</a></p>
</div></text><author><a href="/users/704192/gustavo-melo">Gustavo Melo</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Old post but let me post what I have in this the end 2016. Hope it still could help. </p>
<p>It's a simple way but I think it's powerful to prevent login attack. At least I always use it on every web of mine. We don't need CAPTCHA or any other third party plugins. </p>
<p>When user login for the first time. We create a session like </p>
<pre><code>$_SESSION['loginFail'] = 10; // any number you prefer
</code></pre>
<p>If login success, then we will destroy it and let user login. </p>
<pre><code>unset($_SESSION['loginFail']); // put it after create login session
</code></pre>
<p>But if user fail, as we usually sent error message to them, at the same time we reduce the session by 1 :</p>
<pre><code>$_SESSION['loginFail']-- ; // reduce 1 for every error
</code></pre>
<p>and if user fail 10 times, then we will direct them to other website or any web pages.</p>
<pre><code>if (!isset($_SESSION['loginFail'])) { 

     if ($_SESSION['login_fail'] &lt; 1 ) {

     header('Location:https://google.com/'); // or any web page

     exit();

}
}
</code></pre>
<p>By this way, user can not open or go to our login page anymore, cause it has redirected to other website. </p>
<p>Users has to close the browser ( to destroy session loginFail that we created), open it 'again' to see our login page 'again'.</p>
<p>Is it helpful?</p>
</div></text><author><a href="/users/6723213/sulung-nugroho">Sulung Nugroho</a></author><comments/></answer></answers></post>