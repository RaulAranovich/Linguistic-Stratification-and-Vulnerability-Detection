<?xml version="1.0" encoding="utf-8"?>
<post><title>php - How can I store my users' passwords safely? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>How much more safe is this than plain <a href="http://en.wikipedia.org/wiki/MD5" rel="noreferrer">MD5</a>? I've just started looking into password security. I'm pretty new to PHP.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$salt </span><span class="pun">=</span><span class="pln"> </span><span class="str">'csdnfgksdgojnmfnb'</span><span class="pun">;</span><span class="pln">

$password </span><span class="pun">=</span><span class="pln"> md5</span><span class="pun">(</span><span class="pln">$salt</span><span class="pun">.</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'password'</span><span class="pun">]);</span><span class="pln">
$result </span><span class="pun">=</span><span class="pln"> mysql_query</span><span class="pun">(</span><span class="str">"SELECT id FROM users
                       WHERE username = '"</span><span class="pun">.</span><span class="pln">mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'username'</span><span class="pun">]).</span><span class="str">"'
                       AND password = '$password'"</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mysql_num_rows</span><span class="pun">(</span><span class="pln">$result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">/* Access denied */</span><span class="pln">
    echo </span><span class="str">"The username or password you entered is incorrect."</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> 
</span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $_SESSION</span><span class="pun">[</span><span class="str">'id'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mysql_result</span><span class="pun">(</span><span class="pln">$result</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="str">'id'</span><span class="pun">);</span><span class="pln">
    </span><span class="com">#header("Location: ./");</span><span class="pln">
    echo </span><span class="str">"Hello $_SESSION[id]!"</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments><comment><text><span class="comment-copy">Note php 5.4+ has this built in</span></text><author><a class="comment-user" href="/users/1348195/benjamin-gruenbaum" title="140,087 reputation">Benjamin Gruenbaum</a></author></comment><comment><text><span class="comment-copy">Also see Openwall's <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">PHP password hashing framework</a> (PHPass). Its portable and hardened against a number of common attacks on user passwords.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The easiest way to get your password storage scheme secure is by <strong>using a standard library</strong>.</p>
<p>Because security tends to be a lot more complicated and with more invisible screw up possibilities than most programmers could tackle alone, using a standard library is almost always easiest and most secure (if not the only) available option.</p>
<p><br/></p>
<h3>The new PHP password API (5.5.0+)</h3>
<p>If you are using PHP version 5.5.0 or newer, or if you're using 5.3.7 or newer and install <a href="https://github.com/ircmaxell/password_compat" rel="noreferrer">ircmaxell/password_compat</a>, you can use the new simplified password hashing API</p>
<p>example of code using PHP's password API:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">// $hash is what you would store in your database</span><span class="pln">
$hash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'password'</span><span class="pun">],</span><span class="pln"> PASSWORD_DEFAULT</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="str">'cost'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="lit">12</span><span class="pun">]);</span><span class="pln">

</span><span class="com">// $hash would be the $hash (above) stored in your database for this user</span><span class="pln">
$checked </span><span class="pun">=</span><span class="pln"> password_verify</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'password'</span><span class="pun">],</span><span class="pln"> $hash</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$checked</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    echo </span><span class="str">'password correct'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    echo </span><span class="str">'wrong credentials'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>You can see PHP's password library in action <a href="https://3v4l.org/GrsD6" rel="noreferrer">here</a>.</p>
<p><br/></p>
<h3>The OLD standard library</h3>
<p>Take a look at: <a href="http://www.openwall.com/phpass/" rel="noreferrer"><strong>Portable PHP password hashing framework</strong></a>: <strong>phpass</strong> and make sure you use the <code>CRYPT_BLOWFISH</code> algorithm if at all possible.</p>
<p>Example of code using phpass (v0.2):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">require</span><span class="pun">(</span><span class="str">'PasswordHash.php'</span><span class="pun">);</span><span class="pln">

$pwdHasher </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">PasswordHash</span><span class="pun">(</span><span class="lit">8</span><span class="pun">,</span><span class="pln"> FALSE</span><span class="pun">);</span><span class="pln">

</span><span class="com">// $hash is what you would store in your database</span><span class="pln">
$hash </span><span class="pun">=</span><span class="pln"> $pwdHasher</span><span class="pun">-&gt;</span><span class="typ">HashPassword</span><span class="pun">(</span><span class="pln"> $password </span><span class="pun">);</span><span class="pln">

</span><span class="com">// $hash would be the $hash (above) stored in your database for this user</span><span class="pln">
$checked </span><span class="pun">=</span><span class="pln"> $pwdHasher</span><span class="pun">-&gt;</span><span class="typ">CheckPassword</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$checked</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    echo </span><span class="str">'password correct'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    echo </span><span class="str">'wrong credentials'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>PHPass has been implemented in some quite well known projects:</p>
<ul>
<li>phpBB3</li>
<li>WordPress 2.5+ as well as bbPress</li>
<li>the Drupal 7 release, (module available for Drupal 5 &amp; 6)</li>
<li><a href="http://www.openwall.com/phpass/" rel="noreferrer">others</a></li>
</ul>
<p>The good thing is that you do not need to worry about the details, those details have been programmed by people with experience and reviewed by many folks on the internet.</p>
<p>For more information on password storage schemes, read <a href="http://stackoverflow.com/users/1/jeff-atwood">Jeff</a>`s blog post: <a href="http://www.codinghorror.com/blog/archives/000953.html" rel="noreferrer">You're Probably Storing Passwords Incorrectly</a></p>
<p>Whatever you do if you go for the '<em>I'll do it myself, thank you</em>' approach, <strong>do not use <code>MD5</code> or <code>SHA1</code> anymore</strong>. They are nice hashing algorithm, but considered <em>broken for security purposes</em>.</p>
<p>Currently, using <a href="http://www.php.net/crypt" rel="noreferrer">crypt</a>, with CRYPT_BLOWFISH is the best practice.<br/>
CRYPT_BLOWFISH in PHP is an implementation of the Bcrypt hash. Bcrypt is based on the Blowfish block cipher, making use of it's expensive key setup to slow the algorithm down.</p>
</div></text><author><a href="/users/22674/jacco">Jacco</a></author><comments><comment><text><span class="comment-copy">Yes, yes, a thousand times yes.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">Thank you, mister.</span></text><author><a class="comment-user" href="/users/50173/janis-veinbergs" title="5,421 reputation">Janis Veinbergs</a></author></comment><comment><text><span class="comment-copy">Good answer - thanks.  phpass is a good option.  But note that the "standard libraries" in some popular frameworks and apps are bad.  See e.g. the horrid story of the <a href="http://security.stackexchange.com/questions/3133/mysql-old-password-cryptanalysis">MySQL OLD_PASSWORD cryptanalysis?</a> and the sad story of their bad replacement:  <a href="http://security.stackexchange.com/questions/2986/looking-for-example-of-well-known-app-using-unsalted-hashes/3006#3006">Looking for example of well-known app using unsalted hashes - IT Security</a>  The latter link has other examples of bad standard password functions.</span></text><author><a class="comment-user" href="/users/507544/nealmcb" title="3,713 reputation">nealmcb</a></author></comment><comment><text><span class="comment-copy">MD5 and SHA1 are not broken in general (though they have some weaknesses, and for general purpose hashing SHA-2 should be used instead), they are just too fast to avoid bruteforce/dictionary password attacks (as SHA-2 and probably SHA-3, too).</span></text><author><a class="comment-user" href="/users/600500/pa%c5%adlo-ebermann" title="51,688 reputation">Paŭlo Ebermann</a></author></comment><comment><text><span class="comment-copy">@Jacco: If you don't like my edits, you could had left a comment.</span></text><author><a class="comment-user" href="/users/600500/pa%c5%adlo-ebermann" title="51,688 reputation">Paŭlo Ebermann</a></author></comment><comment><text><span class="comment-copy">I accept that you rolled back your answer - sorry, I thought it was an improvement. (The weaknesses found in MD5 and SHA-1 are mainly relevant for collision attacks, not for preimage attacks as needed here. <a href="http://crypto.stackexchange.com/questions/24/what-password-hash-should-i-use">The problem is that fast hashes are generally bad for password storage, because the small password space allows brute-forcing them.</a>)</span></text><author><a class="comment-user" href="/users/600500/pa%c5%adlo-ebermann" title="51,688 reputation">Paŭlo Ebermann</a></author></comment><comment><text><span class="comment-copy">But why did you also rolled back the edits to the question? "Please help me" is always a bad title for questions here. (And there is wrong grammar in the question, which I corrected, too.)</span></text><author><a class="comment-user" href="/users/600500/pa%c5%adlo-ebermann" title="51,688 reputation">Paŭlo Ebermann</a></author></comment><comment><text><span class="comment-copy"><a href="http://www.mindrot.org/projects/jBCrypt/" rel="nofollow noreferrer">bCrypt</a>, <a href="https://github.com/codahale/bcrypt-ruby" rel="nofollow noreferrer">bCrypt</a>, <a href="https://metacpan.org/module/Authen::Passphrase::BlowfishCrypt" rel="nofollow noreferrer">bCrypt</a> ... did I mention <a href="http://codahale.com/how-to-safely-store-a-password/" rel="nofollow noreferrer">bCrypt</a>?</span></text><author><a class="comment-user" href="/users/538921/eddie-b" title="3,475 reputation">Eddie B</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Your users will be much safer if you used parameterized queries instead of concatenating SQL statements. And <a href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="nofollow noreferrer">the salt</a> should be unique for each user and should be stored along with the password hash.</p>
</div></text><author><a href="/users/60188/anton-gogolev">Anton Gogolev</a></author><comments><comment><text><span class="comment-copy">There is a good article about security in PHP at Nettuts+, password salting is also mentioned. Maybe you should take a look at:  <a href="http://net.tutsplus.com/tutorials/php/simple-techniques-to-lock-down-your-website/" rel="nofollow noreferrer">net.tutsplus.com/tutorials/php/…</a></span></text><author><a class="comment-user" href="/users/114298/f%c3%a1bio-antunes" title="7,144 reputation">Fábio Antunes</a></author></comment><comment><text><span class="comment-copy">The Nettuts+ is a very bad article to use as a model - it includes use of MD5 which can be brute forced very easily even with salt. Instead, just use the PHPass library which is far, far better than any code you may find on a tutorial site, i.e. this answer: <a href="http://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919" title="how can i store my users passwords safely">stackoverflow.com/questions/1581610/…</a></span></text><author><a class="comment-user" href="/users/992887/richvel" title="1,920 reputation">RichVel</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A better way would be for each user to have a unique salt.</p>
<p>The benefit of having a salt is that it makes it harder for an attacker to pre-generate the MD5 signature of every dictionary word.  But if an attacker learns that you have a fixed salt, they could then pre-generate the MD5 signature of every dictionary word prefixed by your fixed salt.</p>
<p>A better way is each time a user changes their password, your system generate a random salt and store that salt along with the user record.  It makes it a bit more expensive to check the password (since you need to look up the salt before you can generate the MD5 signature) but it makes it much more difficult for an attacker to pre-generate MD5's.</p>
</div></text><author><a href="/users/29809/r-samuel-klatchko">R Samuel Klatchko</a></author><comments><comment><text><span class="comment-copy">Salts are usually stored together with the password hash (e.g. the output of the <code>crypt()</code> function). And since you have to retrieve the password hash anyway, using a user specific salt will not make the procedure any more expensive. (Or did you mean generating a new random salt is expensive? I don't really think so.) Otherwise +1.</span></text><author><a class="comment-user" href="/users/36862/inshallah" title="4,211 reputation">Inshallah</a></author></comment><comment><text><span class="comment-copy">For purposes of security, you may want to provide access to the table only through stored procedures and prevent the hash from ever being returned.  Instead, the client passes what it thinks is the hash and gets a success or failure flag.  This allows the stored proc to log the attempt, create a session, etc.</span></text><author><a class="comment-user" href="/users/131926/steven-sudit" title="16,297 reputation">Steven Sudit</a></author></comment><comment><text><span class="comment-copy">@Inshallah - if all users have the same salt, then you can reuse the dictionary attack you use on user1 against user2.  But if each user has a unique salt, you will need to generate a new dictionary for each user you want to attack.</span></text><author><a class="comment-user" href="/users/29809/r-samuel-klatchko" title="57,936 reputation">R Samuel Klatchko</a></author></comment><comment><text><span class="comment-copy">@R Samuel - that's exactly why I voted your answer up, because it recommends the best-practice strategy to avoid such attacks. My comment was meant to express my perplexity about what you said regarding the additional cost of a per-user salt, which I didn't understand at all. (since "salts are usually stored together with the password hash" any additional storage and CPU requirements for a per-user salt are so microscopic, that they need not even be mentioned...)</span></text><author><a class="comment-user" href="/users/36862/inshallah" title="4,211 reputation">Inshallah</a></author></comment><comment><text><span class="comment-copy">@Inshallah - I was thinking about the case where you have the database checked if the hashed password is okay (then you have one db retrieval to get the salt and a second db access to check the hashed password).  You are right about the case where you download the salt/hashed password in a single retrieval and then do the comparison on the client.  Sorry for the confusion.</span></text><author><a class="comment-user" href="/users/29809/r-samuel-klatchko" title="57,936 reputation">R Samuel Klatchko</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>With PHP 5.5 (what I describe is available to even earlier versions, see below) around the corner I'd like to suggest to use its new, built-in solution: <a href="http://php.net/manual/en/function.password-hash.php" rel="noreferrer"><code>password_hash()</code></a> and <a href="http://php.net/manual/en/function.password-verify.php" rel="noreferrer"><code>password_verify()</code></a>. It provides several options in order to achieve the level of password security you need (for example by specifying a "cost" parameter through the <code>$options</code> array)</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
var_dump</span><span class="pun">(</span><span class="pln">password_hash</span><span class="pun">(</span><span class="str">"my-secret-password"</span><span class="pun">,</span><span class="pln"> PASSWORD_DEFAULT</span><span class="pun">));</span><span class="pln">

$options </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">
    </span><span class="str">'cost'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="lit">7</span><span class="pun">,</span><span class="pln"> </span><span class="com">// this is the number of rounds for bcrypt</span><span class="pln">
    </span><span class="com">// 'salt' =&gt; 'TphfsM82o1uEKlfP9vf1f', // you could specify a salt but it is not recommended</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
var_dump</span><span class="pun">(</span><span class="pln">password_hash</span><span class="pun">(</span><span class="str">"my-secret-password"</span><span class="pun">,</span><span class="pln"> PASSWORD_BCRYPT</span><span class="pun">,</span><span class="pln"> $options</span><span class="pun">));</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
<p>will return</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">string</span><span class="pun">(</span><span class="lit">60</span><span class="pun">)</span><span class="pln"> </span><span class="str">"$2y$10$w2LxXdIcqJpD6idFTNn.eeZbKesdu5y41ksL22iI8C4/6EweI7OK."</span><span class="pln">
</span><span class="kwd">string</span><span class="pun">(</span><span class="lit">60</span><span class="pun">)</span><span class="pln"> </span><span class="str">"$2y$07$TphfsM82o1uEKlfP9vf1fOKohBqGVXOJEmnUtQu7Y1UMft1R4D3d."</span></code></pre>
<p>As you might see, the string contains the salt as well as the cost that was specified in the options. It also contains the algorithm used.</p>
<p>Therefore, when checking the password (for example when the user logs in), when using the complimentary <code>password_verify()</code> function it will extract the necessary crypto parameters from the password hash itself.</p>
<p>When not specifying a salt, the generated password hash will be different upon every call of <code>password_hash()</code> because the salt is generated randomly. Therefore comparing a previous hash with a newly generated one will fail, even for a correct password.</p>
<p>Verifying works like this:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">var_dump</span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="str">"my-secret-password"</span><span class="pun">,</span><span class="pln"> </span><span class="str">'$2y$10$BjHJbMCNWIJq7xiAeyFaHOGaO0jjNoE11e0YAer6Zu01OZHN/gk6K'</span><span class="pun">));</span><span class="pln">
var_dump</span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="str">"wrong-password"</span><span class="pun">,</span><span class="pln"> </span><span class="str">'$2y$10$BjHJbMCNWIJq7xiAeyFaHOGaO0jjNoE11e0YAer6Zu01OZHN/gk6K'</span><span class="pun">));</span><span class="pln">

var_dump</span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="str">"my-secret-password"</span><span class="pun">,</span><span class="pln"> </span><span class="str">'$2y$07$TphfsM82o1uEKlfP9vf1fOKohBqGVXOJEmnUtQu7Y1UMft1R4D3d.'</span><span class="pun">));</span><span class="pln">
var_dump</span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="str">"wrong-password"</span><span class="pun">,</span><span class="pln"> </span><span class="str">'$2y$07$TphfsM82o1uEKlfP9vf1fOKohBqGVXOJEmnUtQu7Y1UMft1R4D3d.'</span><span class="pun">));</span></code></pre>
<p>I hope that providing these built-in functions will soon provide better password security in case of data theft, as it reduces the amount of thought the programmer has to put into a proper implementation.</p>
<p>There is a small library (one PHP file) that will give you PHP 5.5's <code>password_hash</code> in PHP 5.3.7+: <a href="https://github.com/ircmaxell/password_compat" rel="noreferrer">https://github.com/ircmaxell/password_compat</a></p>
</div></text><author><a href="/users/578588/akirk">akirk</a></author><comments><comment><text><span class="comment-copy">In most cases it is better to omit the salt parameter. The function creates a salt from the random source of the operating system, there is very little chance that you can provide a better salt on your own.</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">That's what I wrote, didn't I? "if no salt is specified, it is randomly generated, for that reason it is preferable to not specify a salt"</span></text><author><a class="comment-user" href="/users/578588/akirk" title="5,146 reputation">akirk</a></author></comment><comment><text><span class="comment-copy">Most examples show how to add both parameters, even when it is not recommended to add a salt, so i wonder why? And to be honest, i read only the comment behind the code, not on the next line. Anyway, wouldn't it be better when the example shows how to use the function best?</span></text><author><a class="comment-user" href="/users/575765/martinstoeckli" title="14,052 reputation">martinstoeckli</a></author></comment><comment><text><span class="comment-copy">You're right, I agree. I have changed my answer accordingly and commented out the line. Thanks</span></text><author><a class="comment-user" href="/users/578588/akirk" title="5,146 reputation">akirk</a></author></comment><comment><text><span class="comment-copy">how should i check if the saved password and entered password are the same?i am using <code>password_hash()</code> and <code>password_verify</code> no matter what password(correct or not) i used i end up with correct password</span></text><author><a class="comment-user" href="/users/4018130/brownman-revival" title="795 reputation">Brownman Revival</a></author></comment><comment><text><span class="comment-copy">For <code>password_verify</code> the first parameter is what the user entered, the second is the hash from the database. It should only return true if the password was correct. I am not sure what your problem is?</span></text><author><a class="comment-user" href="/users/578588/akirk" title="5,146 reputation">akirk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>That's fine with me. Mr Atwood wrote about <a href="http://www.codinghorror.com/blog/archives/000949.html" rel="nofollow noreferrer">the strength of MD5 against rainbow tables</a>, and basically with a long salt like that you're sitting pretty (though some random punctuation/numbers, it could improve it).</p>
<p>You could also look at SHA-1, which seems to be getting more popular these days.</p>
</div></text><author><a href="/users/9021/nickf">nickf</a></author><comments><comment><text><span class="comment-copy">The note at the bottom of Mr Atwood's post (in red) links off to another post from a security practicioner that states using MD5, SHA1 and other fast hashes for storing passwords is very wrong.</span></text><author><a class="comment-user" href="/users/75658/sipwiz" title="20,780 reputation">sipwiz</a></author></comment><comment><text><span class="comment-copy">It is only wrong in that users can brute-force it quicker. 'slow' hashes are usually made slow by introducing a wait. This is false security. Better to limit the number of times someone can attempt to login.</span></text><author><a class="comment-user" href="/users/15537/matthew-scharley" title="66,910 reputation">Matthew Scharley</a></author></comment><comment><text><span class="comment-copy">@Matthew Scharley: I don't agree that the additional effort imposed by expensive password hashing algorithms is false security. It's to guard against brute-forcing of easily guessable passwords. If you're limiting login attempts, then you're protecting against the same thing (although a bit more effectively). But if an adversary has access to the DB stored hashes, he will be able to brute force such (easily guessable) passwords fairly quickly (depending on how easily guessable). The default for the SHA-256 crypt algorithm is 10000 round, so that would make it 10000 times more difficult.</span></text><author><a class="comment-user" href="/users/36862/inshallah" title="4,211 reputation">Inshallah</a></author></comment><comment><text><span class="comment-copy">The slow hashes are actually made by iterating a fast one a very large number of times, and shuffling the data around in between each iteration.  The goal is to ensure that even if the bad guy gets a copy of your password hashes, he has to burn a considerable amount of CPU time to test his dictionary against your hashes.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">@caf: I believe the bcrypt algorithm makes use of the parameterizable expensiveness of the Eksblowfish key scheduling; not entirely sure how this works, but key scheduling is often a very expensive operation done during the init a cipher context object, before any encryption is done.</span></text><author><a class="comment-user" href="/users/36862/inshallah" title="4,211 reputation">Inshallah</a></author></comment><comment><text><span class="comment-copy">Inshallah: This is true - the bcrypt algorithm is a different design, where the underlying crypto primitive is a block cipher rather than a hash function.  I was referring to schemes based on hash functions, like PHK's MD5 crypt().</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I want to add:</p>
<ul>
<li>Don't limit users passwords by length</li>
</ul>
<p>For compatibility with old systems often set a limit for the maximum length of the password. This is a bad security policy: if you set restriction, set it only for the minimum length of passwords.</p>
<ul>
<li>Don't send user passwords via email</li>
</ul>
<p>For recovering a forgotten password you should send the address by which user can change the password.</p>
<ul>
<li>Update the hashes of users passwords</li>
</ul>
<p>The password hash may be out of date (parameters of the algorithm may be updated). By using the function <a href="http://php.net/manual/en/function.password-needs-rehash.php" rel="nofollow noreferrer"><code>password_needs_rehash()</code></a> you can check it out.</p>
</div></text><author><a href="/users/1134181/aleksey-bykov">Aleksey Bykov</a></author><comments/></answer></answers></post>