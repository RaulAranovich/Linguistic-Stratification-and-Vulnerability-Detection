<?xml version="1.0" encoding="utf-8"?>
<post><title>mysql - How can I prevent SQL injection in PHP? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>If user input is inserted without modification into an SQL query, then the application becomes vulnerable to <a href="https://stackoverflow.com/a/332367/">SQL injection</a>, like in the following example:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$unsafe_variable </span><span class="pun">=</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">'user_input'</span><span class="pun">];</span><span class="pln"> 

mysql_query</span><span class="pun">(</span><span class="str">"INSERT INTO `table` (`column`) VALUES ('$unsafe_variable')"</span><span class="pun">);</span></code></pre>
<p>That's because the user can input something like <code>value'); DROP TABLE table;--</code>, and the query becomes:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">INSERT INTO </span><span class="str">`table`</span><span class="pln"> </span><span class="pun">(</span><span class="str">`column`</span><span class="pun">)</span><span class="pln"> VALUES</span><span class="pun">(</span><span class="str">'value'</span><span class="pun">);</span><span class="pln"> DROP TABLE table</span><span class="pun">;--</span><span class="str">')</span></code></pre>
<p>What can be done to prevent this from happening?</p>
</div></text><author><a href="/users/428190">Andrew G. Johnson</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p><strong>Use prepared statements and parameterized queries.</strong> These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.</p>
<p>You basically have two options to achieve this:</p>
<ol>
<li><p>Using <a href="http://php.net/manual/en/book.pdo.php" rel="noreferrer">PDO</a> (for any supported database driver):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $pdo</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM employees WHERE name = :name'</span><span class="pun">);</span><span class="pln">

$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">'name'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $name</span><span class="pun">));</span><span class="pln">

</span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$stmt </span><span class="kwd">as</span><span class="pln"> $row</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// do something with $row</span><span class="pln">
</span><span class="pun">}</span></code></pre></li>
<li><p>Using <a href="http://php.net/manual/en/book.mysqli.php" rel="noreferrer">MySQLi</a> (for MySQL):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $dbConnection</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'SELECT * FROM employees WHERE name = ?'</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">'s'</span><span class="pun">,</span><span class="pln"> $name</span><span class="pun">);</span><span class="pln">

$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span><span class="pln">

$result </span><span class="pun">=</span><span class="pln"> $stmt</span><span class="pun">-&gt;</span><span class="pln">get_result</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$row </span><span class="pun">=</span><span class="pln"> $result</span><span class="pun">-&gt;</span><span class="pln">fetch_assoc</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// do something with $row</span><span class="pln">
</span><span class="pun">}</span></code></pre></li>
</ol>
<p>If you're connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (e.g. <code>pg_prepare()</code> and <code>pg_execute()</code> for PostgreSQL). PDO is the universal option.</p>
<h2>Correctly setting up the connection</h2>
<p>Note that when using <code>PDO</code> to access a MySQL database <em>real</em> prepared statements are <strong>not used by default</strong>. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using PDO is:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$dbConnection </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> PDO</span><span class="pun">(</span><span class="str">'mysql:dbname=dbtest;host=127.0.0.1;charset=utf8'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'user'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'pass'</span><span class="pun">);</span><span class="pln">

$dbConnection</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
$dbConnection</span><span class="pun">-&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_ERRMODE</span><span class="pun">,</span><span class="pln"> PDO</span><span class="pun">::</span><span class="pln">ERRMODE_EXCEPTION</span><span class="pun">);</span></code></pre>
<p>In the above example the error mode isn't strictly necessary, <strong>but it is advised to add it</strong>. This way the script will not stop with a <code>Fatal Error</code> when something goes wrong. And it gives the developer the chance to <code>catch</code> any error(s) which are <code>throw</code>n as <code>PDOException</code>s.</p>
<p>What is <strong>mandatory</strong> however is the first <code>setAttribute()</code> line, which tells PDO to disable emulated prepared statements and use <em>real</em> prepared statements. This makes sure the statement and the values aren't parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).</p>
<p>Although you can set the <code>charset</code> in the options of the constructor, it's important to note that 'older' versions of PHP (&lt; 5.3.6) <a href="http://php.net/manual/en/ref.pdo-mysql.connection.php" rel="noreferrer">silently ignored the charset parameter</a> in the DSN.</p>
<h2>Explanation</h2>
<p>What happens is that the SQL statement you pass to <code>prepare</code> is parsed and compiled by the database server. By specifying parameters (either a <code>?</code> or a named parameter like <code>:name</code> in the example above) you tell the database engine where you want to filter on. Then when you call <code>execute</code>, the prepared statement is combined with the parameter values you specify. </p>
<p>The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn't intend. Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the <code>$name</code> variable contains <code>'Sarah'; DELETE FROM employees</code> the result would simply be a search for the string <code>"'Sarah'; DELETE FROM employees"</code>, and you will not end up with <a href="http://xkcd.com/327/" rel="noreferrer">an empty table</a>.</p>
<p>Another benefit with using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.</p>
<p>Oh, and since you asked about how to do it for an insert, here's an example (using PDO):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$preparedStatement </span><span class="pun">=</span><span class="pln"> $db</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'INSERT INTO table (column) VALUES (:column)'</span><span class="pun">);</span><span class="pln">

$preparedStatement</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">'column'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $unsafeValue</span><span class="pun">));</span></code></pre>
<h2>Can Prepared Statements Be Used For Dynamic Queries?</h2>
<p>While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.</p>
<p>For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="com">// Value whitelist</span><span class="pln">
</span><span class="com">// $dir can only be 'DESC' otherwise it will be 'ASC'</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">empty</span><span class="pun">(</span><span class="pln">$dir</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> $dir </span><span class="pun">!==</span><span class="pln"> </span><span class="str">'DESC'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   $dir </span><span class="pun">=</span><span class="pln"> </span><span class="str">'ASC'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/1109/theo">Theo</a></author><comments><comment><text><span class="comment-copy">Just to add because I didn't see it anywhere else here, another line of defense is a <a href="https://www.owasp.org/index.php/Web_Application_Firewall" rel="nofollow noreferrer">web application firewall</a> (WAF) that can have rules be set to look for sql injection attacks:</span></text><author><a class="comment-user" href="/users/5509376/jkerak" title="127 reputation">jkerak</a></author></comment><comment><text><span class="comment-copy">I woudl like to suggest use redbeanphp orm which is built on pdo. if you use pdo directly,it is really painful.</span></text><author><a class="comment-user" href="/users/2179189/jewelhuq" title="605 reputation">jewelhuq</a></author></comment><comment><text><span class="comment-copy">To learn more about 'PHP Data Objects' i.e. PDO visite these very good  articals :  1.<a href="http://code.tutsplus.com/tutorials/why-you-should-be-using-phps-pdo-for-database-access--net-12059" rel="nofollow noreferrer">code.tutsplus.com/tutorials/…</a> 2.<a href="http://code.tutsplus.com/tutorials/php-database-access-are-you-doing-it-correctly--net-25338" rel="nofollow noreferrer">code.tutsplus.com/tutorials/…</a></span></text><author><a class="comment-user" href="/users/3286899/rakesh" title="395 reputation">rakesh</a></author></comment><comment><text><span class="comment-copy">Also, the official documentation of mysql_query only allows to execute one query, so any other query besides ; is ignored. Even if this is already deprecated there are a lot of systems under PHP 5.5.0 and that may use this function. <a href="http://php.net/manual/en/function.mysql-query.php" rel="nofollow noreferrer">php.net/manual/en/function.mysql-query.php</a></span></text><author><a class="comment-user" href="/users/3558900/randall-valenciano" title="403 reputation">Randall Valenciano</a></author></comment><comment><text><span class="comment-copy">This is a bad habit but is a post-problem solution : Not only for SQL injection but for any type of injections (for example there was a view template injection hole in F3 framework v2) if you have a ready old website or app is suffering from injection defects , one solution is to reassign the values of your supperglobal predefined vars like $_POST with escaped values at bootstrap. By PDO, still it is possible to escape (also for today frameworks) : substr($pdo-&gt;quote($str, \PDO::PARAM_STR), 1, -1)</span></text><author><a class="comment-user" href="/users/1578387/alix" title="101 reputation">Alix</a></author></comment><comment><text><span class="comment-copy">I disagree with the practice of constantly wrapping every PDO statement in a try/catch. Fatal errors can be good. What's the point of just echo'ing out the errormessage and resuming an erroneous script, when not catching the exception gives you a nice stack trace?</span></text><author><a class="comment-user" href="/users/3714134/hugo-zink" title="165 reputation">Hugo Zink</a></author></comment><comment><text><span class="comment-copy">@Hugo-Zink It's about what the user sees. Having try/catch is all about the user experience.</span></text><author><a class="comment-user" href="/users/139609/joshua-k" title="295 reputation">Joshua K</a></author></comment><comment><text><span class="comment-copy">@JoshuaKersey that's why you disable <code>display_errors</code> in production, and get a nice detailed log instead.</span></text><author><a class="comment-user" href="/users/3714134/hugo-zink" title="165 reputation">Hugo Zink</a></author></comment><comment><text><span class="comment-copy">I know the thread is too old but, linking to this post will clear more doubts <a href="http://www.sqlserverlogexplorer.com/prevent-sql-injection-in-sql-server/" rel="nofollow noreferrer">sqlserverlogexplorer.com/prevent-sql-injection-in-sql-server</a></span></text><author><a class="comment-user" href="/users/5218011/jason-clark" title="691 reputation">Jason Clark</a></author></comment><comment><text><span class="comment-copy">@frosty: parameter binding is generally thought to be safer - apparently escaping can allow edge cases past, especially if the character set is misconfigured in the database.</span></text><author><a class="comment-user" href="/users/472495/halfer" title="12,941 reputation">halfer</a></author></comment><comment><text><span class="comment-copy">@halfer Would be nice if we actually get examples of edge cases though - actual proves, so we can't argue that escaping is enough. Without examples, as you can see below in the answers, plenty of people believes escaping is enough, and others think it's not. Without any definitive prove, just saying something is won't make anyone believe it.</span></text><author><a class="comment-user" href="/users/4993010/frosty" title="1,255 reputation">frosty</a></author></comment><comment><text><span class="comment-copy">@frosty: they may well already be available, if you are willing to search for them. Personally I think prepared statements are cleaner, and since they offer a speed advantage in most databases (via query caching) I don't think such research is worthwhile, since I'd go with parameter binding anyway. But you are most welcome to look into it - and if you do please do share what you find.</span></text><author><a class="comment-user" href="/users/472495/halfer" title="12,941 reputation">halfer</a></author></comment><comment><text><span class="comment-copy">@halfer It's just too painful for me to use. I might do some research though, if someone comes up with a counter-example that proves escaping isn't enough.</span></text><author><a class="comment-user" href="/users/4993010/frosty" title="1,255 reputation">frosty</a></author></comment><comment><text><span class="comment-copy">@frosty: unless you are a genuine and seasoned expert, in general you should favour security over convenience. On the same note, don't wait for other people to deliver whatever research you are after to your doorstop with a ribbon and bow - get searching! I don't understand, in any case, why you find parameter binding awkward - it's not an objection I've heard before. It just requires a bit of practice. There are a lot of good tutorials out there.</span></text><author><a class="comment-user" href="/users/472495/halfer" title="12,941 reputation">halfer</a></author></comment><comment><text><span class="comment-copy">@frosty you are making a fundamental mistake - all escaping a string does is suitably apply slashes before a quotation mark, but it doesn't <i>prevent</i> keywords being used in the string that is applied to the SQL, for example having multiple quotes can confuse the real escape string (in combination with incorrect character encoding such as '<code>\\''' DELETE FROM table</code>' , now, the real escape strings <i>might</i> escape the quotes but the string will still contain the <code>DELETE</code> clause. Please read <a href="https://phpdelusions.net/sql_injection" rel="nofollow noreferrer">phpdelusions.net/sql_injection</a> and <a href="http://stackoverflow.com/a/12118602/3536236">stackoverflow.com/a/12118602/3536236</a></span></text><author><a class="comment-user" href="/users/3536236/martin" title="8,017 reputation">Martin</a></author></comment><comment><text><span class="comment-copy">I think PDO is very useful, PDO is an interface it will Instead of concatenating escaped strings into SQL, in PDO you bind parameters which is an easier and cleaner way of Securing queries. PDO uses MVC scenario for calling method, interface and new class instance.</span></text><author><a class="comment-user" href="/users/2185064/ashish-patel" title="531 reputation">Ashish Patel</a></author></comment><comment><text><span class="comment-copy">I disagree with the practice of constantly wrapping every PDO statement in a try/catch. Fatal errors can be good. What's the point of just echo'ing out the errormessage and resuming an erroneous script,</span></text><author><a class="comment-user" href="/users/5109649/dhana-govindarajan" title="118 reputation">dhana govindarajan</a></author></comment><comment><text><span class="comment-copy">Assuming that I use mysqli prepare statement, how should I handle order by and order type parameters?</span></text><author><a class="comment-user" href="/users/3522687/paulalexandru" title="5,590 reputation">paulalexandru</a></author></comment><comment><text><span class="comment-copy">This answer lacks the explanation of what is a prepared statement - one thing - it's a performance hit if you use a lot of prepared statements during your request and sometimes it accounts for 10x performance hit. Better case would be use PDO with parameter binding off, but statement preparation off.</span></text><author><a class="comment-user" href="/users/119027/donis" title="454 reputation">donis</a></author></comment><comment><text><span class="comment-copy"><a href="https://capec.mitre.org" rel="nofollow noreferrer">CAPEC</a> is a better reference for <a href="https://capec.mitre.org/data/definitions/66.html" rel="nofollow noreferrer">SQL Injection</a>.</span></text><author><a class="comment-user" href="/users/1376258/x01saa" title="365 reputation">x01saa</a></author></comment><comment><text><span class="comment-copy">it help me for prevent Sql injection</span></text><author><a class="comment-user" href="/users/6363660/dhaval-gohel" title="155 reputation">Dhaval Gohel</a></author></comment><comment><text><span class="comment-copy">What about <code>LIKE</code> queries, how does <code>bindParam()</code> working then?</span></text><author><a class="comment-user" href="/users/4916265/justonundermillions" title="3,402 reputation">JustOnUnderMillions</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Warning:</strong>
  The question's sample code uses PHP's <code>mysql</code> extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.</p>
</blockquote>
<p>If you're using a recent version of PHP, the <code>mysql_real_escape_string</code> option outlined below will no longer be available (though <code>mysqli::escape_string</code> is a modern equivalent). These days the <code>mysql_real_escape_string</code> option would only make sense for legacy code on an old version of PHP.</p>
<hr/>
<p>You've got two options - escaping the special characters in your <code>unsafe_variable</code>, or using a parameterized query. Both would protect you from SQL injection. The parameterized query is considered the better practice, but will require changing to a newer mysql extension in PHP before you can use it.</p>
<p>We'll cover the lower impact string escaping one first.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="com">//Connect</span><span class="pln">

$unsafe_variable </span><span class="pun">=</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">"user-input"</span><span class="pun">];</span><span class="pln">
$safe_variable </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$unsafe_variable</span><span class="pun">);</span><span class="pln">

mysql_query</span><span class="pun">(</span><span class="str">"INSERT INTO table (column) VALUES ('"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $safe_variable </span><span class="pun">.</span><span class="pln"> </span><span class="str">"')"</span><span class="pun">);</span><span class="pln">

</span><span class="com">//Disconnect</span></code></pre>
<p>See also, the details of the <a href="http://php.net/mysql_real_escape_string" rel="noreferrer"><code>mysql_real_escape_string</code></a> function.</p>
<p>To use the parameterized query, you need to use <a href="http://php.net/mysqli" rel="noreferrer">MySQLi</a> rather than the <a href="http://php.net/mysql" rel="noreferrer">MySQL</a> functions. To rewrite your example, we would need something like the following.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
    $mysqli </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> mysqli</span><span class="pun">(</span><span class="str">"server"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"username"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"password"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"database_name"</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// TODO - Check that connection was successful.</span><span class="pln">

    $unsafe_variable </span><span class="pun">=</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">"user-input"</span><span class="pun">];</span><span class="pln">

    $stmt </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"INSERT INTO table (column) VALUES (?)"</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// TODO check that $stmt creation succeeded</span><span class="pln">

    </span><span class="com">// "s" means the database expects a string</span><span class="pln">
    $stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">"s"</span><span class="pun">,</span><span class="pln"> $unsafe_variable</span><span class="pun">);</span><span class="pln">

    $stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span><span class="pln">

    $stmt</span><span class="pun">-&gt;</span><span class="pln">close</span><span class="pun">();</span><span class="pln">

    $mysqli</span><span class="pun">-&gt;</span><span class="pln">close</span><span class="pun">();</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
<p>The key function you'll want to read up on there would be <a href="http://php.net/mysqli.prepare" rel="noreferrer"><code>mysqli::prepare</code></a>.</p>
<p>Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like <a href="http://php.net/pdo" rel="noreferrer">PDO</a>.</p>
<p>Please note that the case you asked about is a fairly simple one, and that more complex cases may require more complex approaches. In particular:</p>
<ul>
<li>If you want to alter the structure of the SQL based on user input, parameterised queries are not going to help, and the escaping required is not covered by <code>mysql_real_escape_string</code>. In this kind of case you would be better off passing the user's input through a whitelist to ensure only 'safe' values are allowed through.</li>
<li>If you use integers from user input in a condition and take the <code>mysql_real_escape_string</code> approach, you will suffer from the problem described by <a href="http://stackoverflow.com/users/978756/polynomial">Polynomial</a> in the comments below. This case is trickier because integers would not be surrounded by quotes, so you could deal with by validating that the user input contains only digits.</li>
<li>There are likely other cases I'm not aware of. You might find <a href="http://webappsec.org/projects/articles/091007.txt" rel="noreferrer">http://webappsec.org/projects/articles/091007.txt</a> a useful resource on some of the more subtle problems you can encounter.</li>
</ul>
</div></text><author><a href="/users/797/matt-sheppard">Matt Sheppard</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Every answer here covers only part of the problem.<br/>
In fact, there are <strong>four</strong> different query parts which we can add to it dynamically:</p>
<ul>
<li>a string</li>
<li>a number</li>
<li>an identifier</li>
<li>a syntax keyword.</li>
</ul>
<p>and prepared statements covers only 2 of them</p>
<p>But sometimes we have to make our query even more dynamic, adding operators or identifiers as well.<br/>
So, we will need different protection techniques.</p>
<p>In general, such a protection approach is based on <em>whitelisting</em>.
In this case every dynamic parameter should be hardcoded in your script and chosen from that set.<br/>
For example, to do dynamic ordering:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$orders  </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">(</span><span class="str">"name"</span><span class="pun">,</span><span class="str">"price"</span><span class="pun">,</span><span class="str">"qty"</span><span class="pun">);</span><span class="pln"> </span><span class="com">//field names</span><span class="pln">
$key     </span><span class="pun">=</span><span class="pln"> array_search</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="str">'sort'</span><span class="pun">],</span><span class="pln">$orders</span><span class="pun">));</span><span class="pln"> </span><span class="com">// see if we have such a name</span><span class="pln">
$orderby </span><span class="pun">=</span><span class="pln"> $orders</span><span class="pun">[</span><span class="pln">$key</span><span class="pun">];</span><span class="pln"> </span><span class="com">//if not, first one will be set automatically. smart enuf :)</span><span class="pln">
$query   </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM `table` ORDER BY $orderby"</span><span class="pun">;</span><span class="pln"> </span><span class="com">//value is safe</span></code></pre>
<p>However, there is another way to secure identifiers - escaping. As long as you have an identifier quoted, you can escape backticks inside by doubling them. </p>
<p>As a further step we can borrow a truly brilliant idea of using some placeholder (a proxy to represent the actual value in the query) from the prepared statements and invent a placeholder of another type - an identifier placeholder.</p>
<p>So, to make long story short: it's a <strong>placeholder</strong>, not <strong>prepared statement</strong> can be considered as a silver bullet.  </p>
<p>So, a general recommendation may be phrased as<br/>
<strong>As long as you are adding dynamic parts to the query using placeholders (and these placeholders properly processed of course), you can be sure that your query is safe</strong>.</p>
<p>Still there is an issue with SQL syntax keywords (such as <code>AND</code>, <code>DESC</code> and such) but white-listing seems the only approach in this case.</p>
<h1>Update</h1>
<p>Although there is a general agreement on the best practices regarding SQL injection protection, there are <strong>still many bad practices as well.</strong> And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) <strong>more than 80 deleted answers</strong> - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of bad answers aren't deleted but rather prospering.  </p>
<p>For example, <a href="http://stackoverflow.com/a/11802479/285587">there(1)</a> <a href="http://stackoverflow.com/a/6381189/285587">are(2)</a> <a href="http://stackoverflow.com/a/60195/285587">still(3)</a> <a href="http://stackoverflow.com/a/12426697/285587">many(4)</a> <a href="http://stackoverflow.com/a/21179234/285587">answers(5)</a>, including <a href="http://stackoverflow.com/a/60442/285587">the second most upvoted answer</a> suggesting you manual string escaping - an outdated approach that is proven to be insecure. </p>
<p>Or there is a slightly better answer that suggests just <a href="http://stackoverflow.com/a/12710285/285587">another method of string formatting</a> and even boasts it as ultimate panacea. While of course it is not. This method is no better than regular string formatting yet it keeps all its drawbacks: it is applicable to strings only and, as any other manual formatting, it's essentially optional, non-obligatory measure, prone to human error of any sort. </p>
<p>I think that all this because of one very old superstition, supported by such authorities like <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input">OWASP</a> or <a href="http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description">PHP manual</a>, which proclaims equality between whatever "escaping" and protection from SQL injections. </p>
<p>Despite of what PHP manual said for ages, <strong><code>*_escape_string</code> by no means makes data safe</strong>, and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong because it is manual as opposite to automated. </p>
<p>And OWASP makes it even worse, stressing on escaping <em>user input</em> which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It's destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is "safe" or not) he takes his first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.</p>
<p>So, unlike whatever "escaping", prepared statements <em>is</em> the measure that indeed protects from SQL injection (when applicable).</p>
<p>If you're still not convinced, here is a step-by step explanation I wrote, <a href="http://phpdelusions.net/sql_injection">The Hitchhiker's Guide to SQL Injection prevention</a>, where I explained all these matters in detail, and even compiled a section entirely dedicated to bad practices and their disclosure.</p>
</div></text><author><a href="/users/285587/your-common-sense">Your Common Sense</a></author><comments><comment><text><span class="comment-copy">Great, well thought out article.  I might add that using the Sanitize filters of PHP is kind of (but not exactly) a white listing of sorts.  For example, <code>FILTER_SANITIZE_NUMBER_INT</code> only allows number characters, thereby white listing characters, not entire strings.  In combination with prepared statements, it makes a good "belt and suspenders" approach.</span></text><author><a class="comment-user" href="/users/1408137/sablefoste" title="2,319 reputation">Sablefoste</a></author></comment><comment><text><span class="comment-copy">@Sablefoste you don't need whitelisting here. Any sanitization will be redundant. Less rules to follow, the less mistakes you will make. Although you could do any validations, do it for sake of your application logic, but not for database.</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">"thinking whether some particular variable is "safe" or not is the first step to disaster." Excellent way to put it.</span></text><author><span class="comment-user">user1135300</span></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'd recommend using <a href="http://ca3.php.net/manual/en/book.pdo.php" rel="noreferrer">PDO</a> (PHP Data Objects) to run parameterized SQL queries. </p>
<p>Not only does this protect against SQL injection, it also speeds up queries. </p>
<p>And by using PDO rather than <code>mysql_</code>, <code>mysqli_</code>, and <code>pgsql_</code> functions, you make your app a little more abstracted from the database, in the rare occurrence that you have to switch database providers.</p>
</div></text><author><a href="/users/1862/kibbee">Kibbee</a></author><comments><comment><text><span class="comment-copy">doesn't PDO wrap mysqli for MySQL DBs? In which case surely it can't be any quicker than mysqli. I'd still recommend it though. It's a much better interface that the mysqli API.</span></text><author><a class="comment-user" href="/users/51031/peter-bagnall" title="1,205 reputation">Peter Bagnall</a></author></comment><comment><text><span class="comment-copy">Using parameterized queries is what speeds up the queries. Technically mysqli might be even faster by a very small margin.  The actual amount of time the server takes to respond the the query eclipses any difference in timing that might happen because you are using a wrapper.  But mysqli is tied to the database.  If you want to use a different database engine, you have to change all the calls that use mysqli.  Not so for PDO.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Use <code>PDO</code> and prepared queries.</p>
<p>(<code>$conn</code> is a <code>PDO</code> object)</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $conn</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"INSERT INTO tbl VALUES(:id, :name)"</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bindValue</span><span class="pun">(</span><span class="str">':id'</span><span class="pun">,</span><span class="pln"> $id</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bindValue</span><span class="pun">(</span><span class="str">':name'</span><span class="pun">,</span><span class="pln"> $name</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
</div></text><author><a href="/users/1897/imran">Imran</a></author><comments><comment><text><span class="comment-copy">How it prevents sql injection ??</span></text><author><a class="comment-user" href="/users/3326275/pratik-c-joshi" title="7,872 reputation">Pratik C Joshi</a></author></comment><comment><text><span class="comment-copy">From <a href="https://en.wikipedia.org/wiki/Prepared_statement" rel="nofollow noreferrer">wikipedia</a>: Prepared statements are resilient against SQL injection, because parameter values, which are transmitted later using a different protocol, need not be correctly escaped. If the original statement template is not derived from external input, SQL injection cannot occur.</span></text><author><a class="comment-user" href="/users/1897/imran" title="34,651 reputation">Imran</a></author></comment><comment><text><span class="comment-copy">$conn is not PDO it a variabel and can be anything</span></text><author><a class="comment-user" href="/users/4691734/thecrazyprofessor" title="333 reputation">TheCrazyProfessor</a></author></comment><comment><text><span class="comment-copy">@TheCrazyProfessor In the context of this example, you should assume that the <code>$conn</code> variable references a PDO connection object.</span></text><author><a class="comment-user" href="/users/1897/imran" title="34,651 reputation">Imran</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>As you can see, people suggest you to use prepared statements at the most. It's not wrong, but when your query is executed <strong>just once</strong> per process, there would be a slightly performance penalty. </p>
<p>I was facing this issue, but I think I solved it in <em>very</em> sophisticated way - the way hackers use to avoid using quotes. I used this in conjuction with emulated prepared statements. I use it to prevent <em>all</em> kinds of possible SQL injection attacks.</p>
<h2>My approach:</h2>
<ul>
<li><p>If you expect input to be integer make sure it's <strong><em>really</em></strong> integer. In a variable-type language like PHP it is this <em>very</em> important. You can use for example this very simple but powerful solution: <code>sprintf("SELECT 1,2,3 FROM table WHERE 4 = %u", $input);</code> </p></li>
<li><p>If you expect anything else from integer <strong>hex it</strong>. If you hex it, you will perfectly escape all input. In C/C++ there's a function called <a href="http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html" rel="noreferrer"><code>mysql_hex_string()</code></a>, in PHP you can use <a href="http://www.php.net/manual/en/function.bin2hex.php" rel="noreferrer"><code>bin2hex()</code></a>.</p>
<p>Don't worry about that the escaped string will have 2x size of its original length because even if you use <code>mysql_real_escape_string</code>, PHP has to allocate same capacity <code>((2*input_length)+1)</code>, which is the same.</p></li>
<li><p>This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with <code>0x</code> or use the MySQL function <code>UNHEX</code> instead.</p></li>
</ul>
<p>So for example the query:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT password FROM users WHERE name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'root'</span></code></pre>
<p>Will become:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT password FROM users WHERE name </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x726f6f74</span></code></pre>
<p>or</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT password FROM users WHERE name </span><span class="pun">=</span><span class="pln"> UNHEX</span><span class="pun">(</span><span class="str">'726f6f74'</span><span class="pun">)</span></code></pre>
<p>Hex is the perfect escape. No way to inject.</p>
<h2>Difference between UNHEX function and 0x prefix</h2>
<p>There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:</p>
<p><strong>0x</strong> prefix can only be used on data columns such as <strong>char, varchar, text, block, binary, etc</strong>.<br/>
Also its use is a little complicated if you are about to insert an empty string. You'll have to entirely replace it with <code>''</code>, or you'll get an error.</p>
<p><strong>UNHEX()</strong> works on <strong>any</strong> column; you do not have to worry about the empty string.</p>
<hr/>
<h2>Hex methods are often used as attacks</h2>
<p>Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with <code>mysql_real_escape_string</code>. Then you can avoid use of quotes.</p>
<p>For example, if you just do something like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="str">"SELECT title FROM article WHERE id = "</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="str">"id"</span><span class="pun">])</span></code></pre>
<p>an attack can inject you very <em>easily</em>. Consider the following injected code returned from your script:</p>
<blockquote>
<p>SELECT ... WHERE id = <strong>-1 union all select table_name from information_schema.tables</strong></p>
</blockquote>
<p>and now just extract table structure:</p>
<blockquote>
<p>SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = <strong>0x61727469636c65</strong></p>
</blockquote>
<p>And then just select whatever data ones want. Cool isn't it?</p>
<p>But if the coder of injectable site would hex it, no injection would be possible because the query would look like this: <code>SELECT ... WHERE id = UNHEX('2d312075...3635')</code></p>
</div></text><author><a href="/users/823738/zaffy">Zaffy</a></author><comments><comment><text><span class="comment-copy">@Zaffy, I like the idea, but what about performance, I mean if you have 1 million records and 1000 users searching does it slow down as compare to prepare solution ?</span></text><author><a class="comment-user" href="/users/1160395/sumit-gupta" title="1,481 reputation">Sumit Gupta</a></author></comment><comment><text><span class="comment-copy">I just test SELECT * FROM <code>tblproducts</code> WHERE product_code LIKE ( '%42%') does find record but SELECT *  FROM <code>tblproducts</code> WHERE product_code LIKE ('%' +0x3432 +'%') doesn't, so it simply doesn't work or I did something wrong ?</span></text><author><a class="comment-user" href="/users/1160395/sumit-gupta" title="1,481 reputation">Sumit Gupta</a></author></comment><comment><text><span class="comment-copy">@SumitGupta Yea, you did. MySQL doesnt concatenate with <code>+</code> but with <code>CONCAT</code>. And to the performance: I dont think it affects performance because mysql has to parse data and it doesnt matter if origin is string or hex</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense What errors do you encounter? Be specific.</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense Your  <code>0x . $_GET["id"]</code> for id <code>42</code> will result in byte with ascii code 42. Try <code>SELECT 0x42</code> and you'll see what you are at.</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">Please, please please <b>PLEASE read my code!</b> There is no <code>0x . $_GET["id"]</code> there. But anyway, it won't find a number 42 too</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense You dont understand the concept... If you want to have string in mysql you quote it like this <code>'root'</code> or you can hex it <code>0x726f6f74</code> BUT if you want a number and send it as string you will probably write '42' not CHAR(42) ... '42' in hex would be <code>0x3432</code> not <code>0x42</code></span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">Neither 0x3432 nor 0x42 won't find a thing. <b>That is the point.</b> This is why your "solution" is worse than regular formatting and thus not a solution at all.</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense I have nothing to say... just lol... if you still want to try hex on numeric fields, see second comment. I bet with you that it'll work.</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">@griffin I beg my pardon, did you try to run the very proposed solution yourself? <code>"SELECT title FROM article WHERE id = 0x" . bin2hex($_GET["id"])</code>? What is wrong with representation here?</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">The answer clearly states that it won't work that way with integer values, the reason being that bin2hex converts the passed value to a string (and thus bin2hex(0) is 0x30, and not 0x03) - that's probably the part which confuses you. If you follow that, it works perfectly (at least on my site, tested with 4 different mysql versions on debian machines, 5.1.x to 5.6.x). After all, hexadecimal is only the way of representation, not the value ;)</span></text><author><a class="comment-user" href="/users/1895207/griffin" title="991 reputation">griffin</a></author></comment><comment><text><span class="comment-copy"><code>"SELECT title FROM article WHERE id = ?"</code> can do it for either string and number. And we will have slightly unreadable but reliable query. <code>"SELECT title FROM article WHERE id = '" . mysql_real_escape_string($_GET["id"])."'"</code> can do it for either string and number. And we will have readable and reliable query. <code>"SELECT title FROM article WHERE id = 0x" . bin2hex($_GET["id"])</code> can do it for the string only and we will have unreadable and unreliable query. And "representation" has nothing to do here.</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense you still dont understand ? You cannot use 0x and concat because if the string is empty you will end with an error. If you want simple alternative to your query try this one <code>SELECT title FROM article WHERE id = UNHEX(' . bin2hex($_GET["id"]) . ')</code></span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense If you dont want to do that you dont have to do that.  I'm not forcing you :)</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">@griffin what? What does hexing to do with table size? Are you sure you understand the difference between data and it's representation?</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense read "(fixed entry size)-tables" - each entry is a fixed size. And it's about transforming uint8_t to uint16_t, which can easily be parallelized using (fixed entry size)-tables in a programming language like c. Also, as I said, the real reason to use this would just be to do something different, as any kind of performance difference of the different methods would be so small that it (probably) wouldn't matter in reality.</span></text><author><a class="comment-user" href="/users/1895207/griffin" title="991 reputation">griffin</a></author></comment><comment><text><span class="comment-copy">Prepared statements are slower than string concatenation based sql queries in a scenario where queries are not applied multiple times, at a factor of up to 2:1 (you can execute 2 times as many string based queries than prepared statements in the same time) when using locally hosted mysql 5.x connected through local unix socket. That's the reason for me to prefer string based sql over prepared statements (though sql is painfully slow anyway compared to in-memory kv stores). Also it (=posted answer) is reliable by concept - understand how it works, and you will see why.</span></text><author><a class="comment-user" href="/users/1895207/griffin" title="991 reputation">griffin</a></author></comment><comment><text><span class="comment-copy">This is a really clever approach.  Is this something that will work with other database servers (Oracle, Microsoft, etc), or specific to MySQL?</span></text><author><a class="comment-user" href="/users/218125/cypher" title="963 reputation">Cypher</a></author></comment><comment><text><span class="comment-copy"><a href="http://php.net/manual/en/function.mysql-real-escape-string.php" rel="nofollow noreferrer"><code>mysql_real_escape_string</code></a> is now deprecated, so its no longer a viable option. It will be removed from PHP in the future.  Its best to move onto what the PHP or MySQL folks recommend.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">@jww Although it was deprecated by php, it's not obsolete or deprecated by mysql. It's still safe to use, php is trying to replace those native apis with a higher layers to maximize comfort and security for their end-users. You can see here that <a href="http://pastebin.com/Qpw9Cvrw" rel="nofollow noreferrer">PDO layer uses mysql_real_escape_string</a> as well. Personally I also like using higher-level APIs and leave this kind of stuff to them, because mistakes happen.</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment><comment><text><span class="comment-copy">Chiming in agreement with @MKaama here, I think this is a pretty clever answer. I use parameterized queries myself, but just wanted to see if <code>UNHEX()</code> equivalent existed in SQL Server. Turns out we're left with something along these lines: <code>SELECT CONVERT(VARCHAR(MAX), 0x4142)</code>  Though, I suppose one could port <code>UNHEX()</code> themselves if they <a href="https://github.com/mysql/mysql-server/blob/b4104b21520be032400b768cea09a867068be49d/sql/item_strfunc.cc#L4271-L4308" rel="nofollow noreferrer">really wanted to</a>.</span></text><author><a class="comment-user" href="/users/901156/rdev5" title="662 reputation">rdev5</a></author></comment><comment><text><span class="comment-copy">So you're saying using myqli_real_escape_string inside the query itself without quotes will allow sql injections? And that's not the case if it was used outside of the query?</span></text><author><a class="comment-user" href="/users/4993010/frosty" title="1,255 reputation">frosty</a></author></comment><comment><text><span class="comment-copy">@frosty Not sure if understood but you shouldn't assume type of the user input but prove/verify it instead. Using mysql_real_escape_string on an integer is really a nonsense anyway, since if it's <i>really</i> an integer it can't make the query exploitable. For example the the printf-family functions have formats like %d, %u, %f and so on and will implicitly cast to the desired value or just discard the result. With strings you have to use quotes and also make sure you have properly set charset, or you can use hex method above, prepared statements or so.</span></text><author><a class="comment-user" href="/users/823738/zaffy" title="9,793 reputation">Zaffy</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>IMPORTANT</strong></p>
<p>The best way to prevent SQL Injection is to use <strong>Prepared Statements</strong> <em>instead of escaping</em>, as <a href="https://stackoverflow.com/a/60496/2224584">the accepted answer</a> demonstrates. </p>
<p>There are libraries such as <a href="https://github.com/auraphp/Aura.Sql">Aura.Sql</a> and <a href="https://github.com/paragonie/easydb">EasyDB</a> that allow developers to use prepared statements easier. To learn more about why prepared statements are better at <a href="https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide">stopping SQL injection</a>, refer to <a href="http://stackoverflow.com/a/12118602/2224584">this <code>mysql_real_escape_string()</code> bypass</a> and <a href="https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/">recently fixed Unicode SQL Injection vulnerabilities in WordPress</a>.</p>
</blockquote>
<p>Injection prevention - <a href="http://php.net/manual/en/function.mysql-real-escape-string.php">mysql_real_escape_string()</a></p>
<p>PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, <code>mysql_real_escape_string</code>.</p>
<p><code>mysql_real_escape_string</code> takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(') a user might enter with a MySQL-safe substitute, an escaped quote \'.</p>
<p><strong>NOTE:</strong> you must be connected to the database to use this function!</p>
<p>// Connect to MySQL</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$name_bad </span><span class="pun">=</span><span class="pln"> </span><span class="str">"' OR 1'"</span><span class="pun">;</span><span class="pln"> 

$name_bad </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$name_bad</span><span class="pun">);</span><span class="pln">

$query_bad </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM customers WHERE username = '$name_bad'"</span><span class="pun">;</span><span class="pln">
echo </span><span class="str">"Escaped Bad Injection: &lt;br /&gt;"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $query_bad </span><span class="pun">.</span><span class="pln"> </span><span class="str">"&lt;br /&gt;"</span><span class="pun">;</span><span class="pln">


$name_evil </span><span class="pun">=</span><span class="pln"> </span><span class="str">"'; DELETE FROM customers WHERE 1 or username = '"</span><span class="pun">;</span><span class="pln"> 

$name_evil </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$name_evil</span><span class="pun">);</span><span class="pln">

$query_evil </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM customers WHERE username = '$name_evil'"</span><span class="pun">;</span><span class="pln">
echo </span><span class="str">"Escaped Evil Injection: &lt;br /&gt;"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $query_evil</span><span class="pun">;</span></code></pre>
<p>You can find more details in <em><a href="http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php">MySQL - SQL Injection Prevention</a></em>.</p>
</div></text><author><a href="/users/779158/rahularyansharma">rahularyansharma</a></author><comments><comment><text><span class="comment-copy">This is the best you can do with legacy mysql extension. For new code, you're advised to switch to mysqli or PDO.</span></text><author><a class="comment-user" href="/users/13508/%c3%81lvaro-gonz%c3%a1lez" title="88,106 reputation">Álvaro González</a></author></comment><comment><text><span class="comment-copy">I am not agree with this 'a specially-made function to prevent these attacks'. I think that <code>mysql_real_escape_string</code> purpose is in allow to build correct SQL query for every input data-string. Prevention sql-injection is the side-effect of this function.</span></text><author><a class="comment-user" href="/users/1503018/sectus" title="11,861 reputation">sectus</a></author></comment><comment><text><span class="comment-copy">you dont use functions to write correct input data-strings.  You just write correct ones that don't need escaping or have already been escaped.  mysql_real_escape_string() may have been designed with the purpose you mention in mind, but its only value is preventing injection.</span></text><author><a class="comment-user" href="/users/2792592/nazca" title="96 reputation">Nazca</a></author></comment><comment><text><span class="comment-copy"><b>WARNING!</b> <code>mysql_real_escape_string()</code> <a href="http://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string">is not infallible</a>.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">@eggyal Especially if you're messing around with different charsets.</span></text><author><a class="comment-user" href="/users/491494/wayne-whitty" title="14,291 reputation">Wayne Whitty</a></author></comment><comment><text><span class="comment-copy"><a href="http://php.net/manual/en/function.mysql-real-escape-string.php" rel="nofollow noreferrer"><code>mysql_real_escape_string</code></a> is now deprecated, so its no longer a viable option. It will be removed in the future from PHP.  Its best to move onto what the PHP or MySQL folks recommend.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">@rahularyansharma I'd like to request this be modified with a disclaimer: Prepared Statements are easier to use safely and are more secure from an engineering standpoint: the parameters and the query string are sent in separate packets, thus preventing the parameters from altering the query string. Also: <a href="https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string/12118602#12118602" title="sql injection that gets around mysql real escape string">stackoverflow.com/questions/5741187/…</a></span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Ok the bypass says nothing about "To learn more about why prepared statements are better at stopping SQL injection, refer to this mysql_real_escape_string() bypass". Rather the opposite, that prepared statements suffer the same issues and PDO is not an exception.  "It gets worse. PDO defaults to emulating prepared statements with MySQL. That means that on the client side, it basically does a sprintf through mysql_real_escape_string() (in the C library), which means the following will result in a successful injection:"</span></text><author><a class="comment-user" href="/users/771405/cjohansson" title="170 reputation">cjohansson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Security Warning</strong>: This answer is not in line with security best practices. <a href="https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide" rel="noreferrer">Escaping is inadequate to prevent SQL injection</a>, use <em>prepared statements</em> instead. Use the strategy outlined below at your own risk. (Also, <code>mysql_real_escape_string()</code> was removed in PHP 7.)</p>
</blockquote>
<p>You could do something basic like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$safe_variable </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">"user-input"</span><span class="pun">]);</span><span class="pln">
mysql_query</span><span class="pun">(</span><span class="str">"INSERT INTO table (column) VALUES ('"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $safe_variable </span><span class="pun">.</span><span class="pln"> </span><span class="str">"')"</span><span class="pun">);</span></code></pre>
<p>This won't solve every problem, but it's a very good stepping stone. I left out obvious items such as checking the variable's existence, format (numbers, letters, etc.).</p>
</div></text><author><a href="/users/567/tanerax">Tanerax</a></author><comments><comment><text><span class="comment-copy">I have tried your example and it's work fine for me.Could you clear "this won't solve every problem"</span></text><author><a class="comment-user" href="/users/1252580/chinook" title="195 reputation">Chinook</a></author></comment><comment><text><span class="comment-copy">If you don't quote the string, it's still injectable. Take <code>$q = "SELECT col FROM tbl WHERE x = $safe_var";</code> for example. Setting <code>$safe_var</code> to <code>1 UNION SELECT password FROM users</code> works in this case because of the lack of quotes. It's also possible to inject strings into the query using <code>CONCAT</code> and <code>CHR</code>.</span></text><author><a class="comment-user" href="/users/978756/polynomial" title="18,116 reputation">Polynomial</a></author></comment><comment><text><span class="comment-copy">@Polynomial Completely right, but I'd see this merely as wrong usage. As long as you use it correctly, it will definitely work.</span></text><author><a class="comment-user" href="/users/296974/glglgl" title="55,008 reputation">glglgl</a></author></comment><comment><text><span class="comment-copy">@glglgl That's fine, if you're willing to accept the risk of someone forgetting a quote somewhere in your entire application. Bad development practices keep me in a job ;)</span></text><author><a class="comment-user" href="/users/978756/polynomial" title="18,116 reputation">Polynomial</a></author></comment><comment><text><span class="comment-copy">so, if I write these codes, db is still unprotected? mysql_query("INSERT INTO table (column) VALUES ('$safe_variable')");</span></text><author><a class="comment-user" href="/users/1932887/djonce" title="241 reputation">DjOnce</a></author></comment><comment><text><span class="comment-copy">Does not prevent '1 OR 1=1'</span></text><author><a class="comment-user" href="/users/942296/arvind-bhardwaj" title="3,670 reputation">Arvind Bhardwaj</a></author></comment><comment><text><span class="comment-copy"><b>WARNING!</b> <code>mysql_real_escape_string()</code> <a href="http://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string">is not infallible</a>.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy"><a href="http://php.net/manual/en/function.mysql-real-escape-string.php" rel="nofollow noreferrer"><code>mysql_real_escape_string</code></a> is now deprecated, so its no longer a viable option. It will be removed in the future from PHP.  Its best to move onto what the PHP or MySQL folks recommend.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">Please give me example before mysqli_real_escape_string and after the string which gets generated. As it casuse confusion and no example is given.</span></text><author><a class="comment-user" href="/users/3326275/pratik-c-joshi" title="7,872 reputation">Pratik C Joshi</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Whatever you do end up using, make sure that you check your input hasn't already been mangled by <code>magic_quotes</code> or some other well-meaning rubbish, and if necessary, run it through <code>stripslashes</code> or whatever to sanitise it.</p>
</div></text><author><a href="/users/3542/rob">Rob</a></author><comments><comment><text><span class="comment-copy">Indeed; running with magic_quotes switched on just encourages poor practice. However, sometimes you can't always control the environment to that level - either you don't have access to manage the server, or your application has to coexist with applications that (shudder) depend on such configuration. For these reasons, it's good to write portable applications - though obviously the effort is wasted if you do control the deployment environment, e.g. because it's an in-house application, or only going to be used in your specific environment.</span></text><author><a class="comment-user" href="/users/3542/rob" title="40,156 reputation">Rob</a></author></comment><comment><text><span class="comment-copy">As of PHP 5.4, the abomination known as 'magic quotes' has been <a href="http://php.net/manual/en/security.magicquotes.php" rel="nofollow noreferrer">killed dead</a>. And good riddance to bad rubbish.</span></text><author><a class="comment-user" href="/users/41688/bryanh" title="3,640 reputation">BryanH</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Parameterized query AND input validation is the way to go. There is many scenarios under which SQL injection may occur, even though <code>mysql_real_escape_string()</code> has been used.</p>
<p>Those examples are vulnerable to SQL injection:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$offset </span><span class="pun">=</span><span class="pln"> isset</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="str">'o'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> $_GET</span><span class="pun">[</span><span class="str">'o'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
$offset </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$offset</span><span class="pun">);</span><span class="pln">
</span><span class="typ">RunQuery</span><span class="pun">(</span><span class="str">"SELECT userid, username FROM sql_injection_test LIMIT $offset, 10"</span><span class="pun">);</span></code></pre>
<p>or</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$order </span><span class="pun">=</span><span class="pln"> isset</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="str">'o'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> $_GET</span><span class="pun">[</span><span class="str">'o'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">'userid'</span><span class="pun">;</span><span class="pln">
$order </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$order</span><span class="pun">);</span><span class="pln">
</span><span class="typ">RunQuery</span><span class="pun">(</span><span class="str">"SELECT userid, username FROM sql_injection_test ORDER BY `$order`"</span><span class="pun">);</span></code></pre>
<p>In both cases, you can't use <code>'</code> to protect the encapsulation.</p>
<p><a href="http://www.webappsec.org/projects/articles/091007.txt">Source</a>: <em>The Unexpected SQL Injection (When Escaping Is Not Enough)</em></p>
</div></text><author><a href="/users/154607/cedric">Cedric</a></author><comments><comment><text><span class="comment-copy">Dont take user inputs where not neccessary. sanitize and filter user inputs before using it for database querying. Use the whitelist approach it easier to create white list rather than blacklist read about it here. <a href="https://www.schneier.com/blog/archives/2011/01/whitelisting_vs.html" rel="nofollow noreferrer">schneier.com/blog/archives/2011/01/whitelisting_vs.html</a></span></text><author><a class="comment-user" href="/users/5228630/danyal-fayyaz" title="49 reputation">Danyal Fayyaz</a></author></comment><comment><text><span class="comment-copy">You can prevent SQL injection if you adopt an input validation technique in which user input is authenticated against a set of defined rules for length, type and syntax and also against business rules.</span></text><author><a class="comment-user" href="/users/5324723/josip-ivic" title="2,471 reputation">Josip Ivic</a></author></comment><comment><text><span class="comment-copy">a moment of silence for tones of deleted tables around the globe for using this example : D</span></text><author><a class="comment-user" href="/users/1503846/biohazard" title="899 reputation">BIOHAZARD</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application's architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it's just a matter of time until you forget to correctly format your query at some point in your code.</p>
<p>Adopting the MVC pattern and a framework like <a href="http://cakephp.org/" rel="noreferrer">CakePHP</a> or <a href="http://codeigniter.com/" rel="noreferrer">CodeIgniter</a> is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries. </p>
</div></text><author><a href="/users/171933/johannes-fahrenkrug">Johannes Fahrenkrug</a></author><comments><comment><text><span class="comment-copy">I think your first paragraph is important. Understanding is key. Also, everyone is not working for a company. For a large swath of people, frameworks actually go against the idea of <i>understanding</i>. Getting intimate with the fundamentals may not be valued while working under a deadline, but the do-it-yourselfers out there enjoy getting their hands dirty. Framework developers are not so privileged that everyone else must bow and assume they never make mistakes. The power to make decisions is still important. Who is to say that my framework won't displace some other scheme in the future?</span></text><author><a class="comment-user" href="/users/2495645/anthony-rutledge" title="1,834 reputation">Anthony Rutledge</a></author></comment><comment><text><span class="comment-copy">@AnthonyRutledge You are absolutely correct. It is very important to <i>understand</i> what is going on and why. However, the chance that a true-and-tried and actively used and developed framework has run into and solved a lot of issues and patched a lot of security holes already is pretty high. It's a good idea to look at the source to get a feel for the code quality. If it's an untested mess it's probably not secure.</span></text><author><a class="comment-user" href="/users/171933/johannes-fahrenkrug" title="25,335 reputation">Johannes Fahrenkrug</a></author></comment><comment><text><span class="comment-copy">Here. Here. Good points. However, would you agree that many people can study and learn to adopt an MVC system, but not everyone can reproduce it by hand (controllers and server). One can go too far with this point. Do I need to understand my microwave before I heat up my peanut butter pecan cookies my girl friend made me?  ;-)</span></text><author><a class="comment-user" href="/users/2495645/anthony-rutledge" title="1,834 reputation">Anthony Rutledge</a></author></comment><comment><text><span class="comment-copy">@AnthonyRutledge I agree! I think the use-case makes a difference too: Am I building a photo gallery for my personal homepage or am I building an online banking web application? In the latter case it's very important to understand the details of security and how a framework that I am using is addressing those.</span></text><author><a class="comment-user" href="/users/171933/johannes-fahrenkrug" title="25,335 reputation">Johannes Fahrenkrug</a></author></comment><comment><text><span class="comment-copy">Ah, the security exception to the do it yourself corollary. See, I tend to be willing to risk it all and go for broke. :-) Kidding. With enough time, people can learn to make a pretty darn secure application. Too many people are in a rush. They throw their hands up and assume that the frameworks are <i>safer</i>. After all, they do not have enough time to test and figure things out. Moreover, security is a field that requires dedicated study. It is not something mere programmers know in depth by virtue of understanding algorithms and design patterns.</span></text><author><a class="comment-user" href="/users/2495645/anthony-rutledge" title="1,834 reputation">Anthony Rutledge</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course <strong>PDO is one of the good solution.</strong> But I would like to suggest you some good links prevention from SQL Injection.</p>
<p><a href="http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php">What is SQL injection and how to prevent</a></p>
<p><a href="http://php.net/manual/en/security.database.sql-injection.php">PHP manual for SQL injection</a></p>
<p><a href="http://blogs.msdn.com/b/brian_swan/archive/2010/03/04/what_2700_s-the-right-way-to-avoid-sql-injection-in-php-scripts_3f00_.aspx">Microsoft explanation of SQL injection and prevention in PHP</a></p>
<p>and some other like <a href="http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/">Preventing SQL injection with MySQL and PHP</a></p>
<p>Now, <strong>why you do you need to prevent your query from SQL injection?</strong></p>
<p>I would like to let you know: Why do we try for preventing SQL injection with a short example below:</p>
<p>Query for login authentication match:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$query</span><span class="pun">=</span><span class="str">"select * from users where email='"</span><span class="pun">.</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'email'</span><span class="pun">].</span><span class="str">"' and password='"</span><span class="pun">.</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'password'</span><span class="pun">].</span><span class="str">"' "</span><span class="pun">;</span></code></pre>
<p>Now, if someone (a hacker) puts</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'email'</span><span class="pun">]=</span><span class="pln"> admin@emali</span><span class="pun">.</span><span class="pln">com</span><span class="str">' OR '</span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span></code></pre>
<p>and password anything....</p>
<p>The query will be parsed in the system only upto:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$query</span><span class="pun">=</span><span class="str">"select * from users where email='admin@emali.com' OR '1=1';</span></code></pre>
<p>The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to login as admin without having his password. Now, he can do anything what admin/email person can do. See, it's very dangerous if SQL injection is not prevented.</p>
</div></text><author><a href="/users/1133932/manish-shrivastava">Manish Shrivastava</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I favor <a href="http://en.wikipedia.org/wiki/Stored_procedure" rel="noreferrer">stored procedures</a> (<a href="http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html" rel="noreferrer">MySQL has had stored procedures support since 5.0</a>) from a security point of view - the advantages are -</p>
<ol>
<li>Most databases (including <a href="http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html" rel="noreferrer">MySQL</a>) enable user access to be restricted to executing stored procedures. The fine grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.</li>
<li>They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.</li>
<li>They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.</li>
</ol>
<p>The disadvantages are -</p>
<ol>
<li>They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.</li>
<li>They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.</li>
</ol>
</div></text><author><a href="/users/14944/nikhil">Nikhil</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I think if someone wants to use PHP and MySQL or some other dataBase server:</p>
<ol>
<li>Think about learning <a href="http://php.net/manual/en/book.pdo.php">PDO</a> (PHP Data Objects) – it is a database access layer providing a uniform method of access to multiple databases.</li>
<li>Think about learning <a href="http://en.wikipedia.org/wiki/MySQLi">MySQLi</a></li>
<li>Use native PHP functions like: <a href="http://php.net/manual/en/function.strip-tags.php">strip_tags</a>, <a href="http://php.net/manual/en/function.mysql-real-escape-string.php">mysql_real_escape_string</a> or if variable numeric, just <code>(int)$foo</code>. Read more about type of variables in PHP <a href="http://php.net/manual/en/language.types.php">here</a>. If you're using libraries such as PDO or MySQLi, always use <a href="http://php.net/manual/en/pdo.quote.php">PDO::quote()</a> and <a href="http://php.net/manual/en/mysqli.real-escape-string.php">mysqli_real_escape_string()</a>.</li>
</ol>
<hr/>
<p><strong>Libraries examples:</strong></p>
<p>---- <strong>PDO</strong></p>
<blockquote>
<p>----- No placeholders - ripe for SQL injection! <strong>It's bad</strong></p>
</blockquote>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$request </span><span class="pun">=</span><span class="pln"> $pdoConnection</span><span class="pun">-&gt;(</span><span class="str">"INSERT INTO parents (name, addr, city) values ($name, $addr, $city)"</span><span class="pun">);</span></code></pre>
<blockquote>
<p>----- Unnamed placeholders</p>
</blockquote>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$request </span><span class="pun">=</span><span class="pln"> $pdoConnection</span><span class="pun">-&gt;(</span><span class="str">"INSERT INTO parents (name, addr, city) values (?, ?, ?);</span></code></pre>
<blockquote>
<p>----- Named placeholders</p>
</blockquote>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$request </span><span class="pun">=</span><span class="pln"> $pdoConnection</span><span class="pun">-&gt;(</span><span class="str">"INSERT INTO parents (name, addr, city) value (:name, :addr, :city)"</span><span class="pun">);</span></code></pre>
<p>--- <strong>MySQLi</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$request </span><span class="pun">=</span><span class="pln"> $mysqliConnection</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">'
       SELECT * FROM trainers
       WHERE name = ?
       AND email = ?
       AND last_login &gt; ?'</span><span class="pun">);</span><span class="pln">

    $query</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">'first_param'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'second_param'</span><span class="pun">,</span><span class="pln"> $mail</span><span class="pun">,</span><span class="pln"> time</span><span class="pun">()</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">3600</span><span class="pun">);</span><span class="pln">
    $query</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<hr/>
<p><strong>P.S</strong>:</p>
<p>PDO wins this battle with ease. With support for twelve
different database drivers and named parameters, we can ignore the
small performance loss, and get used to its API. From a security
standpoint, both of them are safe as long as the developer uses them
the way they are supposed to be used</p>
<p>But while both PDO and MySQLi are quite fast, MySQLi performs
insignificantly faster in benchmarks – ~2.5% for non-prepared
statements, and ~6.5% for prepared ones.</p>
<p><strong>And please test every query to your database - it's a better way to prevent injection.</strong></p>
</div></text><author><a href="/users/1032750/imrch">imRcH</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Type cast if possible your parameters. But it's only working on simple types like int, bool and float.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$unsafe_variable </span><span class="pun">=</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">'user_id'</span><span class="pun">];</span><span class="pln">

$safe_variable </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln">$unsafe_variable </span><span class="pun">;</span><span class="pln">

mysql_query</span><span class="pun">(</span><span class="str">"INSERT INTO table (column) VALUES ('"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $safe_variable </span><span class="pun">.</span><span class="pln"> </span><span class="str">"')"</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/842330/devop">devOp</a></author><comments><comment><text><span class="comment-copy">This is one of the few cases where I would use an "escaped value" instead of a prepared statement.  And integer type conversion is extremely efficient.</span></text><author><a class="comment-user" href="/users/2430549/holdoffhunger" title="1,127 reputation">HoldOffHunger</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you want to take advantage of cache engines, like <a href="http://en.wikipedia.org/wiki/Redis_%28data_store%29">Redis</a> or <a href="http://en.wikipedia.org/wiki/Memcached">Memcached</a>, maybe DALMP could be a choice. It uses pure <a href="http://en.wikipedia.org/wiki/MySQLi">MySQLi</a>. Check this: <a href="http://dalmp.readthedocs.org/en/latest/database/PExecute.html">DALMP Database Abstraction Layer for MySQL using PHP.</a> </p>
<p>Also you can 'prepare' your arguments before preparing your query so that you can build dynamic queries and at the end have a full prepared statements query. <a href="http://dalmp.readthedocs.org/en/latest/database/Prepare.html">DALMP Database Abstraction Layer for MySQL using PHP.</a> </p>
</div></text><author><a href="/users/1135424/nbari">nbari</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>For those unsure of how to use PDO (coming from the <code>mysql_</code> functions), I made a <a href="https://github.com/Xeoncross/DByte/blob/master/DB.php">very, very simple PDO wrapper</a> that is a single file. It exists to show how easy it is to do all the common things applications need done. Works with PostgreSQL, MySQL, and SQLite.</p>
<p>Basically, read it <a href="http://php.net/pdo">while you read the manual</a> to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format <strong>you</strong> want.</p>
<blockquote>
<p><strong>I want a single column</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$count </span><span class="pun">=</span><span class="pln"> DB</span><span class="pun">::</span><span class="pln">column</span><span class="pun">(</span><span class="str">'SELECT COUNT(*) FROM `user`);</span></code></pre>
<p><strong>I want an array(key =&gt; value) results (i.e. for making a selectbox)</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$pairs </span><span class="pun">=</span><span class="pln"> DB</span><span class="pun">::</span><span class="pln">pairs</span><span class="pun">(</span><span class="str">'SELECT `id`, `username` FROM `user`);</span></code></pre>
<p><strong>I want a single row result</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$user </span><span class="pun">=</span><span class="pln"> DB</span><span class="pun">::</span><span class="pln">row</span><span class="pun">(</span><span class="str">'SELECT * FROM `user` WHERE `id` = ?'</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">$user_id</span><span class="pun">));</span></code></pre>
<p><strong>I want an array of results</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$banned_users </span><span class="pun">=</span><span class="pln"> DB</span><span class="pun">::</span><span class="pln">fetch</span><span class="pun">(</span><span class="str">'SELECT * FROM `user` WHERE `banned` = ?'</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">TRUE</span><span class="pun">));</span></code></pre>
</blockquote>
</div></text><author><a href="/users/99923/xeoncross">Xeoncross</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Using this PHP function <code>mysql_escape_string()</code> you can get a good prevention in a fast way.</p>
<p>For example: </p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT </span><span class="pun">*</span><span class="pln"> FROM users WHERE name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'".mysql_escape_string($name_from_html_form)."'</span></code></pre>
<p><code>mysql_escape_string</code> — Escapes a string for use in a mysql_query</p>
<p>For more prevention you can add at the end ... </p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">wHERE </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span><span class="pln">   </span><span class="kwd">or</span><span class="pln">  LIMIT </span><span class="lit">1</span></code></pre>
<p>Finally you get:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT </span><span class="pun">*</span><span class="pln"> FROM users WHERE name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'".mysql_escape_string($name_from_html_form)."'</span><span class="pln"> LIMIT </span><span class="lit">1</span></code></pre>
</div></text><author><a href="/users/1720432/nicolas-finelli">Nicolas Finelli</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>A few guidelines for escaping special characters in SQL statements.</p>
<p>Don't use <a href="http://www.php.net/manual/en/intro.mysql.php">MySQL</a>, this extension is deprecated, use <a href="http://php.net/manual/en/book.mysqli.php">MySQLi</a> or <a href="http://php.net/manual/en/book.pdo.php">PDO</a>.</p>
<p><strong>MySQLi</strong></p>
<p>For manually escaping special characters in a string you can use the <a href="http://www.php.net/manual/en/mysqli.real-escape-string.php">mysqli_real_escape_string</a> function. The function will not work properly unless the correct character set is set with <a href="http://www.php.net/manual/en/mysqli.set-charset.php">mysqli_set_charset</a>.</p>
<p>Example:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$mysqli </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> mysqli</span><span class="pun">(</span><span class="pln"> </span><span class="str">'host'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'user'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'password'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'database'</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
$mysqli</span><span class="pun">-&gt;</span><span class="pln">set_charset</span><span class="pun">(</span><span class="pln"> </span><span class="str">'charset'</span><span class="pun">);</span><span class="pln">

$string </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">real_escape_string</span><span class="pun">(</span><span class="pln"> $string </span><span class="pun">);</span><span class="pln">
$mysqli</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="pln"> </span><span class="str">"INSERT INTO table (column) VALUES ('$string')"</span><span class="pln"> </span><span class="pun">);</span></code></pre>
<p>For automatic escaping of values with prepared statements, use <a href="http://www.php.net/manual/en/mysqli.prepare.php">mysqli_prepare</a>, and <a href="http://www.php.net/manual/en/mysqli-stmt.bind-param.php">mysqli_stmt_bind_param</a> where types for the corresponding bind variables must be provided for an appropriate conversion:</p>
<p>Example:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="pln"> </span><span class="str">"INSERT INTO table ( column1, column2 ) VALUES (?,?)"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">

$stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="pln"> </span><span class="str">"is"</span><span class="pun">,</span><span class="pln"> $integer</span><span class="pun">,</span><span class="pln"> $string </span><span class="pun">);</span><span class="pln">

$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<p>No matter if you use prepared statements or mysqli_real_escape_string, you always have to know the type of input data you're working with.</p>
<p>So if you use a prepared statement, you must specify the types of the variables for mysqli_stmt_bind_param function.</p>
<p>And use of mysqli_real_escape_string is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. mysqli_real_escape_string is a useful function when used properly, especially when combined with sprintf.</p>
<p>Example:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$string </span><span class="pun">=</span><span class="pln"> </span><span class="str">"x' OR name LIKE '%John%"</span><span class="pun">;</span><span class="pln">
$integer </span><span class="pun">=</span><span class="pln"> </span><span class="str">'5 OR id != 0'</span><span class="pun">;</span><span class="pln">

$query </span><span class="pun">=</span><span class="pln"> sprintf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"SELECT id, email, pass, name FROM members WHERE email ='%s' AND id = %d"</span><span class="pun">,</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">real_escape_string</span><span class="pun">(</span><span class="pln"> $string </span><span class="pun">),</span><span class="pln"> $integer </span><span class="pun">);</span><span class="pln">

echo $query</span><span class="pun">;</span><span class="pln">
</span><span class="com">// SELECT id, email, pass, name FROM members WHERE email ='x\' OR name LIKE \'%John%' AND id = 5</span><span class="pln">

$integer </span><span class="pun">=</span><span class="pln"> </span><span class="str">'99999999999999999999'</span><span class="pun">;</span><span class="pln">
$query </span><span class="pun">=</span><span class="pln"> sprintf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"SELECT id, email, pass, name FROM members WHERE email ='%s' AND id = %d"</span><span class="pun">,</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">real_escape_string</span><span class="pun">(</span><span class="pln"> $string </span><span class="pun">),</span><span class="pln"> $integer </span><span class="pun">);</span><span class="pln">

echo $query</span><span class="pun">;</span><span class="pln">
</span><span class="com">// SELECT id, email, pass, name FROM members WHERE email ='x\' OR name LIKE \'%John%' AND id = 2147483647</span></code></pre>
</div></text><author><a href="/users/2352773">Danijel</a></author><comments><comment><text><span class="comment-copy">The question is very generic. Some great answers above, but most suggest prepared statements. MySQLi async does not support prepared statements, so the sprintf looks like a great option for this situation.</span></text><author><a class="comment-user" href="/users/433327/dustin-graham" title="1,478 reputation">Dustin Graham</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I use three different ways to prevent my web application from being vulnerable to SQL injection.</p>
<ol>
<li>Use of <code>mysql_real_escape_string()</code>, which is a pre-defined function in <a href="http://en.wikipedia.org/wiki/PHP" rel="noreferrer">PHP</a>, and this code add backslashes to the following characters: <code>\x00</code>, <code>\n</code>, <code>\r</code>, <code>\</code>, <code>'</code>, <code>"</code> and <code>\x1a</code>. Pass the input values as parameters to minimize the chance of SQL injection.</li>
<li>The most advanced way is to use PDOs.</li>
</ol>
<p>I hope this will help you.</p>
<p>Consider the following query:</p>
<p><code>$iId = mysql_real_escape_string("1 OR 1=1");
 $sSql = "SELECT * FROM table WHERE id = $iId";</code></p>
<p>mysql_real_escape_string() will not protect here. If you use single quotes (' ') around your variables inside your query is what protects you against this. Here is an solution below for this:</p>
<p><code>$iId = (int) mysql_real_escape_string("1 OR 1=1");
 $sSql = "SELECT * FROM table WHERE id = $iId";</code></p>
<p>This <a href="http://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string">question</a> has some good answers about this.</p>
<p>I suggest, using PDO is the best option.</p>
<p><strong>Edit:</strong></p>
<p><code>mysql_real_escape_string()</code> is deprecated as of PHP 5.5.0. Use either mysqli or PDO.</p>
<p>An alternative to mysql_real_escape_string() is </p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">string</span><span class="pln"> mysqli_real_escape_string </span><span class="pun">(</span><span class="pln"> mysqli $link </span><span class="pun">,</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> $escapestr </span><span class="pun">)</span></code></pre>
<p><strong>Example:</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$iId </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">real_escape_string</span><span class="pun">(</span><span class="str">"1 OR 1=1"</span><span class="pun">);</span><span class="pln">
$mysqli</span><span class="pun">-&gt;</span><span class="pln">query</span><span class="pun">(</span><span class="str">"SELECT * FROM table WHERE id = $iId"</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/1019484/soumalya-banerjee">Soumalya Banerjee</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.
For example: if you are using mysql database. then enter into the database through terminal or the ui provided and just follow this command:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> GRANT SELECT</span><span class="pun">,</span><span class="pln"> INSERT</span><span class="pun">,</span><span class="pln"> DELETE ON database TO username@</span><span class="str">'localhost'</span><span class="pln"> IDENTIFIED BY </span><span class="str">'password'</span><span class="pun">;</span></code></pre>
<p>This will restrict the user to only get confined with the specified query's only. Remove the delete permission and so the data would never get deleted from the query fired from the php page.
The second thing to do is to flush the privileges so that the mysql refreshes the permissions and updates.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">FLUSH PRIVILEGES</span><span class="pun">;</span><span class="pln"> </span></code></pre>
<p>more information about <a href="http://www.itechp2pexchange.com/content/mysql-flush-privileges-statement">flush</a>.</p>
<p>To see the current privileges for the user fire the following query.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">select</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> mysql</span><span class="pun">.</span><span class="pln">user </span><span class="kwd">where</span><span class="pln"> </span><span class="typ">User</span><span class="pun">=</span><span class="str">'username'</span><span class="pun">;</span></code></pre>
<p>Learn more about <a href="http://kb.mediatemple.net/questions/788/HOWTO:+GRANT+privileges+in+MySQL#dv">GRANT</a>.</p>
</div></text><author><a href="/users/1266952/apurv-nerlekar">Apurv Nerlekar</a></author><comments><comment><text><span class="comment-copy">This answer is <b>essentially wrong</b>, as it doesn't help to prevent an injection prevention but just trying to soften the consequences. In vain.</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy">Right, it doesn't provide a solution, but is what you can do before hand to avoid things.</span></text><author><a class="comment-user" href="/users/1266952/apurv-nerlekar" title="1,863 reputation">Apurv Nerlekar</a></author></comment><comment><text><span class="comment-copy">@Apurv you are talking nonsense. If my goal is to read private information from your database, then not having the DELETE permission means nothing.</span></text><author><a class="comment-user" href="/users/519924/alex-holsgrove" title="923 reputation">Alex Holsgrove</a></author></comment><comment><text><span class="comment-copy">@AlexHolsgrove: Take it easy, I was just suggesting good practices for softening the consequences.</span></text><author><a class="comment-user" href="/users/1266952/apurv-nerlekar" title="1,863 reputation">Apurv Nerlekar</a></author></comment><comment><text><span class="comment-copy">@Apurv You don't want to "soften consequences", you want to do everything possible to protect against it. To be fair though, setting the correct user access is important, but not really what the OP is asking for.</span></text><author><a class="comment-user" href="/users/519924/alex-holsgrove" title="923 reputation">Alex Holsgrove</a></author></comment><comment><text><span class="comment-copy">User1: insert, update, User2: Selects, User3: Delete. Complicated to maintain and may have performance impact having three users connecting but would definitely lock down what can be done in a given situation. User 1 cant delete or read, but adding a column "remove" you can update it where you need something deleting, Do deletes from a cron job using User3 checking for your flag. Point im making, if an insert/update is made sensitive info cant be pulled, if a select is made a delete or write/update can't be made etc. Doesnt eliminate all issues but should help?</span></text><author><a class="comment-user" href="/users/2154871/chris" title="621 reputation">Chris</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Regarding to many useful answers, I hope to add some values to this thread.
SQL injection is type of attack that can be done through user inputs (Inputs that filled by user and then used inside queries), The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, we assume that there might be bad person that try to get secret information (by passing access control) that affect the three principles of security (Confidentiality, Integrity, Availability). </p>
<p>Now, our point is to prevent security threats such as SQL injection attacks, the question asking (How to prevent SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? how you secure your application?</p>
<p>My approach against SQL injection is: clearing user-input data before sending it to database (before using it inside any query).</p>
<p><strong>Data filtering for (Converting unsafe data to safe data)</strong>
Consider that <a href="http://en.wikipedia.org/wiki/PHP#History">PDO</a> and <a href="http://en.wikipedia.org/wiki/MySQLi">MySQLi</a> not available, how can you secure your application? do you force me to use them? what about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border not just for specific language.</p>
<ol>
<li>SQL user (limiting user privilege): most common SQL operations are (SELECT, UPDATE, INSERT), then, why giving UPDATE privilege to a user that not require it? for example: <strong>login, and search pages</strong> are only using SELECT, then, why using db users in these pages with high privileges? 
<strong>RULE: do not create one database user for all privileges, for all SQL operations, you can create your scheme like (deluser, selectuser, updateuser) as usernames for easy usage.</strong></li>
</ol>
<p>see <a href="http://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of least privilege</a></p>
<ol>
<li><p>Data filtering: before building any query user input should be validated and filtered, for programmers, it's important to define some properties for each user-input variables:
<strong>data type, data pattern, and data length</strong>. a field that is a number between (x and y) must be exactly validated using exact rule, for a field that is a string (text): pattern is the case, for example: username must contain only some characters lets say [a-zA-Z0-9_-.] the length vary between (x and n) where x and n (integers, x &lt;=n ).
<strong>Rule: creating exact filters and validation rules are best practice for me.</strong> </p></li>
<li><p>Use other tools: Here, I will also agree with you that prepared statement (parametrized query) and Stored procedures, the disadvantages here is these ways requires advanced skills which are not exist in most users, the basic idea here is to distinguish between SQL query and the data that being used inside, both approach can be used even with unsafe data, because the user-input data here not add anything to the original query such as (any or x=x).
for more information please read <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">OWASP SQL Injection Prevention Cheat Sheet</a>.</p></li>
</ol>
<p>Now, if you are an advanced user, start using these defense as you like, but, for beginners, if they can't quickly implement stored procedure and prepared statement, it's better to filter input data as much they can.</p>
<p>Finally, let's consider that user sends this text below instead of entering his  username:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> UNION SELECT IF</span><span class="pun">(</span><span class="pln">SUBSTRING</span><span class="pun">(</span><span class="typ">Password</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">)=</span><span class="str">'2'</span><span class="pun">,</span><span class="pln">BENCHMARK</span><span class="pun">(</span><span class="lit">100000</span><span class="pun">,</span><span class="pln">SHA1</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)),</span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="typ">User</span><span class="pun">,</span><span class="typ">Password</span><span class="pln"> FROM mysql</span><span class="pun">.</span><span class="pln">user WHERE </span><span class="typ">User</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'root'</span></code></pre>
<p>This input can be checked early without any prepared statement and stored procedures, but to be on safe side, using them starts after user-data filtering and validation.</p>
<p>Last point is detecting unexpected behavior which requires more effort and complexity, it's not recommended for normal web applications.
Unexpected behavior in above user input is: SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, root once these words detected, you can avoid the input.</p>
<h2>UPDATE1:</h2>
<p>A user commented that this post is useless, OK! Here is what <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3%3a_Escaping_All_User_Supplied_Input">OWASP.ORG</a> provided:</p>
<blockquote>
<p>Primary defenses: <br/>
<br/>
      Option #1: Use of Prepared Statements (Parameterized Queries) <br/>
      Option #2: Use of Stored Procedures <br/>
      Option #3: Escaping all User Supplied Input  <br/>
<br/>
  Additional defenses: <br/>
<br/>
      Also Enforce: Least Privilege <br/>
      Also Perform: White List Input Validation <br/></p>
</blockquote>
<p>As you may knew, claiming on any article should be supported by valid argument, at least one reference! Otherwise it's considered as attack and bad claim!</p>
<h2>Update2:</h2>
<p>From the PHP manual, <a href="http://php.net/manual/en/mysqli.quickstart.prepared-statements.php">PHP: Prepared Statements - Manual</a>:</p>
<blockquote>
<p>Escaping and SQL injection <br/></p>
<p>Bound variables will be escaped automatically by the server. The
  server inserts their escaped values at the appropriate places into the
  statement template before execution. A hint must be provided to the
  server for the type of bound variable, to create an appropriate
  conversion. See the mysqli_stmt_bind_param() function for more
  information. <br/></p>
<p>The automatic escaping of values within the server is sometimes
  considered a security feature to prevent SQL injection. The same
  degree of security can be achieved with non-prepared statements, if
  input values are escaped correctly. <br/></p>
</blockquote>
<h2>Update3:</h2>
<p>I created test cases for knowing how PDO and MySQLi sends the query to MySQL server when using prepared statement:</p>
<p><strong>PDO:</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$user </span><span class="pun">=</span><span class="pln"> </span><span class="str">"''1''"</span><span class="pun">;</span><span class="pln"> </span><span class="com">//Malicious keyword</span><span class="pln">
$sql </span><span class="pun">=</span><span class="pln"> </span><span class="str">'SELECT * FROM awa_user WHERE userame =:username'</span><span class="pun">;</span><span class="pln">
$sth </span><span class="pun">=</span><span class="pln"> $dbh</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="pln">$sql</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">ATTR_CURSOR </span><span class="pun">=&gt;</span><span class="pln"> PDO</span><span class="pun">::</span><span class="pln">CURSOR_FWDONLY</span><span class="pun">));</span><span class="pln">
$sth</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">(</span><span class="pln">array</span><span class="pun">(</span><span class="str">':username'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $user</span><span class="pun">));</span></code></pre>
<p><strong>Query Log:</strong></p>
<blockquote>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="lit">189</span><span class="pln"> </span><span class="typ">Query</span><span class="pln"> SELECT </span><span class="pun">*</span><span class="pln"> FROM awa_user WHERE userame </span><span class="pun">=</span><span class="str">'\'\'1\'\''</span><span class="pln">
    </span><span class="lit">189</span><span class="pln"> </span><span class="typ">Quit</span></code></pre>
</blockquote>
<p><strong>MySQLi:</strong></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$stmt </span><span class="pun">=</span><span class="pln"> $mysqli</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"SELECT * FROM awa_user WHERE username =?"</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bind_param</span><span class="pun">(</span><span class="str">"s"</span><span class="pun">,</span><span class="pln"> $user</span><span class="pun">);</span><span class="pln">
$user </span><span class="pun">=</span><span class="pln"> </span><span class="str">"''1''"</span><span class="pun">;</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<p><strong>Query Log:</strong></p>
<blockquote>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="lit">188</span><span class="pln"> </span><span class="typ">Prepare</span><span class="pln">   SELECT </span><span class="pun">*</span><span class="pln"> FROM awa_user WHERE username </span><span class="pun">=?</span><span class="pln">
    </span><span class="lit">188</span><span class="pln"> </span><span class="typ">Execute</span><span class="pln">   SELECT </span><span class="pun">*</span><span class="pln"> FROM awa_user WHERE username </span><span class="pun">=</span><span class="str">'\'\'1\'\''</span><span class="pln">
    </span><span class="lit">188</span><span class="pln"> </span><span class="typ">Quit</span></code></pre>
</blockquote>
<h3>It's clear that a prepared statement is also escaping the data, nothing else.</h3>
<p>As also mentioned in above statement <code>The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly</code>, therefore, this proves that data validation such as <code>intval()</code> is a good idea for integer values before sending any query, in addition, preventing malicious user data before sending the query is <strong>correct and valid approach</strong>.</p>
<p>Please see this question for more detail: <a href="http://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the">PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same result</a></p>
<p>References:</p>
<ol>
<li><a href="http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/#UnionInjections">SQL Injection Cheat Sheet</a></li>
<li><a href="https://www.owasp.org/index.php/SQL_Injection">SQL Injection</a></li>
<li><a href="http://en.wikipedia.org/wiki/Information_security">Information security</a></li>
<li><a href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/security-principles.html">Security Principles</a></li>
<li><a href="http://en.wikipedia.org/wiki/Data_validation">Data validation</a></li>
</ol>
</div></text><author><a href="/posts/14569797/revisions" id="history-14569797" title="show revision history for this post">
        11 revs, 4 users 73%<br/>user1646111
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>A simple way would be to use a PHP framework like <a href="http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter" rel="noreferrer">CodeIgniter</a> or <a href="https://laravel.com/" rel="noreferrer">Laravel</a> which have in-built features like filtering and active-record, so that you don't have to worry about these nuances.</p>
</div></text><author><a href="/users/849829">Deepak Thomas</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are so many answers for <strong>PHP and MySQL</strong>, but here is code for <strong>PHP and Oracle</strong> for preventing SQL injection as well as regular use of oci8 drivers:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$conn </span><span class="pun">=</span><span class="pln"> oci_connect</span><span class="pun">(</span><span class="pln">$username</span><span class="pun">,</span><span class="pln"> $password</span><span class="pun">,</span><span class="pln"> $connection_string</span><span class="pun">);</span><span class="pln">
$stmt </span><span class="pun">=</span><span class="pln"> oci_parse</span><span class="pun">(</span><span class="pln">$conn</span><span class="pun">,</span><span class="pln"> </span><span class="str">'UPDATE table SET field = :xx WHERE ID = 123'</span><span class="pun">);</span><span class="pln">
oci_bind_by_name</span><span class="pun">(</span><span class="pln">$stmt</span><span class="pun">,</span><span class="pln"> </span><span class="str">':xx'</span><span class="pun">,</span><span class="pln"> $fieldval</span><span class="pun">);</span><span class="pln">
oci_execute</span><span class="pun">(</span><span class="pln">$stmt</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/2125924">Chintan Gor</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Warning : the approach described in this answer only applies for very specific scenarios and isn't secure since SQL injection attacks do not only rely on being able to inject <code>X=Y</code>.</strong></p>
<p>If the attackers are trying to hack with the form via PHP's <code>$_GET</code> variable or with the URL's query string, you would be able to catch them if they're not secure.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="typ">RewriteCond</span><span class="pln"> </span><span class="pun">%{</span><span class="pln">QUERY_STRING</span><span class="pun">}</span><span class="pln"> </span><span class="pun">([</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9</span><span class="pun">]+)=([</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9</span><span class="pun">]+)</span><span class="pln">
</span><span class="typ">RewriteRule</span><span class="pln"> </span><span class="pun">^(.*)</span><span class="pln"> </span><span class="pun">^/</span><span class="pln">track</span><span class="pun">.</span><span class="pln">php</span></code></pre>
<p>Because <code>1=1</code>, <code>2=2</code>, <code>1=2</code>, <code>2=1</code>, <code>1+1=2</code>, etc... are the common questions to an SQL database of an attacker. Maybe also it's used by many hacking applications.</p>
<p>But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect <i>(it depends on you)</i> that hacking-specific dynamic query string into a page that will store the attacker's <a href="http://en.wikipedia.org/wiki/IP_address" rel="noreferrer">IP address</a>, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.</p>
</div></text><author><a href="/users/2007055">Servant</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Using <a href="http://in3.php.net/pdo">PDO</a> and <a href="http://in3.php.net/mysqli">MYSQLi</a> is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to use</p>
<p><a href="http://php.net/manual/en/function.mysql-real-escape-string.php">mysql_real_escape_string</a></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$unsafe_variable </span><span class="pun">=</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'user_input'</span><span class="pun">]);</span></code></pre>
<p>There are more ability to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also it would be better to use these functions to check input data.</p>
<p><a href="http://in3.php.net/is_string">is_string</a></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$unsafe_variable </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">is_string</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'user_input'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">'user_input'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">);</span></code></pre>
<p><a href="http://in3.php.net/manual/en/function.is-numeric.php">is_numeric</a></p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$unsafe_variable </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">is_numeric</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'user_input'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">'user_input'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">);</span></code></pre>
<p>And it is so much better to use those functions to check input data with <code>mysql_real_escape_string</code>.</p>
</div></text><author><a href="/users/878888">Rakesh Sharma</a></author><comments><comment><text><span class="comment-copy">Also, there is absolutely no point in checking $_POST array members with is_string()</span></text><author><a class="comment-user" href="/users/285587/your-common-sense" title="119,078 reputation">Your Common Sense</a></author></comment><comment><text><span class="comment-copy"><b>WARNING!</b> <code>mysql_real_escape_string()</code> <a href="http://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string">is not infallible</a>.</span></text><author><a class="comment-user" href="/users/623041/eggyal" title="85,444 reputation">eggyal</a></author></comment><comment><text><span class="comment-copy">@YourCommonSense you need to believe so what you want to update</span></text><author><a class="comment-user" href="/users/878888/rakesh-sharma" title="11,714 reputation">Rakesh Sharma</a></author></comment><comment><text><span class="comment-copy"><a href="http://php.net/manual/en/function.mysql-real-escape-string.php" rel="nofollow noreferrer"><code>mysql_real_escape_string</code></a> is now deprecated, so its no longer a viable option. It will be removed from PHP in the future.  Its best to move onto what the PHP or MySQL folks recommend.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">Deprecated mysql_real_escape_string()</span></text><author><a class="comment-user" href="/users/1203732/megan-fox" title="302 reputation">Megan Fox</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A good idea is to use an <strong>'object-relational mapper'</strong> like <a href="http://j4mie.github.io/idiormandparis/" rel="noreferrer">Idiorm</a>:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$user </span><span class="pun">=</span><span class="pln"> ORM</span><span class="pun">::</span><span class="pln">for_table</span><span class="pun">(</span><span class="str">'user'</span><span class="pun">)</span><span class="pln">
</span><span class="pun">-&gt;</span><span class="pln">where_equal</span><span class="pun">(</span><span class="str">'username'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'j4mie'</span><span class="pun">)</span><span class="pln">
</span><span class="pun">-&gt;</span><span class="pln">find_one</span><span class="pun">();</span><span class="pln">

$user</span><span class="pun">-&gt;</span><span class="pln">first_name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Jamie'</span><span class="pun">;</span><span class="pln">
$user</span><span class="pun">-&gt;</span><span class="pln">save</span><span class="pun">();</span><span class="pln">

$tweets </span><span class="pun">=</span><span class="pln"> ORM</span><span class="pun">::</span><span class="pln">for_table</span><span class="pun">(</span><span class="str">'tweet'</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">-&gt;</span><span class="kwd">select</span><span class="pun">(</span><span class="str">'tweet.*'</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">-&gt;</span><span class="pln">join</span><span class="pun">(</span><span class="str">'user'</span><span class="pun">,</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">
        </span><span class="str">'user.id'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'='</span><span class="pun">,</span><span class="pln"> </span><span class="str">'tweet.user_id'</span><span class="pln">
    </span><span class="pun">))</span><span class="pln">
    </span><span class="pun">-&gt;</span><span class="pln">where_equal</span><span class="pun">(</span><span class="str">'user.username'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'j4mie'</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">-&gt;</span><span class="pln">find_many</span><span class="pun">();</span><span class="pln">

</span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$tweets </span><span class="kwd">as</span><span class="pln"> $tweet</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    echo $tweet</span><span class="pun">-&gt;</span><span class="pln">text</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>It not only saves you from SQL injections, but from syntax errors too! Also Supports collections of models with method chaining to filter or apply actions to multiple results at once and mutliple connection.</p>
</div></text><author><a href="/users/205521">Thomas Ahle</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I've written this little function several years ago:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> sqlvprintf</span><span class="pun">(</span><span class="pln">$query</span><span class="pun">,</span><span class="pln"> $args</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">global</span><span class="pln"> $DB_LINK</span><span class="pun">;</span><span class="pln">
    $ctr </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    ensureConnection</span><span class="pun">();</span><span class="pln"> </span><span class="com">// Connect to database if not connected already.</span><span class="pln">
    $values </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$args </span><span class="kwd">as</span><span class="pln"> $value</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">is_string</span><span class="pun">(</span><span class="pln">$value</span><span class="pun">))</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            $value </span><span class="pun">=</span><span class="pln"> </span><span class="str">"'"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> mysqli_real_escape_string</span><span class="pun">(</span><span class="pln">$DB_LINK</span><span class="pun">,</span><span class="pln"> $value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> </span><span class="str">"'"</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">is_null</span><span class="pun">(</span><span class="pln">$value</span><span class="pun">))</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            $value </span><span class="pun">=</span><span class="pln"> </span><span class="str">'NULL'</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">is_int</span><span class="pun">(</span><span class="pln">$value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">is_float</span><span class="pun">(</span><span class="pln">$value</span><span class="pun">))</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">die</span><span class="pun">(</span><span class="str">'Only numeric, string, array and NULL arguments allowed in a query. Argument '</span><span class="pun">.(</span><span class="pln">$ctr</span><span class="pun">+</span><span class="lit">1</span><span class="pun">).</span><span class="str">' is not a basic type, it\'s type is '</span><span class="pun">.</span><span class="pln"> gettype</span><span class="pun">(</span><span class="pln">$value</span><span class="pun">).</span><span class="pln"> </span><span class="str">'.'</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        $values</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> $value</span><span class="pun">;</span><span class="pln">
        $ctr</span><span class="pun">++;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    $query </span><span class="pun">=</span><span class="pln"> preg_replace_callback</span><span class="pun">(</span><span class="pln">
        </span><span class="str">'/{(\\d+)}/'</span><span class="pun">,</span><span class="pln"> 
        </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">$match</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">use</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$values</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isset</span><span class="pun">(</span><span class="pln">$values</span><span class="pun">[</span><span class="pln">$match</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]]))</span><span class="pln">
            </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">return</span><span class="pln"> $values</span><span class="pun">[</span><span class="pln">$match</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]];</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
            </span><span class="kwd">else</span><span class="pln">
            </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">return</span><span class="pln"> $match</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">},</span><span class="pln">
        $query
    </span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $query</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> runEscapedQuery</span><span class="pun">(</span><span class="pln">$preparedQuery </span><span class="com">/*, ...*/</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    $params </span><span class="pun">=</span><span class="pln"> array_slice</span><span class="pun">(</span><span class="pln">func_get_args</span><span class="pun">(),</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    $results </span><span class="pun">=</span><span class="pln"> runQuery</span><span class="pun">(</span><span class="pln">sqlvprintf</span><span class="pun">(</span><span class="pln">$preparedQuery</span><span class="pun">,</span><span class="pln"> $params</span><span class="pun">));</span><span class="pln"> </span><span class="com">// Run query and fetch results.   </span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $results</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>This allows running statements in an one-liner C#-ish String.Format like:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">runEscapedQuery</span><span class="pun">(</span><span class="str">"INSERT INTO Whatever (id, foo, bar) VALUES ({0}, {1}, {2})"</span><span class="pun">,</span><span class="pln"> $numericVar</span><span class="pun">,</span><span class="pln"> $stringVar1</span><span class="pun">,</span><span class="pln"> $stringVar2</span><span class="pun">);</span></code></pre>
<p>It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is invalid syntax.</p>
<p>SECURITY UPDATE: The previous <code>str_replace</code> version allowed injections by adding {#} tokens into user data. This <code>preg_replace_callback</code> version doesn't cause problems if the replacement contains these tokens.</p>
</div></text><author><a href="/users/58805">Calmarius</a></author><comments><comment><text><span class="comment-copy">To prevent sql injection in PHP  1. Always validate input value.  2. Try to use PDO or MySqli instead of MySql.  For more reference you can check this article What is SQL Injection and How to Prevent SQL Injection</span></text><author><a class="comment-user" href="/users/5700401/abhijit-jagtap" title="707 reputation">Abhijit Jagtap</a></author></comment></comments></answer></answers></post>