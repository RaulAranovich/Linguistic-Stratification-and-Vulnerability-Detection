<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Can I protect against SQL Injection by escaping single-quote and surrounding user input with single-quotes? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I realize that parameterized SQL queries is the optimal way to sanitize user input when building queries that contain user input, but I'm wondering what is wrong with taking user input and escaping any single quotes and surrounding the whole string with single quotes.  Here's the code:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">sSanitizedInput </span><span class="pun">=</span><span class="pln"> </span><span class="str">"'"</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> Replace</span><span class="pun">(</span><span class="pln">sInput</span><span class="pun">,</span><span class="pln"> </span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="str">"'"</span></code></pre>
<p>Any single-quote the user enters is replaced with double single-quotes, which eliminates the users ability to end the string, so anything else they may type, such as semicolons, percent signs, etc, will all be part of the string and not actually executed as part of the command.  We are using Microsoft SQL Server 2000, for which I believe the single-quote is the only string delimiter and the only way to escape the string delimiter, so there is no way to execute anything the user types in.</p>
<p>I don't see any way to launch an SQL injection attack against this, but I realize that if this were as bulletproof as it seems to me someone else would have thought of it already and it would be common practice.  My question is this: what's wrong with this code?  Does anybody know a way to get an SQL injection attack past this sanitization technique?  Sample user input that exploits this technique would be very helpful.</p>
<p>Thanks in advance.</p>
<p>UPDATE:</p>
<p>Thanks to everyone for their answers; pretty much all the information I came across in my research showed up on this page somewhere, which is a sign of the intelligence and skill of the people who have taken time out of their busy days to help me out with this question.  </p>
<p>The reason I have not yet accepted any of the answers is that I still don't know of any way to effectively launch a SQL injection attack against this code.  A few people suggested that a backslash would escape one single-quote and leave the other to end the string so that the rest of the string would be executed as part of the SQL command, and I realize that this method would work to inject SQL into a mySQL database, but in MS SQL 2000 the only way (that I've been able to find) to escape a single-quote is with another single-qoute; backslashes won't do it.  And unless there is a way to stop the escaping of the single-quote, none of the rest of the user input will be executed because it will all be taken as one contiguous string.</p>
<p>I understand that there are better ways to sanitize input but I'm really more interested in learning why the method I provided above won't work.  If anyone knows of any specific way to mount a SQL injection attack against this sanitization method I would love to see it.</p>
</div></text><author><a href="/users/22392/patrick">Patrick</a></author><comments><comment><text><span class="comment-copy"><i>I still don't know of any way to effectively launch a SQL injection attack against this code</i> - ahh, hubris, welcome. To which I say, to anyone reading this, the <a href="https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect" rel="nofollow noreferrer">Dunning Kruger Effect</a> is a dangerous trap. Look at the answers below and don't fall into the mindset that you can reinvent the wheel and do better--<i>better!</i>--than everyone who has gone before.</span></text><author><a class="comment-user" href="/users/41688/bryanh" title="3,640 reputation">BryanH</a></author></comment><comment><text><span class="comment-copy">@BryanH Admitting not to understand how the commonly accepted wisdom applies to a specific case and asking for an example about such specific case is not hubris, it's humbleness. Getting annoyed when someone asks for an example of why the commonly accepted wisdom is right on the other hand might come across as arrogant. Reasoning by specific examples is often a great way to investigate and learn. The way the OP went about this doubt was very useful for my understanding of the subject, especially when he explained the answer he found.</span></text><author><a class="comment-user" href="/users/2814308/santibailors" title="784 reputation">SantiBailors</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>First of all, it's just bad practice. Input validation is always necessary, but it's also always iffy.<br/>
Worse yet, blacklist validation is always problematic, it's much better to explicitly and strictly define what values/formats you accept. Admittedly, this is not always possible - but to some extent it must always be done.<br/>
Some research papers on the subject:</p>
<ul>
<li><a href="http://www.imperva.com/docs/WP_SQL_Injection_Protection_LK.pdf" rel="noreferrer">http://www.imperva.com/docs/WP_SQL_Injection_Protection_LK.pdf</a></li>
<li><a href="http://www.it-docs.net/ddata/4954.pdf" rel="noreferrer">http://www.it-docs.net/ddata/4954.pdf</a> (Disclosure, this last one was mine ;) )</li>
<li><a href="https://www.owasp.org/images/d/d4/OWASP_IL_2007_SQL_Smuggling.pdf" rel="noreferrer">https://www.owasp.org/images/d/d4/OWASP_IL_2007_SQL_Smuggling.pdf</a> (based on the previous paper, which is no longer available)</li>
</ul>
<p>Point is, any blacklist you do (and too-permissive whitelists) can be bypassed. The last link to my paper shows situations where even quote escaping can be bypassed. </p>
<p>Even if these situations do not apply to you, it's still a bad idea. Moreover, unless your app is trivially small, you're going to have to deal with maintenance, and maybe a certain amount of governance: how do you ensure that its done right, everywhere all the time?</p>
<p>The proper way to do it:</p>
<ul>
<li>Whitelist validation: type, length, format or accepted values</li>
<li>If you want to blacklist, go right ahead. Quote escaping is good, but within context of the other mitigations.</li>
<li>Use Command and Parameter objects, to preparse and validate</li>
<li>Call parameterized queries only.</li>
<li>Better yet, use Stored Procedures exclusively. </li>
<li>Avoid using dynamic SQL, and dont use string concatenation to build queries.</li>
<li>If using SPs, you can also limit permissions in the database to executing the needed SPs only, and not access tables directly. </li>
<li>you can also easily verify that the entire codebase only accesses the DB through SPs...</li>
</ul>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">+1 For evil unicode hack in your paper.</span></text><author><a class="comment-user" href="/users/18192/brian" title="17,091 reputation">Brian</a></author></comment><comment><text><span class="comment-copy">When used correctly, dynamic SQL and string concatenation can be used safely with parameterized queries (i.e. with <code>sp_executesql</code> instead of <code>EXEC</code>).  That is, you can dynamically generate your SQL statement so long as none of the concatenated text comes from the user.  This also has performance benefits; <code>sp_executesql</code> supports caching.</span></text><author><a class="comment-user" href="/users/18192/brian" title="17,091 reputation">Brian</a></author></comment><comment><text><span class="comment-copy">@Brian, well duh :). But in reality, how often do you see programmers do that? Moreover, the typical scenario where dynamic SQL is "needed", <i>requires</i> the user input as part of the query (supposedly). If you could do sp_executesql, you wouldn't (usually) need the dynamic sql in the first place.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">I finally ran into a situation that made me realize that it is possible to use unicode to sneak past the string replacement.  The input text was typed into Word, which changed the apostrophe from the straight-down version to a "curly" apostrophe (which looks more like a comma), which was not affected by the string replacement but was treated as a string delimiter by SQL Server. Thanks for the answer AviD (and everyone else)!</span></text><author><a class="comment-user owner" href="/users/22392/patrick" title="4,267 reputation">Patrick</a></author></comment><comment><text><span class="comment-copy">@AviD I think what Brian is saying is where the SqlCommand Text doesn't contain input directly from the user. It will instead contain parameter placeholders such as <code>@name</code> which can then be set to anything you like without the risk of injection. I am discounting someone building something dumb like <code>SqlCommand.Text="EXEC(@userinput)"</code> which would obviously <i>deserve</i> to be destroyed.</span></text><author><a class="comment-user" href="/users/395628/el-ronnoco" title="7,793 reputation">El Ronnoco</a></author></comment><comment><text><span class="comment-copy">@ElRonnoco sure, but I <i>don't</i> discount that, since I've seen it in the wild more times than you'd think...</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD Fair point!</span></text><author><a class="comment-user" href="/users/395628/el-ronnoco" title="7,793 reputation">El Ronnoco</a></author></comment><comment><text><span class="comment-copy">The link to the SQL Smuggling PDF is now broken.  Can you update the link?</span></text><author><a class="comment-user" href="/users/141172/eric-j" title="109,071 reputation">Eric J.</a></author></comment><comment><text><span class="comment-copy">@AviD I updated the link to the SQL Smuggling PDF that you wrote to the only version I could find online... please let us know if there's another location for your paper.</span></text><author><a class="comment-user" href="/users/643591/michael-fredrickson" title="29,065 reputation">Michael Fredrickson</a></author></comment><comment><text><span class="comment-copy">Thanks @MichaelFredrickson!</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Okay, this response will relate to the update of the question: </p>
<blockquote>
<p>"If anyone knows of any specific way to mount a SQL injection attack against this sanitization method I would love to see it."</p>
</blockquote>
<p>Now, besides the MySQL backslash escaping - and taking into account that we're actually talking about MSSQL, there are actually 3 possible ways of still SQL injecting your code</p>
<blockquote>
<p>sSanitizedInput = "'" &amp; Replace(sInput, "'", "''") &amp; "'"</p>
</blockquote>
<p>Take into account that these will not all be valid at all times, and are very dependant on your actual code around it:</p>
<ol>
<li>Second-order SQL Injection - if an SQL query is rebuilt based upon data retrieved from the database <strong>after escaping</strong>, the data is concatenated unescaped and may be indirectly SQL-injected. See </li>
<li>String truncation - (a bit more complicated) - Scenario is you have two fields, say a username and password, and the SQL concatenates both of them. And both fields (or just the first) has a hard limit on length. For instance, the username is limited to 20 characters. Say you have this code:</li>
</ol>
<blockquote>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">username </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">left</span><span class="pun">(</span><span class="pln">Replace</span><span class="pun">(</span><span class="pln">sInput</span><span class="pun">,</span><span class="pln"> </span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">),</span><span class="pln"> </span><span class="lit">20</span><span class="pun">)</span></code></pre>
</blockquote>
<p>Then what you get - is the username, escaped, and then trimmed to 20 characters. The problem here - I'll stick my quote in the 20th character (e.g. after 19 a's), and your escaping quote will be trimmed (in the 21st character). Then the SQL</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">sSQL </span><span class="pun">=</span><span class="pln"> </span><span class="str">"select * from USERS where username = '"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> username </span><span class="pun">+</span><span class="pln"> </span><span class="str">"'  and password = '"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> password </span><span class="pun">+</span><span class="pln"> </span><span class="str">"'"</span></code></pre>
<p>combined with the aforementioned malformed username will result in the password already being <em>outside</em> the quotes, and will just contain the payload directly.<br/>
 3. Unicode Smuggling - In certain situations, it is possible to pass a high-level unicode character that <em>looks</em> like a quote, but <em>isn't</em> - until it gets to the database, where suddenly <em>it is</em>. Since it isn't a quote when you validate it, it will go through easy... See my previous response for more details, and link to original research.</p>
</div></text><author><a href="/users/10080/avid">AviD</a></author><comments><comment><text><span class="comment-copy">Sadly, the link never made it into your answer. :( <a href="http://xkcd.com/979/" rel="nofollow noreferrer">xkcd.com/979</a></span></text><author><a class="comment-user" href="/users/41688/bryanh" title="3,640 reputation">BryanH</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In a nutshell: Never do query escaping yourself. You're bound to get something wrong. Instead, use parameterized queries, or if you can't do that for some reason, use an existing library that does this for you. There's no reason to be doing it yourself.</p>
</div></text><author><a href="/users/12030/nick-johnson">Nick Johnson</a></author><comments><comment><text><span class="comment-copy">Seconded. Strongly.</span></text><author><a class="comment-user" href="/users/10224/pittsburgh-dba" title="3,575 reputation">Pittsburgh DBA</a></author></comment><comment><text><span class="comment-copy">What if you have to deal with something like "Google Fusion tables" where, afaik, there's no any abstraction  library available that supports its dialect?  What would you suggest?</span></text><author><a class="comment-user" href="/users/130929/systempuntoout" title="36,964 reputation">systempuntoout</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I realize this is a long time after the question was asked, but ..</p>
<p>One way to launch an attack on the 'quote the argument' procedure is with string truncation.
According to MSDN, in SQL Server 2000 SP4 (and SQL Server 2005 SP1), a too long string will be quietly truncated. </p>
<p>When you quote a string, the string increases in size. Every apostrophe is repeated.
This can then be used to push parts of the SQL outside the buffer. So you could effectively trim away parts of a where clause.</p>
<p>This would probably be mostly useful in a 'user admin' page scenario where you could abuse the 'update' statement to not do all the checks it was supposed to do.</p>
<p>So if you decide to quote all the arguments, make sure you know what goes on with the string sizes and see to it that you don't run into truncation.</p>
<p>I would recommend going with parameters. Always. Just wish I could enforce that in the database. And as a side effect, you are more likely to get better cache hits because more of the statements look the same. (This was certainly true on Oracle 8)</p>
</div></text><author><a href="/users/34585/j%c3%b8rn-jensen">Jørn Jensen</a></author><comments><comment><text><span class="comment-copy">After posting, I decided that AviD's post covers this, and in more detail. Hopefully my post will still be of help to someone.</span></text><author><a class="comment-user" href="/users/34585/j%c3%b8rn-jensen" title="739 reputation">Jørn Jensen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Input sanitation is not something you want to half-ass. Use your whole ass. Use regular expressions on text fields. TryCast your numerics to the proper numeric type, and report a validation error if it doesn't work. It is very easy to search for attack patterns in your input, such as ' --. Assume all input from the user is hostile.</p>
</div></text><author><a href="/users/15769/tom-dietrich">tom.dietrich</a></author><comments><comment><text><span class="comment-copy">And when you miss that <b>ONE</b> case on <b>ONE</b> input, you're pwnd.</span></text><author><a class="comment-user" href="/users/41688/bryanh" title="3,640 reputation">BryanH</a></author></comment><comment><text><span class="comment-copy">"Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems."</span></text><author><a class="comment-user" href="/users/226555/mickeyf" title="1,493 reputation">mickeyf</a></author></comment><comment><text><span class="comment-copy">@mickeyf I know this is a common sentiment but honestly regular expressions are pretty awesome once you grep them.</span></text><author><a class="comment-user" href="/users/15769/tom-dietrich" title="5,880 reputation">tom.dietrich</a></author></comment><comment><text><span class="comment-copy">@tom.dietrich It always depends on the real life situation. F.ex. regexpr syntax is not standard so in general I would advise against using regexpr in contexts where different systems are integrated to work together. This is because different regexpr engines evaluate regexprs differently, and more importantly this hard fact gets usually downplayed or ignored which can lead developers to not care about these incompatibilities until they get bitten. There are plenty of such incompatibilities; see f.ex. <a href="http://www.regular-expressions.info/shorthand.html" rel="nofollow noreferrer">regular-expressions.info/shorthand.html</a> (search for <code>flavors</code> in that page).</span></text><author><a class="comment-user" href="/users/2814308/santibailors" title="784 reputation">SantiBailors</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I've used this technique when dealing with 'advanced search' functionality, where building a query from scratch was the only viable answer. (Example: allow the user to search for products based on an unlimited set of constraints on product attributes, displaying columns and their permitted values as GUI controls to reduce the learning threshold for users.)</p>
<p>In itself it is safe AFAIK. As another answerer pointed out, however, you may also need to deal with backspace escaping (albeit not when passing the query to SQL Server using ADO or ADO.NET, at least -- can't vouch for all databases or technologies). </p>
<p>The snag is that you really have to be certain which strings contain user input (always potentially malicious), and which strings are valid SQL queries. One of the traps is if you use values from the database -- were those values originally user-supplied? If so, they must also be escaped. My answer is to try to sanitize as late as possible (but no later!), when constructing the SQL query. </p>
<p>However, in most cases, parameter binding is the way to go -- it's just simpler. </p>
</div></text><author><a href="/users/20402/pontus-gagge">Pontus Gagge</a></author><comments><comment><text><span class="comment-copy">You can still use parameter substitution even if you're building your own queries.</span></text><author><a class="comment-user" href="/users/12030/nick-johnson" title="90,861 reputation">Nick Johnson</a></author></comment><comment><text><span class="comment-copy">You should build the SQL statement string from scratch, but still use parameter substitution.</span></text><author><a class="comment-user" href="/users/17832/jeebee" title="14,479 reputation">JeeBee</a></author></comment><comment><text><span class="comment-copy">No, NEVER build your SQL statements from scratch.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">+1 as the only relevant answer so far</span></text><author><a class="comment-user" href="/users/16886/dk" title="1,990 reputation">DK.</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It's a bad idea anyway as you seem to know.</p>
<p>What about something like escaping the quote in string like this: \'</p>
<p>Your replace would result in: \''</p>
<p>If the backslash escapes the first quote, then the second quote has ended the string.</p>
</div></text><author><a href="/users/14663/ww">WW.</a></author><comments><comment><text><span class="comment-copy">Thanks for the response!  I know that attack would work for a mySQL database but I'm pretty sure that MS SQL Server won't accept a backslash as an escape character (I tried it).  Several google searches did not reveal any other escape characters, which really made me wonder why this wouldn't work.</span></text><author><a class="comment-user owner" href="/users/22392/patrick" title="4,267 reputation">Patrick</a></author></comment><comment><text><span class="comment-copy">WW, you are probably thinking of source code, not run-time.</span></text><author><a class="comment-user" href="/users/16886/dk" title="1,990 reputation">DK.</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Simple answer: It will work sometimes, but not all the time.
You want to use white-list validation on <strong>everything</strong> you do, but I realize that's not always possible, so you're forced to go with the best guess blacklist. Likewise, you want to use parametrized stored procs in <strong>everything</strong>, but once again, that's not always possible, so you're forced to use sp_execute with parameters.</p>
<p>There are ways around any usable blacklist you can come up with (and some whitelists too).</p>
<p>A decent writeup is here: <a href="http://www.owasp.org/index.php/Top_10_2007-A2" rel="noreferrer">http://www.owasp.org/index.php/Top_10_2007-A2</a></p>
<p>If you need to do this as a quick fix to give you time to get a real one in place, do it.  But don't think you're safe.</p>
</div></text><author><a href="/posts/141445/revisions" id="history-141445" title="show revision history for this post">
        RaySir
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are two ways to do it, no exceptions, to be safe from SQL-injections; prepared statements or prameterized stored procedures.</p>
</div></text><author><a href="/users/22422/olle">olle</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If you have parameterised queries available you should be using them at all times. All it takes is for one query to slip through the net and your DB is at risk.</p>
</div></text><author><a href="/users/419/the-anti-santa">The Anti-Santa</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Yeah, that should work right up until someone runs <a href="http://msdn.microsoft.com/en-us/library/ms174393.aspx" rel="nofollow noreferrer">SET QUOTED_IDENTIFIER OFF</a> and uses a double quote on you.</p>
<p>Edit: It isn't as simple as not allowing the malicious user to turn off quoted identifiers:</p>
<blockquote>
<p>The SQL Server Native Client ODBC driver and SQL Server Native Client OLE DB Provider for SQL Server automatically set QUOTED_IDENTIFIER to ON when connecting. This can be configured in ODBC data sources, in ODBC connection attributes, or OLE DB connection properties. <b>The default for SET QUOTED_IDENTIFIER is OFF for connections from DB-Library applications.</b></p>
<p>When a stored procedure is created, the <b>SET QUOTED_IDENTIFIER and SET ANSI_NULLS settings are captured and used for subsequent invocations of that stored procedure</b>.</p>
<p>SET QUOTED_IDENTIFIER also <b>corresponds to the QUOTED_IDENTIFER setting of ALTER DATABASE.</b></p>
<p>SET QUOTED_IDENTIFIER is <b>set at parse time</b>. Setting at parse time means that if the SET statement is present in the batch or stored procedure, it takes effect, regardless of whether code execution actually reaches that point; and the SET statement takes effect before any statements are executed.</p>
</blockquote>
<p>There's a lot of ways QUOTED_IDENTIFIER could be off without you necessarily knowing it. Admittedly - this isn't the smoking gun exploit you're looking for, but it's a pretty big attack surface. Of course, if you also escaped double quotes - then we're back where we started. ;)</p>
</div></text><author><a href="/users/2199/mark-brackett">Mark Brackett</a></author><comments><comment><text><span class="comment-copy">That could work, but again, how could they get that code to execute when all user input is surrounded by single quotes?  A specific line(s) of code that would be able to inject SQL into the above code would be very helpful.  Thanks!</span></text><author><a class="comment-user owner" href="/users/22392/patrick" title="4,267 reputation">Patrick</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Your defence would fail if: </p>
<ul>
<li>the query is expecting a number rather than a string</li>
<li>there were any other way to represent a single quotation mark, including: 

<ul>
<li>an escape sequence such as \039 </li>
<li>a unicode character  </li>
</ul></li>
</ul>
<p>(in the latter case, it would have to be something which were expanded only after you've done your replace)</p>
</div></text><author><a href="/users/7211/aj">AJ.</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Patrick, are you adding single quotes around ALL input, even numeric input?  If you have numeric input, but are not putting the single quotes around it, then you have an exposure.</p>
</div></text><author><a href="/users/37749/rob-kraft">Rob Kraft</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>What ugly code all that sanitisation of user input would be! Then the clunky StringBuilder for the SQL statement. The prepared statement method results in much cleaner code, and the SQL Injection benefits are a really nice addition.</p>
<p>Also why reinvent the wheel?</p>
</div></text><author><a href="/users/17832/jeebee">JeeBee</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Rather than changing a single quote to (what looks like) two single quotes, why not just change it to an apostrophe, a quote, or remove it entirely?</p>
<p>Either way, it's a bit of a kludge... especially when you legitimately have things (like names) which may use single quotes...</p>
<p>NOTE: Your method also assumes everyone working on your app always remembers to sanitize input before it hits the database, which probably isn't realistic most of the time.</p>
</div></text><author><a href="/users/3743/kevin-fairchild">Kevin Fairchild</a></author><comments><comment><text><span class="comment-copy">Down-voted because answer does not address question. Question is about escaping strings in SQL. When you escape an arbitrary string (as the questioner is trying to do, in order to deal with unsanitised data), you can’t just replace problematic characters with arbitrary other ones; that corrupts data. (Also, a single quote IS an apostrophe (at least in ASCII).)</span></text><author><a class="comment-user" href="/users/214560/andrewf" title="549 reputation">andrewf</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It might work, but it seems a little hokey to me. I'd recommend verifing that each string is valid by testing it against a regular expression instead.</p>
</div></text><author><a href="/users/18505/rob-ringham">Rob Ringham</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>While you might find a solution that works for strings, for numerical predicates you need to also make sure they're only passing in numbers (simple check is can it be parsed as int/double/decimal?).</p>
<p>It's a lot of extra work.</p>
</div></text><author><a href="/users/507/joseph-daigle">Joseph Daigle</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<h1>Yes, you can, if...</h1>
<p>After studying the topic, I think input sanitized as you suggested is safe, but only under these rules:</p>
<ol>
<li><p>you never allow string values coming from users to become anything else than string literals (i.e. avoid giving configuration option: "Enter additional SQL column names/expressions here:").  Value types other than strings (numbers, dates, ...): convert them to their native data types and provide a routine for SQL literal from each data type.</p>
<ul>
<li>SQL statements are problematic to validate</li>
</ul></li>
<li><p>you either use <code>nvarchar</code>/<code>nchar</code> columns (and prefix string literals with <code>N</code>) OR limit values going into <code>varchar</code>/<code>char</code> columns to ASCII characters only (e.g. throw exception when creating SQL statement)</p>
<ul>
<li>this way you will be avoiding automatic apostrophe conversion from CHAR(700) to CHAR(39) (and maybe other similar Unicode hacks)</li>
</ul></li>
<li><p>you always validate value length to fit actual column length (throw exception if longer)</p>
<ul>
<li>there was a known defect in SQL Server allowing to bypass SQL error thrown on truncation (leading to silent truncation)</li>
</ul></li>
<li><p>you ensure that <code>SET QUOTED_IDENTIFIER</code> is always <code>ON</code></p>
<ul>
<li>beware, it is taken into effect in parse-time, i.e. even in inaccessible sections of code</li>
</ul></li>
</ol>
<p>Complying with these 4 points, you should be safe. If you violate any of them, a way for SQL injection opens.</p>
</div></text><author><a href="/users/2392157/miroxlav">miroxlav</a></author><comments><comment><text><span class="comment-copy">It is like you didn't read all the other answers to this <b>8 year old question</b>, since any number of these answers point out his method <b>fails to stop injection</b> if the attacker simply uses unicode characters.</span></text><author><a class="comment-user" href="/users/215752/hogan" title="47,872 reputation">Hogan</a></author></comment><comment><text><span class="comment-copy">@Hogan – I did, but I think there is extra value in my question. I have much experience and testing behind what I wrote. I know using query parameters is better, but I also fully understand the situation when someone must avoid it due to various reasons (e.g. employer demands to keep the old way). In this case, I think my answer is very comprehensive and has higher value than answers saying "just don't do that", because it shows the way through. Show me other answers here which show the same way and I'll consider deleting mine.</span></text><author><a class="comment-user" href="/users/2392157/miroxlav" title="6,454 reputation">miroxlav</a></author></comment><comment><text><span class="comment-copy">Ok, when (not if) your system gets compromised please come back and delete this answer.... or you could use a parametrized query.</span></text><author><a class="comment-user" href="/users/215752/hogan" title="47,872 reputation">Hogan</a></author></comment><comment><text><span class="comment-copy">@Hogan – I have no problem to do it :) But currently I claim there is no known way to get around this if you keep the 4 rules I posted. If you really think there is a way around it, then just point out where.</span></text><author><a class="comment-user" href="/users/2392157/miroxlav" title="6,454 reputation">miroxlav</a></author></comment></comments></answer></answers></post>