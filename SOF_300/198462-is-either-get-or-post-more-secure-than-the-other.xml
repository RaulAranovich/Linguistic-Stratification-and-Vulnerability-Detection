<?xml version="1.0" encoding="utf-8"?>
<post><title>html - Is either GET or POST more secure than the other? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>When comparing an HTTP GET to an HTTP POST, what are the differences from a security perspective? Is one of the choices inherently more secure than the other? If so, why?</p>
<p>I realize that POST doesn't expose information on the URL, but is there any real value in that or is it just security through obscurity? Is there ever a reason that I should prefer POST when security is a concern?</p>
<p><strong>Edit:</strong><br/>
Over HTTPS, POST data is encoded, but could URLs be sniffed by a 3rd party? Additionally, I am dealing with JSP; when using JSP or a similar framework, would it be fair to say the best practice is to avoid placing sensitive data in the POST or GET altogether and using server side code to handle sensitive information instead?</p>
</div></text><author><a href="/users/20774">James McMahon</a></author><comments><comment><text><span class="comment-copy">There is a nice blog entry about this on Jeff's blog Coding Horror: <a href="http://www.codinghorror.com/blog/archives/001171.html" rel="nofollow noreferrer">Cross-Site Request Forgeries and You</a>.</span></text><author><a class="comment-user" href="/users/4445/fhe" title="4,735 reputation">fhe</a></author></comment><comment><text><span class="comment-copy">Wouldn't you use POST for most things. E.g for an API, say you needed to GET data from a DB, but before the server returns data you would have to be authenticated first? Using post you would simply pass your session ID + all the parameters you need for the request. If you used a GET req for this then your session ID could easily be found either in your browser history or somewhere in the middle.</span></text><author><a class="comment-user" href="/users/4140346/james111" title="3,533 reputation">James111</a></author></comment><comment><text><span class="comment-copy">I remember this discussion from before the war (99' or '00 or so) when https wasn't prevalent.</span></text><author><a class="comment-user" href="/users/884463/david-tonhofer" title="3,926 reputation">David Tonhofer</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>As far as security, they are inherently the same.  While it is true that POST doesn't expose information via the URL, it exposes just as much information as a GET in the actual network communication between the client and server.  If you need to pass information that is sensitive, your first line of defense would be to pass it using Secure HTTP. </p>
<p>GET or query string posts are really good for information required for either bookmarking a particular item, or for assisting in search engine optimization and indexing items.  </p>
<p>POST is good for standard forms used to submit one time data. I wouldn't use GET for posting actual forms, unless maybe in a search form where you want to allow the user to save the query in a bookmark, or something along those lines. </p>
</div></text><author><a href="/users/18893/stephenbayer">stephenbayer</a></author><comments><comment><text><span class="comment-copy">With the caveat that for a GET the URL shown in the location bar can expose data that would be hidden in a POST.</span></text><author><a class="comment-user" href="/users/12950/tvanfosson" title="371,941 reputation">tvanfosson</a></author></comment><comment><text><span class="comment-copy">It's hidden only in the most naive sense</span></text><author><a class="comment-user" href="/users/3029/davetron5000" title="14,020 reputation">davetron5000</a></author></comment><comment><text><span class="comment-copy">true, but you can also say that the keyboard is insecure because someone could be looking over your shoulder when your typing your password.  There's very little difference between security through obscurity and no security at all.</span></text><author><a class="comment-user" href="/users/18893/stephenbayer" title="7,351 reputation">stephenbayer</a></author></comment><comment><text><span class="comment-copy">As mentioned in this post, if data is going to be submitted and especially if it will be saved, it should not be using GET parameters. Thats one easy way for cross site scripting attacks to take place.</span></text><author><a class="comment-user" href="/users/108044/gavin-h" title="7,879 reputation">Gavin H</a></author></comment><comment><text><span class="comment-copy">The visibility (and caching) of querystrings in the URL and thus the address box is <i>clearly</i> less secure. There's no such thing as absolute security so degrees of security are relevant.</span></text><author><a class="comment-user" href="/users/42048/pbreitenbach" title="8,596 reputation">pbreitenbach</a></author></comment><comment><text><span class="comment-copy">@stephenbayer: Suppose that I need to send, say, order id to server to search for the corresponding order details, and then show it to the user for modification. If I use "GET", the order id will be exposed, and if the user is clever enough, he/she may change the order id in the url, which will allow him/her to see orders from other users. What should I do in that case ?</span></text><author><a class="comment-user" href="/users/245679/md-sayem-ahmed" title="17,485 reputation">MD Sayem Ahmed</a></author></comment><comment><text><span class="comment-copy">it's even exposed if you use a post.  in your case, the post would be slightly more secure.  But seriously.. I can change post variables all day long, just as easy as get variables.  Cookies can even be viewed and modified.. never rely on the information you're site is sending in any way shape or form.  The more security you need, the more verification methods you should have in place.</span></text><author><a class="comment-user" href="/users/18893/stephenbayer" title="7,351 reputation">stephenbayer</a></author></comment><comment><text><span class="comment-copy">@Night Shade. How about validating that the order belongs to the user before displaying it? If the user is "clever enough" (read, if they can install any of the gazillion browser plugins that allow you modifiy the http request at will), POST doesn't buy you anything.</span></text><author><a class="comment-user" href="/users/24170/juan-pablo-califano" title="10,289 reputation">Juan Pablo Califano</a></author></comment><comment><text><span class="comment-copy">This answer is totally misleading and dangerous. I can't imagine how it got so many votes. If GET and POST are the same, why do we need them at all?</span></text><author><a class="comment-user" href="/users/486820/rocketr" title="2,535 reputation">RocketR</a></author></comment><comment><text><span class="comment-copy">@RocketR POST and GET are only verbs, You can apply a few verbs to an HTTP request.  The difference is mainly semantics.  GET is used to get information, while POST is used to send new information, PUT is used to update information.  Well that was the design idea, but people use whatever verbs they want.  POST transmissions are no more secure that GET, it is in a different OSI layer that security is handled. It is dangerous to think there is a difference in security between GET and POST.</span></text><author><a class="comment-user" href="/users/18893/stephenbayer" title="7,351 reputation">stephenbayer</a></author></comment><comment><text><span class="comment-copy">@stephenbayer Please read the community answer below and you'll know the difference. I don't mean you can be secure just by using POST alone, but it's a necessary part of a bigger strategy. And it is too thoughtless to just say there's no difference without giving more context. I've seen too many Rails-people using a "catch-everything" method <code>match</code> in place of specific <code>get</code>, <code>post</code>, etc, who don't have a clue about CSRF.</span></text><author><a class="comment-user" href="/users/486820/rocketr" title="2,535 reputation">RocketR</a></author></comment><comment><text><span class="comment-copy">URLs also are frequently logged, for example by nginx. POST is more secure because request bodies are rarely logged. You should never send sensitive information in a query string.</span></text><author><a class="comment-user" href="/users/654332/jesse-reiss" title="3,494 reputation">jesse reiss</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The GET request is marginally less secure than the POST request. Neither offers true "security" by itself; using POST requests <em>will not</em> magically make your website secure against malicious attacks by a noticeable amount. However, using GET requests <em>can</em> make an otherwise secure application insecure.</p>
<p>The mantra that you "must not use GET requests to make changes" is still very much valid, but this has little to do with <em>malicious</em> behaviour. Login forms are the ones most sensitive to being sent using the wrong request type.</p>
<h3>Search spiders and web accelerators</h3>
<p>This is the real reason you should use POST requests for changing data. Search spiders will follow every link on your website, but will not submit random forms they find.</p>
<p>Web accelerators are worse than search spiders, because they run on the clientâ€™s machine, and "click" all links <em>in the context of the logged in user</em>. Thus, an application that uses a GET request to delete stuff, even if it requires an administrator, will happily obey the orders of the (non-malicious!) web accelerator and <a href="http://radar.oreilly.com/archives/2005/05/google-web-acce-1.html" rel="noreferrer">delete everything it sees</a>.</p>
<h3>Confused deputy attack</h3>
<p>A <a href="http://en.wikipedia.org/wiki/Confused_deputy_problem" rel="noreferrer">confused deputy attack</a> (where the deputy is the browser) is <a href="http://haacked.com/archive/2009/04/02/anatomy-of-csrf-attack.aspx" rel="noreferrer">possible regardless of whether you use a GET or a POST request</a>.</p>
<p>On attacker-controlled websites GET and POST are <a href="http://pentestmonkey.net/blog/csrf-xml-post-request" rel="noreferrer">equally easy to submit</a> <a href="http://www.javascript-coder.com/javascript-form/javascript-form-submit.phtml" rel="noreferrer">without user interaction</a>.</p>
<p>The only scenario in which POST is slightly less susceptible is that many websites that arenâ€™t under the attackerâ€™s control (say, a third-party forum) allow embedding arbitrary images (allowing the attacker to inject an arbitrary GET request), but prevent all ways of injecting an arbitary POST request, whether automatic or manual.</p>
<p>One might argue that web accelerators are an example of confused deputy attack, but thatâ€™s just a matter of definition. If anything, a malicious attacker has no control over this, so itâ€™s hardly an <em>attack</em>, even if the deputy <em>is</em> confused.</p>
<h3>Proxy logs</h3>
<p>Proxy servers are likely to log GET URLs in their entirety, without stripping the query string. POST request parameters are not normally logged. Cookies are unlikely to be logged in either case. <a href="http://www.linuxquestions.org/questions/linux-server-73/sample-squid-proxy-log-files-837345/" rel="noreferrer">(example)</a></p>
<p>This is a very weak argument in favour of POST. Firstly, un-encrypted traffic can be logged in its entirety; a malicious proxy already has everything it needs. Secondly, the request parameters are of limited use to an attacker: what they really need is the cookies, so if the only thing they have are proxy logs, they are unlikely to be able to attack either a GET or a POST URL.</p>
<p>There is one exception for login requests: these tend to contain the userâ€™s password. Saving this in the proxy log opens up a vector of attack that is absent in the case of POST. However, login over plain HTTP is inherently insecure anyway.</p>
<h3>Proxy cache</h3>
<p>Caching proxies might retain GET responses, but not POST responses. Having said that, GET responses can be made non-cacheable with less effort than converting the URL to a POST handler.</p>
<h3>HTTP "Referer"</h3>
<p>If the user were to navigate to a third party website from the page served in response to a GET request, that third party website gets to see all the GET request parameters.</p>
<p>Belongs to the category of "reveals request parameters to a third party", whose severity depends on what is present in those parameters. POST requests are naturally immune to this, however to exploit the GET request a hacker would need to insert a link to their own website into the serverâ€™s response.</p>
<h3>Browser history</h3>
<p>This is very similar to the "proxy logs" argument: GET requests are stored in the browser history along with their parameters. The attacker can easily obtain these if they have physical access to the machine.</p>
<h3>Browser refresh action</h3>
<p>The browser will retry a GET request as soon as the user hits "refresh". It might do that when restoring tabs after shutdown. Any action (say, a payment) will thus be repeated without warning.</p>
<p>The browser will not retry a POST request without a warning.</p>
<p>This is a good reason to use only POST requests for changing data, but has nothing to do with malicious behaviour and, hence, security.</p>
<h2>So what should I do?</h2>
<ul>
<li>Use only POST requests to change data, mainly for non-security-related reasons.</li>
<li>Use only POST requests for login forms; doing otherwise introduces attack vectors.</li>
<li>If your site performs sensitive operations, you really need someone who knows what theyâ€™re doing, because this canâ€™t be covered in a single answer. You need to use HTTPS, HSTS, CSP, mitigate SQL injection, <a href="http://en.wikipedia.org/wiki/Cross-site_scripting" rel="noreferrer">script injection (XSS)</a>, <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noreferrer">CSRF</a>, and a gazillion of other things that may be specific to your platform (like the mass assignment vulnerability in various frameworks: <a href="http://freshbrewedcode.com/joshbush/2012/03/05/mass-assignment-aspnet-mvc/" rel="noreferrer">ASP.NET MVC</a>, <a href="http://www.infoq.com/news/2012/03/GitHub-Compromised" rel="noreferrer">Ruby on Rails</a>, etc.). There is no single thing that will make the difference between "secure" (not exploitable) and "not secure".</li>
</ul>
<hr/>
<blockquote>
<p>Over HTTPS, POST data is encoded, but could URLs be sniffed by a 3rd party?</p>
</blockquote>
<p>No, they canâ€™t be sniffed. But the URLs will be stored in the browser history.</p>
<blockquote>
<p>Would it be fair to say the best practice is to avoid possible placing sensitive data in the POST or GET altogether and using server side code to handle sensitive information instead?</p>
</blockquote>
<p>Depends on how sensitive it is, or more specifically, in what way. Obviously the client will see it. Anyone with physical access to the clientâ€™s computer will see it. The client can spoof it when sending it back to you. If those matter then yes, keep the sensitive data on the server and donâ€™t let it leave.</p>
</div></text><author><a href="/users/33080">romkyns</a></author><comments><comment><text><span class="comment-copy">ahem, CSRF is just as possible with POST.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">@AviD It's just slightly more difficult, as you'll also have to incorporate XSS to get someone else to send an undesired POST request.</span></text><author><a class="comment-user" href="/users/296308/lotus-notes" title="3,917 reputation">Lotus Notes</a></author></comment><comment><text><span class="comment-copy">@Lotus Notes, it is very slightly more difficult, but you do not need any kind of XSS. POST requests are being sent all the time all over the place, and dont forget the CSRF can be sourced from <i>any</i> website, XSS not included.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">So, something is more secure because to "hack the planet" I need to know to type in <code>wget --post-data 'action=delete&amp;id=3' http://example.com/do.php'</code> instead of simply <code>wget http://example.com/do.php?action=delete&amp;id=3'</code> ? That's not more secure at all. It's virtually the same thing.</span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment><comment><text><span class="comment-copy">no you have to make somebody else with privileges to type it, as opposed to a GET which will be silently fetched by the browser. considering that every POST form should be protected with verifiable source hash, and there's no such means for a GET link, your point is silly.</span></text><author><a class="comment-user" href="/users/223632/kibitzer" title="2,793 reputation">kibitzer</a></author></comment><comment><text><span class="comment-copy">Well, you could add a hash to all your GET requests exactly the same way you add them to POST forms... But you should still not use GET for anything that modifies data.</span></text><author><a class="comment-user" href="/users/5958/eli" title="4,363 reputation">Eli</a></author></comment><comment><text><span class="comment-copy">@kibitzer â€” What Eli said. Also you could send a link to the admin and when they click it you can fill and submit a form with javascript. POST doesn't functionally offer any extra security than GET, they can both be executed silently within the browser it's just that forum software tends to allow GET requests to third-party sites using images.</span></text><author><a class="comment-user" href="/users/92148/davej" title="1,083 reputation">DaveJ</a></author></comment><comment><text><span class="comment-copy">Using POST over GET doesn't prevent any kind of CSRF. It just makes them slightly easier to do, since it's easier to get people to go to a random website that allows images from urls, than go to a website that you control (enough to have javascript). Doing <code>&lt;body onload="document.getElementById('a').submit()"&gt;&lt;form id="a" action="http://example.com/delete.php" action="post"&gt;&lt;input type="hidden" name="id" value="12"&gt;&lt;/form&gt;</code> isn't really that hard to submit a post somewhere automatically by clicking a link (that contains that html)</span></text><author><a class="comment-user" href="/users/28776/fryguy" title="7,157 reputation">FryGuy</a></author></comment><comment><text><span class="comment-copy">I cant believe nobody brought this up until I did just now, POST DOES NOT LOG BY DEFAULT, GET DOES LOG, therefor, POST &lt; GET for security. And I mean POST Parameters, sure GET can have them also, but then your talking about very a-typical activity.  Sorry about the caps, I didnt mean to scream ;)</span></text><author><a class="comment-user" href="/users/67819/randomnickname42" title="4,892 reputation">RandomNickName42</a></author></comment><comment><text><span class="comment-copy">That's because you're talking about specific software, and not POST vs GET - the server software I'm using doesn't log any requests at all for example, and I would never tell people to use Apache or the like anyway if security (or speed, or ease of use, or ...) is of concern.</span></text><author><a class="comment-user" href="/users/1895207/griffin" title="991 reputation">griffin</a></author></comment><comment><text><span class="comment-copy">Nobody has mentioned it here, but browsers happily execute GET requests all over injecting code across random domains into clients browser - a script link can be loaded from anywhere ( which is why jsonp could exist and is actively being shunned ) Thats a fairly large attack surface.</span></text><author><a class="comment-user" href="/users/295231/kert" title="711 reputation">kert</a></author></comment><comment><text><span class="comment-copy">Imagine if a someone manages to quietly poison one of the popular javascript compressed libraries ( jquery  ) on a prominent CDN site, both with and without SSL .. browsers dont do any code signature checking or even md5sums. just a http get ..</span></text><author><a class="comment-user" href="/users/295231/kert" title="711 reputation">kert</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You have no greater security provided because the variables are sent over HTTP POST than you have with variables sent over HTTP GET.</p>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">HTTP/1.1 provides us with a bunch of methods to send a request</a>:</p>
<ul>
<li>OPTIONS</li>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>TRACE</li>
<li>CONNECT</li>
</ul>
<h2>Lets suppose you have the following HTML document using GET:</h2>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;html&gt;</span><span class="pln">
</span><span class="tag">&lt;body&gt;</span><span class="pln">
</span><span class="tag">&lt;form</span><span class="pln"> </span><span class="atn">action</span><span class="pun">=</span><span class="atv">"http://example.com"</span><span class="pln"> </span><span class="atn">method</span><span class="pun">=</span><span class="atv">"get"</span><span class="tag">&gt;</span><span class="pln">
    User: </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"username"</span><span class="pln"> </span><span class="tag">/&gt;&lt;br/&gt;</span><span class="pln">
    Password: </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"password"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"password"</span><span class="pln"> </span><span class="tag">/&gt;&lt;br/&gt;</span><span class="pln">
    </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"hidden"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"extra"</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"lolcatz"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"submit"</span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/form&gt;</span><span class="pln">
</span><span class="tag">&lt;/body&gt;</span><span class="pln">
</span><span class="tag">&lt;/html&gt;</span></code></pre>
<p>What does your browser ask? It asks this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> GET </span><span class="pun">/?</span><span class="pln">username</span><span class="pun">=</span><span class="pln">swordfish</span><span class="pun">&amp;</span><span class="pln">password</span><span class="pun">=</span><span class="pln">hunter2</span><span class="pun">&amp;</span><span class="pln">extra</span><span class="pun">=</span><span class="pln">lolcatz HTTP</span><span class="pun">/</span><span class="lit">1.1</span><span class="pln">
 </span><span class="typ">Host</span><span class="pun">:</span><span class="pln"> example</span><span class="pun">.</span><span class="pln">com
 </span><span class="typ">Connection</span><span class="pun">:</span><span class="pln"> keep</span><span class="pun">-</span><span class="pln">alive
 </span><span class="typ">Accept</span><span class="pun">:</span><span class="pln"> application</span><span class="pun">/</span><span class="pln">xml</span><span class="pun">,</span><span class="pln">application</span><span class="pun">/</span><span class="pln">xhtml</span><span class="pun">+</span><span class="pln">xml</span><span class="pun">,</span><span class="pln">text</span><span class="pun">/</span><span class="pln">html</span><span class="pun">;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.9</span><span class="pun">,</span><span class="pln">text</span><span class="pun">/</span><span class="pln"> </span><span class="pun">[...</span><span class="pln">truncated</span><span class="pun">]</span><span class="pln">
 </span><span class="typ">User</span><span class="pun">-</span><span class="typ">Agent</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Mozilla</span><span class="pun">/</span><span class="lit">5.0</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Windows</span><span class="pun">;</span><span class="pln"> U</span><span class="pun">;</span><span class="pln"> </span><span class="typ">Windows</span><span class="pln"> NT </span><span class="lit">6.0</span><span class="pun">;</span><span class="pln"> en</span><span class="pun">-</span><span class="pln">US</span><span class="pun">)</span><span class="pln"> </span><span class="pun">[...</span><span class="pln">truncated</span><span class="pun">]</span><span class="pln">
 </span><span class="typ">Accept</span><span class="pun">-</span><span class="typ">Encoding</span><span class="pun">:</span><span class="pln"> gzip</span><span class="pun">,</span><span class="pln">deflate</span><span class="pun">,</span><span class="pln">sdch
 </span><span class="typ">Accept</span><span class="pun">-</span><span class="typ">Language</span><span class="pun">:</span><span class="pln"> en</span><span class="pun">-</span><span class="pln">US</span><span class="pun">,</span><span class="pln">en</span><span class="pun">;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.8</span><span class="pln">
 </span><span class="typ">Accept</span><span class="pun">-</span><span class="typ">Charset</span><span class="pun">:</span><span class="pln"> ISO</span><span class="pun">-</span><span class="lit">8859</span><span class="pun">-</span><span class="lit">1</span><span class="pun">,</span><span class="pln">utf</span><span class="pun">-</span><span class="lit">8</span><span class="pun">;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.7</span><span class="pun">,*;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.3</span></code></pre>
<h2>Now lets pretend we changed that request method to a POST:</h2>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> POST </span><span class="pun">/</span><span class="pln"> HTTP</span><span class="pun">/</span><span class="lit">1.1</span><span class="pln">
 </span><span class="typ">Host</span><span class="pun">:</span><span class="pln"> example</span><span class="pun">.</span><span class="pln">com
 </span><span class="typ">Connection</span><span class="pun">:</span><span class="pln"> keep</span><span class="pun">-</span><span class="pln">alive
 </span><span class="typ">Content</span><span class="pun">-</span><span class="typ">Length</span><span class="pun">:</span><span class="pln"> </span><span class="lit">49</span><span class="pln">
 </span><span class="typ">Cache</span><span class="pun">-</span><span class="typ">Control</span><span class="pun">:</span><span class="pln"> max</span><span class="pun">-</span><span class="pln">age</span><span class="pun">=</span><span class="lit">0</span><span class="pln">
 </span><span class="typ">Origin</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pln">
 </span><span class="typ">Content</span><span class="pun">-</span><span class="typ">Type</span><span class="pun">:</span><span class="pln"> application</span><span class="pun">/</span><span class="pln">x</span><span class="pun">-</span><span class="pln">www</span><span class="pun">-</span><span class="pln">form</span><span class="pun">-</span><span class="pln">urlencoded
 </span><span class="typ">Accept</span><span class="pun">:</span><span class="pln"> application</span><span class="pun">/</span><span class="pln">xml</span><span class="pun">,</span><span class="pln">application</span><span class="pun">/</span><span class="pln">xhtml</span><span class="pun">+</span><span class="pln">xml</span><span class="pun">,</span><span class="pln">text</span><span class="pun">/</span><span class="pln"> </span><span class="pun">[...</span><span class="pln">truncated</span><span class="pun">]</span><span class="pln">
 </span><span class="typ">User</span><span class="pun">-</span><span class="typ">Agent</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Mozilla</span><span class="pun">/</span><span class="lit">5.0</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Windows</span><span class="pun">;</span><span class="pln"> U</span><span class="pun">;</span><span class="pln"> </span><span class="typ">Windows</span><span class="pln"> NT </span><span class="lit">6.0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">[...</span><span class="pln">truncated</span><span class="pun">]</span><span class="pln">
 </span><span class="typ">Accept</span><span class="pun">-</span><span class="typ">Encoding</span><span class="pun">:</span><span class="pln"> gzip</span><span class="pun">,</span><span class="pln">deflate</span><span class="pun">,</span><span class="pln">sdch
 </span><span class="typ">Accept</span><span class="pun">-</span><span class="typ">Language</span><span class="pun">:</span><span class="pln"> en</span><span class="pun">-</span><span class="pln">US</span><span class="pun">,</span><span class="pln">en</span><span class="pun">;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.8</span><span class="pln">
 </span><span class="typ">Accept</span><span class="pun">-</span><span class="typ">Charset</span><span class="pun">:</span><span class="pln"> ISO</span><span class="pun">-</span><span class="lit">8859</span><span class="pun">-</span><span class="lit">1</span><span class="pun">,</span><span class="pln">utf</span><span class="pun">-</span><span class="lit">8</span><span class="pun">;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.7</span><span class="pun">,*;</span><span class="pln">q</span><span class="pun">=</span><span class="lit">0.3</span><span class="pln">

 username</span><span class="pun">=</span><span class="pln">swordfish</span><span class="pun">&amp;</span><span class="pln">password</span><span class="pun">=</span><span class="pln">hunter2</span><span class="pun">&amp;</span><span class="pln">extra</span><span class="pun">=</span><span class="pln">lolcatz</span></code></pre>
<p><strong>BOTH</strong> of these HTTP requests are:</p>
<ul>
<li>Not encrypted</li>
<li>Included in both examples</li>
<li>Can be evesdroped on, and subject to MITM attacks.</li>
<li>Easily reproduced by third party, and script bots.</li>
</ul>
<p>Many <strong>browsers</strong> do not support HTTP methods other than POST/GET.</p>
<p>Many <strong>browsers</strong> behaviors store the page address, but this doesn't mean you can ignore any of these other issues.</p>
<p>So to be specific:</p>
<blockquote>
<p>Is one inherently more secure then another? I realize that POST doesn't expose information on the URL but is there any real value in that or is it just security through obscurity? What is the best practice here?</p>
</blockquote>
<p>This is correct, because the software you're using to speak HTTP tends to store the request variables with one method but not another only prevents someone from looking at your browser history or some other naive attack from a 10 year old who thinks they understand h4x0r1ng, or scripts that check your history store. If you have a script that can check your history store, you could just as easily have one that checks your network traffic, so this entire security through obscurity is only providing obscurity to script kiddies and jealous girlfriends.</p>
<blockquote>
<p>Over https, POST data is encoded, but could urls be sniffed by a 3rd party? </p>
</blockquote>
<p>Here's how SSL works. Remember those two requests I sent above? Here's what they look like in SSL:
(I changed the page to <a href="https://encrypted.google.com/">https://encrypted.google.com/</a> as example.com doesn't respond on SSL).</p>
<h2>POST over SSL</h2>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">q5XQP</span><span class="pun">%</span><span class="typ">RWCd2u</span><span class="com">#o/T9oiOyR2_YO?yo/3#tR_G7 2_RO8w?FoaObi)</span><span class="pln">
oXpB_y</span><span class="pun">?</span><span class="pln">oO4q</span><span class="pun">?</span><span class="str">`2o?O4G5D12Aovo?C@?/P/oOEQC5v?vai /%0Odo
QVw#6eoGXBF_o?/u0_F!_1a0A?Q b%TFyS@Or1SR/O/o/_@5o&amp;_o
9q1/?q$7yOAXOD5sc$H`</span><span class="typ">BECo1w</span><span class="pun">/</span><span class="str">`4?)f!%geOOF/!/#Of_f&amp;AEI#
yvv/wu_b5?/o d9O?VOVOFHwRO/pO/OSv_/8/9o6b0FGOH61O?ti
/i7b?!_o8u%RS/Doai%/Be/d4$0sv_%YD2_/EOAO/C?vv/%X!T?R
_o_2yoBP)orw7H_yQsXOhoVUo49itare#cA?/c)I7R?YCsg ??c'
(_!(0u)o4eIis/S8Oo8_BDueC?1uUO%ooOI_o8WaoO/ x?B?oO@&amp;
Pw?os9Od!c?/$3bWWeIrd_?( `</span><span class="pln">P_C</span><span class="pun">?</span><span class="lit">7</span><span class="pln">_g5O</span><span class="pun">(</span><span class="pln">ob</span><span class="pun">(</span><span class="pln">go</span><span class="pun">?&amp;</span><span class="str">/ooRxR'u/</span><span class="pln">
T</span><span class="pun">/</span><span class="pln">yO3dS</span><span class="pun">&amp;??</span><span class="pln">hIOB</span><span class="pun">/?</span><span class="str">/OI?$oH2_?c_?OsD/</span><span class="pun">/</span><span class="lit">0</span><span class="pun">/</span><span class="pln">_s</span><span class="pun">%</span><span class="pln">r</span></code></pre>
<h2>GET over SSL</h2>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">rV</span><span class="pun">/</span><span class="pln">O8ow1pc</span><span class="str">`?058/8OS_Qy/$7oSsU'qoo#vCbOO`</span><span class="pln">vt</span><span class="pun">?</span><span class="pln">yFo_</span><span class="pun">?</span><span class="typ">EYif</span><span class="pun">)</span><span class="pln">
</span><span class="lit">43</span><span class="str">`I/WOP_8oH0%3OqP_h/cBO&amp;24?'?o_4`</span><span class="pln">scooPSOVWYSV</span><span class="pun">?</span><span class="pln">H</span><span class="pun">?</span><span class="pln">pV</span><span class="pun">!</span><span class="pln">i
</span><span class="pun">?</span><span class="lit">78cU</span><span class="pun">!</span><span class="pln">_b5h</span><span class="str">'/b2coWD?/43Tu?153pI/9?R8!_Od"(//O_a#t8x?__
bb3D?05Dh/PrS6_/&amp;5p@V f $)/xvxfgO'</span><span class="pln">q@y</span><span class="pun">&amp;</span><span class="pln">e</span><span class="pun">&amp;</span><span class="pln">S0rB3D</span><span class="pun">/</span><span class="pln">Y_</span><span class="pun">/</span><span class="pln">fO</span><span class="pun">?</span><span class="pln">
_</span><span class="str">'woRbOV?_!yxSOdwo1G1?8d_p?4fo81VS3sAOvO/Db/br)f4fOxt
_Qs3EO/?2O/TOo_8p82FOt/hO?X_P3o"OVQO_?Ww_dr"'</span><span class="typ">DxHwo</span><span class="com">//P</span><span class="pln">
oEfGtt</span><span class="pun">/</span><span class="pln">_o</span><span class="pun">)</span><span class="lit">5RgoGqui</span><span class="pun">&amp;</span><span class="typ">AXEq</span><span class="pun">/</span><span class="pln">oXv</span><span class="pun">&amp;</span><span class="com">//?%/6_?/x_OTgOEE%v (u(?/</span><span class="pln">
t7DX1O8oD</span><span class="pun">?</span><span class="pln">fVObiooi</span><span class="str">'8)so?o??`o"FyVOByY_ Supo? /'</span><span class="pln">i</span><span class="pun">?</span><span class="typ">Oi</span><span class="str">"4
tr'9/o_7too7q?c2Pv</span></code></pre>
<p>(note: I converted the HEX to ASCII, some of it should obviously not be displayable)</p>
<p>The entire HTTP conversation is encrypted, the only visible portion of communication is on the TCP/IP layer (meaning the IP address and connection port information).</p>
<h3>So let me make a big bold statement here. Your website is not provided greater security over one HTTP method than it is another, hackers and newbs all over the world know exactly how to do what I've just demonstrated here. If you want security, use SSL. Browsers tend to store history, it's recommended by RFC2616 9.1.1 to NOT use GET to perform an action, but to think that POST provides security is flatly wrong.
</h3>
<p>The only thing that POST is a security measure towards? Protection against your jealous ex flipping through your browser history. That's it. The rest of the world is logged into your account laughing at you.</p>
<p>To further demonstrate why POST isn't secure, Facebook uses POST requests all over the place, so how can software such as <a href="http://codebutler.com/firesheep">FireSheep</a> exist?</p>
<p>Note that you may be attacked with <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</a> even if you use HTTPS and your site does not contain <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> vulnerabilities. In short, this attack scenario assumes that the victim (the user of your site or service) is already logged in and has a proper cookie and then the victim's browser is requested to do something with your (supposedly secure) site. If you do not have protection against CSRF the attacker can still execute actions with the victims credentials. The attacker cannot see the server response because it will be transferred to the victim's browser but the damage is usually already done at that point.</p>
</div></text><author><a href="/users/257493">Incognito</a></author><comments><comment><text><span class="comment-copy">Extremely well written that deserves far more up votes</span></text><author><a class="comment-user" href="/users/433069/aolszowka" title="500 reputation">aolszowka</a></author></comment><comment><text><span class="comment-copy">A shame you didn't talk about CSRF :-). Is there any way to contact you?</span></text><author><a class="comment-user" href="/users/851498/florian-margaine" title="32,409 reputation">Florian Margaine</a></author></comment><comment><text><span class="comment-copy">@FlorianMargaine Add me on twitter and I'll DM you my email. <a href="https://twitter.com/#%21/BrianJGraham" rel="nofollow noreferrer">twitter.com/#!/BrianJGraham</a></span></text><author><a class="comment-user" href="/users/257493/incognito" title="13,664 reputation">Incognito</a></author></comment><comment><text><span class="comment-copy">Agree with @aolszowka. Very well written.</span></text><author><a class="comment-user" href="/users/166012/ckv" title="4,599 reputation">ckv</a></author></comment><comment><text><span class="comment-copy">Who said Facebook is secure? Good answer though. <code>+1</code>.</span></text><author><a class="comment-user" href="/users/1438393/amal-murali" title="51,802 reputation">Amal Murali</a></author></comment><comment><text><span class="comment-copy">"[...] so this entire security through obscurity is only providing obscurity to script kiddies and jealous girlfriends.[...]" . this entirely depends on the skills of the jealous gf. moreover, no gf/bf should be allowed to visit your browser history. ever. lol.</span></text><author><a class="comment-user" href="/users/422959/turkishweb" title="167 reputation">turkishweb</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>There is no added security.</strong></p>
<p>Post data does not show up in the history and/or log files but if the data should be kept secure, you need SSL.<br/>
Otherwise, anybody sniffing the wire can read your data anyway.</p>
</div></text><author><a href="/users/22674/jacco">Jacco</a></author><comments><comment><text><span class="comment-copy">SSL encodes POST data but a GET url is unencoded correct?</span></text><author><a class="comment-user owner" href="/users/20774/james-mcmahon" title="24,935 reputation">James McMahon</a></author></comment><comment><text><span class="comment-copy">if you GET a URL over SSL, a third party will not be able to see the URL, so the security is the same</span></text><author><a class="comment-user" href="/users/3029/davetron5000" title="14,020 reputation">davetron5000</a></author></comment><comment><text><span class="comment-copy">that's correct, nemo. Obviously users can still see the data in the URL.</span></text><author><a class="comment-user" href="/users/25066/eric-wendelin" title="23,200 reputation">Eric Wendelin</a></author></comment><comment><text><span class="comment-copy">GET information can only be seen at the start and end of the SSL tunnel</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">And the sys admins when they grep trough the log files.</span></text><author><a class="comment-user" href="/users/18771/tomalak" title="220,647 reputation">Tomalak</a></author></comment><comment><text><span class="comment-copy">I would say there is <i>some</i> added security in that POST data won't be stored in the user's browser history, but GET data will.</span></text><author><a class="comment-user" href="/users/18511/kip" title="56,176 reputation">Kip</a></author></comment><comment><text><span class="comment-copy">I think that my definition of 'security' is different from some people here</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">HTTP over SSL/TLS (implemented correctly) allows the attacker sniffing the wire (or actively tampering) to see only two thing -- the IP address of the destination, and the amount of data going both ways.</span></text><author><a class="comment-user" href="/users/14153/aaron" title="2,949 reputation">Aaron</a></author></comment><comment><text><span class="comment-copy">3 downvotes in a day, but no comment whatsoever?</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Even if <code>POST</code> gives no real security benefit versus <code>GET</code>, for login forms or any other form with relatively sensitive information, make sure you are using <code>POST</code> as:</p>
<ol>
<li>The information <code>POST</code>ed will not be saved in the user's history.</li>
<li>The sensitive information (password, etc.) sent in the form will not be visible later on in the URL bar (by using <code>GET</code>, it will be visible in the history and the URL bar).</li>
</ol>
<p>Also, <code>GET</code> has a theorical limit of data. <code>POST</code> doesn't.</p>
<p>For real sensitive info, make sure to use <code>SSL</code> (<code>HTTPS</code>)</p>
</div></text><author><a href="/users/26210/andrew-moore">Andrew Moore</a></author><comments><comment><text><span class="comment-copy">for 1.  Browser often, for the convenience of users,  save information posted in form fields.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment><comment><text><span class="comment-copy">@Kibbee: By spec, they shouldn't. The major browsers doesn't save that information.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">In the default settings, every time I enter a username and password in firefox / IE, it asks me if I want to save this information, specifically so I won't have to type it in later.</span></text><author><a class="comment-user" href="/users/1862/kibbee" title="47,390 reputation">Kibbee</a></author></comment><comment><text><span class="comment-copy">Andrew I think he means auto complete on user input fields. For instance, Firefox remembers all data I enter in my website, so when I begin to type text into a search box it will offer to complete the text with my previous searches.</span></text><author><a class="comment-user owner" href="/users/20774/james-mcmahon" title="24,935 reputation">James McMahon</a></author></comment><comment><text><span class="comment-copy">Yes, well, that's the point of auto-complete, isn't it. What I meant was the actually history, not auto-complete.</span></text><author><a class="comment-user" href="/users/26210/andrew-moore" title="66,537 reputation">Andrew Moore</a></author></comment><comment><text><span class="comment-copy">If the attacker can access full browser history, he has access to full browser auto-complete data, too.</span></text><author><a class="comment-user" href="/users/334451/mikko-rantalainen" title="4,667 reputation">Mikko Rantalainen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Neither one of GET and POST is inherently "more secure" than the other, just like neither one of fax and phone is "more secure" than the other. The various HTTP methods are provided so that you can choose the one which is most appropiate for the problem you're trying to solve. GET is more appropiate for <a href="http://en.wikipedia.org/wiki/Idempotence" rel="noreferrer">idempotent</a> queries while POST is more appropiate for "action" queries, but you can shoot yourself in the foot just as easily with any of them if you don't understand the security architecture for the application you're maintaining.</p>
<p>It's probably best if you read <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" rel="noreferrer">Chapter 9: Method Definitions</a> of the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" rel="noreferrer">HTTP/1.1 RFC</a> to get an overall idea of what GET and POST were originally envisioned ot mean.</p>
</div></text><author><a href="/users/14444/mihai-limb%c4%83%c8%99an">Mihai LimbÄƒÈ™an</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The difference between GET and POST should not be viewed in terms of security, but rather in their intentions towards the server.  GET should never change data on the server - at least other than in logs - but POST can create new resources.</p>
<p>Nice proxies won't cache POST data, but they may cache GET data from the URL, so you could say that POST is supposed to be more secure.  But POST data would still be available to proxies that don't play nicely.</p>
<p>As mentioned in many of the answers, the only sure bet is via SSL.</p>
<p>But DO make sure that GET methods do not commit any changes, such as deleting database rows, etc.</p>
</div></text><author><a href="/users/27600/ruquay">ruquay</a></author><comments><comment><text><span class="comment-copy">I agree with this. The question is not security, it's what POST and GET are designed to do.</span></text><author><a class="comment-user" href="/users/42048/pbreitenbach" title="8,596 reputation">pbreitenbach</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>My usual methodology for choosing is something like:</p>
<ul>
<li><strong>GET</strong> for items that will be <strong>retrieved</strong> later by URL

<ul>
<li>E.g. Search should be GET so you can do search.php?s=XXX later on</li>
</ul></li>
<li><strong>POST</strong> for items that will be <strong>sent</strong>
<ul>
<li>This is <em>relatively</em> invisible comapred to GET and harder to send, but data can still be sent via cURL.</li>
</ul></li>
</ul>
</div></text><author><a href="/users/2025/ross">Ross</a></author><comments><comment><text><span class="comment-copy">anybody can send POST data: &lt;form method="POST" action="<a href="http://whatever.com%22%3E" rel="nofollow noreferrer">whatever.com"&gt;</a>;</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">But it <i>is</i> harder to do a POST than a GET. A GET is just a URL in the address box. A POST requires a &lt;form&gt; in an HTML page or cURL.</span></text><author><a class="comment-user" href="/users/42048/pbreitenbach" title="8,596 reputation">pbreitenbach</a></author></comment><comment><text><span class="comment-copy">So a fake post takes notepad and 5 minutes of time... not really much harder.  I have used notepad to add features to a phone system that didn't exist.  I was able to create a copy of the admin forms for the system that would allow me to assign commands to buttons that "were not possible" as far the vendor was concerned.</span></text><author><a class="comment-user" href="/users/89586/matthew-whited" title="17,074 reputation">Matthew Whited</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Neither one magically confers security on a request, however GET implies some side effects that generally prevent it from being secure.</p>
<p>GET URLs show up in browser history and webserver logs.  For this reason, they should never be used for things like login forms and credit card numbers.</p>
<p>However, just POSTing that data doesn't make it secure, either.  For that you want SSL.  Both GET and POST send data in plaintext over the wire when used over HTTP.</p>
<p>There are other good reasons to POST data, too - like the ability to submit unlimited amounts of data, or hide parameters from casual users.</p>
<p>The downside is that users can't bookmark the results of a query sent via POST.  For that, you need GET.</p>
</div></text><author><a href="/users/27603/edebill">edebill</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This isn't security related but... <strong>browsers doesn't cache POST requests</strong>.</p>
</div></text><author><a href="/users/1100/daniel-silveira">Daniel Silveira</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Consider this situation: A sloppy API accepts GET requests like:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">http</span><span class="pun">:</span><span class="com">//www.example.com/api?apikey=abcdef123456&amp;action=deleteCategory&amp;id=1</span></code></pre>
<p>In some settings, when you request this URL and if there is an error/warning regarding the request, this whole line gets logged in the log file. Worse yet: if you forget to disable error messages in the production server, this information is just displayed in plain in the browser! Now you've just given your API key away to everyone.</p>
<p>Unfortunately, there are real API's working this way.</p>
<p>I wouldn't like the idea of having some sensitive info in the logs or displaying them in the browser. POST and GET is not the same. Use each where appropriate.</p>
</div></text><author><a href="/posts/8601786/revisions" id="history-8601786" title="show revision history for this post">
        Halil Ã–zgÃ¼r
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<ol>
<li><p>SECURITY as safety of data IN TRANSIT: no difference between POST and GET.</p></li>
<li><p>SECURITY as safety of data ON THE COMPUTER: POST is safer (no URL history)</p></li>
</ol>
</div></text><author><a href="/posts/1297819/revisions" id="history-1297819" title="show revision history for this post">
        kashmiri
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Many people adopt a convention (alluded to by Ross) that GET requests only retrieve data, and do not modify any data on the server, and POST requests are used for all data modification.  While one is not more inherently secure than the other, if you <em>do</em> follow this convention, you can apply cross-cutting security logic (e.g. only people with accounts can modify data, so unauthenticated POSTs are rejected).  </p>
</div></text><author><a href="/users/23883/eric-r-rath">Eric R. Rath</a></author><comments><comment><text><span class="comment-copy">Actually it isn't a "convention" it's part of the HTTP standard. The RFC is very explicit in what to expect from the different methods.</span></text><author><a class="comment-user" href="/users/24243/john-nilsson" title="7,924 reputation">John Nilsson</a></author></comment><comment><text><span class="comment-copy">In fact if you allow GET requests to modify state then it's possible a browser that is pre-fetching pages it thinks you might visit will accidentally take actions you didn't want it to.</span></text><author><a class="comment-user" href="/users/257321/jessta" title="1,576 reputation">Jessta</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It is harder to alter a POST request (it requires more effort than editing the query string). <strong>Edit:</strong> In other words, it's only security by obscurity, and barely that.</p>
</div></text><author><a href="/users/17964/eyelidlessness">eyelidlessness</a></author><comments><comment><text><span class="comment-copy">I can alter POST requests just as easy as query string requests, using a few add ons for Firefox.  i can even modify cookie data to my heart's content.</span></text><author><a class="comment-user" href="/users/18893/stephenbayer" title="7,351 reputation">stephenbayer</a></author></comment><comment><text><span class="comment-copy">Yeah, not that much harder. Might slow the script kiddies down, but they're still out there.</span></text><author><a class="comment-user" href="/users/2757/danimal" title="6,279 reputation">Danimal</a></author></comment><comment><text><span class="comment-copy">it won't slow down script kiddies, it is exactly the type of thing script kiddies try all the time.   The problem is that they sometimes succeed.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">Uh. Using addons for Firefox = more effort than query string.</span></text><author><a class="comment-user" href="/users/17964/eyelidlessness" title="43,318 reputation">eyelidlessness</a></author></comment><comment><text><span class="comment-copy">Your answer will give people a false sense that they are being more secure when using a post, when in fact, they are not.  Bad answer, bad man.</span></text><author><a class="comment-user" href="/users/96/chris-marasti-georg" title="24,112 reputation">Chris Marasti-Georg</a></author></comment><comment><text><span class="comment-copy">I edited to make the intent of my answer more clear. Hopefully that helps.</span></text><author><a class="comment-user" href="/users/17964/eyelidlessness" title="43,318 reputation">eyelidlessness</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm not about to repeat all the other answers, but there's one aspect that I haven't yet seen mentioned - it's the story of disappearing data. I don't know where to find it, but... </p>
<p>Basically it's about a web application that mysteriously every few night did loose all its data and nobody knew why. Inspecting the Logs later revealed that the site was found by google or another arbitrary spider, that happily GET (read: GOT) all the links it found on the site - including the "delete this entry" and "are you sure?" links. </p>
<p>Actually - part of this has been mentioned. This is the story behind "don't change data on GET but only on POST". Crawlers will happily follow GET, never POST. Even robots.txt doesn't help against misbehaving crawlers.</p>
</div></text><author><a href="/users/13447/olaf-kock">Olaf Kock</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You should also be aware that if your sites contains link to other external sites you dont control using GET will put that data in the refeerer header on the external sites when they press the links on your site. So transfering login data through GET methods is ALWAYS a big issue. Since that might expose login credentials for easy access by just checking the logs or looking in Google analytics (or similar).</p>
</div></text><author><a href="/posts/4718850/revisions" id="history-4718850" title="show revision history for this post">
        3cho
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The notion of security is meaningless unless you define what it is that you want to be secure against.</p>
<p>If you want to be secure against stored browser history, some types of logging, and people looking at your URLs, then POST is more secure.</p>
<p>If you want to be secure against somebody sniffing your network activity, then there's no difference.</p>
</div></text><author><a href="/posts/10198686/revisions" id="history-10198686" title="show revision history for this post">
        Taymon
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>RFC7231:</p>
<p>"   URIs are intended to be shared, not secured, even when they identify
   secure resources.  URIs are often shown on displays, added to
   templates when a page is printed, and stored in a variety of
   unprotected bookmark lists.  It is therefore unwise to include
   information within a URI that is sensitive, personally identifiable,
   or a risk to disclose.</p>
<p>Authors of services ought to avoid GET-based forms for the submission
   of sensitive data because that data will be placed in the
   request-target.  Many existing servers, proxies, and user agents log
   or display the request-target in places where it might be visible to
   third parties.  Such services ought to use POST-based form submission
   instead."</p>
<p>This RFC clearly states that sensitive data should not be submitted using GET. Because of this remark, some implementors might not handle data obtained from the query portion of a GET request with the same care. I'm working on a protocol myself that ensures integrity of data. According to this spec I shouldn't have to guarantee integrity of the GET data (which I will because nobody adheres to these specs)</p>
</div></text><author><a href="/posts/33782504/revisions" id="history-33782504" title="show revision history for this post">
        Silver
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As previously some people have said, HTTPS brings security.</p>
<p>However, POST is a bit more safe than GET because GET could be stored in the history.</p>
<p>But even more, sadly, sometimes the election of POST or GET is not up to the developer.  For example a hyperlink is always send by GET (unless its transformed into a post form using javascript).</p>
</div></text><author><a href="/posts/35813468/revisions" id="history-35813468" title="show revision history for this post">
        magallanes
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>GET is visible to anyone (even the one on your shoulder now) and is saved on cache, so is less secure of using post, btw post without some cryptographics routine is not sure, for a bit of security you've to use SSL (https)</p>
</div></text><author><a href="/users/27340/kentaromiura">kentaromiura</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>One reason <strong>POST is worse for security is that GET</strong> is logged by default, parameters and all data is almost universally logged by your webserver.</p>
<p><a href="http://stackoverflow.com/questions/989967/best-way-to-log-post-data-in-apache">POST</a> is the <em>opposite</em>, it's almost universally <strong>not logged</strong>, leading to very difficult to spot attacker activity.  </p>
<p>I don't buy the argument "it's too big", that's no reason to not log <em>anything</em>, at least 1KB, would go a long way for people to identify attackers working away at a weak entry-point until it pop's, then POST does a double dis-service, by enabling any HTTP based back-door to silently pass unlimited amounts of data.</p>
</div></text><author><a href="/posts/5797770/revisions" id="history-5797770" title="show revision history for this post">
        RandomNickName42
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The difference is that GET sends data open and POST hidden (in the http-header).</p>
<p>So get is better for non-secure data, like query strings in Google. Auth-data shall never be send via GET - so use POST here. Of course the whole theme is a little more complicated. If you want to read more, read <a href="http://geekroom.de/entwicklung/webentwickler-get-oder-post/" rel="nofollow">this article</a> (in German).</p>
</div></text><author><a href="/users/561729">Daniel</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Recently <a href="http://breachattack.com/" rel="nofollow">an attack</a> was published, that allows man in a middle to reveal request body of compressed HTTPS requests. Because request headers and URL are not compressed by HTTP, GET requests are better secured against this particular attack. </p>
<p><a href="http://en.wikipedia.org/wiki/CRIME_%28security_exploit%29" rel="nofollow">There are modes</a> in which GET requests are also vulnerable, SPDY compresses request headers, TLS also provides an optional (rarely used) compression. In these scenarios the attack is easier to prevent (browser vendors already provided fixes). HTTP level compression is a more fundamental feature, it is unlikely that vendors will disable it.</p>
<p>It is just an example that shows a scenario in which GET is more secure than POST, but I don't think it would be a good idea to choose GET over POST from this attack reason. The attack is quite sophisticated and requires non-trivial prerequisites (Attacker needs to be able to control part of the request content). It is better to disable HTTP compression in scenarios where the attack would be harmful.</p>
</div></text><author><a href="/users/1031601">Jan Wrobel</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This is an old post, but I'd like to object to some of the answers. If you're transferring sensitive data, you'll want to be using SSL. If you use SSL with a GET parameter (e.g. ?userid=123), that data will be sent in plain text! If you send using a POST, the values get put in the encrypted body of the message, and therefore are not readable to most MITM attacks.</p>
<p>The big distinction is where the data is passed. It only makes sense that if the data is placed in a URL, it CAN'T be encrypted otherwise you wouldn't be able to route to the server because only you could read the URL. That's how a GET works.</p>
<p>In short, you can securely transmit data in a POST over SSL, but you cannot do so with a GET, using SSL or not.</p>
</div></text><author><a href="/posts/9116864/revisions" id="history-9116864" title="show revision history for this post">
        LVM
        </a></author><comments><comment><text><span class="comment-copy">This is completely untrue. SSL is a transport layer protocol. It connects to the server FIRST, then sends ALL Application data as an encrypted binary stream of data. Check out this thread: <a href="http://answers.google.com/answers/threadview/id/758002.html" rel="nofollow noreferrer">answers.google.com/answers/threadview/id/758002.html</a></span></text><author><a class="comment-user" href="/users/636131/simeon-g" title="827 reputation">Simeon G</a></author></comment><comment><text><span class="comment-copy">Do a TCPDump and you'll see that this is 100% true. In order to connect to the server, you have to send your request unencrypted. If you do that as a GET, your args get added to the initial request and are therefore unencrypted. Regardless of what you see in the post you linked, you can test this with TCPDump (or similar).</span></text><author><a class="comment-user" href="/users/1150655/lvm" title="6 reputation">LVM</a></author></comment><comment><text><span class="comment-copy">Done! Just ran tcpdump on my Mac. And your answer came up 100% false. Here's the command I used:    sudo tcpdump -w ssl.data -A -i en1 -n dst port 443 Then when I looked in ssl.data of course I saw gobly gook. All HTTP data was encrypted. And to make sure a normal non-ssl call worked, I used:    sudo tcpdump -w clear.data -A -i en1 -n dst port 80 And sure enough, inside clear.data I had all headers and URIs showing in the clear. I tested this on my gmail and google plus (which are HTTPS) and on some non SSL pages like google.com.</span></text><author><a class="comment-user" href="/users/636131/simeon-g" title="827 reputation">Simeon G</a></author></comment><comment><text><span class="comment-copy">I'm not a network expert so if you think I used the wrong commands on tcpdump please feel free to correct me.</span></text><author><a class="comment-user" href="/users/636131/simeon-g" title="827 reputation">Simeon G</a></author></comment><comment><text><span class="comment-copy">I don't have the command offhand, but you can also check it with Wireshark/Ethereal.</span></text><author><a class="comment-user" href="/users/1150655/lvm" title="6 reputation">LVM</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Even POST accepts GET requests. Assume you have a form having inputs like user.name and user.passwd, those are supposed to support user name and password. If we simply add a ?user.name="my user&amp;user.passwd="my password", then request will be accepted by "bypassing the logon page".</p>
<p>A solution for this is to implement filters (java filters as an e) on server side and detect no string queries are passed as GET arguments.</p>
</div></text><author><a href="/posts/12969266/revisions" id="history-12969266" title="show revision history for this post">
        Saber Chebka
        </a></author><comments><comment><text><span class="comment-copy">Not true! This depends entirely on your backend as to whether code accepting POSTs also accepts GETs.</span></text><author><a class="comment-user" href="/users/391445/colin-t-hart" title="3,896 reputation">Colin 't Hart</a></author></comment></comments></answer></answers></post>