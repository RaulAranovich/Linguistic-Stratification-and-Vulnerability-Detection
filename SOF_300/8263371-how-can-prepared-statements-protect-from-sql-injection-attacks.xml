<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How can prepared statements protect from SQL injection attacks? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>How do <a href="http://en.wikipedia.org/wiki/Prepared_statement">prepared statements</a> help us prevent <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection</a> attacks?</p>
<p>Wikipedia says:</p>
<blockquote>
<p>Prepared statements are resilient against SQL injection, because
  parameter values, which are transmitted later using a different
  protocol, need not be correctly escaped. If the original statement
  template is not derived from external input, SQL injection cannot
  occur.</p>
</blockquote>
<p>I cannot see the reason very well. What would be a simple explanation in easy English and some examples?</p>
</div></text><author><a href="/users/63550/peter-mortensen">Peter Mortensen</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The idea is very simple - the query and the data are sent to the SQL server <em>separately</em>.<br/>
That's all.</p>
<p>The root of the SQL injection problem is <strong>mixing of the code and the data.</strong> </p>
<p>In fact, our SQL query is <strong>a full legitimate program</strong>. 
And we are creating this program dynamically by adding some data on the fly. Thus, this data may interfere with program <em>code</em> and even alter it, as every injection example shows it:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pun">$</span><span class="pln">expected_data </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
</span><span class="pun">$</span><span class="pln">query         </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM users where id=$expected_data"</span><span class="pun">;</span></code></pre>
<p>will produce a regular query </p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">SELECT</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">FROM</span><span class="pln"> users </span><span class="kwd">where</span><span class="pln"> id</span><span class="pun">=</span><span class="lit">1</span></code></pre>
<p>while this code</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pun">$</span><span class="pln">spoiled_data </span><span class="pun">=</span><span class="pln"> </span><span class="str">"1; DROP TABLE users;"</span><span class="pln">
</span><span class="pun">$</span><span class="pln">query        </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM users where id=$spoiled_data"</span><span class="pun">;</span></code></pre>
<p>will produce malicious sequence</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">SELECT</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">FROM</span><span class="pln"> users </span><span class="kwd">where</span><span class="pln"> id</span><span class="pun">=</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">DROP</span><span class="pln"> </span><span class="kwd">TABLE</span><span class="pln"> users</span><span class="pun">;</span></code></pre>
<p>It works because we are adding data directly to the program body and it become a part of the program. </p>
<p>So, the data may alter the program and depending on the data passed, we will have either regular output or table <code>users</code> deleted.</p>
<p>While <strong>in case of prepared statements we don't alter our program, it remains intact</strong><br/>
That's the point. </p>
<p>We are sending <em>program</em> to the server first</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pun">$</span><span class="pln">db-</span><span class="pun">&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"SELECT * FROM users where id=?"</span><span class="pun">);</span></code></pre>
<p>where the data is substituted by some <em>variable</em> called "placeholder".</p>
<p>Note that the very same query being sent to the server, without any data in it! And then we're sending the data with the second request, totally separated from the query itself:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pun">$</span><span class="pln">db-</span><span class="pun">&gt;</span><span class="kwd">execute</span><span class="pun">($</span><span class="pln">data</span><span class="pun">);</span></code></pre>
<p>so, it can't alter our program and do any harm.<br/>
Quite simple - isn't it? </p>
<p>However, it worth to be noted that <strong>not every time</strong> you're using placeholder, <strong>it is processed as a prepared statement</strong>.</p>
<p>Placeholder is a general idea for substituting actual data with a variable for the future processing, while prepared statement is the only subset of them.  </p>
<p>So, sometimes we actually have to compose query along with data, but <strong>if every bit of data is properly formatted according to it's type - nothing wrong could be happen</strong>.  </p>
<p>So, for example, by default PDO <strong>do not use prepared statements</strong> but rather compose the regular query. But because it substitutes every placeholder with properly formatted data, nothing bad could happen.</p>
<p>But it you want to tell PDO to do it straight way, to use real prepared statements, you have to set this setting:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pun">$</span><span class="pln">dbh-</span><span class="pun">&gt;</span><span class="pln">setAttribute</span><span class="pun">(</span><span class="pln"> PDO</span><span class="pun">::</span><span class="pln">ATTR_EMULATE_PREPARES</span><span class="pun">,</span><span class="pln"> false </span><span class="pun">);</span></code></pre>
<p>Please also note that <strong>formatting is not to be confused with escaping</strong>. Formatting involves a lot more actions than silly escaping. So, do not try manual escaping at home, at least until you get to know every formatting rule for the every distinct query part.</p>
<p>The only thing I have to add, always omitted in the every manual:</p>
<p>Prepared statements can protect only <em>data</em>, but <strong>can't defend the program itself</strong>.<br/>
So, once we have to add, say, a dynamical <strong>identifier</strong> - a field name, for example, prepared statements can't help us. 
I've <a href="http://stackoverflow.com/q/8255054/285587"><strong>explained the matter recently</strong></a>, so I won't repeat myself. </p>
</div></text><author><a href="/users/285587/your-common-sense">Your Common Sense</a></author><comments><comment><text><span class="comment-copy">"for example, by default PDO do not use prepared statements" - it is not exactly true, because PDO emulate prepared statements only for drivers that doesn't support such feature.</span></text><author><a class="comment-user" href="/users/1461984/pinepain" title="6,970 reputation">pinepain</a></author></comment><comment><text><span class="comment-copy">@zaq178miami: "PDO emulates prepared statements only for drivers that don't support the feature" - is not exactly true.  MySQL has supported prepared statements for quite a while now.  The PDO driver has as well.  But yet, MySQL queries were still prepared by PDO by default, last time i checked.</span></text><author><a class="comment-user" href="/users/319403/chao" title="58,174 reputation">cHao</a></author></comment><comment><text><span class="comment-copy">What is different between <code>$spoiled_data = "1; DROP TABLE users;"</code> -&gt; <code>$query        = "SELECT * FROM users where id=$spoiled_data";</code>, compared to: <code>$db-&gt;prepare("SELECT * FROM users where id=?");</code>-&gt; <code>$data = "1; DROP TABLE users;"</code> -&gt; <code>$db-&gt;execute($data);</code>. Won't they do the same thing?</span></text><author><a class="comment-user" href="/users/1488445/juha-untinen" title="375 reputation">Juha Untinen</a></author></comment><comment><text><span class="comment-copy">@Juha Untinen The data can be anything. It will not parse the data. That is DATA not the command. So even if the $data contains sql commands, it will not be executed. Also, if the id is a number, then the string content will generate a report or value zero.</span></text><author><a class="comment-user" href="/users/2655623/salivan" title="924 reputation">Salivan</a></author></comment><comment><text><span class="comment-copy">awesomely explained! Thanks</span></text><author><a class="comment-user" href="/users/4441060/candh" title="155 reputation">candh</a></author></comment><comment><text><span class="comment-copy">Nobody said anything about PDO or PHP</span></text><author><a class="comment-user" href="/users/855567/adam-f" title="1,445 reputation">Adam F</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Here is SQL for setting up an example:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">CREATE</span><span class="pln"> </span><span class="kwd">TABLE</span><span class="pln"> employee</span><span class="pun">(</span><span class="pln">name varchar</span><span class="pun">,</span><span class="pln"> paymentType varchar</span><span class="pun">,</span><span class="pln"> amount bigint</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">INSERT</span><span class="pln"> </span><span class="kwd">INTO</span><span class="pln"> employee </span><span class="kwd">VALUES</span><span class="pun">(</span><span class="str">'Aaron'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'salary'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">100</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">INSERT</span><span class="pln"> </span><span class="kwd">INTO</span><span class="pln"> employee </span><span class="kwd">VALUES</span><span class="pun">(</span><span class="str">'Aaron'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'bonus'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">50</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">INSERT</span><span class="pln"> </span><span class="kwd">INTO</span><span class="pln"> employee </span><span class="kwd">VALUES</span><span class="pun">(</span><span class="str">'Bob'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'salary'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">50</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">INSERT</span><span class="pln"> </span><span class="kwd">INTO</span><span class="pln"> employee </span><span class="kwd">VALUES</span><span class="pun">(</span><span class="str">'Bob'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'bonus'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span></code></pre>
<p>The Inject class is vulnerable to SQL injection. The query is dynamically pasted together with user input. The intent of the query was to show information about Bob. Either salary or bonus, based on user input. But the malicious user manipulates the input corrupting the query by tacking on the equivalent of an 'or true' to the where clause so that everything is returned, including the information about Aaron which was supposed to be hidden.</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">import java</span><span class="pun">.</span><span class="pln">sql</span><span class="pun">.*;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> class Inject </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> static void main</span><span class="pun">(</span><span class="pln">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> throws SQLException </span><span class="pun">{</span><span class="pln">

        String url </span><span class="pun">=</span><span class="pln"> </span><span class="str">"jdbc:postgresql://localhost/postgres?user=user&amp;password=pwd"</span><span class="pun">;</span><span class="pln">
        Connection conn </span><span class="pun">=</span><span class="pln"> DriverManager</span><span class="pun">.</span><span class="pln">getConnection</span><span class="pun">(</span><span class="pln">url</span><span class="pun">);</span><span class="pln">

        Statement stmt </span><span class="pun">=</span><span class="pln"> conn</span><span class="pun">.</span><span class="pln">createStatement</span><span class="pun">();</span><span class="pln">
        String sql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT paymentType, amount FROM employee WHERE name = 'bob' AND paymentType='"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> args</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"'"</span><span class="pun">;</span><span class="pln">
        System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">sql</span><span class="pun">);</span><span class="pln">
        ResultSet rs </span><span class="pun">=</span><span class="pln"> stmt</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">(</span><span class="pln">sql</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rs</span><span class="pun">.</span><span class="pln">next</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">rs</span><span class="pun">.</span><span class="pln">getString</span><span class="pun">(</span><span class="str">"paymentType"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> rs</span><span class="pun">.</span><span class="pln">getLong</span><span class="pun">(</span><span class="str">"amount"</span><span class="pun">));</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Running this, the first case is with normal usage, and the second with the malicious injection:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">c</span><span class="pun">:\</span><span class="pln">temp</span><span class="pun">&gt;</span><span class="pln">java Inject salary
</span><span class="kwd">SELECT</span><span class="pln"> paymentType</span><span class="pun">,</span><span class="pln"> amount </span><span class="kwd">FROM</span><span class="pln"> employee </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'bob'</span><span class="pln"> </span><span class="kwd">AND</span><span class="pln"> paymentType</span><span class="pun">=</span><span class="str">'salary'</span><span class="pln">
salary </span><span class="lit">50</span><span class="pln">

c</span><span class="pun">:\</span><span class="pln">temp</span><span class="pun">&gt;</span><span class="pln">java Inject </span><span class="str">"salary' OR 'a'!='b"</span><span class="pln">
</span><span class="kwd">SELECT</span><span class="pln"> paymentType</span><span class="pun">,</span><span class="pln"> amount </span><span class="kwd">FROM</span><span class="pln"> employee </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'bob'</span><span class="pln"> </span><span class="kwd">AND</span><span class="pln"> paymentType</span><span class="pun">=</span><span class="str">'salary'</span><span class="pln"> </span><span class="kwd">OR</span><span class="pln"> </span><span class="str">'a'</span><span class="pun">!=</span><span class="str">'b'</span><span class="pln">
salary </span><span class="lit">100</span><span class="pln">
bonus </span><span class="lit">50</span><span class="pln">
salary </span><span class="lit">50</span><span class="pln">
bonus </span><span class="lit">0</span></code></pre>
<p>You should not build your SQL statements with string concatenation of user input. Not only is it vulnerable to injection, but it has caching implications on the server as well (the statement changes, so less likely to get a SQL statement cache hit whereas the bind example is always running the same statement).</p>
<p>Here is an example of Binding to avoid this kind of injection:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">import java</span><span class="pun">.</span><span class="pln">sql</span><span class="pun">.*;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> class Bind </span><span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> static void main</span><span class="pun">(</span><span class="pln">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> throws SQLException </span><span class="pun">{</span><span class="pln">

        String url </span><span class="pun">=</span><span class="pln"> </span><span class="str">"jdbc:postgresql://localhost/postgres?user=postgres&amp;password=postgres"</span><span class="pun">;</span><span class="pln">
        Connection conn </span><span class="pun">=</span><span class="pln"> DriverManager</span><span class="pun">.</span><span class="pln">getConnection</span><span class="pun">(</span><span class="pln">url</span><span class="pun">);</span><span class="pln">

        String sql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT paymentType, amount FROM employee WHERE name = 'bob' AND paymentType=?"</span><span class="pun">;</span><span class="pln">
        System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">sql</span><span class="pun">);</span><span class="pln">

        PreparedStatement stmt </span><span class="pun">=</span><span class="pln"> conn</span><span class="pun">.</span><span class="pln">prepareStatement</span><span class="pun">(</span><span class="pln">sql</span><span class="pun">);</span><span class="pln">
        stmt</span><span class="pun">.</span><span class="pln">setString</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> args</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]);</span><span class="pln">

        ResultSet rs </span><span class="pun">=</span><span class="pln"> stmt</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">();</span><span class="pln">

        </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rs</span><span class="pun">.</span><span class="pln">next</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">rs</span><span class="pun">.</span><span class="pln">getString</span><span class="pun">(</span><span class="str">"paymentType"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> rs</span><span class="pun">.</span><span class="pln">getLong</span><span class="pun">(</span><span class="str">"amount"</span><span class="pun">));</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Running this with the same input as the previous example shows the malicious code does not work because there is no paymentType matching that string:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">c</span><span class="pun">:\</span><span class="pln">temp</span><span class="pun">&gt;</span><span class="pln">java Bind salary
</span><span class="kwd">SELECT</span><span class="pln"> paymentType</span><span class="pun">,</span><span class="pln"> amount </span><span class="kwd">FROM</span><span class="pln"> employee </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'bob'</span><span class="pln"> </span><span class="kwd">AND</span><span class="pln"> paymentType</span><span class="pun">=?</span><span class="pln">
salary </span><span class="lit">50</span><span class="pln">

c</span><span class="pun">:\</span><span class="pln">temp</span><span class="pun">&gt;</span><span class="pln">java Bind </span><span class="str">"salary' OR 'a'!='b"</span><span class="pln">
</span><span class="kwd">SELECT</span><span class="pln"> paymentType</span><span class="pun">,</span><span class="pln"> amount </span><span class="kwd">FROM</span><span class="pln"> employee </span><span class="kwd">WHERE</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'bob'</span><span class="pln"> </span><span class="kwd">AND</span><span class="pln"> paymentType</span><span class="pun">=?</span></code></pre>
</div></text><author><a href="/users/726422/glenn">Glenn</a></author><comments><comment><text><span class="comment-copy">Does using a prepared statement from the program connecting to the database have the same effect as using a prepared statement that's part of the db? For example Postgres has it's own prepared statement and would using it prevent SQL injection? <a href="http://www.postgresql.org/docs/9.2/static/sql-prepare.html" rel="nofollow noreferrer">postgresql.org/docs/9.2/static/sql-prepare.html</a></span></text><author><a class="comment-user" href="/users/1279820/celeritas" title="4,454 reputation">Celeritas</a></author></comment><comment><text><span class="comment-copy">@Celeritas I don't have a definitive answer for Postgresql. Looking at the docs, it appears the effect is the same. <code>PREPARE</code> creates a fixed named statement that is already parsed  (i.e. the statement is not going to change any more regardless of the input) while <code>EXECUTE</code> will run the named statement binding the parameters. Since <code>PREPARE</code> only has session duration, it really looks like it is meant for performance reasons, not for preventing injection via psql scripts. For psql access, could give permissions to stored procedures and bind the parameters within the procs.</span></text><author><a class="comment-user" href="/users/726422/glenn" title="6,559 reputation">Glenn</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Basically, with prepared statements the data coming in from a potential hacker is treated as data - and there's no way it can be intermixed with your application SQL and/or be interpreted as SQL (which can happen when data passed in is placed directly into your application SQL).</p>
<p>This is because prepared statements "prepare" the SQL query first to find an efficient query plan, and send the actual values that presumably come in from a form later - at that time the query is actually executed.  </p>
<p>More great info here:</p>
<p><a href="http://www.programmerinterview.com/index.php/database-sql/example-of-prepared-statements-and-sql-injection-prevention/">Prepared statements and SQL Injection</a></p>
</div></text><author><a href="/users/1348090/jose">Jose</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>In <a href="http://en.wikipedia.org/wiki/Microsoft_SQL_Server" rel="nofollow">SQL Server</a>, using a prepared statement is definitely injection-proof because the input parameters don't form the query. It means that the executed query is not a dynamic query.
Example of an SQL injection vulnerable statement.</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">string sqlquery </span><span class="pun">=</span><span class="pln"> </span><span class="str">"select * from table where username='"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> inputusername </span><span class="pun">+</span><span class="str">"' and password='"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> pass </span><span class="pun">+</span><span class="pln"> </span><span class="str">"'"</span><span class="pun">;</span></code></pre>
<p>Now if the value in the inoutusername variable is something like a' or 1=1 --, this query now becomes:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">select</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="kwd">table</span><span class="pln"> </span><span class="kwd">where</span><span class="pln"> username</span><span class="pun">=</span><span class="str">'a'</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> </span><span class="com">-- and password=asda</span></code></pre>
<p>And the rest is commented after <code>--</code>, so it never gets executed and bypassed as using the prepared statement example as below.</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">Sqlcommand command </span><span class="pun">=</span><span class="pln"> new sqlcommand</span><span class="pun">(</span><span class="str">"select * from table where username = @userinput and password=@pass"</span><span class="pun">);</span><span class="pln">
command</span><span class="pun">.</span><span class="pln">Parameters</span><span class="pun">.</span><span class="kwd">Add</span><span class="pun">(</span><span class="pln">new SqlParameter</span><span class="pun">(</span><span class="str">"@userinput"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">100</span><span class="pun">));</span><span class="pln">
command</span><span class="pun">.</span><span class="pln">Parameters</span><span class="pun">.</span><span class="kwd">Add</span><span class="pun">(</span><span class="pln">new SqlParameter</span><span class="pun">(</span><span class="str">"@pass"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">100</span><span class="pun">));</span><span class="pln">
command</span><span class="pun">.</span><span class="pln">prepare</span><span class="pun">();</span></code></pre>
<p>So in effect you cannot send another parameter in, thus avoiding SQL injection...</p>
</div></text><author><a href="/users/1059329/lloydom">lloydom</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The key phrase is  <code>need not be correctly escaped</code>. That means that you don't to worry about people trying to throw in dashes, apostrophes, quotes, etc...</p>
<p>It is all handled for you.</p>
</div></text><author><a href="/users/451192/feisty-mango">Feisty Mango</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">ResultSet rs </span><span class="pun">=</span><span class="pln"> statement</span><span class="pun">.</span><span class="pln">executeQuery</span><span class="pun">(</span><span class="str">"select * from foo where value = "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> httpRequest</span><span class="pun">.</span><span class="pln">getParameter</span><span class="pun">(</span><span class="str">"filter"</span><span class="pun">);</span></code></pre>
<p>Let’s assume you have that in a Servlet you right. If a malevolent person passed a bad value for 'filter' you might hack your database.</p>
</div></text><author><a href="/users/100565/mebigfatguy">MeBigFatGuy</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>When you create and send a prepared statement to the DBMS, it's stored as the SQL query for execution.</p>
<p>You later bind your data to the query such that the DBMS uses that data as the query parameters for execution (parameterization).  The DBMS doesn't use the data you bind as a supplemental to the already compiled SQL query; it's simply the data.</p>
<p>This means it's fundamentally impossible to perform SQL injection using prepared statements.  The very nature of prepared statements and their relationship with the DBMS prevents this.</p>
</div></text><author><a href="/users/512994/wulfgarpro">wulfgarpro</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Root Cause #1 - The Delimiter Problem</strong></p>
<p>Sql injection is possible because we use quotation marks to delimit strings and also to be parts of strings, making it impossible to interpret them sometimes.  If we had delimiters that could not be used in string data, sql injection never would have happened. Solving the delimiter problem eliminates the sql injection problem. Structure queries do that.</p>
<p><strong>Root Cause #2 - Human Nature, People are Crafty and <em>Some Crafty People Are Malicious</em></strong> <strong><em>And All People Make Mistakes</em></strong></p>
<p>The other root cause of sql injection is human nature.  People, including programmers, make mistakes.  When you make a mistake on a structured query, it does not make your system vulnerable to sql injection.  If you are not using structured queries, mistakes can generate sql injection vulnerability.</p>
<p><strong>How Structured Queries Resolve the Root Causes of SQL Injection</strong></p>
<p>Structured Queries Solve The Delimiter Problem, by by putting sql commands in one statement and putting the  data  in a separate programming statement.  Programming statements create the separation needed.</p>
<p><strong>Structured queries help prevent human error from creating critical security holes.</strong>
With regard to humans making mistakes, sql injection cannot happen when structure queries are used. There are ways of preventing sql injection that don't involve structured queries, but normal human error in that approaches usually leads to at least some exposure to sql injection.  Structured Queries are fail safe from sql injection.  You can make all the mistakes in the world, almost, with structured queries, same as any other programming, but none that you can make can be turned into a ssstem taken over by sql injection.  That is why people like to say this is the right way to prevent sql injection.</p>
<p>So, there you have it, the causes of sql injection and the nature structured queries that makes them impossible when they are used.</p>
</div></text><author><a href="/users/1569275/danallen">DanAllen</a></author><comments/></answer></answers></post>