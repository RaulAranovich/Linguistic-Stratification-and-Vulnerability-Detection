<?xml version="1.0" encoding="utf-8"?>
<post><title>How to solve performance problem with Java SecureRandom? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>If you want a cryptographically strong random number in Java, you use SecureRandom. Unfortunately, SecureRandom can be very slow. If it uses /dev/random on Linux, it can block waiting for sufficient entropy to build up. How do you avoid the peformance penalty?</p>
<p>Has anyone used <a href="https://uncommons-maths.dev.java.net/" rel="noreferrer">Uncommon Maths</a> as a solution to this problem?</p>
<p>Can anybody confirm that this performance problem has been solved in JDK 6?</p>
</div></text><author><a href="/users/3150/david-g">David G</a></author><comments><comment><text><span class="comment-copy">It seems this is related to <a href="http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html#generateSeed%28int%29" rel="nofollow noreferrer">SecureRandom.generateSeed()</a> slowness. There's a rejected defect explaining the slowness and a workaround: <a href="http://bugs.java.com/view_bug.do?bug_id=6521844" rel="nofollow noreferrer">JDK-6521844 : SecureRandom hangs on Linux Systems</a></span></text><author><a class="comment-user" href="/users/435605/alikelzin-kilaka" title="13,167 reputation">AlikElzin-kilaka</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>If you want true random data, then unfortunately you have to wait for it. This includes the seed for a SecureRandom PRNG. Uncommon Maths can't gather true random data any faster than SecureRandom, although it can connect to the internet to download seed data from a particular website. My guess is that this is unlikely to be faster than /dev/random where that's available.</p>
<p>If you want a PRNG, do something like this:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="typ">SecureRandom</span><span class="pun">.</span><span class="pln">getInstance</span><span class="pun">(</span><span class="str">"SHA1PRNG"</span><span class="pun">);</span></code></pre>
<p>What strings are supported depends on the SecureRandom SPI provider, but you can enumerate them using Security.getProviders() and Provider.getService().</p>
<p>Sun is fond of SHA1PRNG, so it's widely available. It isn't especially fast as PRNGs go, but PRNGs will just be crunching numbers, not blocking for physical measurement of entropy.</p>
<p>The exception is that if you don't call setSeed() before getting data, then the PRNG will seed itself once the first time you call next() or nextBytes(). It will usually do this using a fairly small amount of true random data from the system. This call may block, but will make your source of random numbers far more secure than any variant of "hash the current time together with the PID, add 27, and hope for the best". If all you need is random numbers for a game, though, or if you want the stream to be repeatable in future using the same seed for testing purposes, an insecure seed is still useful.</p>
</div></text><author><a href="/users/13005/steve-jessop">Steve Jessop</a></author><comments><comment><text><span class="comment-copy">Uncommons Maths only downloads data from the Internet for seeding, it doesn't return that random data when generating random numbers.</span></text><author><a class="comment-user" href="/users/5171/dan-dyer" title="41,077 reputation">Dan Dyer</a></author></comment><comment><text><span class="comment-copy">Same with SecureRandom - the /dev/urandom is only for seeding.</span></text><author><a class="comment-user" href="/users/10080/avid" title="10,324 reputation">AviD</a></author></comment><comment><text><span class="comment-copy">Yep. When the questioner says "if you want a random number you use SecureRandom - this can be slow", I thought maybe he's using getSeed for everything and draining his entropy pool. The fix isn't to get JDK 6, it's to use SecureRandom the way it's intended ;-)</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">@Dan Dyer - I've corrected my comment about Uncommon Maths. I did take a look at your page, so I knew that by "random numbers" I meant "for its seed" rather that "to return to the user". But you're quite right that isn't what I said...</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">"it's widely available". Isn't it included with <i>every</i> compliant JDK? It's on the list of java security standard names... (<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SecureRandom" rel="nofollow noreferrer">docs.oracle.com/javase/8/docs/technotes/guides/security/…</a>)</span></text><author><a class="comment-user" href="/users/8313/sean-reilly" title="14,927 reputation">Sean Reilly</a></author></comment><comment><text><span class="comment-copy">@Sean: I don't remember how all this works now (question was a long time ago and I don't really do Java any more). But the documentation says "supplied by the SUN provider". So presumably it's always in the JDK, but needn't necessarily be included in Java implementations other than Oracle's.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">@SteveJessop from the standard names document: "The JDK Security API requires and uses a set of standard names for algorithms, certificate and keystore types." The provider name can certainly be different with a non-Oracle JDK, but I read this as requiring that the algorithm names are standard and don't change, i.e. there will always be some implementation of SHA1PRNG on every Java platform.</span></text><author><a class="comment-user" href="/users/8313/sean-reilly" title="14,927 reputation">Sean Reilly</a></author></comment><comment><text><span class="comment-copy">@SeanReilly: fortunately it's a <i>lot</i> of years since I last had to run a TCK and argue with Sun whether failures actually mean that the implementation doesn't conform or just that the tests don't match the spec :-)</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You should be able to select the faster-but-slightly-less-secure /dev/urandom on Linux using:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pun">-</span><span class="typ">Djava</span><span class="pun">.</span><span class="pln">security</span><span class="pun">.</span><span class="pln">egd</span><span class="pun">=</span><span class="pln">file</span><span class="pun">:/</span><span class="pln">dev</span><span class="pun">/</span><span class="pln">urandom</span></code></pre>
<p>However, this doesn't work with Java 5 and later (<a href="https://bugs.openjdk.java.net/browse/JDK-6202721" rel="noreferrer">Java Bug 6202721</a>). The suggested work-around is to use:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pun">-</span><span class="typ">Djava</span><span class="pun">.</span><span class="pln">security</span><span class="pun">.</span><span class="pln">egd</span><span class="pun">=</span><span class="pln">file</span><span class="pun">:/</span><span class="pln">dev</span><span class="pun">/./</span><span class="pln">urandom</span></code></pre>
<p>(note the extra '/./')</p>
</div></text><author><a href="/users/50926/thomas-leonard">Thomas Leonard</a></author><comments><comment><text><span class="comment-copy">Note that the Java Bug report says "Not a defect".  In other words even though the default is <code>/dev/urandom</code>, Sun treats this as a magic string and uses <code>/dev/random</code> anyway, so you have to fake it out.  When is a <code>file:</code> URL not a <code>file:</code> URL?  Whenever Sun decides it's not :-(</span></text><author><a class="comment-user" href="/users/18157/jim-garrison" title="61,737 reputation">Jim Garrison</a></author></comment><comment><text><span class="comment-copy">Having just spent a bunch of time investigating this, it seems that the normal setting, even with <code>file:/dev/urandom</code> set in <code>-Djava.security.egd</code> or in <code>securerandom.source</code> in the java.security file, <code>/dev/random/</code> is still read whenever <code>SecureRandom.getSeed()</code> (or <code>setSeed()</code> is called). The workaround with <code>file:/dev/./urandom</code> results in not reading <code>/dev/random</code> at all (confirmed with strace)</span></text><author><a class="comment-user" href="/users/4249/matt-b" title="98,628 reputation">matt b</a></author></comment><comment><text><span class="comment-copy">@owlstead I think we are agreeing with each other.</span></text><author><a class="comment-user" href="/users/4249/matt-b" title="98,628 reputation">matt b</a></author></comment><comment><text><span class="comment-copy"><code>/dev/urandom</code> isn't less secure than <code>/dev/random</code> when implemented with a modern CSPRNG: <a href="http://en.wikipedia.org/wiki//dev/random#FreeBSD" rel="nofollow noreferrer">en.wikipedia.org/wiki//dev/random#FreeBSD</a></span></text><author><a class="comment-user" href="/users/166524/lapo" title="2,198 reputation">lapo</a></author></comment><comment><text><span class="comment-copy">See also evaluation at <a href="http://bugs.sun.com/view_bug.do?bug_id=4705093" rel="nofollow noreferrer">bugs.sun.com/view_bug.do?bug_id=4705093</a></span></text><author><a class="comment-user" href="/users/603516/vadzim" title="9,606 reputation">Vadzim</a></author></comment><comment><text><span class="comment-copy">I think the main fear of <code>/dev/urandom/</code> is what happens if you use it to generate secrets on new hardware out of the box, which might be in a quite predictable state. <code>/dev/urandom/</code> won't block for entropy even though that's one case where you should. The situation is even worse if the secret is persistent, like if the first thing your device does on first boot is generate a public-private key pair. Outside of those scary situations, a good <code>/dev/urandom</code> is better than using the common <code>SecureRandom</code> algorithms anyway.</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">Isn't it automatic /dev/unrandom on linux also ?</span></text><author><a class="comment-user" href="/users/870382/novice-user" title="694 reputation">Novice User</a></author></comment><comment><text><span class="comment-copy">Which one is correct ? -Djava.security.egd=file:/dev/./urandom or file:///dev/urandom @mattb</span></text><author><a class="comment-user" href="/users/2519577/aarish" title="1,186 reputation">Aarish</a></author></comment><comment><text><span class="comment-copy">I have a follow up question. <a href="http://stackoverflow.com/questions/40383430/tomcat-takes-too-much-time-to-start-java-securerandom" title="tomcat takes too much time to start java securerandom">stackoverflow.com/questions/40383430/…</a>. Is it ok to do so in production? Will this have any impact on security (like Session ID becoming predictable)?</span></text><author><a class="comment-user" href="/users/6785908/random-dude" title="1,387 reputation">random_dude</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>On Linux, the default implementation for SecureRandom is "NativePRNG" (source code <a href="http://www.java2s.com/Open-Source/Java/6.0-JDK-Platform/solaris/sun/security/provider/NativePRNG.java.htm" rel="noreferrer">here</a>), which tends to be very slow.  On Windows, the default is "SHA1PRNG", which as others pointed out you can also use on Linux if you specify it explicitly.</p>
<p>"NativePRNG" differs from "SHA1PRNG" and Uncommons Maths' <a href="http://maths.uncommons.org/api/org/uncommons/maths/random/AESCounterRNG.html" rel="noreferrer">AESCounterRNG</a> in that it continuously receives entropy from the operating system (by reading from /dev/urandom).  The other PRNGs do not acquire any additional entropy after seeding.</p>
<p>AESCounterRNG is about 10x faster than "SHA1PRNG", which IIRC is itself two or three times faster than "NativePRNG".</p>
<p>If you need a faster PRNG that acquires entropy after initialisation, see if you can find a Java implementation of <a href="http://en.wikipedia.org/wiki/Fortuna_%28PRNG%29" rel="noreferrer">Fortuna</a>.  The core PRNG of a Fortuna implementation is identical to that used by AESCounterRNG, but there is also a sophisticated system of entropy pooling and automatic reseeding.</p>
</div></text><author><a href="/users/5171/dan-dyer">Dan Dyer</a></author><comments><comment><text><span class="comment-copy">This link is not working.<a href="https://uncommons-maths.dev.java.net/nonav/api/org/uncommons/maths/random/AESCounterRNG.html" rel="nofollow noreferrer">uncommons-maths.dev.java.net/nonav/api/org/uncommons‌​/maths/…</a>. Is there anywhere I can see this?</span></text><author><a class="comment-user" href="/users/527617/uvm" title="6,964 reputation">UVM</a></author></comment><comment><text><span class="comment-copy">@Unni Just updated the link.  Please note that the performance claims I made in this answer might not be valid any more.  I think things may have got better in recent versions of Java and there can be differences in performance between platforms (i.e. Windows vs. Liux).</span></text><author><a class="comment-user" href="/users/5171/dan-dyer" title="41,077 reputation">Dan Dyer</a></author></comment><comment><text><span class="comment-copy">I was just running one example of SecureRandom with a MessageDigest and made a hexencoded it.The entire operation in my windows 7 PC took 33 milliseconds.Is it an issue.I used SHA1PRNG.SecureRandom prng = SecureRandom.getInstance("SHA1PRNG"); String randomNum  = new Integer( prng.nextInt() ).toString();MessageDigest sha = MessageDigest.getInstance("SHA-1");result            = sha.digest( randomNum.getBytes() ); str = hexEncode(result);</span></text><author><a class="comment-user" href="/users/527617/uvm" title="6,964 reputation">UVM</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>If you want truly "cryptographically strong" randomness, then you need a strong entropy source. /dev/random is slow because it has to wait for system events to gather entropy (disk reads, network packets, mouse movement, keypresses, etc.).</p>
<p>A faster solution is a hardware random number generator. You may already have one built-in to your motherboard; check out the <a href="http://www.mjmwired.net/kernel/Documentation/hw_random.txt" rel="noreferrer">hw_random documentation</a> for instructions on figuring out if you have it, and how to use it. The rng-tools package includes a daemon which will feed hardware generated entropy into /dev/random.</p>
<p>If a HRNG is not available on your system, and you are willing to sacrifice entropy strength for performance, you will want to seed a good PRNG with data from /dev/random, and let the PRNG do the bulk of the work. There are several NIST-approved PRNG's listed in  <a href="http://csrc.nist.gov/publications/nistpubs/800-90/SP800-90revised_March2007.pdf" rel="noreferrer">SP800-90</a> which are straightforward to implement.</p>
</div></text><author><a href="/users/9573/chris-kite">Chris Kite</a></author><comments><comment><text><span class="comment-copy">Good point, but my code is part of a commercial application. I don't have any control over the server environment. I think the target servers are always without mouse and keyboard and rely entirely on disk and network I/O for entropy, which is probably the root problem.</span></text><author><a class="comment-user owner" href="/users/3150/david-g" title="4,304 reputation">David G</a></author></comment><comment><text><span class="comment-copy">I discovered that /dev/random was dependent on system events, so as a temporary workaround, I just moved my mouse back and forth while my test ran....</span></text><author><a class="comment-user" href="/users/1324595/david-k" title="813 reputation">David K</a></author></comment><comment><text><span class="comment-copy">That 82802 hub for the i820 chipset was painfully slow (RIP). I'm amazed you could gather anything useful from it. I think I spent more time blocking on it rather than collecting octets.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I had a similar problem with calls to SecureRandom blocking for about 25 seconds at a time on a headless Debian server. I installed the haveged daemon to ensure /dev/random is kept topped up, on headless servers you need something like this to generate the required entropy. 
My calls to SecureRandom now perhaps take milliseconds.  </p>
</div></text><author><a href="/users/3438692/thunder">thunder</a></author><comments><comment><text><span class="comment-copy">apt-get install haveged then update-rc.d haveged defaults</span></text><author><a class="comment-user" href="/users/808901/rodrigo-garcia" title="790 reputation">Rodrigo Garcia</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The problem you referenced about /dev/random is not with the SecureRandom algorithm, but with the source of randomness that it uses. The two are orthogonal. You should figure out which one of the two is slowing you down.</p>
<p>UncommonMaths page that you linked explicitly mentions that they are not addressing the source of randomness.</p>
<p>You can try different JCE providers, such as BouncyCastle, to see if their implementation of SecureRandom is faster.</p>
<p>A brief <a href="http://www.google.com/search?q=fortuna+/dev/random" rel="nofollow noreferrer">search</a> also reveals Linux patches that replace the default implementation with Fortuna. I don't know much more about this, but you're welcome to investigate.</p>
<p>I should also mention that while it's very dangerous to use a badly implemented SecureRandom algorithm and/or randomness source, you can roll your own JCE Provider with a custom implementation of SecureRandomSpi. You will need to go through a process with Sun to get your provider signed, but it's actually pretty straightforward; they just need you to fax them a form stating that you're aware of the US export restrictions on crypto libraries.</p>
</div></text><author><a href="/users/10026/ykaganovich">ykaganovich</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Use the secure random as initialization source for a recurrent algorithm; you could use then a Mersenne twister for the bulk work instead of the one in UncommonMath, which has been around for a while and proven better than other prng</p>
<p><a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Mersenne_twister</a></p>
<p>Make sure to refresh now and then the secure random used for the initialization, for example you could have one secure random generated per client, using one mersenne twister pseudo random generator per client, obtaining a high enough degree of randomization</p>
</div></text><author><a href="/users/2273540/lorenzo-boccaccia">Lorenzo Boccaccia</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>My experience has been only with slow initialization of the PRNG, not with generation of random data after that. Try a more eager initialization strategy. Since they're expensive to create, treat it like a singleton and reuse the same instance. If there's too much thread contention for one instance, pool them or make them thread-local.</p>
<p>Don't compromise on random number generation. A weakness there compromises all of your security.</p>
<p>I don't see a lot of COTS atomic-decay–based generators, but there are several plans out there for them, if you really need a lot of random data. One site that always has interesting things to look at, including HotBits, is <a href="http://www.fourmilab.ch/" rel="nofollow noreferrer">John Walker's Fourmilab.</a></p>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">I've always wondered about this, since hadronic tau decay products nearly attain the ideal of a randomized source I just cannot get rid of my wish to use that rather than algorithmic tools. For op's purpose, I decided long ago that some front-end time is endemic to all secure tools. If one is going to need a randomizer, that can be called in the constructor and just remember to construct one at page load time, it's buried under the avl swap-in and even as picky as I am it goes un-noticed.</span></text><author><a class="comment-user" href="/users/177505/nicholas-jordan" title="540 reputation">Nicholas Jordan</a></author></comment><comment><text><span class="comment-copy">Intel 8xx chipsets (and probably many others) have a hardware RNG that uses thermal noise, a truly unpredictable quantum effect. Trusted Platform Modules can contain hardware RNGs too, but unfortunately, the one in my laptop does not.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,733 reputation">erickson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>It sounds like you should be clearer about your RNG requirements. The strongest cryptographic RNG requirement (as I understand it) would be that even if you know the algorithm used to generate them, and you know all previously generated random numbers, you could not get any useful information about any of the random numbers generated in the future, without spending an impractical amount of computing power.</p>
<p>If you don't need this full guarantee of randomness then there are probably appropriate performance tradeoffs. I would tend to agree with <a href="http://stackoverflow.com/questions/137212/how-to-solve-performance-problem-with-java-securerandom#138745">Dan Dyer's response</a> about AESCounterRNG from Uncommons-Maths, or Fortuna (one of its authors is Bruce Schneier, an expert in cryptography). I've never used either but the ideas appear reputable at first glance.</p>
<p>I would <em>think</em> that if you could generate an initial random seed periodically (e.g. once per day or hour or whatever), you could use a fast stream cipher to generate random numbers from successive chunks of the stream (if the stream cipher uses XOR then just pass in a stream of nulls or grab the XOR bits directly). ECRYPT's <a href="http://www.ecrypt.eu.org/stream/" rel="nofollow noreferrer">eStream</a> project has lots of good information including performance benchmarks. This wouldn't maintain entropy between the points in time that you replenish it, so if someone knew one of the random numbers and the algorithm you used, technically it might be possible, with a lot of computing power, to break the stream cipher and guess its internal state to be able to predict future random numbers. But you'd have to decide whether that risk and its consequences are sufficient to justify the cost of maintaining entropy.</p>
<p>Edit: here's some <a href="http://www.tml.tkk.fi/Opinnot/T-110.470/2004/20041101.pdf" rel="nofollow noreferrer">cryptographic course notes on RNG</a> I found on the 'net that look very relevant to this topic.</p>
</div></text><author><a href="/users/44330/jason-s">Jason S</a></author><comments><comment><text><span class="comment-copy">"Fortuna (one of its authors is Bruce Schneier, an expert in cryptography)" -- and the other one is Niels Ferguson, an expert in cryptography :-)</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There is a tool (on Ubuntu at least) that will feed artificial randomness into your system.  The command is simply:</p>
<pre class="lang-java prettyprint prettyprinted" style=""><code><span class="pln">rngd </span><span class="pun">-</span><span class="pln">r </span><span class="pun">/</span><span class="pln">dev</span><span class="pun">/</span><span class="pln">urandom</span></code></pre>
<p>and you may need a sudo at the front.  If you don't have rng-tools package, you will need to install it.  I tried this, and it definitely helped me!</p>
<p>Source: <a href="http://www.mattvsworld.com/blog/2010/02/speed-up-key-generation-with-artificial-entropy/" rel="nofollow">matt vs world</a></p>
</div></text><author><a href="/users/1324595/david-k">David K</a></author><comments><comment><text><span class="comment-copy">This is somewhat dangerous because it fully disables the Linux kernel’s entropy level estimation, system-wide. I think for testing purposes (reads: Jenkins running an app’s testsuite) using /dev/./urandom is fine, but in production, it’s not.</span></text><author><a class="comment-user" href="/users/2171120/mirabilos" title="3,119 reputation">mirabilos</a></author></comment><comment><text><span class="comment-copy">This is actually the only solution that worked for me. I had a “not enough entropy” problem when building an Android project with Gradle on Jenkins CI, and passing a parameter to the build did not help.</span></text><author><a class="comment-user" href="/users/4568679/slav" title="346 reputation">Slav</a></author></comment><comment><text><span class="comment-copy">I had to combine <code>sudo rngd -r /dev/urandom</code> with <code>sudo apt install rng-tools</code> in xenial</span></text><author><a class="comment-user" href="/users/1548557/mrmesees" title="393 reputation">MrMesees</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I faced same <a href="http://stackoverflow.com/questions/40383430/tomcat-takes-too-much-time-to-start-java-securerandom">issue</a>. After some Googling with the right search terms, I came across this nice article on <a href="https://www.digitalocean.com/community/tutorials/how-to-setup-additional-entropy-for-cloud-servers-using-haveged" rel="nofollow noreferrer">DigitalOcean</a>. </p>
<h2>haveged is a potential solution without compromising on security.</h2>
<p>I am merely quoting the relevant part from the article here.</p>
<blockquote>
<p>Based on the HAVEGE principle, and previously based on its associated
  library, haveged allows generating randomness based on variations in
  code execution time on a processor. Since it's nearly impossible for
  one piece of code to take the same exact time to execute, even in the
  same environment on the same hardware, the timing of running a single
  or multiple programs should be suitable to seed a random source. The
  haveged implementation seeds your system's random source (usually
  /dev/random) using differences in your processor's time stamp counter
  (TSC) after executing a loop repeatedly</p>
</blockquote>
<h2>How to install haveged</h2>
<p>Follow the steps in this article. <a href="https://www.digitalocean.com/community/tutorials/how-to-setup-additional-entropy-for-cloud-servers-using-haveged" rel="nofollow noreferrer">https://www.digitalocean.com/community/tutorials/how-to-setup-additional-entropy-for-cloud-servers-using-haveged</a></p>
<p>I have posted it <a href="http://stackoverflow.com/a/40603084/6785908">here</a></p>
</div></text><author><a href="/users/6785908/random-dude">random_dude</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Using Java 8, I found that on Linux calling <code>SecureRandom.getInstanceStrong()</code> would give me the <code>NativePRNGBlocking</code> algorithm. This would often block for many seconds to generate a few bytes of salt.</p>
<p>I switched to explicitly asking for <code>NativePRNGNonBlocking</code> instead, and as expected from the name, it no longer blocked. I have no idea what the security implications of this are. Presumably the non-blocking version can't guarantee the amount of entropy being used.</p>
<p><strong>Update</strong>: Ok, I found <a href="https://tersesystems.com/2015/12/17/the-right-way-to-use-securerandom/" rel="nofollow noreferrer">this excellent explanation</a>.</p>
<p>In a nutshell, to avoid blocking, use <code>new SecureRandom()</code>. This uses <code>/dev/urandom</code>, which doesn't block and is basically as secure as <code>/dev/random</code>. From the post: "The only time you would want to call /dev/random is when the machine is first booting, and entropy has not yet accumulated".</p>
<p><code>SecureRandom.getInstanceStrong()</code> gives you the absolute strongest RNG, but it's only safe to use in situations where a bunch of blocking won't effect you.</p>
</div></text><author><a href="/users/94152/lachlan">Lachlan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I haven't hit against this problem myself, but I'd spawn a thread at program start which immediately tries to generate a seed, then dies.  The method which you call for randoms will join to that thread if it is alive so the first call only blocks if it occurs very early in program execution.</p>
</div></text><author><a href="/users/1490/nick">Nick</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Something else to look at is the property securerandom.source in file lib/security/java.security
</p><p>There may be a performance benefit to using /dev/urandom rather than /dev/random. Remember that if the quality of the random numbers is important, don't make a compromise which breaks security.</p>
</div></text><author><a href="/users/18093/diastrophism">Diastrophism</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>If your hardware supports it try using Java RdRand Utility available at:
<a href="http://code.google.com/p/lizalab-rdrand-util/" rel="nofollow">http://code.google.com/p/lizalab-rdrand-util/</a></p>
<p>Its based on Intel's RDRAND instruction and is about 10 times faster than SecureRandom and no bandwidth issues for large volume implementation.</p>
<p>Full disclosure, I'm the author of the utility.</p>
</div></text><author><a href="/users/2781824/user2781824">user2781824</a></author><comments><comment><text><span class="comment-copy">You might want to read <a href="http://people.umass.edu/gbecker/BeckerChes13.pdf" rel="nofollow noreferrer">people.umass.edu/gbecker/BeckerChes13.pdf</a> and be sure to <i>never</i> use <i>only</i> Intel RDRAND data. Always mix it with some other unpredictable data, such as the output of an aRC4 stream cipher (seeded from /dev/urandom and with the first few KiB of output thrown away for their known bias).</span></text><author><a class="comment-user" href="/users/2171120/mirabilos" title="3,119 reputation">mirabilos</a></author></comment><comment><text><span class="comment-copy">+1 mirabilos. I think <code>RDRAND</code> is a good source, but its a bit untrustworthy. It definitely needs to be one input of many into a collector (no offense to David Johnston).</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>You can try Apache commons Math project, that has some implementations of well-know algorithms:</p>
<p><a href="https://commons.apache.org/proper/commons-math/userguide/random.html" rel="nofollow">https://commons.apache.org/proper/commons-math/userguide/random.html</a></p>
<p>However, be careful with the performance. The default constructor of <code>RandomDataGenerator</code> creates a dedicated instance of <code>Well19937c</code>, that is a very expensive operation. </p>
<p>According to the documentation, this class <strong>is not</strong> thread safe, but if you can guarantee that only one Thread will access this class, you can initialize only one instance per Thread.</p>
</div></text><author><a href="/users/750117/jfcorugedo">jfcorugedo</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Problem statement</strong></p>
<p>This library <a href="https://github.com/middlesphere/msprandom" rel="nofollow">msprandom</a> demonstrates a technique of generating random numbers for cryptographic purposes without hardware generators. Encryption and signing requires a random numbers with good quality. Generating a random numbers (or sequences of random bytes) without hardware generators is not trivial task. Especially this problem is actual for a small devices where sources of random data are absent or limited. The solution is to have true random seed saved in a secured file (vault) and cipher which can produce encrypted pseudo random generated (PRNG) sequences based on random seed with good random characteristics.</p>
<p>Many cryptographic libraries (e.g. BouncyCastle) use SecureRandom class for encryption and signing to get random numbers. SecureRandom depends on OS implementation. Another words, realization of random engine is outside your application which you cannot control. To avoid of using poor random numbers you MUST seed SecureRandom generator with good random data every time you call cryptographic functions which requires the random data. Or you can extend SecureRandom class with your realization that produces a random numbers which quality you can control.</p>
<p><strong>Idea</strong></p>
<p>We need to use true random data stored in a secured data vault. </p>
<p>Some steps how to <a href="https://github.com/middlesphere/msprandom" rel="nofollow">msprandom</a> inside your application: </p>
<ol>
<li>Generate on your computer or notebook a true random seed and put it to a vault using this library. </li>
<li>Put a vault (file) with random seed on your device, computer or server where you need to encrypt and sign data. </li>
<li>Load the vault once at the start of the program when you need encrypt or sign data. </li>
<li>Call gen-rand function from msprandom library to get random bytes as many times as you need.</li>
</ol>
<p>The vault with random seed is encrypted and secured with HMAC. Random seed in a vault is updated every time you load vault with unpredictable way, so HMAC is changing too. Changing a vault is made intentionally against situation if attacker can rich some copy of your vault in the past.</p>
<p><strong>True random data generator</strong></p>
<p>To generate a true random seed a human input is used in <a href="https://github.com/middlesphere/msprandom" rel="nofollow">msprandom</a>. Here are the algorithm of collecting a random data:</p>
<ol>
<li>We run separate thread where atomic counter increments every tic from 0..255 with a very high speed.</li>
<li>Wait for unbuffered key press by human and get a scan code of pressed button.</li>
<li>Take current nanoseconds value from start of Epoch and take mod 256 to convert its value to a random byte.</li>
<li>Xor values between each other: scan-code-byte ^ current-counter-value ^ nanoseconds to produce random byte.</li>
<li>Add random byte to output vector. We suppose that only 3 bits has true randomness in this random byte. So, to get true random 32 bytes we need ~ 32*3 button press from user input. </li>
<li>Repeat steps 2-5 until we get required amount of random bytes.
If we collected required amount of random data then do final step -&gt; hash output vector with cryptographically strong hash function to guarantee that probability 1 and 0 bits in output vector will be 0.5. Note, that hash function used here only to mix random bits and do not influence to the quality of random data. So hash(random data) = random data.
Using this algorithm the msprandom collects a true 512 random bits as a seed which will be saved an a vault.</li>
</ol>
<p><strong>Why 512 random bits is enough?</strong></p>
<p>Well, every PRNG needs a true random seed. If an attacker knows a seed then it can predict key generation and so on. 256 bits of initial random seed is far enough to keep millitary grade secrets. I did 512 to be sure that nobody can brute force or guess the initial random seed. So, you can freely use msprandom to seed you PRNG or SecureRandom generators.</p>
</div></text><author><a href="/users/2210859/mike">mike</a></author><comments/></answer></answers></post>