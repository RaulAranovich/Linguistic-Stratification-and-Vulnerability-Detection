<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Do htmlspecialchars and mysql_real_escape_string keep my PHP code safe from injection? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Earlier today a question was asked regarding <a href="http://stackoverflow.com/questions/110458/what-percentage-of-my-time-will-be-spent-in-user-input-verfication-during-web-d">input validation strategies in web apps</a>.</p>
<p>The top answer, at time of writing, suggests in <code>PHP</code> just using <code>htmlspecialchars</code> and <code>mysql_real_escape_string</code>. </p>
<p>My question is: Is this always enough? Is there more we should know? Where do these functions break down?</p>
</div></text><author><a href="/users/4248328/alive-to-die">Alive to Die</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>When it comes to database queries, always try and use prepared parameterised queries. The <code>mysqli</code> and <code>PDO</code> libraries support this. This is infinitely safer than using escaping functions such as <code>mysql_real_escape_string</code>.</p>
<p>Yes, <code>mysql_real_escape_string</code> is effectively just a string escaping function. It is not a magic bullet. All it will do is escape dangerous characters in order that they can be safe to use in a single query string. However, if you do not sanitise your inputs beforehand, then you will be vulnerable to certain attack vectors.</p>
<p>Imagine the following SQL:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$result </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT fields FROM table WHERE id = "</span><span class="pun">.</span><span class="pln">mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_POST</span><span class="pun">[</span><span class="str">'id'</span><span class="pun">]);</span></code></pre>
<p>You should be able to see that this is vulnerable to exploit.<br/>
Imagine the <code>id</code> parameter contained the common attack vector:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="lit">1</span><span class="pln"> OR </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span></code></pre>
<p>There's no risky chars in there to encode, so it will pass straight through the escaping filter. Leaving us:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT fields FROM table WHERE id</span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> OR </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span></code></pre>
<p>Which is a lovely SQL injection vector and would allow the attacker to return all the rows.
Or</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="lit">1</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> is_admin</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> order </span><span class="kwd">by</span><span class="pln"> id limit </span><span class="lit">1</span></code></pre>
<p>which produces</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT fields FROM table WHERE id</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> is_admin</span><span class="pun">=</span><span class="lit">1</span><span class="pln"> order </span><span class="kwd">by</span><span class="pln"> id limit </span><span class="lit">1</span></code></pre>
<p>Which allows the attacker to return the first administrator's details in this completely fictional example.</p>
<p>Whilst these functions are useful, they must be used with care. You need to ensure that all web inputs are validated to some degree. In this case, we see that we can be exploited because we didn't check that a variable we were using as a number, was actually numeric. In PHP you should widely use a set of functions to check that inputs are integers, floats, alphanumeric etc.   But when it comes to SQL, heed most the value of the prepared statement. The above code would have been secure if it was a prepared statement as the database functions would have known that <code>1 OR 1=1</code> is not a valid literal.</p>
<p>As for <code>htmlspecialchars()</code>. That's a minefield of its own.</p>
<p>There's a real problem in PHP in that it has a whole selection of different html-related escaping functions, and no clear guidance on exactly which functions do what. </p>
<p>Firstly, if you are inside an HTML tag, you are in real trouble. Look at</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">echo </span><span class="str">'&lt;img src= "'</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> htmlspecialchars</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="str">'imagesrc'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> </span><span class="str">'" /&gt;'</span><span class="pun">;</span></code></pre>
<p>We're already inside an HTML tag, so we don't need &lt; or &gt; to do anything dangerous. Our attack vector could just be <code>javascript:alert(document.cookie)</code></p>
<p>Now resultant HTML looks like</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;img</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="pln"> </span><span class="atv">"javascript:alert(document.cookie)"</span><span class="pln"> </span><span class="tag">/&gt;</span></code></pre>
<p>The attack gets straight through. </p>
<p>It gets worse. Why? because <code>htmlspecialchars</code> (when called this way) only encodes double quotes and not single. So if we had </p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">echo </span><span class="str">"&lt;img src= '"</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> htmlspecialchars</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="str">'imagesrc'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> </span><span class="str">". /&gt;"</span><span class="pun">;</span></code></pre>
<p>Our evil attacker can now inject whole new parameters</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">pic</span><span class="pun">.</span><span class="pln">png</span><span class="str">' onclick='</span><span class="pln">location</span><span class="pun">.</span><span class="pln">href</span><span class="pun">=</span><span class="pln">xxx</span><span class="str">' onmouseover='</span><span class="pun">...</span></code></pre>
<p>gives us</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="tag">&lt;img</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">'pic.png'</span><span class="pln"> </span><span class="atn">onclick</span><span class="pun">=</span><span class="atv">'</span><span class="pln">location</span><span class="pun">.</span><span class="pln">href</span><span class="pun">=</span><span class="pln">xxx</span><span class="atv">'</span><span class="pln"> </span><span class="atn">onmouseover</span><span class="pun">=</span><span class="atv">'</span><span class="pun">...</span><span class="atv">'</span><span class="pln"> </span><span class="tag">/&gt;</span></code></pre>
<p>In these cases, there is no magic bullet, you just have to santise the input yourself. If you try and filter out bad characters you will surely fail. Take a whitelist approach and only let through the chars which are good. Look at the <a href="http://ha.ckers.org/xss.html" rel="noreferrer">XSS cheat sheet</a> for examples on how diverse vectors can be</p>
<p>Even if you use <code>htmlspecialchars($string)</code> outside of HTML tags, you are still vulnerable to multi-byte charset attack vectors.</p>
<p>The most effective you can be is to use the a combination of mb_convert_encoding and htmlentities as follows.</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$str </span><span class="pun">=</span><span class="pln"> mb_convert_encoding</span><span class="pun">(</span><span class="pln">$str</span><span class="pun">,</span><span class="pln"> </span><span class="str">'UTF-8'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'UTF-8'</span><span class="pun">);</span><span class="pln">
$str </span><span class="pun">=</span><span class="pln"> htmlentities</span><span class="pun">(</span><span class="pln">$str</span><span class="pun">,</span><span class="pln"> ENT_QUOTES</span><span class="pun">,</span><span class="pln"> </span><span class="str">'UTF-8'</span><span class="pun">);</span></code></pre>
<p>Even this leaves IE6 vulnerable, because of the way it handles UTF. However, you could fall back to a more limited encoding, such as ISO-8859-1, until IE6 usage drops off.</p>
<p>For a more in-depth study to the multibyte problems, see <a href="http://stackoverflow.com/a/12118602/1820">http://stackoverflow.com/a/12118602/1820</a></p>
</div></text><author><a href="/users/1820/cheekysoft">Cheekysoft</a></author><comments><comment><text><span class="comment-copy">The only thing missed here, is that the first example for the DB query ... a simple intval() would solve the injection.  Always use intval() in place of mysqlescape...() when needing a number and not a string.</span></text><author><a class="comment-user" href="/users/24950/robert-k" title="21,751 reputation">Robert K</a></author></comment><comment><text><span class="comment-copy">and remember that using parameterized queries will allow you to always have data treated as data and not code. Use a library such as PDO and use parameterised queries whenever possible.</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">Excellent answer!</span></text><author><a class="comment-user" href="/users/110337/joedevon" title="1,704 reputation">joedevon</a></author></comment><comment><text><span class="comment-copy">@The Wicked Flea I would argue type casting with (int) is better. It's faster, and one less parenthesis you need to close on the other side.</span></text><author><a class="comment-user" href="/users/31671/alex" title="285,218 reputation">alex</a></author></comment><comment><text><span class="comment-copy">+1 : I just had to vote up this 1-year old answer. This even thought me a thing or 2 about XSS.</span></text><author><a class="comment-user" href="/users/146455/duroth" title="3,879 reputation">Duroth</a></author></comment><comment><text><span class="comment-copy">Two remarks: 1. In the first example, you'd be safe if you also put quotes around the parameter, like <code>$result = "SELECT fields FROM table WHERE id = '".mysql_real_escape_string($_POST['id'])."'";</code> 2. In the second case (attribute containing URL), there's no use for <code>htmlspecialchars</code> at all; in these cases, you should encode input using a URL encoding scheme, e.g., using <a href="http://php.net/rawurlencode" rel="nofollow noreferrer"><code>rawurlencode</code></a>. That way, a user can't insert <code>javascript:</code> et al.</span></text><author><a class="comment-user" href="/users/258127/marcel-korpel" title="17,718 reputation">Marcel Korpel</a></author></comment><comment><text><span class="comment-copy">@Marcel 1: kinda true, but adding quotes wouldn't be right, as then you'd have the database comparing a string to a number; much better to restrict the variable to only being an integer. 2: Yes absolutely! It is important to understand the context of the injection location and encode accordingly - Very much the point of this post: Validate as appropriate and encode as appropriate; don't just blindly use some particular function thinking it will keep you safe.</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">+1 this was great</span></text><author><a class="comment-user" href="/users/435317/drewdin" title="916 reputation">Drewdin</a></author></comment><comment><text><span class="comment-copy">“htmlspecialchars only encodes double quotes and not single”: that's not true, it depends on flags being set, see its <a href="http://php.net/htmlspecialchars#refsect1-function.htmlspecialchars-parameters" rel="nofollow noreferrer">parameters</a>.</span></text><author><a class="comment-user" href="/users/258127/marcel-korpel" title="17,718 reputation">Marcel Korpel</a></author></comment><comment><text><span class="comment-copy">Why do you use mb_convert_encoding in combination of htmlentities? Is not sure htmlentities() alone?</span></text><author><a class="comment-user" href="/users/365251/markzzz" title="13,724 reputation">markzzz</a></author></comment><comment><text><span class="comment-copy">@markzzz because htmlentities on it's own is vulnerable to multibyte character attacks. For a good ref on avoiding XSS see <a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet" rel="nofollow noreferrer">owasp.org/index.php/…</a></span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">Uhm, can you give a simple example? Not sure about what do you mean as multibyte chars :)</span></text><author><a class="comment-user" href="/users/365251/markzzz" title="13,724 reputation">markzzz</a></author></comment><comment><text><span class="comment-copy">@Cheekysoft I would like an example of multibyte charset attack as well</span></text><author><a class="comment-user" href="/users/616559/templar" title="948 reputation">Templar</a></author></comment><comment><text><span class="comment-copy">@Templar see <a href="http://stackoverflow.com/a/12118602/1820">stackoverflow.com/a/12118602/1820</a></span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">This should be bolded: <code>Take a whitelist approach and only let through the chars which are good.</code> A blacklist will always miss something. +1</span></text><author><a class="comment-user" href="/users/1286942/jo-smo" title="1,944 reputation">Jo Smo</a></author></comment><comment><text><span class="comment-copy">Would you recommend using htmlentities and mb_convert_encoding in conjunction with prepared statements? <a href="http://php.net/manual/en/mysqli.quickstart.prepared-statements.php" rel="nofollow noreferrer">php.net/manual/en/mysqli.quickstart.prepared-statements.php</a></span></text><author><a class="comment-user" href="/users/2750864/theramax" title="85 reputation">Theramax</a></author></comment><comment><text><span class="comment-copy">@MartínMolina No! do not attempt to write a one-size-fits-all function. Always deal use a mechanism appropriate for what you are doing. When sending to a database, use bound parameters; when protecting against XSS, use the appropriate output-encoding technique for the context into which you are injecting.</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">"Even if you use htmlspecialchars($string) outside of HTML tags, you are still vulnerable to multi-byte charset attack vectors." Could you please explain? this this php piece unsafe? <code>echo "&lt;something&gt;" .htmlspecialchars($untrusted_string). "&lt;/something&gt;"</code></span></text><author><a class="comment-user" href="/users/2347534/hello-world" title="530 reputation">Hello World</a></author></comment><comment><text><span class="comment-copy">@HelloWorld For an understanding of the theory behind why this was written, see <a href="http://stackoverflow.com/questions/1412239/">stackoverflow.com/questions/1412239</a>   However, in the five years since this was written, htmlspecialchars and htmlentities now attempt to detect invalid multi-byte character sequences (although it may be safest to mb_convert_encoding than to rely on the native error); and since php5.4, the system default encoding is UTF-8; and IE6 is deprecated and unsupported. This should mean that in your particular injection context, you should be safe (but may get an unexpected warning if the user sends malformed utf)</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">If we pass <code>htmlspecialchars</code> through the entire string though, all those examples will not work. As the comma's will be converted to their special characters. I'd recommend <code>htmlspecialchars($str, ENT_QUOTES, 'UTF-8');</code></span></text><author><a class="comment-user" href="/users/1254837/nick-newman" title="635 reputation">NiCk Newman</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In addition to Cheekysoft's excellent answer:</p>
<ul>
<li>Yes, they will keep you safe, but only if they're used absolutely correctly. Use them incorrectly and you will still be vulnerable, and may have other problems (for example data corruption)</li>
<li>Please use parameterised queries instead (as stated above). You can use them through e.g. PDO or via a wrapper like PEAR DB</li>
<li>Make sure that magic_quotes_gpc and magic_quotes_runtime are off at all times, and never get accidentally turned on, not even briefly. These are an early and deeply misguided attempt by PHP's developers to prevent security problems (which destroys data)</li>
</ul>
<p>There isn't really a silver bullet for preventing HTML injection (e.g. cross site scripting), but you may be able to achieve it more easily if you're using a library or templating system for outputting HTML. Read the documentation for that for how to escape things appropriately.</p>
<p>In HTML, things need to be escaped differently depending on context. This is especially true of strings being placed into Javascript.</p>
</div></text><author><a href="/users/13724/markr">MarkR</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would definitely agree with the above posts, but I have one small thing to add in reply to Cheekysoft's answer, specifically:</p>
<blockquote>
<p>When it comes to database queries,
  always try and use prepared
  parameterised queries. The mysqli and
  PDO libraries support this. This is
  infinitely safer than using escaping
  functions such as
  mysql_real_escape_string.</p>
<p>Yes, mysql_real_escape_string is
  effectively just a string escaping
  function. It is not a magic bullet.
  All it will do is escape dangerous
  characters in order that they can be
  safe to use in a single query string.
  However, if you do not sanitise your
  inputs beforehand, then you will be
  vulnerable to certain attack vectors.</p>
<p>Imagine the following SQL:</p>
<p>$result = "SELECT fields FROM table
  WHERE id =
  ".mysql_real_escape_string($_POST['id']);</p>
<p>You should be able to see that this is
  vulnerable to exploit. Imagine the id
  parameter contained the common attack
  vector:</p>
<p>1 OR 1=1</p>
<p>There's no risky chars in there to
  encode, so it will pass straight
  through the escaping filter. Leaving
  us:</p>
<p>SELECT fields FROM table WHERE id = 1
  OR 1=1</p>
</blockquote>
<p>I coded up a quick little function that I put in my database class that will strip out anything that isnt a number. It uses preg_replace, so there is prob a bit more optimized function, but it works in a pinch...</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> </span><span class="typ">Numbers</span><span class="pun">(</span><span class="pln">$input</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  $input </span><span class="pun">=</span><span class="pln"> preg_replace</span><span class="pun">(</span><span class="str">"/[^0-9]/"</span><span class="pun">,</span><span class="str">""</span><span class="pun">,</span><span class="pln"> $input</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$input </span><span class="pun">==</span><span class="pln"> </span><span class="str">''</span><span class="pun">)</span><span class="pln"> $input </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> $input</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>So instead of using</p>
<blockquote>
<p>$result = "SELECT fields FROM table WHERE id = ".mysqlrealescapestring("1 OR 1=1");</p>
</blockquote>
<p>I would use</p>
<blockquote>
<p>$result = "SELECT fields FROM table WHERE id = ".Numbers("1 OR 1=1");</p>
</blockquote>
<p>and it would safely run the query</p>
<blockquote>
<p>SELECT fields FROM table WHERE id = 111</p>
</blockquote>
<p>Sure, that just stopped it from displaying the correct row, but I dont think that is a big issue for whoever is trying to inject sql into your site ;)</p>
</div></text><author><a href="/users/20579/brilliantwinter">BrilliantWinter</a></author><comments><comment><text><span class="comment-copy">Perfect! This is the exactly kind of sanitisation you need. The initial code failed because it didn't validate that a number was numeric. Your code does this. you should call Numbers() on all integer-use vars whose values originate from outside the codebase.</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">It's worth mentioning that intval() will work perfectly fine for this, since PHP automatically coerces integers to strings for you.</span></text><author><a class="comment-user" href="/users/79/adam-ernst" title="14,713 reputation">Adam Ernst</a></author></comment><comment><text><span class="comment-copy">I prefer intval. It turns 1abc2 to 1, not 12.</span></text><author><a class="comment-user" href="/users/44065/jmucchiello" title="13,257 reputation">jmucchiello</a></author></comment><comment><text><span class="comment-copy">intval is better, expecially on ID.  Most of the time, if its been corrupted, its just as is above, 1 or 1=1.  You really shouldn't leak other people's ID.  So intval will return the correct ID. After that, you should check if the original and cleaned values are the same.  Its a great way of not only stopping attacks, but finding the attackers.</span></text><author><a class="comment-user" href="/users/1075029/triunenature" title="306 reputation">triunenature</a></author></comment><comment><text><span class="comment-copy">The incorrect row would be disastrous if you are showing personal data, you would see another user's information!  instead it would be better to check <code>return preg_match('/^[0-9]+$/',$input) ? $input : 0;</code></span></text><author><a class="comment-user" href="/users/857113/frank-forte" title="558 reputation">Frank Forte</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>An important piece of this puzzle is contexts. Someone sending "1 OR 1=1" as the ID is not a problem if you quote every argument in your query:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT fields FROM table WHERE id</span><span class="pun">=</span><span class="str">'".mysql_real_escape_string($_GET['</span><span class="pln">id</span><span class="str">'])."'"</span></code></pre>
<p>Which results in:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">SELECT fields FROM table WHERE id</span><span class="pun">=</span><span class="str">'1 OR 1=1'</span></code></pre>
<p>which is ineffectual. Since you're escaping the string, the input cannot break out of the string context. I've tested this as far as version 5.0.45 of MySQL, and using a string context for an integer column does not cause any problems.</p>
</div></text><author><a href="/users/6726/lucas-oman">Lucas Oman</a></author><comments><comment><text><span class="comment-copy">and then i'll start my attack vector with the multi-byte char 0xbf27 which in your latin1 database will be converted by the filter fuction as 0xbf5c27 - which is a single multibyte character followed by a single quote.</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">Try not to safeguard against a single known attack-vector. You will end up chasing your tail until the end of time applying patch after patch to your code. Standing back and looking at the general cases will leaed to safer code and a better security-focussed mindset.</span></text><author><a class="comment-user owner" href="/users/1820/cheekysoft" title="23,093 reputation">Cheekysoft</a></author></comment><comment><text><span class="comment-copy">I agree; ideally, OP will use prepared statements.</span></text><author><a class="comment-user" href="/users/6726/lucas-oman" title="11,797 reputation">Lucas Oman</a></author></comment><comment><text><span class="comment-copy">While the quoting of arguments suggested by this post isn't foolproof it will mitigate many of the common 1 OR 1=1 type attacks so it's worthy of mention.</span></text><author><a class="comment-user" href="/users/615686/night-owl" title="2,277 reputation">Night Owl</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">$result </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT fields FROM table WHERE id = "</span><span class="pun">.(</span><span class="pln">INT</span><span class="pun">)</span><span class="pln"> $_GET</span><span class="pun">[</span><span class="str">'id'</span><span class="pun">];</span></code></pre>
<p>Works well, even better on 64 bit systems. Beware of your systems limitations on addressing large numbers though, but for database ids this works great 99% of the time.</p>
<p>You should be using a single function/method for cleaning your values as well. Even if this function is just a wrapper for mysql_real_escape_string().  Why? Because one day when an exploit to your preferred method of cleaning data is found you only have to update it one place, rather than a system-wide find and replace.</p>
</div></text><author><a href="/users/530151/systematical">systematical</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>why, oh WHY, would you <strong>not</strong> include quotes around user input in your sql statement?  seems quite silly not to!  including quotes in your sql statement would render "1 or 1=1" a fruitless attempt, no?</p>
<p>so now, you'll say, "what if the user includes a quote (or double quotes) in the input?"</p>
<p>well, easy fix for that: just remove user input'd quotes.  eg: <code>input =~ s/'//g;</code>.  now, it seems to me anyway, that user input would be secured...</p>
</div></text><author><a href="/users/7703090/jarett-l">Jarett L</a></author><comments><comment><text><span class="comment-copy">"why, oh WHY, would you not include quotes around user input in your sql statement?" — The question says nothing about not quoting user input.</span></text><author><a class="comment-user" href="/users/19068/quentin" title="529,013 reputation">Quentin</a></author></comment><comment><text><span class="comment-copy">"well, easy fix for that" — Terrible fix for that. That throws away data. The solution mentioned in the question itself is a better approach.</span></text><author><a class="comment-user" href="/users/19068/quentin" title="529,013 reputation">Quentin</a></author></comment><comment><text><span class="comment-copy">while i agree the question does not address quoting user input, it still seems sill not to quote the input.  and, i would rather toss data than input bad data.  generally, in an injection attack, you do NOT want that data anyway....right?</span></text><author><a class="comment-user" href="/users/7703090/jarett-l" title="1 reputation">Jarett L</a></author></comment><comment><text><span class="comment-copy">"while i agree the question does not address quoting user input, it still seems sill not to quote the input." — No, it doesn't. The question doesn't demonstrate it one way or the other.</span></text><author><a class="comment-user" href="/users/19068/quentin" title="529,013 reputation">Quentin</a></author></comment><comment><text><span class="comment-copy">can you show an example of how one might be "tossing away data" when one doesn't want the data "tossed away"?  I'm just a little confused, and really would like clarification....</span></text><author><a class="comment-user" href="/users/7703090/jarett-l" title="1 reputation">Jarett L</a></author></comment><comment><text><span class="comment-copy">"generally, in an injection attack, you do NOT want that data anyway" — It should be assumed that sometimes people will submit genuine data that is not an attack. That data might include <code>'</code> characters. A form asking for the visitor's name might be used by <i>Mr. O'Reilly</i> to take a very basic example.</span></text><author><a class="comment-user" href="/users/19068/quentin" title="529,013 reputation">Quentin</a></author></comment><comment><text><span class="comment-copy">excellent point.  ty.</span></text><author><a class="comment-user" href="/users/7703090/jarett-l" title="1 reputation">Jarett L</a></author></comment><comment><text><span class="comment-copy">so, instead of deleting the quote, couldn't i just convert it to an html element (i don't think element is the word i want).  for instance, %27 instead, then? (obviously i'm new to this, and wish to avoid plastering my code with "sql injection checks"</span></text><author><a class="comment-user" href="/users/7703090/jarett-l" title="1 reputation">Jarett L</a></author></comment><comment><text><span class="comment-copy">@JarettL Either get used to using prepared statements or <a href="http://bobby-tables.com/" rel="nofollow noreferrer">get used to Bobby Tables wrecking your data every Tuesday</a>.  Parameterized SQL is the single best way to protect yourself against SQL injection.  You don't need to do "SQL injection checks" if you are using a prepared statement.  They're extremely easy to implement (and in my opinion, make the code MUCH easier to read), protect from various idiosyncrasies of string concatenation and sql injection, and best of all, you don't have to reinvent the wheel to implement it.</span></text><author><a class="comment-user" href="/users/3393505/siyual" title="10,733 reputation">Siyual</a></author></comment></comments></answer></answers></post>