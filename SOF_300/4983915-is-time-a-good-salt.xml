<?xml version="1.0" encoding="utf-8"?>
<post><title>php - Is time() a good salt? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm looking at some code that I have not written myself. The code tries to hash a password with SHA512 and uses just <code>time()</code> as the salt. Is <code>time()</code> too simple a salt for this or is this code safe?</p>
<p>Thanks for the answers and comments. I will sum it up here for the new readers:</p>
<ul>
<li>salt should be different for each user, so if 2 users register at the same time, their salts won't be unique. This is a problem, but not a big one. </li>
<li>but salt shouldn't be in any way related to the user, so time() is not a good salt. </li>
<li>"<em>Use a random, evenly distributed, high entropy salt.</em>" -- That's a mouthful, so what code could possibly generate a <code>random, evenly distributed, high entropy</code> salt?</li>
</ul>
<p>Ok, so how about I replace time() with a random string 32 char long. The random string could be generated from looping 32 times over a set of alphabet chars. Does that sound good?</p>
</div></text><author><a href="/users/1438393/amal-murali">Amal Murali</a></author><comments><comment><text><span class="comment-copy">I recommend using a two part salt. One unique per user salt. And one that's stored in a config file and kept secret. That way an attacker needs access to both the filesystem and the database, and not only the database.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment><comment><text><span class="comment-copy">on a unix based system, you probably have access to /dev/random otherwise, use you could... hmm, this is a good questions that deserves it's own thread.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@Your last question: <code>mt_rand</code> isn't cryptographically strong, but it will give you much more "randomness" than <code>time</code>. PHP currently doesn't provide a way to get cryptographically strong random numbers (but this is being worked on). So you should either stick to <code>mt_rand</code> or fork <code>/dev/(u)random</code>.</span></text><author><a class="comment-user" href="/users/385378/nikic" title="70,498 reputation">NikiC</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<h2><strong>Short answer:</strong></h2>
<p>No, <code>time()</code> is not a good salt.</p>
<h2>Long answer:</h2>
<p><sup><em>copied from my answer to <a href="http://stackoverflow.com/questions/1645161/salt-generation-and-open-source-software/1645190#1645190">Salt Generation and open source software</a></em></sup></p>
<blockquote>
<h3>What is a salt?</h3>
<p>A salt is a <em>random</em> set of bytes of a fixed length that is added to the input of a hash algorithm.</p>
<p><br/></p>
<h3>Why is salting (or seeding) a hash useful?</h3>
<p>Adding a random salt to a hash ensures that the same password will produce many different hashes. The salt is usually stored in the database, together with the result of the hash function.
  Salting a hash is good for a number of reasons:</p>
<ol>
<li>Salting greatly increases the difficulty/cost of precomputated attacks (including <a href="http://en.wikipedia.org/wiki/Rainbow_table#Rainbow_tables">rainbow tables</a>)</li>
<li>Salting makes sure that the same password does not result in the same hash. 
  This makes sure you cannot determine if two users have the same password. And, <em>even more important</em>, you cannot determine if the same person uses the same password across different systems.</li>
<li><s>Salting increases the complexity of passwords, thereby greatly decreasing the effectiveness of both </s><a href="http://en.wikipedia.org/wiki/Dictionary_attack">Dictionary-</a><s> and </s><a href="http://en.wikipedia.org/wiki/Birthday_attack">Birthday attacks</a><s>.</s> (This is only true if the salt <em>is</em> stored separate from the hash).</li>
<li>Proper salting <em>greatly</em> increases the storage need for precomputation attacks, up to the point where they are no longer practical. (8 character case-sensitive alpha-numeric passwords with 16 bit salt, hashed to a 128 bit value, would take up <a href="https://www.google.com/search?q=62%5E8+%2a+2%5E16+%2a+128+bits+%3D&amp;gws_rd=ssl">just under 200</a> <a href="http://en.wikipedia.org/wiki/Exabyte">exabytes</a> without rainbow reduction).</li>
</ol>
<p><br/></p>
<h3>There is no need for the salt to be secret.</h3>
<p>A salt is not a secret key, instead a salt 'works' by making the hash function specific to each instance. With salted hash, there is not <em>one</em> hash function, but one for every possible salt value. This prevent the attacker from attacking <em>N</em> hashed passwords for less than <em>N</em> times the cost of attacking one password. This is the point of the salt.<br/>
  A "secret salt" is not a salt, it is called a "key", and it means that you are no longer computing a hash, but a <a href="http://en.wikipedia.org/wiki/Message_authentication_code">Message Authentication Code</a> (MAC). Computing MAC is tricky business (much trickier than simply slapping together a key and a value into a hash function) and it is a very different subject altogether.</p>
<p>The salt <strong>must be random</strong> for every instance in which it is used. This ensures that an attacker has to attack every salted hash separately.<br/>
  If you rely on your salt (or salting algorithm) being secret, you enter the realms of <a href="http://en.wikipedia.org/wiki/Security_through_obscurity#Arguments_against">Security Through Obscurity</a> (won't work). Most probably, you do not get additional security from the salt secrecy; you just get the warm fuzzy feeling of security. So instead of making your system more secure, it just distracts you from reality.</p>
<p><br/></p>
<h3>So, why does the salt have to be random?</h3>
<p>Technically, the salt should be <em>unique</em>. The point of the salt is to be distinct for each hashed password. This is meant <em>worldwide</em>. Since there is no central organization which distributes unique salts on demand, we have to rely on the next best thing, which is random selection with an unpredictable random generator, preferably within a salt space large enough to make collisions improbable (two instances using the same salt value).</p>
<p>It is tempting to try to derive a salt from some data which is "presumably unique", such as the user ID, but such schemes often fail due to some nasty details:</p>
<ol>
<li><p>If you use <strong>for example the user ID</strong>, some bad guys, attacking distinct systems, may just pool their resources and create precomputed tables for user IDs 1 to 50. A user ID is unique <em>system-wide</em> but not <em>worldwide</em>.</p></li>
<li><p>The same applies to the <strong>username</strong>: there is one "root" per Unix system, but there are many roots in the world. A rainbow table for "root" would be worth the effort, since it could be applied to millions of systems. Worse yet, there are also many "bob" out there, and many do not have sysadmin training: their passwords could be quite weak.</p></li>
<li><p>Uniqueness is also temporal. Sometimes, users change their password. For each <strong>new password</strong>, a <strong>new salt</strong> must be selected. Otherwise, an attacker obtained the hash of the old password and the hash of the new could try to attack both simultaneously.</p></li>
</ol>
<p>Using a random salt obtained from a cryptographically secure, unpredictable PRNG may be some kind of overkill, but at least it <em>provably</em> protects you against all those hazards. It's not about preventing the attacker from knowing what an <em>individual</em> salt is, it's about not giving them the big, fat target that will be used on a substantial number of potential targets. Random selection makes the targets as thin as is practical.</p>
<p><br/></p>
<h3>In conclusion:</h3>
<p>Use a random, evenly distributed, high entropy salt. Use a new salt whenever you create a new password or change a password. Store the salt along with the hashed password. Favor big salts (at least 10 bytes, preferably 16 or more).</p>
<p>A salt does not turn a bad password into a good password. It just makes sure that the attacker will at least pay the dictionary attack price for <em>each</em> bad password he breaks.</p>
<p><br/>
<em>Usefull sources:</em><br/>
<a href="http://stackoverflow.com/questions/536584/non-random-salt-for-password-hashes/536756#536756">stackoverflow.com: <em>Non-random salt for password hashes</em></a><br/>
<a href="http://www.schneier.com/book-practical.html">Bruce Schneier: <em>Practical Cryptography</em></a> (book)<br/>
<a href="http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html">Matasano Security: <em>Enough with the Rainbow Tables</em></a><br/>
<a href="http://www.usenix.org/events/usenix99/provos/provos_html/node9.html">usenix.org: <em>Unix crypt used salt since 1976</em></a><br/>
<a href="http://www.owasp.org/">owasp.org</a>: <a href="http://www.owasp.org/index.php/Hashing_Java#Why_add_salt_.3F"><em>Why add salt</em></a><br/>
<a href="http://www.openwall.com/">openwall.com</a>: <a href="http://www.openwall.com/lists/john-users/2005/12/18/1"><em>Salts</em></a> </p>
<p><em>Disclaimer:</em><br/>
  I'm not a security expert. (Although this answer was reviewed by <a href="http://stackoverflow.com/users/254279/thomas-pornin">Thomas Pornin</a>)<br/>
  If any of the security professionals out there find something wrong, please do comment or edit this wiki answer.</p>
</blockquote>
<p><br/>
<strong>As for what seems to be a good source for your random salt</strong><br/>
<sup>Also read: <a href="http://stackoverflow.com/questions/3436376/what-is-the-most-secure-seed-for-random-number-generation/3532136#3532136">What is the most secure seed for random number generation?</a></sup><br/>
In the absence of dedicated, hardware based, random generators, the best way of obtaining random data is to ask the operating system (on Linux, this is called <code>/dev/random</code> or <code>/dev/urandom</code> [both have advantages and problems, choose your poison]; on Windows, call <code>CryptGenRandom()</code>)  </p>
<p>If for some reason you do not have access to the above mentioned sources of random, in PHP you could use the following function:<br/>
<sup>From the source of <a href="http://www.openwall.com/phpass/">phpass v0.3</a></sup> </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
</span><span class="com">/**
 * Generate pseudo random bits
 * @copyright: public domain
 * @link http://www.openwall.com/phpass/
 * @param int $length number of bits to generate
 * @return string A string with the hexadecimal number
 * @note don't try to improve this, you will likely just ruin it
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> random_bits</span><span class="pun">(</span><span class="pln">$entropy</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $entropy </span><span class="pun">/=</span><span class="pln"> </span><span class="lit">8</span><span class="pun">;</span><span class="pln">
    $state </span><span class="pun">=</span><span class="pln"> uniqid</span><span class="pun">();</span><span class="pln">
    $str </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">&lt;</span><span class="pln"> $entropy</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">16</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $state </span><span class="pun">=</span><span class="pln"> md5</span><span class="pun">(</span><span class="pln">microtime</span><span class="pun">().</span><span class="pln">$state</span><span class="pun">);</span><span class="pln">
        $str </span><span class="pun">.=</span><span class="pln"> md5</span><span class="pun">(</span><span class="pln">$state</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    $str </span><span class="pun">=</span><span class="pln"> unpack</span><span class="pun">(</span><span class="str">'H*'</span><span class="pun">,</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$str</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $entropy</span><span class="pun">));</span><span class="pln">
    </span><span class="com">// for some weird reason, on some machines 32 bits binary data comes out as 65! hex characters!?</span><span class="pln">
    </span><span class="com">// so, added the substr</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">str_pad</span><span class="pun">(</span><span class="pln">$str</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> $entropy</span><span class="pun">*</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="str">'0'</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $entropy</span><span class="pun">*</span><span class="lit">2</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
</div></text><author><a href="/users/22674">Jacco</a></author><comments><comment><text><span class="comment-copy">ok, so how about I replace time() with a random string 32 char long. The random string could be generated from looping 32 times over a set of alphabet chars. Does that sound good?</span></text><author><a class="comment-user owner" href="/users/605098/zmol" title="939 reputation">zmol</a></author></comment><comment><text><span class="comment-copy">You should block-quote that. And consider making it a community wiki as just quoting another answer is not that big output.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,781 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">blockquoted the copied part</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">downvote but no comment?</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">It might be worth noting a new function in the (standard) OpenSSL extension in PHP 5.3: <a href="http://php.net/openssl_random_pseudo_bytes" rel="nofollow noreferrer"><code>openssl_random_pseudo_bytes()</code></a> as a fast, effective, well-tested entropy generator.</span></text><author><a class="comment-user" href="/users/168868/charles" title="41,480 reputation">Charles</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Updated</strong></p>
<p>It's not a really good salt, but probably good enough to defeat all but the most determined and resourceful attackers. The requirements for a good salt are:</p>
<ul>
<li>Different for each user</li>
<li>long enough (at the very least alphanumeric 8 characters) to make the concatenation of salt and (potentially weak) password too long for a brute force attack.</li>
</ul>
<p><code>time()</code> values are not really long enough, since they have 10 characters, but only digits. </p>
<p>Also, sometimes two users may get the same value when they are created within the same second. But that's only a problem if you have situations where many users are automatically created within the same second.</p>
<p>In any case, far more important than a perfect salt is using a good hash function, and SHA512 is one of the best we have available right now.</p>
</div></text><author><a href="/users/16883/michael-borgwardt">Michael Borgwardt</a></author><comments><comment><text><span class="comment-copy">Another requirement is, that the salt isn't in any way related to the user. Thus <code>time()</code> isn't ideal, as you already said.</span></text><author><a class="comment-user" href="/users/385378/nikic" title="70,498 reputation">NikiC</a></author></comment><comment><text><span class="comment-copy">Where the length of 8 chars came from?</span></text><author><a class="comment-user" href="/users/251311/zerkms" title="158,747 reputation">zerkms</a></author></comment><comment><text><span class="comment-copy">You missed one criterium: non-predictable. In other words, time is not a good salt.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">Not a good salt. One attack vector is based on forensically determining what time the data was encrypted.</span></text><author><a class="comment-user" href="/users/573261/richardthekiwi" title="75,327 reputation">RichardTheKiwi</a></author></comment><comment><text><span class="comment-copy">@Jacco Why is unpredictability that important for a salt used in password hashing? The attacker knows the hash since it is stored in the database together with the hash.</span></text><author><a class="comment-user" href="/users/445517/codesinchaos" title="78,763 reputation">CodesInChaos</a></author></comment><comment><text><span class="comment-copy">@cyberkiwi: attacker knows the salt, so what? There is no way to do anything but bruteforce in this case anyway.</span></text><author><a class="comment-user" href="/users/251311/zerkms" title="158,747 reputation">zerkms</a></author></comment><comment><text><span class="comment-copy">Because time() is a clustered result. I know that more users are only during daytime than during nighttime. So building my precomputation attack takes less time as I can achieve a higher chance of succes by predicting that the big chunk of user-passwords where created during daytime. (the downvote isn't mine)</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@Jacco I updated the question to include a summary of the answers, and requesting clarification about what you said <code>Use a random, evenly distributed, high entropy salt.</code> See my updated question</span></text><author><a class="comment-user owner" href="/users/605098/zmol" title="939 reputation">zmol</a></author></comment><comment><text><span class="comment-copy">@Jacco: You don't need to predict anything, you <i>know</i> the salt for each user. The clustering is no problem at all unless you get a situation where a large number of users is automatically created within the same second. Or, of course, if your hash function has weaknesses.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@zerkms: around 8 characters is where brute force attacks start getting really expensive, so you want your salt to push even weak/dictionary passwords well over that limit. But now I realize that time() only produces digits, making it decidedly too weak.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@Michael Borgwardt ok, so how about I replace time() with a random string 32 char long. The random string could be generated from looping 32 times over a set of alphabet chars. Does that sound good?</span></text><author><a class="comment-user owner" href="/users/605098/zmol" title="939 reputation">zmol</a></author></comment><comment><text><span class="comment-copy">@Michael Borgwardt the world is bigger than 1 system alone. The power of precomputation attacks is in re-usability, across systems. There is just no reason not to use a random salt and sidestep the entire problem.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@zmol: not sure I understand your method, but 32 alphanumeric characters would definitely be enough.</span></text><author><a class="comment-user" href="/users/16883/michael-borgwardt" title="258,504 reputation">Michael Borgwardt</a></author></comment><comment><text><span class="comment-copy">@Michael Borgwardt: uhm, longer salt make the hash evaluation longer?! Are you sure? "making it decidedly too weak." --- Why? sha wasn't compromised, so there is no way to hack it by any intelligent way, only bruteforce (and it doesn't matter what the salt is in this case). Am I wrong?</span></text><author><a class="comment-user" href="/users/251311/zerkms" title="158,747 reputation">zerkms</a></author></comment><comment><text><span class="comment-copy">@Jacco rainbow tables are large enough for even non-salted values. If you need to calculate rainbow table for every salt in the world, this is technically not feasible. IOW there's no practical way for reuse of calculations. Also, as others said, salt is known or can be learned, so how random it is, doens't matter.</span></text><author><a class="comment-user" href="/users/47961/eugene-mayevski-eldos" title="36,320 reputation">Eugene Mayevski 'EldoS</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>This post may veer a little too far away from your original question, but I hope you find it useful;</p>
<p>Security is about raising barriers and hurdles; defence in depth. There is no truly secure hashing solution, just ones that are hard to break. It's like putting in a burglar alarm and window locks in your house - make your site less attractive to break into than someone else's. </p>
<p>Salt for a crypt algorithm is only a small part of the security problem. A single salt simply means that there is one less thing to figure out when trying to break the password for multiple users. A low-entropy salt (such as the server's time) makes it a little bit harder, and a high-entropy salt makes it harder still. Which of these to use, and whether it's something you need to worry about primarily depends upon both the sensitivity of the data you're protecting, but also what other security measures you have in place. A site that just gives a personalised weather forecast for a selected city obviously has less sensitive data than one which has your home address, mother's maiden name, date of birth and other info which could be used for identification purposes.</p>
<p>So here's the rub; a high entropy salt is still a bad salt if it's easily obtainable.</p>
<p>In the real world, storing a salt in the database (random or not) is probably less secure than using a constant salt and burying it away from private eyes in a file inaccessible via the web browser. Whilst a unique and high entropy salt is harder to guess, if you've allowed root login from any server on MySql and set the password to 'password' it doesn't really matter! Constrast how easy it is to crack the database versus getting a valid login to your server - which is possibly more difficult to do discretely as you can put fail2ban and a plethora of other attack vector watchers in place depending upon your setup. </p>
<p>You can combine the two approaches by storing the location of a file containing a user-specific salt in the database, rather than the salt itself. Whether having to crack both the file system and the database is warranted depends whether the sensitivity of the data you are trying to protect warrants this overhead. </p>
<p>Another, alternative, recommendation from security experts is to store the username in a separate database (and ideally different technology) to the password, and reference between the two using a UUID. E.g. use both MySQL and SQLite. This means that both databases have to be cracked (and is also why, to go down a separate rabbit hole for the sake of an example, you should not store user details and credit card numbers in the same database since one is of no use without the other).</p>
<p>Note that Algorithms like SHA-512 and Blowfish can return the salt as part of their hash. Be careful with these as if you store the complete hash you give away the algorithm, which means there's two less thing for the hackers to figure out (the salt also gives away the algorithm).</p>
<p>Make sure you enforce strong passwords and usernames, so dictionary attacks will fail; I know of dictionaries for all 6-alphanumeric combinations of username/ password entries for MD5 and I suspect that there are more than this available for all sorts of algorithms. With the explosion of low-cost cloud and CPGPU computing, the size and complexity of available dictionaries is going to explode.</p>
<p>Ultimately, the most secure way is never to programatically generate a salt but require a user to enter it along with their username and password over a SSL link (so can't be snooped), but never store it. This is the approach taken by credit card companies; i.e. the 3-digit CSV security key on your credit card which you have to enter each and every time you buy online, since it should never be stored in any database. If you really want to generate the salt, send it to them separately (e.g. via SMS message or Email) and still make them enter it manually each time. With this approach, although more secure, you need to contrast the complexity against whether users will just stop using the site as you've made it too difficult for them to be bothered with it. </p>
<p>All of the above still relies on the fact that you also have protection in place against session hijacking, cross-site scripting, etc., etc. The world's strongest password algorithm is irrelevant if all I need to do is to calculate a valid PHPSESSID for a logged-in user and hijack it!</p>
<p>I am not a security expert, but have read up on this as much as I reasonably can do. The fact that there are so many books on the subject indicates how big the answer to your question really is.</p>
<p>A couple of really great books you might like to try which I've found invaluable are;</p>
<p>Web Application Vulnerabilities Detect, Exploit, Prevent - ISBN-13: 978-1-59749-209-6</p>
<p>Preventing Web Attacks with Apache - ISBN-13: 978-0-321-32128-2</p>
</div></text><author><a href="/users/614913/matt">Matt</a></author><comments><comment><text><span class="comment-copy">Although in general your answer is correct, some of the statements are plain false: "a high entropy salt is still a bad salt if it's easily obtainable." This statement, for example, is simply not true.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h3>No, time() is not a good salt</h3>
<p>It's best not to reinvent the wheel when it comes to authentication, but to answer your question, <strong><em>no</em></strong>. The problem with time():</p>
<ul>
<li>It's predictable and it correlates to potentially discoverable things. These issues make it easier to cross-match different hashed results.</li>
<li>There aren't very many possible values. Since the high-order bits don't change, it's an even narrower salt than it first appears.</li>
<li>Using it repeats previous mistakes. If this app were the <em>first</em> one to use <em>time()</em> as a salt, at least it would require a <em>new</em> attack.</li>
</ul>
</div></text><author><a href="/users/140740/digitalross">DigitalRoss</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Yes.<br/>
It seems that a unix timestamp, stored in the user database as a "Member since" field going to be decent salt.</p>
<p>However, salt question is most negligible one.
There are much more important things you have to pay attention to:</p>
<ol>
<li><p>Most likely not a password nor salt or hashing algorithm going to be weakest part of your site. Some lame file injection or XSS or CSRF surely is. So, don't make a too big deal of it.<br/>
Speaking of a true random string of 32 char long in the typical web-application is like speaking about 32-inch armored door in the wooden barn. </p></li>
<li><p>Speaking of passwords, <strong>most ever important</strong> thing is <strong>password complexity.</strong> With weak password no salt nor hashing algorithm, even super-ingenious-incredible-hard one, could help. It's a pain to ask users to use complex password, but without it everything else becomes a piece of crap.<br/>
So, your first concern should be password complexity. 12-16 characters of different case, including numbers and punctuation is a requirement. </p></li>
<li><p>As for the salt, <s>I see no benefit in using time, as you have to store it along with other user data. Better use a email - it's random enough and you have it already anyway. Don't forget to rehash a password if user changes their email. </s> it seems that unix timstamp going to be a decent salt, no need to use email or anything else.</p></li>
</ol>
<p><strong>Update</strong><br/>
As I can see, many people still unable to get the point.<br/>
Like that guy from the comments, saying</p>
<blockquote>
<p>Many users use weak passwords (we should educate them, or at least keep trying), but that is no excuse; they still deserve good security</p>
</blockquote>
<p><strong>They deserve, no doubt. But with weak password the mission. is. impossible.</strong></p>
<h1>If your password is weak, then no salt will protect it.</h1>
<p>While salt is not that important to spend a 10-kilobyte text on the topic. </p>
</div></text><author><a href="/users/285587/your-common-sense">Your Common Sense</a></author><comments><comment><text><span class="comment-copy">Many websites don't protect anything of value. But since users tend to reuse passwords a lot, the passwords themselves become the most valuable set of data typically available on those website. So in my opinion, properly securing the passwords is important, whatever the situation. Many users use weak passwords (we should educate them, or at least keep trying), but that is no excuse; they still deserve good security. Also, using a random salt is easy to implement; advising something else is just advising others to stop caring.</span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">I think this answer gets a lot of things wrong. a) Password complexity is not anywhere as important as password length. Having punctuations in a password is more harm than it is good. b) passwords, for most trivial sites, are the most important asset a site has. c) Even with a weak password, there are plenty of things you can do to enhance its security. However, I do agree that no salt in itself will protect a weak password. You need at least a proper hashing strategy as well.</span></text><author><a class="comment-user" href="/users/365237/eis" title="25,735 reputation">eis</a></author></comment><comment><text><span class="comment-copy">Where is the harm in having punctuations in a password? @eis</span></text><author><a class="comment-user" href="/users/2784939/ren%c3%a9-roth" title="1,097 reputation">René Roth</a></author></comment><comment><text><span class="comment-copy">@RenéRoth you're far less likely to remember them correctly in the long term, so the likelihood that you'll write them down increases.</span></text><author><a class="comment-user" href="/users/365237/eis" title="25,735 reputation">eis</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Salt is use to prevent rainbow attacks by breaking the match between the password and precomputed hash. So the main task for a salt is to be different for each user/password record. Quality of randomization of the salt doesn't matter much as long as the salt is different for different users. </p>
</div></text><author><a href="/users/47961/eugene-mayevski-eldos">Eugene Mayevski 'EldoS</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>the date when a member joins a forum/website is generally openly access able , which would be same as time() hence making your salt useless. </p>
</div></text><author><a href="/users/197992/mr-coder">Mr Coder</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>No! Never use the current time as the salt. You can use something like 'SecureRandom' in java to generate a random salt that is secure. Always use an unpredictable random number as the salt.<br/> Using time as the salt will help you to remove collisions only upto a certain extent(because two users can sypply the same passwords at the same time), but still make the passwords recoverable.</p>
</div></text><author><a href="/users/1139023/ashwin">Ashwin</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The user name should be sufficient enough and perhaps the registration time stamp, but you should store it somewhere in the database. Anyway every value you use to salt your password hash, should be stored some way, so you can recalculate the hash.</p>
<p>Is salting with user name + a time stamp secure enough? It should be. For cracking SHA512 Hashes normally Rainbow Tables are used. A user name + a time stamp should be a salt which is uniquq enough, so there is no way there is some Rainbow Table on the net which contains precalculated hashes with passwords, which are salted this way.</p>
</div></text><author><a href="/users/335976/kalkin">kalkin</a></author><comments><comment><text><span class="comment-copy">For what reason?</span></text><author><a class="comment-user" href="/users/251311/zerkms" title="158,747 reputation">zerkms</a></author></comment><comment><text><span class="comment-copy">I over read that he wants to hash passwords. Like i said the username and perhaps the registration timestamp should be enough.</span></text><author><a class="comment-user" href="/users/335976/kalkin" title="571 reputation">kalkin</a></author></comment></comments></answer></answers></post>