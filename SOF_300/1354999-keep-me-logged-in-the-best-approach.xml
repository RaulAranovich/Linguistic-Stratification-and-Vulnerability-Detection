<?xml version="1.0" encoding="utf-8"?>
<post><title>php - "Keep Me Logged In" - the best approach - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>My web application uses sessions to store information about the user once they've logged in, and to maintain that information as they travel from page to page within the app. In this specific application, I'm storing the <code>user_id</code>, <code>first_name</code> and <code>last_name</code> of the person. </p>
<p>I'd like to offer a "Keep Me Logged In" option on log in that will put a cookie on the user's machine for two weeks, that will restart their session with the same details when they return to the app.</p>
<p>What is the best approach for doing this? I don't want to store their <code>user_id</code> in the cookie, as it seems like that would make it easy for one user to try and forge the identity of another user.</p>
</div></text><author><a href="/users/736809/jimbo">Jimbo</a></author><comments><comment><text><span class="comment-copy">Be sure and skip to the <a href="http://stackoverflow.com/a/17266448/451969">real answer</a> by ircmaxwell.</span></text><author><a class="comment-user" href="/users/451969/jared-farrish" title="36,334 reputation">Jared Farrish</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Security Notice</strong>: Basing the cookie off an MD5 hash of deterministic data is a bad idea; it's better to use a random token derived from a CSPRNG. See <a href="http://stackoverflow.com/a/17266448/2224584">ircmaxell's answer</a> to this question for a more secure approach.</p>
</blockquote>
<p>Usually I do something like this:</p>
<ol>
<li>User logs in with 'keep me logged in'  </li>
<li>Create session  </li>
<li>Create a cookie called SOMETHING containing: md5(salt+username+ip+salt) and a cookie called somethingElse containing id   </li>
<li>Store cookie in database  </li>
<li>User does stuff and leaves ----  </li>
<li>User returns, check for somethingElse cookie, if it exists, get the old hash from the database for that user, check of the contents of cookie SOMETHING match with the hash from the database, which should also match with a newly calculated hash (for the ip) thus: cookieHash==databaseHash==md5(salt+username+ip+salt), if they do, goto 2, if they don't goto 1</li>
</ol>
<p>Off course you can use different cookie names etc. also you can change the content of the cookie a bit, just make sure it isn't to easily created. You can for example also create a user_salt when the user is created and also put that in the cookie. </p>
<p>Also you could use sha1 instead of md5 (or pretty much any algorithm)</p>
</div></text><author><a href="/users/35197/pim-jager">Pim Jager</a></author><comments><comment><text><span class="comment-copy">Why include the IP in the hash? Also, make sure to include timestamp information in the cookie and use this information to establish a maximum age for the cookie so that you are not creating an identity token that is good for eternity.</span></text><author><a class="comment-user" href="/users/160830/scott-mitchell" title="6,459 reputation">Scott Mitchell</a></author></comment><comment><text><span class="comment-copy">Nice answer. So I am assuming when they log out, the session is destroyed, the cookie is removed, and the record in the DB is deleted?</span></text><author><a class="comment-user" href="/users/1390354/barfoon" title="10,370 reputation">barfoon</a></author></comment><comment><text><span class="comment-copy">Yes, on logout you destroy/remove everything, that way the user won't accidentaly be logged in on return.</span></text><author><a class="comment-user" href="/users/35197/pim-jager" title="24,515 reputation">Pim Jager</a></author></comment><comment><text><span class="comment-copy">very nice one... well its nice to use the hash of all the mixture but we can use Session ID (use just the long session id string instead of the hash) generated by the php or any other language those are too very robust!... thanks Pim :)</span></text><author><a class="comment-user" href="/users/370029/abhishek-dilliwal" title="108 reputation">Abhishek Dilliwal</a></author></comment><comment><text><span class="comment-copy">@Abhishek Dilliwal: This is a pretty old thread but i came across it looking for the same answer as Mathew. I don't think using the session_ID would work for Pim's answer because you can't check the db hash, cookie hash and current session_ID because the session_ID changes every session_start(); just thought i'd point this out.</span></text><author><a class="comment-user" href="/users/478222/partack" title="556 reputation">Partack</a></author></comment><comment><text><span class="comment-copy">I'm sorry to be dull but what is the purpose of the second cookie somethingELSE? What is id in this case? Is it just a simple sort of "true/false" value to indicate whether the user wants to use the keep me logged in feature at all? If so, why not just check to see if the cookie SOMETHING exists in the first place? If the user didn't want their login to persist, the SOMETHING cookie wouldn't be there in the first place right? Finally, are you generating the hash again dynamically and checking it against the cookie and the DB as an extra measure of security?</span></text><author><a class="comment-user" href="/users/745388/itsmequinn" title="748 reputation">itsmequinn</a></author></comment><comment><text><span class="comment-copy">@Pim Jager: I'm also curious why you would need to include the IP - was your solution primarily focused on desktop web applications that would not be expected to be assigned different IPs or would you stand firm on including the IP if the app is intended to be used with mobile / laptop devices across various networks as well?</span></text><author><a class="comment-user" href="/users/814752/danny-bullis" title="934 reputation">Danny Bullis</a></author></comment><comment><text><span class="comment-copy">@itsmequinn: the purpose of the second cookie somethingELSE is to be stored on the client machine; the app needs to be able to compare the value stored in somethingELSE (e.g. a username, email address, or unique id) with the hashed value that is stored in the database. Notice the comparison step above of "cookieHash==databaseHash". This is the hashed value of the somethingELSE cookie being compared to the value that was stored at a prior time in the database, like when the user originally clicked "keep me logged in." In short, it's how you verify the current client machine is the original one.</span></text><author><a class="comment-user" href="/users/814752/danny-bullis" title="934 reputation">Danny Bullis</a></author></comment><comment><text><span class="comment-copy">@itsmequinn: sorry ran out of room. Yes, you generate the hash again dynamically with the value stored in somethingELSE, and compare that to the hashed value stored in the database (make sure you hash them the same way). Yes, if somethingELSE isn't there at all, then the user is taken through the login process all over again.</span></text><author><a class="comment-user" href="/users/814752/danny-bullis" title="934 reputation">Danny Bullis</a></author></comment><comment><text><span class="comment-copy">If you have your own MD5_encrypt and decrypt functions it will save you from storing the md5 value in the DB</span></text><author><a class="comment-user" href="/users/973969/dan-carter" title="156 reputation">Dan Carter</a></author></comment><comment><text><span class="comment-copy">In europe most consumer internet providers renew the IP after 24hrs (or earlier) which makes IP based keep-me-logged-in-identification impossible.</span></text><author><a class="comment-user" href="/users/1114320/sliq" title="7,257 reputation">Sliq</a></author></comment><comment><text><span class="comment-copy">Token should be RANDOM, not connected with user/his IP/his useragent/anything in any way. It's major security flaw.</span></text><author><a class="comment-user" href="/users/1504252/pamil" title="657 reputation">pamil</a></author></comment><comment><text><span class="comment-copy">Why do you use two salts?  md5(salt+username+ip+salt)</span></text><author><a class="comment-user" href="/users/856932/aaron-kreider" title="698 reputation">Aaron Kreider</a></author></comment><comment><text><span class="comment-copy">@pimjager - excellent</span></text><author><a class="comment-user" href="/users/3091530/user3091530" title="378 reputation">user3091530</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>OK, let me put this bluntly: if you're putting user data, or anything derived from user data into a cookie for this purpose, you're doing something wrong. </p>
<p>There. I said it. Now we can move on to the actual answer.</p>
<p>What's wrong with hashing user data, you ask? Well, it comes down to exposure surface and security through obscurity. </p>
<p>Imagine for a second that you're an attacker. You see a cryptographic cookie set for the remember-me on your session. It's 32 characters wide. Gee. That may be an MD5...</p>
<p>Let's also imagine for a second that they know the algorithm that you used. For example:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">md5</span><span class="pun">(</span><span class="pln">salt</span><span class="pun">+</span><span class="pln">username</span><span class="pun">+</span><span class="pln">ip</span><span class="pun">+</span><span class="pln">salt</span><span class="pun">)</span></code></pre>
<p>Now, all an attacker needs to do is brute force the "salt" (which isn't really a salt, but more on that later), and he can now generate all the fake tokens he wants with any username for his IP address! But brute-forcing a salt is hard, right? Absolutely. But modern day GPUs are exceedingly good at it. And unless you use sufficient randomness in it (make it large enough), it's going to fall quickly, and with it the keys to your castle.</p>
<p>In short, the only thing protecting you is the salt, which isn't really protecting you as much as you think.</p>
<p><strong>But Wait!</strong></p>
<p>All of that was predicated that the attacker knows the algorithm! If it's secret and confusing, then you're safe, right? <strong>WRONG</strong>. That line of thinking has a name: <em>Security Through Obscurity</em>, which should <strong>NEVER</strong> be relied upon.</p>
<p><strong>The Better Way</strong></p>
<p>The better way is to never let a user's information leave the server, except for the id. </p>
<p>When the user logs in, generate a large (128 to 256 bit) random token. Add that to a database table which maps the token to the userid, and then send it to the client in the cookie.</p>
<p>What if the attacker guesses the random token of another user? </p>
<p>Well, let's do some math here. We're generating a 128 bit random token. That means that there are:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">possibilities </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">^</span><span class="lit">128</span><span class="pln">
possibilities </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3.4</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">10</span><span class="pun">^</span><span class="lit">38</span></code></pre>
<p>Now, to show how absurdly large that number is, let's imagine every server on the internet (let's say 50,000,000 today) trying to brute-force that number at a rate of 1,000,000,000 per second each. In reality your servers would melt under such load, but let's play this out.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">guesses_per_second </span><span class="pun">=</span><span class="pln"> servers </span><span class="pun">*</span><span class="pln"> guesses
guesses_per_second </span><span class="pun">=</span><span class="pln"> </span><span class="lit">50</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pln">
guesses_per_second </span><span class="pun">=</span><span class="pln"> </span><span class="lit">50</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span></code></pre>
<p>So 50 quadrillion guesses per second. That's fast! Right?</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">time_to_guess </span><span class="pun">=</span><span class="pln"> possibilities </span><span class="pun">/</span><span class="pln"> guesses_per_second
time_to_guess </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3.4e38</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">50</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pln">
time_to_guess </span><span class="pun">=</span><span class="pln"> </span><span class="lit">6</span><span class="pun">,</span><span class="lit">800</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span><span class="pun">,</span><span class="lit">000</span></code></pre>
<p>So 6.8 sextillion seconds... </p>
<p>Let's try to bring that down to more friendly numbers.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="lit">215</span><span class="pun">,</span><span class="lit">626</span><span class="pun">,</span><span class="lit">585</span><span class="pun">,</span><span class="lit">489</span><span class="pun">,</span><span class="lit">599</span><span class="pln"> years</span></code></pre>
<p>Or even better:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="lit">47917</span><span class="pln"> times the age of the universe</span></code></pre>
<p>Yes, that's 47917 times the age of the universe... </p>
<p>Basically, it's not going to be cracked.</p>
<p>So to sum up:</p>
<p>The better approach that I recommend is to store the cookie with three parts. </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> onLogin</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $token </span><span class="pun">=</span><span class="pln"> </span><span class="typ">GenerateRandomToken</span><span class="pun">();</span><span class="pln"> </span><span class="com">// generate a token, should be 128 - 256 bit</span><span class="pln">
    storeTokenForUser</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">,</span><span class="pln"> $token</span><span class="pun">);</span><span class="pln">
    $cookie </span><span class="pun">=</span><span class="pln"> $user </span><span class="pun">.</span><span class="pln"> </span><span class="str">':'</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $token</span><span class="pun">;</span><span class="pln">
    $mac </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $cookie</span><span class="pun">,</span><span class="pln"> SECRET_KEY</span><span class="pun">);</span><span class="pln">
    $cookie </span><span class="pun">.=</span><span class="pln"> </span><span class="str">':'</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $mac</span><span class="pun">;</span><span class="pln">
    setcookie</span><span class="pun">(</span><span class="str">'rememberme'</span><span class="pun">,</span><span class="pln"> $cookie</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Then, to validate:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> rememberMe</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $cookie </span><span class="pun">=</span><span class="pln"> isset</span><span class="pun">(</span><span class="pln">$_COOKIE</span><span class="pun">[</span><span class="str">'rememberme'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> $_COOKIE</span><span class="pun">[</span><span class="str">'rememberme'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        list </span><span class="pun">(</span><span class="pln">$user</span><span class="pun">,</span><span class="pln"> $token</span><span class="pun">,</span><span class="pln"> $mac</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> explode</span><span class="pun">(</span><span class="str">':'</span><span class="pun">,</span><span class="pln"> $cookie</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">hash_equals</span><span class="pun">(</span><span class="pln">hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $user </span><span class="pun">.</span><span class="pln"> </span><span class="str">':'</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $token</span><span class="pun">,</span><span class="pln"> SECRET_KEY</span><span class="pun">),</span><span class="pln"> $mac</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        $usertoken </span><span class="pun">=</span><span class="pln"> fetchTokenByUserName</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hash_equals</span><span class="pun">(</span><span class="pln">$usertoken</span><span class="pun">,</span><span class="pln"> $token</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            logUserIn</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Note: Do not use the token or combination of user and token to lookup a record in your database. Always be sure to fetch a record based on the user and use a timing-safe comparison function to compare the fetched token afterwards. <a href="http://blog.ircmaxell.com/2014/11/its-all-about-time.html" rel="noreferrer">More about timing attacks</a>.</p>
<p>Now, it's <strong>very</strong> important that the <code>SECRET_KEY</code> be a cryptographic secret (generated by something like <code>/dev/urandom</code> and/or derived from a high-entropy input). Also, <code>GenerateRandomToken()</code> needs to be a strong random source (<code>mt_rand()</code> is not nearly strong enough. Use a library, such as <a href="https://github.com/ircmaxell/RandomLib" rel="noreferrer">RandomLib</a> or <a href="https://github.com/paragonie/random_compat" rel="noreferrer">random_compat</a>, or <code>mcrypt_create_iv()</code> with <code>DEV_URANDOM</code>)...</p>
<p>The <a href="https://secure.php.net/hash_equals" rel="noreferrer"><code>hash_equals()</code></a> is to prevent <a href="http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/" rel="noreferrer">timing attacks</a>.
If you use a PHP version below PHP 5.6 the function <a href="https://secure.php.net/hash_equals" rel="noreferrer"><code>hash_equals()</code></a> is not supported. In this case you can replace <a href="https://secure.php.net/hash_equals" rel="noreferrer"><code>hash_equals()</code></a> with the timingSafeCompare function:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">/**
 * A timing safe equals comparison
 *
 * To prevent leaking length information, it is important
 * that user input is always used as the second parameter.
 *
 * @param string $safe The internal (safe) value to be checked
 * @param string $user The user submitted (unsafe) value
 *
 * @return boolean True if the two strings are identical.
 */</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> timingSafeCompare</span><span class="pun">(</span><span class="pln">$safe</span><span class="pun">,</span><span class="pln"> $user</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">function_exists</span><span class="pun">(</span><span class="str">'hash_equals'</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> hash_equals</span><span class="pun">(</span><span class="pln">$safe</span><span class="pun">,</span><span class="pln"> $user</span><span class="pun">);</span><span class="pln"> </span><span class="com">// PHP 5.6</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// Prevent issues if string length is 0</span><span class="pln">
    $safe </span><span class="pun">.=</span><span class="pln"> chr</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    $user </span><span class="pun">.=</span><span class="pln"> chr</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// mbstring.func_overload can make strlen() return invalid numbers</span><span class="pln">
    </span><span class="com">// when operating on raw binary strings; force an 8bit charset here:</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">function_exists</span><span class="pun">(</span><span class="str">'mb_strlen'</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $safeLen </span><span class="pun">=</span><span class="pln"> mb_strlen</span><span class="pun">(</span><span class="pln">$safe</span><span class="pun">,</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">
        $userLen </span><span class="pun">=</span><span class="pln"> mb_strlen</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">,</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $safeLen </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$safe</span><span class="pun">);</span><span class="pln">
        $userLen </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// Set the result to the difference between the lengths</span><span class="pln">
    $result </span><span class="pun">=</span><span class="pln"> $safeLen </span><span class="pun">-</span><span class="pln"> $userLen</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Note that we ALWAYS iterate over the user-supplied length</span><span class="pln">
    </span><span class="com">// This is to prevent leaking length information</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">&lt;</span><span class="pln"> $userLen</span><span class="pun">;</span><span class="pln"> $i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// Using % here is a trick to prevent notices</span><span class="pln">
        </span><span class="com">// It's safe, since if the lengths are different</span><span class="pln">
        </span><span class="com">// $result is already non-0</span><span class="pln">
        $result </span><span class="pun">|=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ord</span><span class="pun">(</span><span class="pln">$safe</span><span class="pun">[</span><span class="pln">$i </span><span class="pun">%</span><span class="pln"> $safeLen</span><span class="pun">])</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">[</span><span class="pln">$i</span><span class="pun">]));</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// They are only identical strings if $result is exactly 0...</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $result </span><span class="pun">===</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">I strongly encourage everybody to upvote this excellent answer (as the currently accepted answer is 4 years old now).</span></text><author><a class="comment-user" href="/users/1114320/sliq" title="7,257 reputation">Sliq</a></author></comment><comment><text><span class="comment-copy">@ircmaxell : note that $COOKIE in function rememberMe() should be $_COOKIE</span></text><author><a class="comment-user" href="/users/446594/darkbee" title="4,659 reputation">DarkBee</a></author></comment><comment><text><span class="comment-copy">You are better with numbers than anything else :)</span></text><author><a class="comment-user" href="/users/816802/anuj" title="106 reputation">Anuj</a></author></comment><comment><text><span class="comment-copy">But doesn't this approach mean that anyone can take this username and cookie and log in as this user from any other device?</span></text><author><a class="comment-user" href="/users/2213898/simpler" title="76 reputation">Simpler</a></author></comment><comment><text><span class="comment-copy">Excellent! I would suggest providing a complete demonstration on a site like Github - This would become very famous.</span></text><author><a class="comment-user" href="/users/445820/aborted" title="1,371 reputation">Aborted</a></author></comment><comment><text><span class="comment-copy">Do you have to store the SECRET_KEY in the database as well as the token?</span></text><author><a class="comment-user" href="/users/1136379/arken" title="397 reputation">Arken</a></author></comment><comment><text><span class="comment-copy">@Arken no, the SECRET_KEY must stay somewhere safe in your code. If your database is hacked but not your code, you'll definitely be in trouble but at least your secret is safe.</span></text><author><a class="comment-user" href="/users/181206/capsule" title="4,575 reputation">Capsule</a></author></comment><comment><text><span class="comment-copy">ok, so if the secret stays in the code is it randomnly generated everytime the user loads the page, or is a constant variable that never changes?</span></text><author><a class="comment-user" href="/users/1136379/arken" title="397 reputation">Arken</a></author></comment><comment><text><span class="comment-copy">Do you recommend storing the rememberme cookie for say 30 days and if it expires then update to a new token or just keep updating the remember me cookie expiration and keep the token the same?</span></text><author><a class="comment-user" href="/users/1072492/dan" title="4,181 reputation">Dan</a></author></comment><comment><text><span class="comment-copy">lol :-), note that 47917 years is the maximum time to guess, the random token could be guessed in 1 hour too.</span></text><author><a class="comment-user" href="/users/458509/storm-buster" title="2,743 reputation">storm_buster</a></author></comment><comment><text><span class="comment-copy">@storm_buster It could be guessed in an hour.  (Also, it is 47917 ages  of the universe, not years.)   However, the probability of guessing it in a ages of the universe is a/47917.  The expectation value is 47917/2, which seems safe. :-)</span></text><author><a class="comment-user" href="/users/1375292/troy-daniels" title="782 reputation">Troy Daniels</a></author></comment><comment><text><span class="comment-copy">It's weird because your code contradicts your answer. You say "if you're putting user data into a cookie  [...] you're doing something wrong", but that is exactly what your code is doing! Isn't it better to remove the username from the cookie, calculate the hash over the token only (and maybe add the ip address to prevent cookie theft) and then do fetchUsernameByToken instead of fetchTokenByUserName in rememberMe()?</span></text><author><a class="comment-user" href="/users/789838/leven" title="469 reputation">Leven</a></author></comment><comment><text><span class="comment-copy">@leven the username is kept in the cookie since it can happen that the same random token is generated for two different username.. username becomes the unique identifier here</span></text><author><a class="comment-user" href="/users/1127787/lakshay" title="916 reputation">Lakshay</a></author></comment><comment><text><span class="comment-copy">As far as I can see, the cookie might as well just be a user id with no encryption.  OK - a big, hard to guess user id, but what you have stored is exactly what you need to log in. Am I missing something?</span></text><author><a class="comment-user" href="/users/1049792/enigma-plus" title="860 reputation">Enigma Plus</a></author></comment><comment><text><span class="comment-copy">@TractionBusinessSolutions yes, if you have it, you're logged in. It's a secret in that case. How else could you do it without it being a secret (yet still functioning to auto-login)? The key here is not obfuscation or anything, but making it hard to guess. So that if you know 1 remember me cookie, you can't generate or predict others. And this solves that attack surface...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">Since PHP 5.6, <a href="http://php.net/manual/en/function.hash-equals.php" rel="nofollow noreferrer">hash_equals</a> can be used to prevent timing attacks when doing string comparisons.</span></text><author><a class="comment-user" href="/users/624884/f21" title="13,605 reputation">F21</a></author></comment><comment><text><span class="comment-copy">I absolutely love this answer, this said: How does the hmac make a difference in this example. If there was additional unknown information (time, browser info, ...) in it, it would make sense, but as it stands, it seems to make no difference. If the cookie was stolen, then with or without the hmac it would be accepted. If not, then with our without it, it should take an average of 47917/2 life-times of the universe to guess it (ok, plus some security through obscurity added by the <code>SECRET_KEY</code> ;-)). Or am I missing something here?</span></text><author><a class="comment-user" href="/users/1680919/levit" title="7,703 reputation">Levit</a></author></comment><comment><text><span class="comment-copy">@Levit it prevents someone from taking a valid token, and changing the userid attached to it.</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@ircmaxell: Ah thx, I see! I store tokens already with associated userid in the database, so I did not think about that. Good point, and great answer!</span></text><author><a class="comment-user" href="/users/1680919/levit" title="7,703 reputation">Levit</a></author></comment><comment><text><span class="comment-copy">Lot's of good stuff in this answer, but as @levit notices, the hashing inside the cookie is unnecessary as both the user and token are stored in the database. Changing only the userid in the cookie won't help an attacker. The token in the database <a href="http://fishbowl.pastiche.org/2004/01/19/persistent_login_cookie_best_practice/" rel="nofollow noreferrer">needs to be hashed</a> (which it isn't here) to prevent misuse in case of database theft. fetchTokenByUserName is a bad idea as you can login from multiple pc's, tablets, smartphones. it is better to check if the combination of token and username is in the database.</span></text><author><a class="comment-user" href="/users/63849/jan-derk" title="810 reputation">Jan Derk</a></author></comment><comment><text><span class="comment-copy">And if you check on token and userid in the database no timing safe compare is needed either.</span></text><author><a class="comment-user" href="/users/63849/jan-derk" title="810 reputation">Jan Derk</a></author></comment><comment><text><span class="comment-copy">@JanDerk: Really good points too! Especially <b>multilple tokens</b> per user and <b>storing hashed</b> versions of the passwords instead. I also really like your point on timing-safety on comparing hashes, all hashes being equal in length (I actually wrote <a href="http://security.stackexchange.com/a/75746/28814">this answer</a> recently, about the exact same issue)!</span></text><author><a class="comment-user" href="/users/1680919/levit" title="7,703 reputation">Levit</a></author></comment><comment><text><span class="comment-copy">@storm_buster: I hope you were kidding ^^ But, yes it really could happen! It is just a bit more likely that one morning you are woken up by thunder, sampling Mozart's 5th symphony (in the correct key), have an earthquake schmear you a bagel and deliver it from the kitchen to your bed, while the lightning outside your window morses you "Enjoy your meal!". It really is possible, just not very likely.</span></text><author><a class="comment-user" href="/users/1680919/levit" title="7,703 reputation">Levit</a></author></comment><comment><text><span class="comment-copy">When retrieving from database, I just do <code>SELECT .. FROM .. WHERE token=this AND uname=that</code> (assuming a sane SQL type DB, and parameterized queries). If a proper row is returned, the cookies are valid. Is this a good way to check the cookie data?</span></text><author><a class="comment-user" href="/users/3459110/awal-garg" title="4,722 reputation">Awal Garg</a></author></comment><comment><text><span class="comment-copy">@JanDerk Am I misunderstood, finally  what we have got  is just store user id in cookie, and compare it with the token and username in database?</span></text><author><a class="comment-user" href="/users/1247890/wolfrevo" title="131 reputation">wolfrevo</a></author></comment><comment><text><span class="comment-copy">@Jacob You should store the userid and the token in a cookie and compare that to the hashed(token) / userid combination in the database. You can have multiple hashed(token) / userid combinations for the same user if she logs in from multiple devices.</span></text><author><a class="comment-user" href="/users/63849/jan-derk" title="810 reputation">Jan Derk</a></author></comment><comment><text><span class="comment-copy">Sorry but why do you return false in the middle of the validate function?</span></text><author><a class="comment-user" href="/users/814601/fernando" title="4,409 reputation">Fernando</a></author></comment><comment><text><span class="comment-copy">Regardless of the solution, we cannot do anything if an attacker A steals the cookie directly from the computer of the victim V, am I right? A can login as he was V, without the password. At least until the next time V logs in (if you change the cookie every time). IP checking is not a real solution since people change IP frequently. Someone can say that if A can access V's machine, at that point he can do whatever he wants; it is not true, he could have the possibility to access it  just for a very short time (enough to steal the cookie) and then do the rest of the "work" with his machine.</span></text><author><a class="comment-user" href="/users/858981/eugenio" title="688 reputation">Eugenio</a></author></comment><comment><text><span class="comment-copy">@Fernando I'm copying this script for a site I'm using, as it seems sound, and I encountered the same issue. I'm thinking this may be a bug/error in the script, and it should be negated, i.e. if(!...). I've changed the behavior for if the check fails to redirect to my logout script (to delete the incorrect/not valid cookie) using header(Refresh: ...) and then exit() -ing the validation script.  <code>if (!timingSafeCompare( ... )) {            header('Refresh: 3; url=login_logout.php');             echo 'Cookie not recognized, sending you to login form.';  		   exit();       }</code></span></text><author><a class="comment-user" href="/users/1049701/jelle-veraa" title="103 reputation">Jelle Veraa</a></author></comment><comment><text><span class="comment-copy">@Fernando Yes there was an exclamation point missing. This error was smuggled in from an edit in May 2015. The answer is now edited.</span></text><author><a class="comment-user" href="/users/2311074/adam" title="1,007 reputation">Adam</a></author></comment><comment><text><span class="comment-copy">@JanDerk I understand that you say its better to save the hashed token in the database and remove the $mac value - its cleaner. But there is nothing wrong with the approach of ircmaxell. In case of database theft, the hacker still has no access, because he doesn't know the $mac value. Thus, in ircmaxell's approach it is not necessary to save the hashed token.</span></text><author><a class="comment-user" href="/users/2311074/adam" title="1,007 reputation">Adam</a></author></comment><comment><text><span class="comment-copy">If you was to write a book, I would buy it</span></text><author><a class="comment-user" href="/users/701363/jquerybeast" title="4,910 reputation">jQuerybeast</a></author></comment><comment><text><span class="comment-copy">You don't store cookie into database?</span></text><author><a class="comment-user" href="/users/6381081/martin-aj" title="1,391 reputation">Martin AJ</a></author></comment><comment><text><span class="comment-copy">Folks, I'd really recommend taking this one step further. First, Don't just have a KEY, why not have a session ID as well. With the combination, you can avoid brute force attacks. If I have a session ID: ABCDEF, and a key 123456, then I can prevent someone from hacking both. If I get a request for session ABCDEF with a key of 123457, then I destroy the  ABCDEF session. This way, even if they 'guess' a valid id, unless their first 'guess' at a KEY is perfect, they no longer have a valid session to guess for. As IP concerns, store this in a session table somewhere and compare for VALID requests.</span></text><author><a class="comment-user" href="/users/1539331/new2web" title="152 reputation">NEW2WEB</a></author></comment><comment><text><span class="comment-copy">Best answer ever!</span></text><author><a class="comment-user" href="/users/3127057/mirko-brombin" title="452 reputation">Mirko Brombin</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Introduction</strong></p>
<p>Your title <strong>“Keep Me Logged In” - the best approach</strong> make it difficult for me to know where to start because if you are looking at best approach then you would have to consideration the following :</p>
<ul>
<li>Identification</li>
<li>Security </li>
</ul>
<p><strong>Cookies</strong></p>
<p>Cookies are vulnerable, Between common browser cookie-theft vulnerabilities and cross-site scripting attacks we must accept that cookies are not safe. To help improve security you must note that <code>php</code> <code>setcookies</code> has additional functionality such as </p>
<blockquote>
<p>bool <a href="http://php.net/manual/en/function.setcookie.php" rel="noreferrer">setcookie</a> ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool <strong>$secure</strong> = false [, bool <strong>$httponly</strong> = false ]]]]]] )</p>
</blockquote>
<ul>
<li>secure (Using HTTPS connection)</li>
<li>httponly (Reduce identity theft through XSS attack)</li>
</ul>
<p><strong>Definitions</strong> </p>
<ul>
<li>Token ( Unpredictable random string of n length eg. /dev/urandom)</li>
<li>Reference ( Unpredictable random string of n length eg. /dev/urandom)</li>
<li>Signature (Generate a keyed hash value using the HMAC method)</li>
</ul>
<p><strong>Simple Approach</strong> </p>
<p>A simple solution would be :</p>
<ul>
<li>User is logged on with Remember Me</li>
<li>Login Cookie issued with token &amp; Signature</li>
<li>When is returning , Signature is checked</li>
<li>If Signature is ok .. then username &amp; token is looked up in the database </li>
<li>if not valid .. return to login page</li>
<li>If valid automatically login </li>
</ul>
<p>The above case study summarizes all example given on this page but they disadvantages is that </p>
<ul>
<li>There is no way to know if the cookies was stolen</li>
<li>Attacker may be access  sensitive operations such as change of password or data such as personal and baking information etc.</li>
<li>The compromised cookie would still be valid for the cookie life span </li>
</ul>
<p><strong>Better Solution</strong></p>
<p>A better solution would be </p>
<ul>
<li>User is logged in and remember me is selected </li>
<li>Generate Token &amp; signature and store in cookie </li>
<li>The tokens are random and are only valid for single autentication </li>
<li>The token are replace on each visit to the site</li>
<li>When a non-logged user visit the site  the signature , token and username are verified </li>
<li>Remember me login should have limited access and not allow modification of password , personal information etc.</li>
</ul>
<p><em>Example Code</em> </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">// Set privateKey</span><span class="pln">
</span><span class="com">// This should be saved securely </span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> </span><span class="str">'fc4d57ed55a78de1a7b31e711866ef5a2848442349f52cd470008f6d30d47282'</span><span class="pun">;</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> pack</span><span class="pun">(</span><span class="str">"H*"</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln"> </span><span class="com">// They key is used in binary form</span><span class="pln">

</span><span class="com">// Am Using Memecahe as Sample Database</span><span class="pln">
$db </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Memcache</span><span class="pun">();</span><span class="pln">
$db</span><span class="pun">-&gt;</span><span class="pln">addserver</span><span class="pun">(</span><span class="str">"127.0.0.1"</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// Start Remember Me</span><span class="pln">
    $rememberMe </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RememberMe</span><span class="pun">(</span><span class="pln">$key</span><span class="pun">);</span><span class="pln">
    $rememberMe</span><span class="pun">-&gt;</span><span class="pln">setDB</span><span class="pun">(</span><span class="pln">$db</span><span class="pun">);</span><span class="pln"> </span><span class="com">// set example database</span><span class="pln">

    </span><span class="com">// Check if remember me is present</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$data </span><span class="pun">=</span><span class="pln"> $rememberMe</span><span class="pun">-&gt;</span><span class="pln">auth</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        printf</span><span class="pun">(</span><span class="str">"Returning User %s\n"</span><span class="pun">,</span><span class="pln"> $data</span><span class="pun">[</span><span class="str">'user'</span><span class="pun">]);</span><span class="pln">

        </span><span class="com">// Limit Acces Level</span><span class="pln">
        </span><span class="com">// Disable Change of password and private information etc</span><span class="pln">

    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// Sample user</span><span class="pln">
        $user </span><span class="pun">=</span><span class="pln"> </span><span class="str">"baba"</span><span class="pun">;</span><span class="pln">

        </span><span class="com">// Do normal login</span><span class="pln">
        $rememberMe</span><span class="pun">-&gt;</span><span class="pln">remember</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">);</span><span class="pln">
        printf</span><span class="pun">(</span><span class="str">"New Account %s\n"</span><span class="pun">,</span><span class="pln"> $user</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Exception</span><span class="pln"> $e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    printf</span><span class="pun">(</span><span class="str">"#Error  %s\n"</span><span class="pun">,</span><span class="pln"> $e</span><span class="pun">-&gt;</span><span class="pln">getMessage</span><span class="pun">());</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p><em>Class Used</em> </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">RememberMe</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> $key </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> $db</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">function</span><span class="pln"> __construct</span><span class="pun">(</span><span class="pln">$privatekey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $this</span><span class="pun">-&gt;</span><span class="pln">key </span><span class="pun">=</span><span class="pln"> $privatekey</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> setDB</span><span class="pun">(</span><span class="pln">$db</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $this</span><span class="pun">-&gt;</span><span class="pln">db </span><span class="pun">=</span><span class="pln"> $db</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> auth</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

        </span><span class="com">// Check if remeber me cookie is present</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln"> isset</span><span class="pun">(</span><span class="pln">$_COOKIE</span><span class="pun">[</span><span class="str">"auto"</span><span class="pun">])</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> empty</span><span class="pun">(</span><span class="pln">$_COOKIE</span><span class="pun">[</span><span class="str">"auto"</span><span class="pun">]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Decode cookie value</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln"> $cookie </span><span class="pun">=</span><span class="pln"> </span><span class="lit">@json_decode</span><span class="pun">(</span><span class="pln">$_COOKIE</span><span class="pun">[</span><span class="str">"auto"</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Check all parameters</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isset</span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">[</span><span class="str">'user'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> isset</span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">[</span><span class="str">'token'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> isset</span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">[</span><span class="str">'signature'</span><span class="pun">])))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        $var </span><span class="pun">=</span><span class="pln"> $cookie</span><span class="pun">[</span><span class="str">'user'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $cookie</span><span class="pun">[</span><span class="str">'token'</span><span class="pun">];</span><span class="pln">

        </span><span class="com">// Check Signature</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">verify</span><span class="pun">(</span><span class="pln">$var</span><span class="pun">,</span><span class="pln"> $cookie</span><span class="pun">[</span><span class="str">'signature'</span><span class="pun">]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Exception</span><span class="pun">(</span><span class="str">"Cokies has been tampared with"</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Check Database</span><span class="pln">
        $info </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">db</span><span class="pun">-&gt;</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">[</span><span class="str">'user'</span><span class="pun">]);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln"> $info</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"> </span><span class="com">// User must have deleted accout</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Check User Data</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln"> $info </span><span class="pun">=</span><span class="pln"> json_decode</span><span class="pun">(</span><span class="pln">$info</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Exception</span><span class="pun">(</span><span class="str">"User Data corrupted"</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Verify Token</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$info</span><span class="pun">[</span><span class="str">'token'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> $cookie</span><span class="pun">[</span><span class="str">'token'</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Exception</span><span class="pun">(</span><span class="str">"System Hijacked or User use another browser"</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">/**
         * Important
         * To make sure the cookie is always change
         * reset the Token information
         */</span><span class="pln">

        $this</span><span class="pun">-&gt;</span><span class="pln">remember</span><span class="pun">(</span><span class="pln">$info</span><span class="pun">[</span><span class="str">'user'</span><span class="pun">]);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $info</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> remember</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $cookie </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">
                </span><span class="str">"user"</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $user</span><span class="pun">,</span><span class="pln">
                </span><span class="str">"token"</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">getRand</span><span class="pun">(</span><span class="lit">64</span><span class="pun">),</span><span class="pln">
                </span><span class="str">"signature"</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">null</span><span class="pln">
        </span><span class="pun">];</span><span class="pln">
        $cookie</span><span class="pun">[</span><span class="str">'signature'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">[</span><span class="str">'user'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> $cookie</span><span class="pun">[</span><span class="str">'token'</span><span class="pun">]);</span><span class="pln">
        $encoded </span><span class="pun">=</span><span class="pln"> json_encode</span><span class="pun">(</span><span class="pln">$cookie</span><span class="pun">);</span><span class="pln">

        </span><span class="com">// Add User to database</span><span class="pln">
        $this</span><span class="pun">-&gt;</span><span class="pln">db</span><span class="pun">-&gt;</span><span class="kwd">set</span><span class="pun">(</span><span class="pln">$user</span><span class="pun">,</span><span class="pln"> $encoded</span><span class="pun">);</span><span class="pln">

        </span><span class="com">/**
         * Set Cookies
         * In production enviroment Use
         * setcookie("auto", $encoded, time() + $expiration, "/~root/",
         * "example.com", 1, 1);
         */</span><span class="pln">
        setcookie</span><span class="pun">(</span><span class="str">"auto"</span><span class="pun">,</span><span class="pln"> $encoded</span><span class="pun">);</span><span class="pln"> </span><span class="com">// Sample</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> verify</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> $hash</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $rand </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$hash</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> $rand</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> $hash</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> hash</span><span class="pun">(</span><span class="pln">$value</span><span class="pun">,</span><span class="pln"> $rand </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $rand </span><span class="pun">=</span><span class="pln"> $rand </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">getRand</span><span class="pun">(</span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> $rand</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $rand </span><span class="pun">.</span><span class="pln"> bin2hex</span><span class="pun">(</span><span class="pln">hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $value </span><span class="pun">.</span><span class="pln"> $rand</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">));</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> getRand</span><span class="pun">(</span><span class="pln">$length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">case</span><span class="pln"> function_exists</span><span class="pun">(</span><span class="str">"mcrypt_create_iv"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln">
                $r </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="pln">$length</span><span class="pun">,</span><span class="pln"> MCRYPT_DEV_URANDOM</span><span class="pun">);</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">case</span><span class="pln"> function_exists</span><span class="pun">(</span><span class="str">"openssl_random_pseudo_bytes"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln">
                $r </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="pln">$length</span><span class="pun">);</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">case</span><span class="pln"> is_readable</span><span class="pun">(</span><span class="str">'/dev/urandom'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="com">// deceze</span><span class="pln">
                $r </span><span class="pun">=</span><span class="pln"> file_get_contents</span><span class="pun">(</span><span class="str">'/dev/urandom'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $length</span><span class="pun">);</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">default</span><span class="pln"> </span><span class="pun">:</span><span class="pln">
                $i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
                $r </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pun">;</span><span class="pln">
                </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">$i </span><span class="pun">++</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> $length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                    $r </span><span class="pun">.=</span><span class="pln"> chr</span><span class="pun">(</span><span class="pln">mt_rand</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">255</span><span class="pun">));</span><span class="pln">
                </span><span class="pun">}</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">bin2hex</span><span class="pun">(</span><span class="pln">$r</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $length</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p><em>Testing in Firefox &amp; Chrome</em> </p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/9HiEL.png"/></p>
<p><em>Advantage</em> </p>
<ul>
<li>Better Security </li>
<li>Limited access for attacker </li>
<li>When cookie is stolen its only valid for single access </li>
<li>When next the original user access the site you can automatically detect and notify the user of theft </li>
</ul>
<p><em>Disadvantage</em> </p>
<ul>
<li>Does not support persistent connection via multiple browser (Mobile &amp; Web)</li>
<li>The cookie can still be stolen because the user only gets the notification after the next login.</li>
</ul>
<p><em>Quick Fix</em></p>
<ul>
<li>Introduction of approval system for each system that must have persistent connection </li>
<li>Use multiple cookies for the authentication</li>
</ul>
<p><strong>Multiple Cookie Approach</strong></p>
<p>When an attacker is about to steal cookes the only focus it on a particular website or domain eg. <strong>example.com</strong></p>
<p>But really you can authenticate a user from 2 different domains (<strong>example.com</strong> &amp; <strong>fakeaddsite.com</strong>) and make it look like "Advert Cookie" </p>
<ul>
<li>User Logged on to <strong>example.com</strong> with remember me</li>
<li>Store username , token , reference in cookie</li>
<li>Store username , token , reference in Database eg. Memcache </li>
<li>Send refrence id via get and iframe to <strong>fakeaddsite.com</strong></li>
<li>fakeaddsite.com uses the reference to fetch user &amp; token from Database</li>
<li>fakeaddsite.com stores the signature</li>
<li>When a user is returning fetch signature information with iframe from fakeaddsite.com</li>
<li>Combine it data and do the validation </li>
<li>..... you know the remaining</li>
</ul>
<p>Some people might wonder how can you use 2 different cookies ? Well its possible, imagine <code>example.com = localhost</code> and <code>fakeaddsite.com = 192.168.1.120</code>. If you inspect the cookies it would look like this </p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/JflH3.png"/></p>
<p>From the image above </p>
<ul>
<li>The current site visited is localhost </li>
<li>It also contains cookies set from 192.168.1.120</li>
</ul>
<p>192.168.1.120</p>
<ul>
<li>Only accepts defined <code>HTTP_REFERER</code></li>
<li>Only accepts connection from specified <code>REMOTE_ADDR</code></li>
<li>No JavaScript , No content but consist nothing rather than sign information and add or retrieve it from cookie </li>
</ul>
<p><em>Advantage</em></p>
<ul>
<li>99% percent of the time you have tricked the attacker </li>
<li>You can easily lock the account in the attacker first attempt  </li>
<li>Attack can be prevented even before the next login like the other methods </li>
</ul>
<p><em>Disadvantage</em> </p>
<ul>
<li>Multiple Request to server just for a single login </li>
</ul>
<p><em>Improvement</em> </p>
<ul>
<li>Done use iframe use <code>ajax</code> </li>
</ul>
</div></text><author><a href="/users/1226894/baba">Baba</a></author><comments><comment><text><span class="comment-copy">Even though @ircmaxell described the theory quite well, I prefer this approach, as it works excellent without the need to store the user ID (which would be an unwanted disclosure) and also includes more fingerprints than just the user ID and hash to identify the user, such as the browser. This makes it even harder for an attacker to make use of a stolen cookie. It's the best and most secure approach I've seen so far. +1</span></text><author><a class="comment-user" href="/users/3930946/marcello-m%c3%b6nkemeyer" title="465 reputation">Marcello Mönkemeyer</a></author></comment><comment><text><span class="comment-copy">+1 for "Remember me login should have limited access and not allow modification of password , personal information etc."</span></text><author><a class="comment-user" href="/users/4059832/spencer-oreilly" title="82 reputation">Spencer O'Reilly</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There are two very interesting articles, I found while searching for a perfect solution for the "remember-me"-problem:</p>
<ul>
<li><a href="http://fishbowl.pastiche.org/2004/01/19/persistent_login_cookie_best_practice/" rel="noreferrer">Persistent Login Cookie Best Practice</a></li>
<li><a href="http://jaspan.com/improved_persistent_login_cookie_best_practice" rel="noreferrer">Improved Persistent Login Cookie Best Practice</a></li>
</ul>
</div></text><author><a href="/users/11354/stefan-gehrig">Stefan Gehrig</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I asked one angle of this question <a href="http://stackoverflow.com/questions/1074831/remember-me-on-this-computer-how-should-it-work">here</a>, and the answers will lead you to all the token-based timing-out cookie links you need.</p>
<p>Basically, you do not store the userId in the cookie. You store a one-time token (huge string) which the user uses to pick-up their old login session. Then to make it really secure, you ask for a password for heavy operations (like changing the password itself).</p>
</div></text><author><a href="/users/8047/dan-rosenstark">Dan Rosenstark</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would recommend the approach mentioned by Stefan (i.e. follow the guidelines in <a href="http://jaspan.com/improved_persistent_login_cookie_best_practice" rel="noreferrer">Improved Persistent Login Cookie Best Practice</a>) and also recommend that you make sure your cookies are <a href="http://www.codinghorror.com/blog/2008/08/protecting-your-cookies-httponly.html" rel="noreferrer">HttpOnly cookies</a> so they are not accessible to, potentially malicious, JavaScript.</p>
</div></text><author><a href="/users/1654/walter-rumsby">Walter Rumsby</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Generate a hash, maybe with a secret only you know, then store it in your DB so it can be associated with the user. Should work quite well.</p>
</div></text><author><a href="/users/106862/jani-hartikainen">Jani Hartikainen</a></author><comments><comment><text><span class="comment-copy">Would this be a unique identifier that is created when the user is created, or would it change every time the user generates a new "Keep Me Logged In" cookie?</span></text><author><a class="comment-user owner" href="/users/55619/matthew" title="2,203 reputation">Matthew</a></author></comment><comment><text><span class="comment-copy">Tim Jansson's answer describes a good approach to producing the hash though I'd feel safer if it didn't include the password</span></text><author><a class="comment-user" href="/users/106862/jani-hartikainen" title="31,720 reputation">Jani Hartikainen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>My solution is like this. It's not 100% bulletproof but I think it will save you for the most of the cases.</p>
<p>When user logged in successfully create a string with this information:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$data </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">SALT </span><span class="pun">+</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> hash</span><span class="pun">(</span><span class="typ">User</span><span class="pln"> </span><span class="typ">Agent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> username 
                     </span><span class="pun">+</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">LoginTimestamp</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">":"</span><span class="pun">+</span><span class="pln"> SALT</span><span class="pun">)</span></code></pre>
<p>Encrypt <code>$data</code>, set type to <a href="https://www.owasp.org/index.php/HttpOnly" rel="nofollow">HttpOnly</a> and set cookie.</p>
<p>When user come back to your site, Make this steps:</p>
<ol>
<li>Get cookie data. Remove dangerous characters inside cookie. Explode it with <code>:</code> character. </li>
<li>Check validity. If cookie is older than X days then redirect user to login page.</li>
<li>If cookie is not old; Get latest password change time from database. If password is changed after user's last login redirect user to login page.</li>
<li>If pass wasn't changed recently; Get user's current browser agent. Check whether (currentUserAgentHash == cookieUserAgentHash). IF agents are same go to next step, else redirect to login page.</li>
<li>If all steps passed successfully authorize username.</li>
</ol>
<p>If user signouts, remove this cookie. Create new cookie if user re-logins.</p>
</div></text><author><a href="/users/429938/trante">trante</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I don't understand the concept of storing encrypted stuff in a cookie when it is the encrypted version of it that you need to do your hacking.  If I'm missing something, please comment.</p>
<p>I am thinking about taking this approach to 'Remember Me'.  If you can see any issues, please comment.</p>
<ol>
<li><p>Create a table to store "Remember Me" data in - separate to the user table so that I can log in from multiple devices.</p></li>
<li><p>On successful login (with Remember Me ticked):</p>
<p>a) Generate a unique random string to be used as the UserID on this machine: bigUserID</p>
<p>b) Generate a unique random string: bigKey</p>
<p>c) Store a cookie:  bigUserID:bigKey</p>
<p>d) In the "Remember Me" table, add a record with: UserID, IP Address, bigUserID, bigKey</p></li>
<li><p>If trying to access something that requires login:</p>
<p>a) Check for the cookie and search for bigUserID &amp; bigKey with a matching IP address</p>
<p>b) If you find it, Log the person in but set a flag in the user table "soft login" so that for any dangerous operations, you can prompt for a full login.</p></li>
<li><p>On logout, Mark all the "Remember Me" records for that user as expired.</p></li>
</ol>
<p>The only vulnerabilities that I can see is;</p>
<ul>
<li>you could get hold of someone's laptop and spoof their IP address with the cookie.</li>
<li>you could spoof a different IP address each time and guess the whole thing - but with two big string to match, that would be...doing a similar calculation to above...I have no idea...huge odds?</li>
</ul>
</div></text><author><a href="/users/1049792/enigma-plus">Enigma Plus</a></author><comments><comment><text><span class="comment-copy">Hello, and thanks for this answer, I like it. One question though : why do you have to generate 2 random strings - bigUserID &amp; bigKey ? Why don't you generate just 1 and use it ?</span></text><author><a class="comment-user" href="/users/1928380/jeremy-belolo" title="977 reputation">Jeremy Belolo</a></author></comment><comment><text><span class="comment-copy">bigKey expires after a predefined amount of time, but bigUserID doesn't.  bigUserID is to allow you to have multiple sessions on different devices at the same IP address.  Hope that makes sense - I had to think for a moment:)</span></text><author><a class="comment-user" href="/users/1049792/enigma-plus" title="860 reputation">Enigma Plus</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Old thread, but still a valid concern. I noticed some good responses about security, and avoiding use of 'security through obscurity', but the actual technical methods given were not sufficient in my eyes. Things I must say before I contribute my method:</p>
<ul>
<li><strong>NEVER</strong> store a password in clear text...EVER!</li>
<li><strong>NEVER</strong> store a user's hashed password in more than one location in your database. Your server backend is always capable of pulling the hashed password from the users table. It's not more efficient to store redundant data in lieu of additional DB transactions, the inverse is true.</li>
<li>Your Session ID's should be unique, so no two users could <strong>ever</strong> share an ID, hence the purpose of an ID (could your Driver's License ID number ever match another persons? No.) This generates a two-piece unique combination, based on 2 unique strings. Your Sessions table should use the ID as the PK. To allow multiple devices to be trusted for auto-signin, use another table for trusted devices which contains the list of all validated devices (see my example below), and is mapped using the username.</li>
<li>It serves no purpose to hash known data into a cookie, the cookie can be copied. What we are looking for is a complying user device to provide authentic information that cannot be obtained without an attacker compromising the user's machine (again, see my example). This would mean, however, that a legitimate user who forbids his machine's static information (i.e. MAC address, device hostname, useragent if restricted by browser, etc.) from remaining consistent (or spoofs it in the first place) will not be able to use this feature. But if this is a concern, consider the fact that you are offering auto-signin to users whom <strong><em>identify themselves uniquely</em></strong>, so if they refuse to be known by spoofing their MAC, spoofing their useragent, spoofing/changing their hostname, hiding behind proxies, etc., then they are not identifiable, and should never be authenticated for an automatic service. If you want this, you need to look into smart-card access bundled with client-side software that establishes identity for the device being used.</li>
</ul>
<p>That all being said, there are two great ways to have auto-signin on your system.</p>
<p>First, the cheap, easy way that puts it all on someone else. If you make your site support logging in with, say, your google+ account, you probably have a streamlined google+ button that will log the user in if they are already signed into google (I did that here to answer this question, as I am always signed into google). If you want the user automatically signed in if they are already signed in with a trusted and supported authenticator, and checked the box to do so, have your client-side scripts perform the code behind the corresponding 'sign-in with' button before loading, just be sure to have the server store a unique ID in an auto-signin table that has the username, session ID, and the authenticator used for the user. Since these sign-in methods use AJAX, you are waiting for a response anyway, and that response is either a validated response or a rejection. If you get a validated response, use it as normal, then continue loading the logged in user as normal. Otherwise, the login failed, but don't tell the user, just continue as not logged in, they will notice. This is to prevent an attacker who stole cookies (or forged them in an attempt to escalate privileges) from learning that the user auto-signs into the site.</p>
<p>This is cheap, and might also be considered dirty by some because it tries to validate your potentially already signed in self with places like Google and Facebook, without even telling you. It should, however, not be used on users who have not asked to auto-signin your site, and this particular method is only for external authentication, like with Google+ or FB.</p>
<p>Because an external authenticator was used to tell the server behind the scenes whether or not a user was validated, an attacker cannot obtain anything other than a unique ID, which is useless on its own. I'll elaborate:</p>
<ul>
<li>User 'joe' visits site for first time, Session ID placed in cookie 'session'.</li>
<li>User 'joe' Logs in, escalates privileges, gets new Session ID and renews cookie 'session'.</li>
<li>User 'joe' elects to auto-signin using google+, gets a unique ID placed in cookie 'keepmesignedin'.</li>
<li>User 'joe' has google keep them signed in, allowing your site to auto-signin the user using google in your backend.</li>
<li>Attacker systematically tries unique IDs for 'keepmesignedin' (this is public knowledge handed out to every user), and is not signed into anywhere else; tries unique ID given to 'joe'.</li>
<li>Server receives Unique ID for 'joe', pulls match in DB for a google+ account.</li>
<li>Server sends Attacker to login page that runs an AJAX request to google to login.</li>
<li>Google server receives request, uses its API to see Attacker is not logged in currently.</li>
<li>Google sends response that there is no currently signed in user over this connection.</li>
<li>Attacker's page receives response, script automatically redirects to login page with a POST value encoded in the url.</li>
<li>Login page gets the POST value, sends the cookie for 'keepmesignedin' to an empty value and a valid until date of 1-1-1970 to deter an automatic attempt, causing the Attacker's browser to simply delete the cookie.</li>
<li>Attacker is given normal first-time login page.</li>
</ul>
<p>No matter what, even if an attacker uses an ID that does not exist, the attempt should fail on all attempts except when a validated response is received.</p>
<p>This method can and should be used in conjunction with your internal authenticator for those who sign into your site using an external authenticator.</p>
<p><strong>=========</strong></p>
<p>Now, for your very own authenticator system that can auto-signin users, this is how I do it:</p>
<p>DB has a few tables:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">TABLE users</span><span class="pun">:</span><span class="pln">
UID </span><span class="pun">-</span><span class="pln"> </span><span class="kwd">auto</span><span class="pln"> increment</span><span class="pun">,</span><span class="pln"> PK
username </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(</span><span class="lit">255</span><span class="pun">),</span><span class="pln"> unique</span><span class="pun">,</span><span class="pln"> indexed</span><span class="pun">,</span><span class="pln"> NOT NULL
password_hash </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(</span><span class="lit">255</span><span class="pun">),</span><span class="pln"> NOT NULL
</span><span class="pun">...</span></code></pre>
<p>Note that the username is capable of being 255 characters long. I have my server program limit usernames in my system to 32 characters, but external authenticators might have usernames with their @domain.tld be larger than that, so I just support the maximum length of an email address for maximum compatibility.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">TABLE sessions</span><span class="pun">:</span><span class="pln">
session_id </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(?),</span><span class="pln"> PK
session_token </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(?),</span><span class="pln"> NOT NULL
session_data </span><span class="pun">-</span><span class="pln"> </span><span class="typ">MediumText</span><span class="pun">,</span><span class="pln"> NOT NULL</span></code></pre>
<p>Note that there is no user field in this table, because the username, when logged in, is in the session data, and the program does not allow null data. The session_id and the session_token can be generated using random md5 hashes, sha1/128/256 hashes, datetime stamps with random strings added to them then hashed, or whatever you would like, but the entropy of your output should remain as high as tolerable to mitigate brute-force attacks from even getting off the ground, and all hashes generated by your session class should be checked for matches in the sessions table prior to attempting to add them.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">TABLE autologin</span><span class="pun">:</span><span class="pln">
UID </span><span class="pun">-</span><span class="pln"> </span><span class="kwd">auto</span><span class="pln"> increment</span><span class="pun">,</span><span class="pln"> PK
username </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(</span><span class="lit">255</span><span class="pun">),</span><span class="pln"> NOT NULL</span><span class="pun">,</span><span class="pln"> allow duplicates
hostname </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(</span><span class="lit">255</span><span class="pun">),</span><span class="pln"> NOT NULL</span><span class="pun">,</span><span class="pln"> allow duplicates
mac_address </span><span class="pun">-</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">(</span><span class="lit">23</span><span class="pun">),</span><span class="pln"> NOT NULL</span><span class="pun">,</span><span class="pln"> unique
token </span><span class="pun">-</span><span class="pln"> varchar</span><span class="pun">(?),</span><span class="pln"> NOT NULL</span><span class="pun">,</span><span class="pln"> allow duplicates
expires </span><span class="pun">-</span><span class="pln"> datetime code</span></code></pre>
<p>MAC addresses by their nature are supposed to be UNIQUE, therefore it makes sense that each entry has a unique value. Hostnames, on the other hand, could be duplicated on separate networks legitimately. How many people use "Home-PC" as one of their computer names? The username is taken from the session data by the server backend, so manipulating it is impossible. As for the token, the same method to generate session tokens for pages should be used to generate tokens in cookies for the user auto-signin. Lastly, the datetime code is added for when the user would need to revalidate their credentials. Either update this datetime on user login keeping it within a few days, or force it to expire regardless of last login keeping it only for a month or so, whichever your design dictates.</p>
<p>This prevents someone from systematically spoofing the MAC and hostname for a user they know auto-signs in. <strong><em>NEVER</em></strong> have the user keep a cookie with their password, clear text or otherwise. Have the token be regenerated on each page navigation, just as you would the session token. This massively reduces the likelihood that an attacker could obtain a valid token cookie and use it to login. Some people will try to say that an attacker could steal the cookies from the victim and do a session replay attack to login. If an attacker could steal the cookies (which is possible), they would certainly have compromised the entire device, meaning they could just use the device to login anyway, which defeats the purpose of stealing cookies entirely. As long as your site runs over HTTPS (which it should when dealing with passwords, CC numbers, or other login systems), you have afforded all the protection to the user that you can within a browser.</p>
<p>One thing to keep in mind: session data should not expire if you use auto-signin. You can expire the ability to continue the session falsely, but validating into the system should resume the session data if it is persistent data that is expected to continue between sessions. If you want both persistent AND non-persistent session data, use another table for persistent session data with the username as the PK, and have the server retrieve it like it would the normal session data, just use another variable.</p>
<p>Once a login has been achieved in this way, the server should still validate the session. This is where you can code expectations for stolen or compromised systems; patterns and other expected results of logins to session data can often lead to conclusions that a system was hijacked or cookies were forged in order to gain access. This is where your ISS Tech can put rules that would trigger an account lockdown or auto-removal of a user from the auto-signin system, keeping attackers out long enough for the user to determine how the attacker succeeded and how to cut them off.</p>
<p>As a closing note, be sure that any recovery attempt, password changes, or login failures past the threshold result in auto-signin being disabled until the user validates properly and acknowledges this has occurred.</p>
<p>I apologize if anyone was expecting code to be given out in my answer, that's not going to happen here. I will say that I use PHP, jQuery, and AJAX to run my sites, and I NEVER use Windows as a server... ever. </p>
</div></text><author><a href="/users/3449006/user253780">user253780</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Implementing a "Keep Me Logged In" feature means you need to define exactly what that will mean to the user. In the simplest case, I would use that to mean the session has a much longer timeout: 2 days (say) instead of 2 hours. To do that, you will need your own session storage, probably in a database, so you can set custom expiry times for the session data. Then you need to make sure you set a cookie that will stick around for a few days (or longer), rather than expire when they close the browser.</p>
<p>I can hear you asking "why 2 days? why not 2 weeks?". This is because using a session in PHP will automatically push the expiry back. This is because a session's expiry in PHP is actually an idle timeout. </p>
<p>Now, having said that, I'd probably implement a harder timeout value that I store in the session itself, and out at 2 weeks or so, and add code to see that and to forcibly invalidate the session. Or at least to log them out. This will mean that the user will be asked to login periodically. Yahoo! does this.</p>
</div></text><author><a href="/users/28832/staticsan">staticsan</a></author><comments><comment><text><span class="comment-copy">Setting a longer session is probably bad because it wastes server resources and it will affect the performance adversely</span></text><author><a class="comment-user" href="/users/3091530/user3091530" title="378 reputation">user3091530</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I read all the answers and still found it difficult to extract what I was supposed to do. If a picture is worth 1k words I hope this helps others implement a secure persistent storage based on Barry Jaspan's <a href="http://jaspan.com/improved_persistent_login_cookie_best_practice" rel="nofollow noreferrer">Improved Persistent Login Cookie Best Practice</a></p>
<p><a href="https://i.stack.imgur.com/VGbRV.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/VGbRV.png"/></a></p>
<p>If you have questions, feedback, or suggestions, I will try to update the diagram to reflect for the newbie trying to implement a secure persistent login.</p>
</div></text><author><a href="/users/2070773/josh-woodcock">Josh Woodcock</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Use some kind of "cookie" hash, the username + <code>md5($ip, $username, $password)</code>? That would be my suggestion. </p>
<p>And <code>if(md5($_SERVER['REMOTE_ADDR'], $username, $password) = $cookiehash)</code> ? :) </p>
</div></text><author><a href="/users/165710/tim-jansson">Tim Jansson</a></author><comments><comment><text><span class="comment-copy">Keeping a password, or anything even related to it (such as a hash, which can be bruteforced) on the client? Not adding salt to an MD5 hash even though dictionaries that are available on the Internet? -1 for security issues with this approach.</span></text><author><a class="comment-user" href="/users/19530/maxvt" title="8,191 reputation">MaxVT</a></author></comment><comment><text><span class="comment-copy">-1, for security issues and assuming always static IPs.</span></text><author><a class="comment-user" href="/users/89771/alix-axel" title="93,655 reputation">Alix Axel</a></author></comment><comment><text><span class="comment-copy">Don't use deterministic data for secure authentication. If they hacker is able to hack one account they can hack the entire site.</span></text><author><a class="comment-user" href="/users/2070773/josh-woodcock" title="1,113 reputation">Josh Woodcock</a></author></comment></comments></answer></answers></post>