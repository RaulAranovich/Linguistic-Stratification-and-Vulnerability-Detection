<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Difference between Hashing a Password and Encrypting it - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>The current top-voted to <a href="http://stackoverflow.com/questions/325862/what-are-the-most-common-security-mistakes-programmers-make">this question</a> states:</p>
<blockquote>
<p>Another one that's not so much a security issue, although it is security-related, is complete and abject failure to <strong>grok the difference between hashing a password and encrypting it</strong>. Most commonly found in code where the programmer is trying to provide unsafe "Remind me of my password" functionality.</p>
</blockquote>
<p>What exactly is this difference? I was always under the impression that hashing was a form of encryption. What is the unsafe functionality the poster is referring to?</p>
</div></text><author><a href="/users/15055/claudiu">Claudiu</a></author><comments><comment><text><span class="comment-copy">A well-written article about why you should not simply hash you secrets/passwords. Instead use HMAC. <a href="http://benlog.com/articles/2008/06/19/dont-hash-secrets/" rel="nofollow noreferrer">benlog.com/articles/2008/06/19/dont-hash-secrets</a></span></text><author><a class="comment-user" href="/users/1039404/jay-kumar" title="1,104 reputation">Jay Kumar</a></author></comment><comment><text><span class="comment-copy">Excellent summary of subject on StackExchange security blog: <a href="http://security.blogoverflow.com/2011/11/why-passwords-should-be-hashed/" rel="nofollow noreferrer">security.blogoverflow.com/2011/11/…</a></span></text><author><a class="comment-user" href="/users/55452/david-j-liszewski" title="8,234 reputation">David J. Liszewski</a></author></comment><comment><text><span class="comment-copy">@JayKumar: The article you linked is very misleading. It conflates password salts (which are expected to be visible to attackers) with MAC keys (which are expected to remain secret). David J. Liszewski's link provides a much more accurate description.</span></text><author><a class="comment-user" href="/users/440302/rufflewind" title="6,031 reputation">Rufflewind</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Hashing is a one way function (well, a mapping). It's irreversible, you apply the secure hash algorithm and you cannot get the original string back. The most you can do is to generate what's called "a collision", that is, finding a different string that provides the same hash. Cryptographically secure hash algorithms are designed to prevent the occurrence of collisions. You can attack a secure hash by the use of a <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="noreferrer">rainbow table</a>, which you can contrarrest by applying a <a href="http://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noreferrer">salt</a> to the hash before storing it.</p>
<p>Encrypting is a proper (two way) function. It's reversible, you can decrypt the mangled string to get original string if you have the key.</p>
<p>The unsafe functionality it's referring to is that if you encrypt the passwords, your application has the key stored somewhere and an attacker who gets access to your database (and/or code) can get the original passwords by getting both the key and the encrypted text, whereas with a hash it's impossible.</p>
<p>People usually say that if a cracker owns your database or your code he doesn't need a password, thus the difference is moot. This is naïve, because you still have the duty to protect your users' passwords, mainly because most of them do use the same password over and over again, exposing them to a greater risk by leaking their passwords.</p>
</div></text><author><a href="/users/5190/vinko-vrsalovic">Vinko Vrsalovic</a></author><comments><comment><text><span class="comment-copy">To be clear, get the desired security with the hash, it must be a cryptographically secure hash algorithm with the specific property that not only the hash be non-reversable BUT ALSO computationally impractical to generate ANY other string that generates the same hash.</span></text><author><a class="comment-user" href="/users/1553/tall-jeff" title="7,416 reputation">Tall Jeff<span class="mod-flair" title="moderator">♦</span></a></author></comment><comment><text><span class="comment-copy">Yes and no...  Hash collisions need to be hard to generate for the sake of your own application's security, but non-reversability is sufficient for avoiding password leakage.</span></text><author><a class="comment-user" href="/users/18914/dave-sherohman" title="32,498 reputation">Dave Sherohman</a></author></comment><comment><text><span class="comment-copy">Thanks for the clear answer</span></text><author><a class="comment-user" href="/users/17787/chegueverra" title="5,454 reputation">CheGueVerra</a></author></comment><comment><text><span class="comment-copy">... thought to be irreversible ...</span></text><author><a class="comment-user" href="/users/1337/brad-gilbert" title="17,248 reputation">Brad Gilbert</a></author></comment><comment><text><span class="comment-copy">... designed to be irreversible ...</span></text><author><a class="comment-user" href="/users/5190/vinko-vrsalovic" title="175,840 reputation">Vinko Vrsalovic</a></author></comment><comment><text><span class="comment-copy">Dave: No it isn't. Here is a hash that isn't reversible : <code>f(n) = n % 2</code>. It also has a very high collision rate and is totally useless for crypto purposes. A lack of collisions is critical in a cryptographyically-secure hash.</span></text><author><a class="comment-user" href="/users/154152/noon-silk" title="41,472 reputation">Noon Silk</a></author></comment><comment><text><span class="comment-copy">silky: and how exactly are you going to get the original password back from your lousy hash function? I suggest you reread Dave's comment</span></text><author><a class="comment-user" href="/users/5190/vinko-vrsalovic" title="175,840 reputation">Vinko Vrsalovic</a></author></comment><comment><text><span class="comment-copy">If anything, a hash function that has a large number of collisions is better for the security of the passwords, however it would obviously mean more passwords could be used to login to the account.</span></text><author><a class="comment-user" href="/users/1476996/williamvicary" title="623 reputation">williamvicary</a></author></comment><comment><text><span class="comment-copy">if a user gets access to the server, they can get access to the config files. That being the case, is it recommended against storing the salt in the config files (i.e. should the salt be hardcoded)?</span></text><author><a class="comment-user" href="/users/534062/n00b" title="1,380 reputation">n00b</a></author></comment><comment><text><span class="comment-copy">@n00b salt's can't be hard coded because every hashed item should use a separate salt. The point of a salt is if both UserA and UserB uses password "1234" if you find out UserA's password you can't tell UserB used the same password because they had different salts. It is not security critical that a salts is kept secret, most implementations just concatenate the salt on to the front or the back of the binary blob that represents the hash.</span></text><author><a class="comment-user" href="/users/80274/scott-chamberlain" title="81,204 reputation">Scott Chamberlain</a></author></comment><comment><text><span class="comment-copy">@ScottChamberlain, How is it known which salt was used to generate the hash of a user's password (i.e. the hash stored in /etc/shadow)? A successful authentication seems to require that we know which salt was used so we can hash a user's input so we may arrive at the same hash</span></text><author><a class="comment-user" href="/users/2446071/sherrellbc" title="1,347 reputation">sherrellbc</a></author></comment><comment><text><span class="comment-copy">@sherrellbc Usually the salt is prepended or appended on to the hash. Specifically in <code>/etc/shadow</code> the data between the 2nd and 3rd <code>$</code> is the salt that was used. See <a href="http://www.aychedee.com/2012/03/14/etc_shadow-password-hash-formats/" rel="nofollow noreferrer">this page</a> for a full breakdown of how <code>/etc/shadow</code> stores it's hash and salt.</span></text><author><a class="comment-user" href="/users/80274/scott-chamberlain" title="81,204 reputation">Scott Chamberlain</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Hashing is a one-way function, meaning that once you hash a password it is <em>very</em> difficult to get the original password back from the hash.  Encryption is a two-way function, where it's much easier to get the original text back from the encrypted text.</p>
<p>Plain hashing is easily defeated using a dictionary attack, where an attacker just pre-hashes every word in a dictionary (or every combination of characters up to a certain length), then uses this new dictionary to look up hashed passwords.  Using a unique random salt for each hashed password stored makes it much more difficult for an attacker to use this method.  They would basically need to create a new unique dictionary for every salt value that you use, slowing down their attack terribly.</p>
<p>It's unsafe to store passwords using an encryption algorithm because if it's easier for the user or the administrator to get the original password back from the encrypted text, it's also easier for an attacker to do the same.</p>
</div></text><author><a href="/users/1288/bill-the-lizard">Bill the Lizard</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I've always thought that Encryption can be converted both ways, in a way that the end value can bring you to original value and with Hashing you'll not be able to revert from the end result to the original value. </p>
</div></text><author><a href="/users/17787/chegueverra">CheGueVerra</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Hashing algorithms are usually cryptographic in nature, but the principal difference is that encryption is reversible through decryption, and hashing is not.</p>
<p>An encryption function typically takes input and produces encrypted output that is the same, or slightly larger size.</p>
<p>A hashing function takes input and produces a typically smaller output, typically of a fixed size as well.</p>
<p>While it isn't possible to take a hashed result and "dehash" it to get back the original input, you can typically brute-force your way to something that produces the same hash.</p>
<p>In other words, if a authentication scheme takes a password, hashes it, and compares it to a hashed version of the requires password, it might not be required that you actually know the original password, only its hash, and you can brute-force your way to something that will match, even if it's a different password.</p>
<p>Hashing functions are typically created to minimize the chance of collisions and make it hard to just calculate something that will produce the same hash as something else.</p>
</div></text><author><a href="/users/267/lasse-v-karlsen">Lasse V. Karlsen</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p><img alt="Encrypted vs Hashed Passwords" src="https://i.stack.imgur.com/TNdb1.png"/></p>
<p>As shown in the above image, if the password is encrypted it is always a hidden secret where someone can extract the plain text password. However when password is hashed, you are relaxed as there is hardly any method of recovering the password from the hash value.</p>
<hr/>
<p>Extracted from <a href="http://www.digizol.com/2011/09/encrypted-vs-hashed-passwords-better.html" rel="noreferrer">Encrypted vs Hashed Passwords - Which is better?</a></p>
<h2>Is encryption good?</h2>
<p>Plain text passwords can be encrypted using symmetric encryption algorithms like DES, AES or with any other algorithms and be stored inside the database. At the authentication (confirming the identity with user name and password), application will decrypt the encrypted password stored in database and compare with user provided password for equality. In this type of an password handling approach, even if someone get access to database tables the passwords will not be simply reusable. However there is a bad news in this approach as well. If somehow someone obtain the cryptographic algorithm along with the key used by your application, he/she will be able to view all the user passwords stored in your database by decryption. "This is the best option I got", a software developer may scream, but is there a better way?</p>
<h2>Cryptographic hash function (one-way-only)</h2>
<p>Yes there is, may be you have missed the point here. Did you notice that there is no requirement to decrypt and compare? If there is one-way-only conversion approach where the password can be converted into some converted-word, but the reverse operation (generation of password from converted-word) is impossible. Now even if someone gets access to the database, there is no way that the passwords be reproduced or extracted using the converted-words. In this approach, there will be hardly anyway that some could know your users' top secret passwords; and this will protect the users using the same password across multiple applications. What algorithms can be used for this approach?</p>
</div></text><author><a href="/users/2581128/lkamal">lkamal</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>As correct as the other answers may be, in the context that the quote was in, hashing is a tool that may be used in securing information, encryption is a process that takes information and makes it very difficult for unauthorized people to read/use.</p>
</div></text><author><a href="/users/117/peter-coulton">Peter Coulton</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Ideally you should do both.</p>
<p>First Hash the pass password for the one way security.  Use a salt for extra security.</p>
<p>Then encrypt the hash to defend against dictionary attacks if your database of password hashes is compromised.</p>
</div></text><author><a href="/users/221560/logicmagic">LogicMagic</a></author><comments><comment><text><span class="comment-copy">Encrypt it with what? If they pwned you so hard that they got to the database with all your user's passwords (hashed, encrypted or otherwise), wouldn't they be able to find the key to decrypt them?</span></text><author><a class="comment-user" href="/users/1201863/luc" title="819 reputation">Luc</a></author></comment><comment><text><span class="comment-copy">This shoudn't be downvoted. It is a possibility which shouldn't be ruled out that easy, that the database is compromised while the application isn't. Therefore encrypting the hash is an extra layer of security.</span></text><author><a class="comment-user" href="/users/808824/arie" title="198 reputation">Arie</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Hashing: It is a one-way algorithm and once hashed can not rollback and this is its sweet point against encryption. If we perform encryption, there will a key to do this. If this key will be leaked all of your passwords could be decrypt easily. 
On the other hand, even if your database will be hacked or your server admin took data from DB and you used hashed passwords, hacker will not able to break these hashed passwords. This would actually practically impossible if we use hashing with proper salt and additional security with PBKDF2.</p>
<p>If you want to take a look on how should you write your hash functions, you can visit <a href="https://github.com/rahulgarg1985/CodeNode/blob/master/CodeNode.Core/Utils/Hasher.cs" rel="nofollow">here</a>.</p>
<p>There are many algorithms to perform hashing.</p>
<ol>
<li><p>MD5 - Uses the Message Digest Algorithm 5 (MD5) hash function. The output hash is 128 bits in length. The MD5 algorithm was designed by Ron Rivest in the early 1990s and is not a preferred option today.</p></li>
<li><p>SHA1 - Uses Security Hash Algorithm (SHA1) hash published in 1995. The output hash is 160 bits in length. Although most widely used, this is not a preferred option today.</p></li>
<li><p>HMACSHA256, HMACSHA384,HMACSHA512 - Use the functions SHA-256, SHA-384, and SHA-512 of the SHA-2 family. SHA-2 was published in 2001. The output hash lengths are 256, 384, and 512 bits, respectively,as the hash functions’ names indicate.</p></li>
</ol>
</div></text><author><a href="/users/3368262/rahul-garg">Rahul Garg</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Here's one reason you may want to use one over the other - password retrieval. </p>
<p>If you only store a hash of a user's password, you can't offer a 'forgotten password' feature.</p>
</div></text><author><a href="/users/755368/phil">Phil</a></author><comments><comment><text><span class="comment-copy">You obviously did not read the accepted answer well enough.  Read carefully:  You're <i>not</i> supposed to offer a password <b>retrieval</b> feature.  You're <i>supposed</i> to offer a password <b>reset</b> feature.  I have administered many websites for years, including vBulletin, phpBB, e107, IPB, blogspot, and even my own custom-built CMS.  As an administrator you NEVER EVER need to have someone's pre-hashed password.  You just don't.  And you shouldn't have it either.  If you don't agree with what I'm saying, let me assure you: you're wrong.</span></text><author><a class="comment-user" href="/users/856987/lakey" title="455 reputation">Lakey</a></author></comment><comment><text><span class="comment-copy">woops, yes I did mis-read it, thanks for pointing that out!</span></text><author><a class="comment-user" href="/users/755368/phil" title="45 reputation">Phil</a></author></comment><comment><text><span class="comment-copy">Sorry about being WAY too angry.  I just see too many websites store passwords in plain text and it frustrates me.  As a side note: some security-minded websites like to make users change their passwords periodically.  They want to ensure the person doesn't change his password from "Password1" to "Password2".  So they retain the plain-text password in order to do these comparisons at a later date.  That is not good practice.  What they need to do, in that case, is perform analysis on the password FIRST, making a bunch of similar passwords -- hash each one -- and only store the <i>hashes</i>.</span></text><author><a class="comment-user" href="/users/856987/lakey" title="455 reputation">Lakey</a></author></comment><comment><text><span class="comment-copy">No problem, it made me go back and re-read the question and also do further research, so all is not lost :-) I'm not sure what I was thinking when I wrote that answer. cheers</span></text><author><a class="comment-user" href="/users/755368/phil" title="45 reputation">Phil</a></author></comment></comments></answer></answers></post>