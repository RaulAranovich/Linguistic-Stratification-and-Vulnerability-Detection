<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Simplest two-way encryption using PHP - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>What is the simplest way of doing two way encryption in common PHP installs?</p>
<p>I need to be able to encrypt data with a string key, and use the same key to decrypt on the other end.</p>
<p>The security isn't as big of a concern as the portability of the code, so I'd like to be able to keep things as simple as possible. Currently, I am using an RC4 implementation, but if I can find something natively supported I figure I can save a lot of unnecessary code.</p>
</div></text><author><a href="/users/792066/braiam">Braiam</a></author><comments><comment><text><span class="comment-copy"><a href="http://www.go4expert.com/forums/showthread.php?t=5555" rel="nofollow noreferrer">Just XOR your string.</a></span></text><author><a class="comment-user" href="/users/303759/fix-moeller" title="616 reputation">fix_moeller</a></author></comment><comment><text><span class="comment-copy">I think "best" and "simplest" are two very different questions.</span></text><author><a class="comment-user" href="/users/13675/sparr" title="6,514 reputation">Sparr</a></author></comment><comment><text><span class="comment-copy">For general purpose encryption, use <a href="https://github.com/defuse/php-encryption/" rel="nofollow noreferrer">defuse/php-encryption/</a> instead of rolling your own.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Hands away from <a href="https://github.com/defuse/php-encryption/" rel="nofollow noreferrer">github.com/defuse/php-encryption</a> - it is slower by orders of magnitude than mcrypt.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy"><code>defuse/php-encryption</code> uses <code>openssl()</code> which can leverage <code>AES-NI</code> (which libmcrypt does not) and, depending on how much data you are encrypting, can therefore provide much faster encryption throughput than mcrypt. Please post a side-by-side benchmark to substantiate your claim.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Also, @EugenRieck, encryption probably will not be the bottleneck of your application. If it is, use libsodium ;)</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">@Scott Thinking along the lines of "this will probably not be the bottleneck" is what brought us a lot of bad software.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">If you're really encrypting/decrypting a lot of data to the point that the milliseconds it costs bogs your application down, bite the bullet and switch to libsodium. <code>Sodium::crypto_secretbox()</code> and <code>Sodium::crypto_secretbox_open()</code> are secure and performant.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Since my previous comment was posted, libsodium's PHP bindings changed. Now you want to use <code>\Sodium\crypto_secretbox()</code> and <code>\Sodium\crypto_secretbox_open()</code>.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p><strong>Edited:</strong></p>
<p>You should really be using <a href="https://php.net/openssl_encrypt">openssl_encrypt()</a> &amp; <a href="https://php.net/openssl_decrypt">openssl_decrypt()</a></p>
<p>As <a href="http://stackoverflow.com/a/30189841/2224584">Scott</a> says, Mcrypt is not a good idea as it has not been updated since 2007.</p>
<p>There is even an RFC to remove Mcrypt from PHP - <a href="https://wiki.php.net/rfc/mcrypt-viking-funeral">https://wiki.php.net/rfc/mcrypt-viking-funeral</a></p>
</div></text><author><a href="/users/472084/472084">472084</a></author><comments><comment><text><span class="comment-copy">Really recommending OpenSSL? Will need to patch every few days for another horrible bug.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">@EugenRieck Yes, that's the point. Mcrypt doesn't receive patches. OpenSSL receives patches as soon as any vulnerability is discovered, big or small.</span></text><author><a class="comment-user" href="/users/431780/greg" title="12,838 reputation">Greg</a></author></comment><comment><text><span class="comment-copy">@Greg big happens every other day - this is just bad-written software.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">Software that doesn't get patched â‰  Software that works.</span></text><author><a class="comment-user" href="/users/431780/greg" title="12,838 reputation">Greg</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Important</strong>: Unless you have a <em>very</em> particular use-case, <a href="https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded" rel="noreferrer">do not encrypt passwords</a>, use a password hashing algorithm instead. When someone says they <em>encrypt</em> their passwords in a server-side application, they're either uninformed or they're describing a dangerous system design. <a href="https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016" rel="noreferrer">Safely storing passwords</a> is a totally separate problem from encryption.</p>
<p>Be informed. Design safe systems.</p>
<h1>Portable Data Encryption in PHP</h1>
<p>If you're using <a href="http://php.net/eol.php" rel="noreferrer">PHP 5.4 or newer</a> and don't want to write a cryptography module yourself, I recommend using <a href="https://github.com/defuse/php-encryption" rel="noreferrer">an existing library that provides authenticated encryption</a>. The library I linked relies only on what PHP provides and is under periodic review by a handful of security researchers. (Myself included.)</p>
<p>If your portability goals do not prevent requiring PECL extensions, <strong><a href="https://pecl.php.net/package/libsodium" rel="noreferrer">libsodium</a></strong> is <em>highly</em> recommended over anything you or I can write in PHP.</p>
<p>If you want to try your hand at cryptography engineering, read on.</p>
<hr/>
<p>First, you should take the time to learn <a href="https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly#title.2.1" rel="noreferrer">the dangers of unauthenticated encryption</a> and <a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/" rel="noreferrer">the Cryptographic Doom Principle</a>.</p>
<ul>
<li>Encrypted data can still be tampered with by a malicious user.</li>
<li>Authenticating the encrypted data prevents tampering.</li>
<li>Authenticating the unencrypted data does not prevent tampering.</li>
</ul>
<h2>Encryption and Decryption</h2>
<p>Encryption in PHP is actually simple (we're going to use <a href="https://php.net/openssl_encrypt" rel="noreferrer"><code>openssl_encrypt()</code></a> and <a href="https://php.net/openssl_decrypt" rel="noreferrer"><code>openssl_decrypt()</code></a> once you have made some decisions about how to encrypt your information. Consult <code>openssl_get_cipher_methods()</code> for a list of the methods supported on your system. The best choice is <a href="http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html" rel="noreferrer">AES in CTR mode</a>:</p>
<ul>
<li><code>aes-128-ctr</code></li>
<li><code>aes-192-ctr</code></li>
<li><code>aes-256-ctr</code></li>
</ul>
<p>There is currently no reason to believe that the <a href="https://github.com/defuse/php-encryption/issues/35" rel="noreferrer">AES key size</a> is a significant issue to worry about (bigger is probably <em>not</em> better, due to bad key-scheduling in the 256-bit mode).</p>
<p>Note: <strong>We are not using <code>mcrypt</code> because it is <a href="http://sourceforge.net/projects/mcrypt/files/Libmcrypt" rel="noreferrer">abandonware</a></strong> and has <a href="http://sourceforge.net/p/mcrypt/patches/10" rel="noreferrer">unpatched bugs</a> that might be security-affecting. Because of these reasons, I encourage other PHP developers to avoid it as well.</p>
<h3>Simple Encryption/Decryption Wrapper using OpenSSL</h3>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">UnsafeCrypto</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> METHOD </span><span class="pun">=</span><span class="pln"> </span><span class="str">'aes-256-ctr'</span><span class="pun">;</span><span class="pln">

    </span><span class="com">/**
     * Encrypts (but does not authenticate) a message
     * 
     * @param string $message - plaintext message
     * @param string $key - encryption key (raw binary expected)
     * @param boolean $encode - set to TRUE to return a base64-encoded 
     * @return string (raw binary)
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> encrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $encode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        $nonceSize </span><span class="pun">=</span><span class="pln"> openssl_cipher_iv_length</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">METHOD</span><span class="pun">);</span><span class="pln">
        $nonce </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="pln">$nonceSize</span><span class="pun">);</span><span class="pln">

        $ciphertext </span><span class="pun">=</span><span class="pln"> openssl_encrypt</span><span class="pun">(</span><span class="pln">
            $message</span><span class="pun">,</span><span class="pln">
            </span><span class="kwd">self</span><span class="pun">::</span><span class="pln">METHOD</span><span class="pun">,</span><span class="pln">
            $key</span><span class="pun">,</span><span class="pln">
            OPENSSL_RAW_DATA</span><span class="pun">,</span><span class="pln">
            $nonce
        </span><span class="pun">);</span><span class="pln">

        </span><span class="com">// Now let's pack the IV and the ciphertext together</span><span class="pln">
        </span><span class="com">// Naively, we can just concatenate</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$encode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> base64_encode</span><span class="pun">(</span><span class="pln">$nonce</span><span class="pun">.</span><span class="pln">$ciphertext</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $nonce</span><span class="pun">.</span><span class="pln">$ciphertext</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Decrypts (but does not verify) a message
     * 
     * @param string $message - ciphertext message
     * @param string $key - encryption key (raw binary expected)
     * @param boolean $encoded - are we expecting an encoded string?
     * @return string
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> decrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $encoded </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$encoded</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            $message </span><span class="pun">=</span><span class="pln"> base64_decode</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$message </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Exception</span><span class="pun">(</span><span class="str">'Encryption failure'</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        $nonceSize </span><span class="pun">=</span><span class="pln"> openssl_cipher_iv_length</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">METHOD</span><span class="pun">);</span><span class="pln">
        $nonce </span><span class="pun">=</span><span class="pln"> mb_substr</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $nonceSize</span><span class="pun">,</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">
        $ciphertext </span><span class="pun">=</span><span class="pln"> mb_substr</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $nonceSize</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">

        $plaintext </span><span class="pun">=</span><span class="pln"> openssl_decrypt</span><span class="pun">(</span><span class="pln">
            $ciphertext</span><span class="pun">,</span><span class="pln">
            </span><span class="kwd">self</span><span class="pun">::</span><span class="pln">METHOD</span><span class="pun">,</span><span class="pln">
            $key</span><span class="pun">,</span><span class="pln">
            OPENSSL_RAW_DATA</span><span class="pun">,</span><span class="pln">
            $nonce
        </span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">return</span><span class="pln"> $plaintext</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<h3>Usage Example</h3>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$message </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Ready your ammunition; we attack at dawn.'</span><span class="pun">;</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> hex2bin</span><span class="pun">(</span><span class="str">'000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f'</span><span class="pun">);</span><span class="pln">

$encrypted </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UnsafeCrypto</span><span class="pun">::</span><span class="pln">encrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">
$decrypted </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UnsafeCrypto</span><span class="pun">::</span><span class="pln">decrypt</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">

var_dump</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln"> $decrypted</span><span class="pun">);</span></code></pre>
<p><strong>Demo</strong>: <a href="https://3v4l.org/jl7qR" rel="noreferrer">https://3v4l.org/jl7qR</a></p>
<hr/>
<p><strong>The above simple crypto library still is not safe to use.</strong> We need to <a href="http://tonyarcieri.com/all-the-crypto-code-youve-ever-written-is-probably-broken" rel="noreferrer">authenticate ciphertexts and verify them before we decrypt</a>.</p>
<p><strong>Note</strong>: By default, <code>UnsafeCrypto::encrypt()</code> will return a raw binary string. Call it like this if you need to store it in a binary-safe format (base64-encoded):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$message </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Ready your ammunition; we attack at dawn.'</span><span class="pun">;</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> hex2bin</span><span class="pun">(</span><span class="str">'000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f'</span><span class="pun">);</span><span class="pln">

$encrypted </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UnsafeCrypto</span><span class="pun">::</span><span class="pln">encrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
$decrypted </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UnsafeCrypto</span><span class="pun">::</span><span class="pln">decrypt</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">

var_dump</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln"> $decrypted</span><span class="pun">);</span></code></pre>
<p><strong>Demo</strong>: <a href="http://3v4l.org/f5K93" rel="noreferrer">http://3v4l.org/f5K93</a></p>
<h3>Simple Authentication Wrapper</h3>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">SaferCrypto</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">UnsafeCrypto</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> HASH_ALGO </span><span class="pun">=</span><span class="pln"> </span><span class="str">'sha256'</span><span class="pun">;</span><span class="pln">

    </span><span class="com">/**
     * Encrypts then MACs a message
     * 
     * @param string $message - plaintext message
     * @param string $key - encryption key (raw binary expected)
     * @param boolean $encode - set to TRUE to return a base64-encoded string
     * @return string (raw binary)
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> encrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $encode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        list</span><span class="pun">(</span><span class="pln">$encKey</span><span class="pun">,</span><span class="pln"> $authKey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">::</span><span class="pln">splitKeys</span><span class="pun">(</span><span class="pln">$key</span><span class="pun">);</span><span class="pln">

        </span><span class="com">// Pass to UnsafeCrypto::encrypt</span><span class="pln">
        $ciphertext </span><span class="pun">=</span><span class="pln"> parent</span><span class="pun">::</span><span class="pln">encrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $encKey</span><span class="pun">);</span><span class="pln">

        </span><span class="com">// Calculate a MAC of the IV and ciphertext</span><span class="pln">
        $mac </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln"> $ciphertext</span><span class="pun">,</span><span class="pln"> $authKey</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$encode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> base64_encode</span><span class="pun">(</span><span class="pln">$mac</span><span class="pun">.</span><span class="pln">$ciphertext</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="com">// Prepend MAC to the ciphertext and return to caller</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $mac</span><span class="pun">.</span><span class="pln">$ciphertext</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Decrypts a message (after verifying integrity)
     * 
     * @param string $message - ciphertext message
     * @param string $key - encryption key (raw binary expected)
     * @param boolean $encoded - are we expecting an encoded string?
     * @return string (raw binary)
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> decrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $encoded </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        list</span><span class="pun">(</span><span class="pln">$encKey</span><span class="pun">,</span><span class="pln"> $authKey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">::</span><span class="pln">splitKeys</span><span class="pun">(</span><span class="pln">$key</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$encoded</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            $message </span><span class="pun">=</span><span class="pln"> base64_decode</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$message </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Exception</span><span class="pun">(</span><span class="str">'Encryption failure'</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Hash Size -- in case HASH_ALGO is changed</span><span class="pln">
        $hs </span><span class="pun">=</span><span class="pln"> mb_strlen</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">),</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">
        $mac </span><span class="pun">=</span><span class="pln"> mb_substr</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $hs</span><span class="pun">,</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">

        $ciphertext </span><span class="pun">=</span><span class="pln"> mb_substr</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $hs</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="str">'8bit'</span><span class="pun">);</span><span class="pln">

        $calculated </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="pln">
            </span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln">
            $ciphertext</span><span class="pun">,</span><span class="pln">
            $authKey</span><span class="pun">,</span><span class="pln">
            </span><span class="kwd">true</span><span class="pln">
        </span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">hashEquals</span><span class="pun">(</span><span class="pln">$mac</span><span class="pun">,</span><span class="pln"> $calculated</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Exception</span><span class="pun">(</span><span class="str">'Encryption failure'</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="com">// Pass to UnsafeCrypto::decrypt</span><span class="pln">
        $plaintext </span><span class="pun">=</span><span class="pln"> parent</span><span class="pun">::</span><span class="pln">decrypt</span><span class="pun">(</span><span class="pln">$ciphertext</span><span class="pun">,</span><span class="pln"> $encKey</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">return</span><span class="pln"> $plaintext</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Splits a key into two separate keys; one for encryption
     * and the other for authenticaiton
     * 
     * @param string $masterKey (raw binary)
     * @return array (two raw binary strings)
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> splitKeys</span><span class="pun">(</span><span class="pln">$masterKey</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// You really want to implement HKDF here instead!</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">[</span><span class="pln">
            hash_hmac</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln"> </span><span class="str">'ENCRYPTION'</span><span class="pun">,</span><span class="pln"> $masterKey</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">),</span><span class="pln">
            hash_hmac</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln"> </span><span class="str">'AUTHENTICATION'</span><span class="pun">,</span><span class="pln"> $masterKey</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">];</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Compare two strings without leaking timing information
     * 
     * @param string $a
     * @param string $b
     * @ref https://paragonie.com/b/WS1DLx6BnpsdaVQW
     * @return boolean
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> hashEquals</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">,</span><span class="pln"> $b</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">function_exists</span><span class="pun">(</span><span class="str">'hash_equals'</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> hash_equals</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">,</span><span class="pln"> $b</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        $nonce </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="lit">32</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln"> $a</span><span class="pun">,</span><span class="pln"> $nonce</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">::</span><span class="pln">HASH_ALGO</span><span class="pun">,</span><span class="pln"> $b</span><span class="pun">,</span><span class="pln"> $nonce</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<h3>Usage Example</h3>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$message </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Ready your ammunition; we attack at dawn.'</span><span class="pun">;</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> hex2bin</span><span class="pun">(</span><span class="str">'000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f'</span><span class="pun">);</span><span class="pln">

$encrypted </span><span class="pun">=</span><span class="pln"> </span><span class="typ">SaferCrypto</span><span class="pun">::</span><span class="pln">encrypt</span><span class="pun">(</span><span class="pln">$message</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">
$decrypted </span><span class="pun">=</span><span class="pln"> </span><span class="typ">SaferCrypto</span><span class="pun">::</span><span class="pln">decrypt</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">

var_dump</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln"> $decrypted</span><span class="pun">);</span></code></pre>
<p><strong>Demos</strong>: <a href="http://3v4l.org/49Zdh" rel="noreferrer">raw binary</a>, <a href="http://3v4l.org/DSO3I" rel="noreferrer">base64-encoded</a></p>
<hr/>
<p>If anyone wishes to use this <code>SaferCrypto</code> library in a production environment, or your own implementation of the same concepts, I strongly recommend reaching out to <a href="http://crypto.stackexchange.com">your resident cryptographers</a> for a second opinion before you do. They'll be able tell you about mistakes that I might not even be aware of.</p>
<p>You will be much better off using <a href="https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide" rel="noreferrer">a reputable cryptography library</a>.</p>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments><comment><text><span class="comment-copy">So, I am just trying to get the UnsafeCrypto working first.  The encryption happens fine, but every time I run the decrypt, I am getting 'false' as the response.  I am using the same key to decrypt, and passing true on the encode, as well as the decode.  There is, what I assume is a typeo in the example, I am wondering if that is where my problem is coming from.  Can you explain where the $mac variable is coming from, and should it simply be $iv?</span></text><author><a class="comment-user" href="/users/618266/david-c" title="2,180 reputation">David C</a></author></comment><comment><text><span class="comment-copy">@DavidC <a href="http://stackoverflow.com/posts/30189841/revisions">Yes, it should</a>. Sorry for not noticing this sooner. I've also added 3v4l.org demos of the example code.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">OpenSSL - proud creators of heartbleed and friends. No thanks.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">@EugenRieck The OpenSSL cipher implementations are probably the only parts that don't suck, and it's the only way to leverage AES-NI in vanilla PHP. If you install on OpenBSD, PHP will be compiled against LibreSSL without the PHP code noticing a difference. Libsodium &gt; OpenSSL any day. Also, <a href="https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong" rel="nofollow noreferrer">don't use libmcrypt</a>. <b>What would you recommend PHP developers use instead of OpenSSL?</b></span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">@ScottArciszewski - You were quite able to read my recommendation, when you downvoted it: We are all grown-ups here, no need to play games. EOD, let's just agree to disagree.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">supported only in PHP 5.3 and above <a href="http://php.net/manual/en/function.openssl-encrypt.php" rel="nofollow noreferrer">php.net/manual/en/function.openssl-encrypt.php</a> any option for lower version preferably 5.2 but encrypted cipher should be pure text?</span></text><author><a class="comment-user" href="/users/2541634/akshay-khale" title="2,365 reputation">Akshay Khale</a></author></comment><comment><text><span class="comment-copy"><a href="https://secure.php.net/eol.php" rel="nofollow noreferrer">Neither 5.2 nor 5.3 are supported anymore</a>. You should instead look into updating to a <a href="https://secure.php.net/supported-versions.php" rel="nofollow noreferrer">supported version of PHP</a>, such a 5.6.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Your suggested cipher method is not available on my system. How do I know which alternatives are safe? There are literally 17 different "AES" options on my server for example.</span></text><author><a class="comment-user" href="/users/19851/abhi-beckert" title="21,134 reputation">Abhi Beckert</a></author></comment><comment><text><span class="comment-copy">(<code>aes-*-cbc</code> or <code>aes-*-ctr</code>) then HMAC-SHA256 is fine. <code>aes-*-gcm</code> is better, but not available before PHP 7.1.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">@ScottArciszewski, I have published a C# .NET port of your very helpful classes on GitHub: <a href="https://github.com/mayerwin/SaferCrypto" rel="nofollow noreferrer">github.com/mayerwin/SaferCrypto</a></span></text><author><a class="comment-user" href="/users/541420/erwin-mayer" title="8,090 reputation">Erwin Mayer</a></author></comment><comment><text><span class="comment-copy">The <b>UnsafeCrypto</b> class not work properly with URLs, How can we make it produce encrypted strings ready to use in URLs ?</span></text><author><a class="comment-user" href="/users/2432219/bbeta" title="312 reputation">BBeta</a></author></comment><comment><text><span class="comment-copy">@BBeta <a href="https://paragonie.com/blog/2015/09/comprehensive-guide-url-parameter-encryption-in-php" rel="nofollow noreferrer">paragonie.com/blog/2015/09/â€¦</a></span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Use <a href="http://php.net/manual/en/function.mcrypt-encrypt.php" rel="nofollow"><code>mcrypt_encrypt()</code></a> and <a href="http://php.net/manual/en/function.mcrypt-decrypt.php" rel="nofollow"><code>mcrypt_decrypt()</code></a> with corresponding parameters. Really easy and straight forward, and you use a battle-tested encryption package.</p>
<p><strong>EDIT</strong> </p>
<p>5 years and 4 months after this answer, the <code>mcrypt</code> extension is now in the process of deprecation and eventual removal from PHP.</p>
</div></text><author><a href="/users/1100552/eugen-rieck">Eugen Rieck</a></author><comments><comment><text><span class="comment-copy">Battle tested and not updated for more than 8 years?</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy">Well, mcrypt is in PHP7 and not deprecated - that's good enough for me. Not all code is of OpenSSL's horrible quality and needs patching every few days.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">mcrypt is not just horrible with regards to support. It also doesn't implement best practices like PKCS#7 compliant padding, authenticated encryption. It won't support SHA-3 or any other new algorithm as nobody is maintaining it, robbing you of an upgrade path. Furthermore it used to accept things like partial keys, performing zero padding etc. There is a good reason why it is in the process of being gradually removed from PHP.</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy">Whatever pleases you - I won't touch the mess that is OpenHeartbleed with a 10 foot pole, and since there is no sign of deprecation in PHP I question your story. We will have to agree to disagree.</span></text><author><a class="comment-user" href="/users/1100552/eugen-rieck" title="44,662 reputation">Eugen Rieck</a></author></comment><comment><text><span class="comment-copy">In PHP 7.1, all mcrypt_* functions will raise an E_DEPRECATED notice.  In PHP 7.1+1 (be it 7.2 or 8.0), the mcrypt extension will be moved out of core and into PECL, where people who <i>really</i> want to install it may still do so if they can install PHP extensions from PECL.</span></text><author><a class="comment-user" href="/users/1090395/mladen-janjetovic" title="3,422 reputation">Mladen Janjetovic</a></author></comment><comment><text><span class="comment-copy">you are invited to the funeral : <a href="https://wiki.php.net/rfc/mcrypt-viking-funeral" rel="nofollow noreferrer">wiki.php.net/rfc/mcrypt-viking-funeral</a></span></text><author><a class="comment-user" href="/users/236281/jean-christophe-meillaud" title="1,063 reputation">Jean-Christophe Meillaud</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Here is simple but secure enough implementation:</p>
<ul>
<li>AES-256 encryption in CBC mode  </li>
<li>PBKDF2 to create encryption key out of plain-text password  </li>
<li>HMAC to authenticate the encrypted message.</li>
</ul>
<p>Code and examples are here: <a href="http://stackoverflow.com/a/19445173/1387163">http://stackoverflow.com/a/19445173/1387163</a></p>
</div></text><author><a href="/users/1387163/eugene-fidelin">Eugene Fidelin</a></author><comments/></answer></answers></post>