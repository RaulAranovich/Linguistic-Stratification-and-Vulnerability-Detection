<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Which functions in the C standard library commonly encourage bad practice? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>This is inspired by <a href="http://stackoverflow.com/questions/4580329/string-handling-practices-in-c">this question</a> and the comments on one particular answer in that I learnt that <code>strncpy</code> is not a very safe string handling function in C and that it pads zeros, until it reaches <code>n</code>, something I was unaware of.</p>
<p>Specifically, to quote <a href="http://stackoverflow.com/users/379897/r">R..</a></p>
<blockquote>
<p>strncpy does not null-terminate, and
  does null-pad the whole remainder of
  the destination buffer, which is a
  huge waste of time. You can work
  around the former by adding your own
  null padding, but not the latter. It
  was never intended for use as a "safe
  string handling" function, but for
  working with fixed-size fields in Unix
  directory tables and database files.
  snprintf(dest, n, "%s", src) is the
  only correct "safe strcpy" in standard
  C, but it's likely to be a lot slower.
  By the way, truncation in itself can
  be a major bug and in some cases might
  lead to privilege elevation or DoS, so
  throwing "safe" string functions that
  truncate their output at a problem is
  not a way to make it "safe" or
  "secure". Instead, you should ensure
  that the destination buffer is the
  right size and simply use strcpy (or
  better yet, memcpy if you already know
  the source string length).</p>
</blockquote>
<p>And from <a href="http://stackoverflow.com/users/15168/jonathan-leffler">Jonathan Leffler</a></p>
<blockquote>
<p>Note that strncat() is even more
  confusing in its interface than
  strncpy() - what exactly is that
  length argument, again? It isn't what
  you'd expect based on what you supply
  strncpy() etc - so it is more error
  prone even than strncpy(). For copying
  strings around, I'm increasingly of
  the opinion that there is a strong
  argument that you only need memmove()
  because you always know all the sizes
  ahead of time and make sure there's
  enough space ahead of time. Use
  memmove() in preference to any of
  strcpy(), strcat(), strncpy(),
  strncat(), memcpy().</p>
</blockquote>
<p>So, I'm clearly a little rusty on the C standard library. Therefore, I'd like to pose the question:</p>
<p><strong>What C standard library functions are used inappropriately/in ways that may cause/lead to security problems/code defects/inefficiencies?</strong></p>
<p>In the interests of objectivity, I have a number of criteria for an answer:</p>
<ul>
<li>Please, if you can, cite design reasons behind the function in question i.e. its intended purpose.</li>
<li>Please highlight the misuse to which the code is currently put.</li>
<li>Please state why that misuse may lead towards a problem. I know that should be obvious but it prevents soft answers.</li>
</ul>
<p>Please avoid:</p>
<ul>
<li>Debates over naming conventions of functions (except where this unequivocably causes confusion).</li>
<li>"I prefer x over y" - preference is ok, we all have them but I'm interested in actual unexpected side effects and how to guard against them.</li>
</ul>
<p>As this is likely to be considered subjective and has no definite answer I'm flagging for community wiki straight away.</p>
<p>I am also working as per C99.</p>
</div></text><author><span class="community-wiki" title="This post is community owned as of Jan 4 '11 at 21:25. Votes do not generate reputation, and it can be edited by users with 100 rep">
            community wiki
        </span></author><comments><comment><text><span class="comment-copy">Any function can be used inappropriately and in ways that can lead to security holes.</span></text><author><a class="comment-user" href="/users/375874/falmarri" title="28,689 reputation">Falmarri</a></author></comment><comment><text><span class="comment-copy">@Falmarri - but some are frequently used inappropriately where others aren't, some seem to encourage misuse where others don't.</span></text><author><a class="comment-user" href="/users/180247/steve314" title="18,468 reputation">Steve314</a></author></comment><comment><text><span class="comment-copy">Why use C, when you can use C++?</span></text><author><a class="comment-user" href="/users/365102/mateen-ulhaq" title="7,293 reputation">Mateen Ulhaq</a></author></comment><comment><text><span class="comment-copy">Why eat grapes when you can eat bananas?</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">Why brush your teeth with a toilet brush? Just because it's bigger doesn't mean it'll do the job faster, or better.</span></text><author><a class="comment-user" href="/users/149482/matt-joiner" title="44,944 reputation">Matt Joiner</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>A common pitfall with the <code>strtok()</code> function is to assume that the parsed string is left unchanged, while it actually replaces the separator character with <code>'\0'</code>.</p>
<p>Also, <code>strtok()</code> is used by making subsequent calls to it, until the entire string is tokenized. Some library implementations store <code>strtok()</code>'s internal status in a global variable, which may induce some nasty suprises, if <code>strtok()</code> is called from multiple threads at the same time.</p>
<p>The <a href="https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard" rel="nofollow">CERT C Secure Coding Standard</a> lists many of these pitfalls you asked about.</p>
</div></text><author><a href="/users/287954">mizo</a></author><comments><comment><text><span class="comment-copy">+1 For mirroring my thoughts on strtok() and for mentioning the CERT C Secure Coding Standard.</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">+1, that's a great link, also @Jonathan sorry to quote you but you guys made me think "I definitely need to understand what's going on much more clearly". Hope you don't mind being famous!</span></text><author><span class="comment-user">user257111</span></author></comment><comment><text><span class="comment-copy">Technically, it is the library function rather than the compiler that stores the state.  The big problem is if you isolate a token in your string, and then call a function which, unbeknownst to you, itself calls <code>strtok()</code>.</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">@Ninefingers: I'll survive my 15 seconds of infamy :D</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy"><code>strtok</code> is <i>required</i> to keep its internal status globally even with threads, at least in a POSIX environment where threads are specified. This is because a conforming program could start parsing in one thread and finish in another. Of course MS has their own version of threads where they can specify the different (thread-local) behavior like they do, but it conflicts with POSIX.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">This is now community wiki which is good, but it still looks like I have to accept an answer, so I'm accepting this one for the CERT C Secure Coding Standard, which provides oodles of useful information.</span></text><author><span class="comment-user">user257111</span></author></comment><comment><text><span class="comment-copy">I'm puzzled as to why no-one has mentioned <code>strtok_r</code> as being (slightly) less confusing in that it doesn't keep global state.</span></text><author><a class="comment-user" href="/users/3177124/abligh" title="18,840 reputation">abligh</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>What C standard library functions are used inappropriately/in ways that may cause/lead to security problems/code defects/inefficiencies ?</p>
</blockquote>
<p>I'm gonna go with the obvious :</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">gets</span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">s</span><span class="pun">);</span></code></pre>
<p>With its remarkable particularity that it's simply impossible to use it appropriately.</p>
</div></text><author><a href="/posts/4588679/revisions" id="history-4588679" title="show revision history for this post">
        icecrime
        </a></author><comments><comment><text><span class="comment-copy">MacOS X actually prints out a runtime warning when you use it.</span></text><author><a class="comment-user" href="/users/492716/onemasse" title="3,868 reputation">onemasse</a></author></comment><comment><text><span class="comment-copy">Now that's one function I can honestly say I've never misused, because I've never actually used it.</span></text><author><span class="comment-user">user257111</span></author></comment><comment><text><span class="comment-copy"><code>gets()</code>: the absolute zero of software security.</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">Note that C0x will remove <code>gets()</code> from the standard.  Unfortunately, it will be another 10-20 years after that is finalized before it is removed from most implementations - backwards compatibility with insecurity dictates that.</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">@onemasse: does it really?  I hadn't noticed (but then, I don't use it, even in throwaway code!).  Much better that it warns about that than about <code>mktemp()</code>, which I do see periodically in some of the code I work on.</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">@Jonathan and MSVC won't support it... especially if it doesn't support C99.</span></text><author><span class="comment-user">user257111</span></author></comment><comment><text><span class="comment-copy">MSVC might. Their deal with the committee is that they'll support the new standard if the committee adds all their hideous <code>*_s</code> "secure" functions to the standard to force *nix implementations to pollute themselves with it. ;-)</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@Jonathan: I don't think it'll take 20 years.  I expect most *nix implementations, at least, will be pretty quick to guard it in the header with <code>#if defined IM_A_MORON_LET_ME_SHOOT_MYSELF_IN_THE_FOOT</code>.</span></text><author><a class="comment-user" href="/users/142434/stephen-canon" title="79,412 reputation">Stephen Canon</a></author></comment><comment><text><span class="comment-copy">@JonathanLeffler: The 2011 ISO C standard has indeed removed <code>gets()</code> from the standard library.</span></text><author><a class="comment-user" href="/users/827263/keith-thompson" title="159,193 reputation">Keith Thompson</a></author></comment><comment><text><span class="comment-copy">@KeithThompson: Yes! Now to get <code>gets()</code> removed from the system libraries everywhere, or replaced in the system library with <code>char *gets(char *str) { abort(); }</code> with a secondary library, <code>-lgets</code>, that has to be added to the link line to get the old style insecure <code>gets()</code> function.  A linker warning would be good (like for <code>mktemp()</code>) -- if that doesn't already occur. An unconditional compiler warning would be nice, too.</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In almost all cases, <code>atoi()</code> should not be used (this also applies to <code>atof()</code>, <code>atol()</code> and <code>atoll()</code>).</p>
<p>This is because these functions do not detect out-of-range errors at all - the standard simply says <em>"If the value of the result cannot be represented, the behavior is undefined."</em>.  So the only time they can be safely used is if you can prove that the input will certainly be within range (for example, if you pass a string of length 4 or less to <code>atoi()</code>, it cannot be out of range).</p>
<p>Instead, use one of the <code>strtol()</code> family of functions.</p>
</div></text><author><a href="/posts/4589447/revisions" id="history-4589447" title="show revision history for this post">
        caf
        </a></author><comments><comment><text><span class="comment-copy">+1 for pointing out the (mostly theoretical, but still) danger of <code>atoi</code> and UB.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">Excellent point.  There is no reason to use <code>ato*</code>.</span></text><author><a class="comment-user" href="/users/142434/stephen-canon" title="79,412 reputation">Stephen Canon</a></author></comment><comment><text><span class="comment-copy">It's actually pretty handy if you know what platform your code will run on, which, chances are, you do. E.g. MSVC says <i>The return value is 0 for <code>atoi</code> and <code>_wtoi</code>, if the input cannot be converted to a value of that type.</i>, so it's pretty well-defiend. (Also, this is another example where "undefined" and "implementation-defined" actually aren't exactly different -- they can both be defined by the implementation.)</span></text><author><a class="comment-user" href="/users/541686/mehrdad" title="110,253 reputation">Mehrdad</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Let us extend the question to interfaces in a broader sense.</p>
<p><code>errno</code>:</p>
<p>technically it is not even clear what it is, a variable, a macro, an implicit function call? In practice on modern systems it is mostly a macro that transforms into a function call to have a thread specific error state. It is evil:</p>
<ul>
<li>because it may cause overhead for the
caller to access the value, to check the "error" (which might just be an exceptional event)</li>
<li>because it even imposes at some places that the caller clears this "variable" before making a library call </li>
<li>because it implements a simple error
return by setting a global state, of the library.</li>
</ul>
<p>The forthcoming standard gets the definition of <code>errno</code> a bit more straight, but these uglinesses remain</p>
</div></text><author><a href="/posts/4589151/revisions" id="history-4589151" title="show revision history for this post">
        Jens Gustedt
        </a></author><comments><comment><text><span class="comment-copy">While it's a bit ugly, there's very little that's error-prone or dangerous about <code>errno</code>. It's a macro which evaluates to a modifiable lvalue of type <code>int</code>, which is plenty well-defined. As far as I can tell, this means you can take and save its address and access the current value through that address if you like. The only "bad practices" I can think of that <code>errno</code> might encourage are (1) modelling your own libraries error reporting on it, and (2) using <code>&amp;errno</code> as a cheap universally-portable thread-id. :-)</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">Quoth the standard: "The macro... <code>errno</code> which exapands to a modifiable lvalue that has type <code>int</code>...". So it is clear that it is a macro.</span></text><author><a class="comment-user" href="/users/545127/raedwald" title="19,372 reputation">Raedwald</a></author></comment><comment><text><span class="comment-copy">@Raedwald: yes, but it is not clear how the lvalue is obtained. Nowadays it is usually a function call, I think.</span></text><author><a class="comment-user" href="/users/366377/jens-gustedt" title="58,062 reputation">Jens Gustedt</a></author></comment><comment><text><span class="comment-copy">Surely <code>errno</code> is a macro, rather than an <code>extern int</code>, precisely to give the implementation that flexibility? Why is it a problem what it is?</span></text><author><a class="comment-user" href="/users/545127/raedwald" title="19,372 reputation">Raedwald</a></author></comment><comment><text><span class="comment-copy">Indeed, I don't see any problem with it being a modifiable lvalue whose definition is up to the implementation.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@R..: That is a very evil portable thread-id, would it work for compilers/platforms without TLS support?</span></text><author><a class="comment-user" href="/users/149482/matt-joiner" title="44,944 reputation">Matt Joiner</a></author></comment><comment><text><span class="comment-copy">@Jens Gustedt: Can you expand on the alleged changes in errno definition in forthcoming standard? I'm curious.</span></text><author><a class="comment-user" href="/users/149482/matt-joiner" title="44,944 reputation">Matt Joiner</a></author></comment><comment><text><span class="comment-copy">@Matt: it states explicitly that it has thread local storage duration. This is possible, there, since the new standard will have a thread model, quite close to POSIX BTW.</span></text><author><a class="comment-user" href="/users/366377/jens-gustedt" title="58,062 reputation">Jens Gustedt</a></author></comment><comment><text><span class="comment-copy">@Raedwald: problem is perhaps said too much, but the overhead that a simple <code>errno = 0;</code> produces is very difficult to estimate for an application.</span></text><author><a class="comment-user" href="/users/366377/jens-gustedt" title="58,062 reputation">Jens Gustedt</a></author></comment><comment><text><span class="comment-copy">@Matt: If it's a modifiable lvalue of type <code>int</code>, taking the address of it is valid, and it can't be the same as another thread's <code>errno</code> address. This does not depend on compiler-level TLS. For example <code>&amp;(*__errno_location())</code> is the same as <code>__errno_location()</code>. If you're writing your own locking code using atomic primitives (C1x, gcc builtins, or asm), <code>&amp;errno</code> seems like the safest "owner id" you can get without pulling in dependency on a specific threads implementation (pthreads, solaris, windows, etc.). I agree it's a bit evil though...</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@R, @Matt: the standard doesn't impose that the lvalue is the same between two subsequent uses of the macro by the same thread, I think. Although I have to admit that it sounds a bit insane to assume differently, but you could imagine that the library in addition of the thread-id keeps track of some other state of the thread and re-assigns a new address here and then.</span></text><author><a class="comment-user" href="/users/366377/jens-gustedt" title="58,062 reputation">Jens Gustedt</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There is often a strtok_r.</p>
<p>For realloc, if you need to use the old pointer, it's not that hard to use another variable. If your program fails with an allocation error, then cleaning up the old pointer is often not really necessary.</p>
</div></text><author><a href="/posts/4589221/revisions" id="history-4589221" title="show revision history for this post">
        davep
        </a></author><comments><comment><text><span class="comment-copy">I was going to say that this should be a comment, not an answer, but you can't comment without rep, so here, have some.</span></text><author><a class="comment-user" href="/users/142434/stephen-canon" title="79,412 reputation">Stephen Canon</a></author></comment><comment><text><span class="comment-copy">At the point when you say "often there is <code>strtok_r()</code>", you run into "occasionally there isn't" and "what are you going to do when it is not available?".  The secondary issue is the assumed platform - the question talks about C99, where <code>strtok_r()</code> is not available (nor is <code>strtok_s()</code> in general - from TR 24731-1).</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I would put <code>printf</code> and <code>scanf</code> pretty high up on this list.  The fact that you have to get the formatting specifiers exactly correct makes these functions tricky to use and extremely easy to get wrong.  It's also very hard to avoid buffer overruns when reading data out.  Moreover, the "printf format string vulnerability" has probably caused countless security holes when well-intentioned programmers specify client-specified strings as the first argument to printf, only to find the stack smashed and security compromised many years down the line.</p>
</div></text><author><a href="/posts/4588620/revisions" id="history-4588620" title="show revision history for this post">
        templatetypedef
        </a></author><comments><comment><text><span class="comment-copy">if your compiler is not able to tell you "you have used %x with an int number", ditch it, or turn its warning flags on.</span></text><author><a class="comment-user" href="/users/22985/batchyx" title="3,449 reputation">BatchyX</a></author></comment><comment><text><span class="comment-copy">I disagree.  It's only when the format string is computed at runtime instead of a constant string that they become dangerous.  GCC even has a nice warning option <code>-Wformat-nonliteral</code> for that case (which of course should be combined with <code>-Werror</code> to make warnings errors).</span></text><author><a class="comment-user" href="/users/9530/adam-rosenfield" title="257,958 reputation">Adam Rosenfield</a></author></comment><comment><text><span class="comment-copy">while you're at it, just enable -Wall, which also enable -Wformat.</span></text><author><a class="comment-user" href="/users/22985/batchyx" title="3,449 reputation">BatchyX</a></author></comment><comment><text><span class="comment-copy">@Adam: It's only <i>insecure</i> if you use runtime-computed format strings (or the <code>%n</code> format specifier), but it's still easy to get them wrong (although compiler warnings do help).</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">using the %n format specifier is perfectly fine when used correctly. This is even needed in some cases (that's why it's there).</span></text><author><a class="comment-user" href="/users/22985/batchyx" title="3,449 reputation">BatchyX</a></author></comment><comment><text><span class="comment-copy">The sprintf() function may also lead to buffer overruns if variables are output as something bigger than expected.  For example, code might expect that an "unsigned long" will take at most eleven bytes (ten digits and a null terminator) but crash on 64-bit systems where an unsigned long might take 21.</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment><comment><text><span class="comment-copy">The <code>printf</code> family (especially <code>snprintf</code>) is actually the best, most secure way to construct strings in the C standard library if you're remotely competent at C. I don't think these functions are at all to blame for idiots passing non-format strings in place of the format string argument...</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@R.: I don't think one would have had to be an idiot in the 1990's to e.g. sprintf a %lu into a 16-byte buffer without checking the numerical value of the data in question.  IMHO, what's too bad is that there's no standard vgprintf which would accept (in addition to vprintf arguments) a void* and a pointer to a function that takes a void * and a char; such a function could be used to synthesize any of the printf or vprintf variants, along with a bounds-limited sprintf, line-wrapped console printf, or any other desired printf-ish function.</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment><comment><text><span class="comment-copy">@supercat: I would say it was always stupid to use a constant independent of the appropriate <code>sizeof</code> expression as the buffer size. As for your theoretical <code>vgprintf</code>, it would be nice, but the problem is what level to put it at. I'm sure a lot of people would rather have <code>FILE</code> objects with user-provided callbacks, and use <code>vfprintf</code> with them. Of course this would be harder to use in the simplest cases, and might impose unwanted restrictions on the possible implementations of <code>stdio</code>.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">One more thing to think about regarding <code>vgprintf</code>... would the callbacks be required to accept data in whatever unit the implementation sends it in, or would they expect whole fields at a time? In the latter case, this requires dynamic allocation in the implementation and thus has out-of-memory failure conditions. In the former, <code>vgprintf</code> has <code>O(1)</code> space requirements (although possibly up to 8k or so if exact floating point output is required).</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@R.: How would one use sizeof() to compute the size of a string necessary to accommodate a decimal-printed number?  Simply figure (CHAR_BITS * sizeof(unsigned long))&gt;&gt;6+2 or something?  As for vgprintf, it would accept a void*, which would be passed to the output function.  For fprintf, it would be a FILE*; for sprintf, it would be a char**; for snprintf, it could be a pointer to a local struct with a char*, length so far, and maximum length.  No need for dynamic allocation.  Whoever calls vgprintf would be responsible for ensuring the passed in pointer was suitable for the passed-in function.</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment><comment><text><span class="comment-copy">@R.: BTW, I think vgprintf is a good way to explain the value of delegates in object-oriented languages.  In C, it's necessary to pass separately a function pointer and some data, and manually ensure that functions are only paired with the types of data they expect.  Delegates allow a function pointer to be bundled with a piece of data, which will be compile-time validated to ensure it's the proper type for the function.</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment><comment><text><span class="comment-copy">@supercat: I always use <code>3*sizeof(type)+2</code> because I don't write text processing code except on POSIX and POSIX-like systems where <code>CHAR_BIT</code> is required to be 8. But you can bring in <code>CHAR_BIT</code> if you like.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Any of the functions that manipulate global state, like <code>gmtime()</code> or <code>localtime()</code>.  These functions simply can't be used safely in multiple threads.</p>
<p><strong>EDIT:</strong> <code>rand()</code> is in the same category it would seem.  At least there are no guarantees of thread-safety, and on my Linux system the man page warns that it is non-reentrant and non-threadsafe.</p>
</div></text><author><a href="/users/47984">j_random_hacker</a></author><comments><comment><text><span class="comment-copy">As far as I know, the only conformant way to make <code>rand</code> thread-safe would be to synchronize it with a mutex, which would hurt performance quite a bit. For a given seed, it's supposed to always return the same sequence of pseudo-random numbers, so using a thread-local state could break this semantic in conformant applications which use their own mutex around calls to <code>rand</code>.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">... or which initially use <code>srand</code> and <code>rand</code> only in the main thread, then after initialization continue to use it in a newly created thread while never again using it in the main thread.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>One of my bêtes noire is <a href="http://stackoverflow.com/questions/4547570/tokenizing-a-string-in-c"><code>strtok()</code></a>, because it is non-reentrant and because it hacks the string it is processing into pieces, inserting NUL at the end of each token it isolates.  The problems with this are legion; it is distressingly often touted as a solution to a problem, but is as often a problem itself.  Not always - it can be used safely.  But only if you are careful.  The same is true of most functions, with the notable exception of <code>gets()</code> which cannot be used safely.</p>
</div></text><author><a href="/posts/4588940/revisions" id="history-4588940" title="show revision history for this post">
        Jonathan Leffler
        </a></author><comments><comment><text><span class="comment-copy">It's worth pointing out that <code>strtok()</code> was probably added because the pattern (<code>strchr()</code> or <code>strpbrk()</code> to look for a delimiter; overwrite delimiter with <code>'\0'</code>; loop until no more delimiters) is so common.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">@caf: that works if you don't need to know what the delimiter was, but not when you do need to know the delimiter.  See the question linked in my answer - and the pathetic excuses for apologia from those advocating <code>strtok()</code>.  It isn't often I use downvotes; there are two answers there with downvotes from me!</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">Well, I tend to think that <code>strtok()</code> is a little unfairly maligned, even if some of the criticisms are fair.  Perhaps because I've found more than one occasion when it <i>was</i> exactly what I wanted - as long as you stay within its intended domain (parsing simple strings like <code>PATH</code> variables) rather than trying to parse complex documents with it, I don't think it's too bad.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">@caf: The problem is that, as soon as somebody wants to take your code and use it in a library setting rather than in <code>main()</code>, they run into a nasty surprise and have to rip out <code>strtok</code> and replace it with a sane alternative.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@R.: Well, yes - all of the above should be taken modulo the usual caveats that apply to all non-reentrant functions.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There's already one answer about <code>realloc</code>, but I have a different take on it. A lot of time, I've seen people write <code>realloc</code> when they mean <code>free</code>; <code>malloc</code> - in other words, when they have a buffer full of trash that needs to change size before storing new data. This of course leads to potentially-large, cache-thrashing <code>memcpy</code> of trash that's about to be overwritten.</p>
<p>If used correctly with growing data (in a way that avoids worst-case <code>O(n^2)</code> performance for growing an object to size <code>n</code>, i.e. growing the buffer geometrically instead of linearly when you run out of space), <code>realloc</code> has doubtful benefit over simply doing your own new <code>malloc</code>, <code>memcpy</code>, and <code>free</code> cycle. The only way <code>realloc</code> can ever avoid doing this internally is when you're working with a single object at the top of the heap.</p>
<p>If you like to zero-fill new objects with <code>calloc</code>, it's easy to forget that <code>realloc</code> won't zero-fill the new part.</p>
<p>And finally, one more common use of <code>realloc</code> is to allocate more than you need, then resize the allocated object down to just the required size. But this can actually be harmful (additional allocation and <code>memcpy</code>) on implementations that strictly segregate chunks by size, and in other cases might increase fragmentation (by splitting off part of a large free chunk to store a new small object, instead of using an existing small free chunk).</p>
<p>I'm not sure if I'd say <code>realloc</code> <em>encourages</em> bad practice, but it's a function I'd watch out for.</p>
</div></text><author><a href="/posts/4590443/revisions" id="history-4590443" title="show revision history for this post">
        R..
        </a></author><comments><comment><text><span class="comment-copy">My guess is that the object being <code>realloc()</code>-ed <i>can</i> be extended in-place often enough to make preferring it over <code>free(); malloc();</code> worthwhile.  And your point about <code>realloc()</code>ing down to a smaller size causing fragmentation is weak I think -- yes, it could cause fragmentation, namely the exact amount of fragmentation that would have been caused if we had known the correct size to ask for at the time of the original <code>malloc()</code> call.</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">No. In the worst case, over-allocate and realloc-down provides fragmentation as bad as if you'd never performed the realloc-down. It will never be as good as allocating the right amount to begin with unless the right amount could only have been obtained by splitting off from a larger free chunk. As for extending in-place, if you're talking about an object that grows over time (like a buffer reading in a long file), you can only grow it geometrically or you'll risk <code>O(n^2)</code> copying time. When growing geometrically, extending in-place is <i>almost never</i> possible.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">As an example of the fragmentation, suppose you have a program that allocates 100k chunks and reallocates them down to ~1k, and makes no other allocation operations. After <code>heap_size/100k</code> (=20000 on many 32-bit systems) allocations, the next will fail, despite only 1% of the heap being "in-use". An allocator can avoid this issue by always moving chunks when they're resized down by a large factor, at the expense of some performance...</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">See what you mean about fragmentation.  But your scenario is unlikely: usually a realloc-down happens soon after the orginal allocation, before other allocations happen.  Also I don't see another, better way to approach the problem when you don't know the necessary size -- the only possibly sane alternative being to try exponentially larger guesses until one fits, but (a) usually that's more trouble than it's worth, (b) it requires O(log n) allocations and (c) it relies on being able to reacquire the data you're trying to store multiple times (impossible if, say, you're reading from a pipe).</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">Also not sure why you think growing geometrically and in-place is "almost never" possible.  I don't have stats (nor I suspect do you), but I expect a decent proportion of reallocations act on the most recently (re)allocated block, which is likely to be so extendable.  I think the strongest thing you could say against <code>realloc()</code> here is that this likelihood of in-place extension of the most recently allocated block reduces the chance of actually getting O(n^2) behaviour from a poorly-thought-out (linearly-growing) growth scheme, thereby encouraging this bad practice.</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">A <code>malloc</code> implementation that aims to avoid fragmentation will aim satisfy all allocations using a free chunk that's as close as possible to the requested size. In dlmalloc-like implementations with a logarithmic free bin scale, the chunk used to satisfy the allocation will never be more than a small factor (1.5x, I believe) larger than the request, unless no free chunks that small are available. Sure it's possible, but I think it's pretty unlikely to have non-top-of-heap large free chunks but no small free chunks.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">As for what to do when you don't know the size that's needed, my favorite approach is almost always to figure it out, even if that means running your computation once and throwing the results away, then running it again. (For instance, first calling <code>snprintf</code> with a zero size.) If you really want to do the over-allocate-and-shrink approach, you can simply call <code>malloc</code>, <code>memcpy</code>, and <code>free</code> yourself, and fallback to trying <code>realloc</code> if <code>malloc</code> fails. This is safe against inducing fragmentation.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">Good conversation :)  "it's pretty unlikely to have non-top-of-heap large free chunks but no small free chunks" -- I agree.  I'd say you're much more likely to have a stack-like sequence of allocations and deallocations that leave no (or very few) gaps at all, so that there is a high probability that any given <code>malloc()</code> call will be allocating from the end of currently allocated memory and so can be extended in-place with an immediately subsequent <code>realloc()</code>.  Still true even if size binning is used -- it's not the case that certain memory ranges "belong" just to certain allocation sizes.</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">... or if it is then the system is inherently memory-wasteful.  Re overallocate-and-shrink, I don't understand how calling <code>malloc()</code>, <code>memcpy()</code> and <code>free()</code> myself is less prone to fragmentation than calling <code>realloc()</code>, since AFAICT that's exactly what <code>realloc()</code> would do itself if it's unable to extend in-place.  Could you explain?</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">Actually, whether or not a stack-like sequence of allocations and deallocations leaves no gaps will depend on when/how free blocks are coalesced so I'll concede that one (with the proviso that this is definitely a common pattern, so an allocation system that created much fragmentation under it would be a poor system).  But I'd like to know about the overallocate-and-shrink scenario.</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">Suppose you have (aside from top-of-heap which we'll ignore for simplicity) just two free chunks A and B of sizes 1k and 10k, respectively, and you want to overallocate 5k and resize it down to 1k. The allocation splits B in half, and after resizing down, you're left with chunks of sizes 1k and 9k. If you'd allocated just 1k to begin with, you'd have it all in one free chunk of size 10k. I call that less fragmentation. The same would apply if you performed the <code>malloc</code>/<code>memcpy</code>/<code>free</code> sequence yourself: you'd end up with a 10k chunk free.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">I see, thanks.  I would say you're more likely to <i>increase</i> fragmentation with this strategy however, as if there is just a single free chunk (namely the top-of-heap, which would likely be the case if only stack-like allocation/deallocation has occurred so far) <code>malloc()</code>+<code>memcpy()</code>+<code>free()</code> necessarily creates a hole (in your example, of size 5Kb) while in-place shrinking doesn't.</span></text><author><a class="comment-user" href="/users/47984/j-random-hacker" title="39,766 reputation">j_random_hacker</a></author></comment><comment><text><span class="comment-copy">Indeed, memory allocation is a <b>very hard</b> problem and no strategy can ever be optimal for all cases and usage patterns. I think it's pretty reasonable to assume most programs will typically have a number of free chunks of various sizes in play most of the time, though.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment><comment><text><span class="comment-copy">@R..: If there are chunks of 1K and 10K, allocating 5K and shrinking to 1K won't be as good as allocating 1K to start with, but allocating 5K and shrinking to 1.1K would leave chunks of 1K and 8.9K, versus 1K, 5K and 3.8K.  What would have been better yet would have been if the standard library had defined some routines to use handles, since those are the real key to recovering from fragmentation.</span></text><author><a class="comment-user" href="/users/363751/supercat" title="45,690 reputation">supercat</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>How about the <code>malloc</code> family in general? The vast majority of large, long-lived programs I've seen use dynamic memory allocation all over the place as if it were free. Of course real-time developers know this is a myth, and careless use of dynamic allocation can lead to catastrophic blow-up of memory usage and/or fragmentation of address space to the point of memory exhaustion.</p>
<p>In some higher-level languages without machine-level pointers, dynamic allocation is not so bad because the implementation can move objects and defragment memory during the program's lifetime, as long as it can keep references to these objects up-to-date. A non-conventional C implementation could do this too, but working out the details is non-trivial and it would incur a very significant cost in all pointer dereferences and make pointers rather large, so for practical purposes, it's not possible in C.</p>
<p>My suspicion is that the correct solution is usually for long-lived programs to perform their small routine allocations as usual with <code>malloc</code>, but to keep large, long-lived data structures in a form where they can be reconstructed and replaced periodically to fight fragmentation, or as large <code>malloc</code> blocks containing a number of structures that make up a single large unit of data in the application (like a whole web page presentation in a browser), or on-disk with a fixed-size in-memory cache or memory-mapped files.</p>
</div></text><author><a href="/posts/4606015/revisions" id="history-4606015" title="show revision history for this post">
        R..
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>On a wholly different tack, I've never really understood the benefits of <code>atan()</code> when there is <code>atan2()</code>.  The difference is that <code>atan2()</code> takes two arguments, and returns an angle anywhere in the range -π..+π.  Further, it avoids divide by zero errors and loss of precision errors (dividing a very small number by a very large number, or vice versa).  By contrast, the <code>atan()</code> function only returns a value in the range -π/2..+π/2, and you have to do the division beforehand (I don't recall a scenario where <code>atan()</code> could be used without there being a division, short of simply generating a table of arctangents).  Providing 1.0 as the divisor for <code>atan2()</code> when given a simple value is not pushing the limits.</p>
</div></text><author><a href="/posts/4589115/revisions" id="history-4589115" title="show revision history for this post">
        Jonathan Leffler
        </a></author><comments><comment><text><span class="comment-copy"><code>atan( )</code> is often used when doing certain trig operations (but you're right that there's always an implicit <code>1</code> hiding somewhere, and it wouldn't hurt to make it explicit).</span></text><author><a class="comment-user" href="/users/142434/stephen-canon" title="79,412 reputation">Stephen Canon</a></author></comment><comment><text><span class="comment-copy">I would note one benefit of <code>atan( )</code>, however: it's ~2x faster on a good math library, because it doesn't need to do the divide.  I suspect that's why it exists.</span></text><author><a class="comment-user" href="/users/142434/stephen-canon" title="79,412 reputation">Stephen Canon</a></author></comment><comment><text><span class="comment-copy">Sometimes <code>atan</code> is not used for trigonometry but as a nice smooth (actually analytic) function with desirable monotonicity and boundary conditions.</span></text><author><a class="comment-user" href="/users/379897/r" title="134,818 reputation">R..</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Another answer, since these are not really related, <code>rand</code>:</p>
<ul>
<li>it is of unspecified random quality</li>
<li>it is not re-entrant</li>
</ul>
</div></text><author><a href="/posts/4589165/revisions" id="history-4589165" title="show revision history for this post">
        Jens Gustedt
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Some of this functions are modifying some global state. (In windows) this state is shared per single thread - you can get unexpected result. For example, the first call of <code>rand</code> in every thread will give the same result, and it requires some care to make it pseudorandom, but deterministic (for debug purposes).</p>
</div></text><author><a href="/posts/4589170/revisions" id="history-4589170" title="show revision history for this post">
        crazylammer
        </a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p><code>basename()</code> and <code>dirname()</code> aren't threadsafe.</p>
</div></text><author><a href="/users/353253">arsenm</a></author><comments><comment><text><span class="comment-copy">These are a functions of a single argument that modify their argument. This is like saying avoid += because it's not threadsafe.</span></text><author><span class="comment-user">user79758</span></author></comment><comment><text><span class="comment-copy">No, they are not threadsafe. From the manpage: "The basename() function returns a pointer to internal static storage space that will be overwritten by subsequent calls. The function may modify the string pointed to by path."</span></text><author><a class="comment-user" href="/users/353253/arsenm" title="2,117 reputation">arsenm</a></author></comment><comment><text><span class="comment-copy">Whether or not they are threadsafe, <code>basename</code> and <code>dirname</code> are not part of the C standard library.</span></text><author><a class="comment-user" href="/users/142434/stephen-canon" title="79,412 reputation">Stephen Canon</a></author></comment></comments></answer></answers></post>