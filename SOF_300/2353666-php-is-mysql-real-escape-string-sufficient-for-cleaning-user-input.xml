<?xml version="1.0" encoding="utf-8"?>
<post><title>security - PHP: Is mysql_real_escape_string sufficient for cleaning user input? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>Is <code>mysql_real_escape_string</code> sufficient for cleaning user input in most situations?</p>
<p>::EDIT::</p>
<p>I'm thinking mostly in terms of preventing SQL injection but I ultimately want to know if I can trust user data after I apply mysql_real_escape_string or if I should take extra measures to clean the data before I pass it around the application and databases. </p>
<p>I see where cleaning for HTML chars is important but I wouldn't consider it necessary for trusting user input.</p>
<p>T</p>
</div></text><author><a href="/users/164468/thomas">Thomas</a></author><comments><comment><text><span class="comment-copy">XSS is a huge problem, if you ignore it you're asking for problems of equal magnitude. You must validate on the way in, but if you aren't stripping javascript when you display user content it's really, really trivial to do things like Session Hijacking and XSS attacks which is frankly, waaay easier to use than SQL injection but is a little newer so people don't get it yet.</span></text><author><a class="comment-user" href="/users/203731/chuck-vose" title="3,852 reputation">Chuck Vose</a></author></comment><comment><text><span class="comment-copy"><code>mysql_real_escape_string</code> is only intended to protect against SQL injections. For other vulnerabilities you need other tools.</span></text><author><a class="comment-user" href="/users/53114/gumbo" title="424,781 reputation">Gumbo</a></author></comment><comment><text><span class="comment-copy">@Gumbo mysql_real_we_really_mean_it_this_time_escape_string would cover those cases. When it is added in the near future.</span></text><author><a class="comment-user" href="/users/67468/david" title="17,034 reputation">David</a></author></comment><comment><text><span class="comment-copy">@David hilarious, but bollocks, no one function can do all cleaning.</span></text><author><a class="comment-user" href="/users/650492/johan" title="52,571 reputation">Johan</a></author></comment><comment><text><span class="comment-copy"><a href="http://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string">Escaping the string</a> is not safe! Learn about <a href="http://en.wikipedia.org/wiki/Prepared_statement" rel="nofollow noreferrer">prepared</a> statements for <a href="http://php.net/manual/en/mysqli.quickstart.prepared-statements.php" rel="nofollow noreferrer">MySQLi</a>.</span></text><author><a class="comment-user" href="/users/4233593/jeff-puckett-ii" title="7,696 reputation">Jeff Puckett II</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p><code>mysql_real_escape_string</code> is not sufficient in all situations but it is definitely very good friend. The <strong>better</strong> solution is using <strong><a href="http://php.net/manual/en/pdo.prepared-statements.php" rel="noreferrer">Prepared Statements</a></strong></p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">//example from http://php.net/manual/en/pdo.prepared-statements.php</span><span class="pln">

$stmt </span><span class="pun">=</span><span class="pln"> $dbh</span><span class="pun">-&gt;</span><span class="pln">prepare</span><span class="pun">(</span><span class="str">"INSERT INTO REGISTRY (name, value) VALUES (?, ?)"</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bindParam</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> $name</span><span class="pun">);</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">bindParam</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> $value</span><span class="pun">);</span><span class="pln">

</span><span class="com">// insert one row</span><span class="pln">
$name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'one'</span><span class="pun">;</span><span class="pln">
$value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
$stmt</span><span class="pun">-&gt;</span><span class="pln">execute</span><span class="pun">();</span></code></pre>
<p>Also, not to forget <strong><a href="http://htmlpurifier.org/" rel="noreferrer">HTMLPurifier</a></strong> that can be used to discard any invalid/suspicious characters.</p>
<p>...........</p>
<p><strong>Edit:</strong>
Based on the comments below, I need to post this link (I should have done before sorry for creating confusion)</p>
<p><strong><a href="http://ilia.ws/archives/103-mysql_real_escape_string-versus-Prepared-Statements.html" rel="noreferrer">mysql_real_escape_string() versus Prepared Statements</a></strong></p>
<p><strong>Quoting:</strong></p>
<blockquote>
<p>mysql_real_escape_string() prone to
  the same kind of issues affecting
  addslashes().</p>
</blockquote>
<p><strong>Chris Shiflett</strong> (Security Expert)</p>
</div></text><author><a href="/users/139459/sarfraz">Sarfraz</a></author><comments><comment><text><span class="comment-copy">Give an example of where it is not sufficient, but where Prepared Statements are.</span></text><author><a class="comment-user" href="/users/1585/marius" title="38,187 reputation">Marius</a></author></comment><comment><text><span class="comment-copy">@Marius: Especially in situations when characters are encoded with UTF8, hex ,etc. If you research on internet, you would find that most developers suggest using Prepared statements over mysql_real_escape_string if possible. Sorry at this time i can't remember the link. Hope that clarifies, sorry for bad english :(</span></text><author><a class="comment-user" href="/users/139459/sarfraz" title="253,288 reputation">Sarfraz</a></author></comment><comment><text><span class="comment-copy">While I agree that prepared statements are superior, I would also be very interested in knowing when mysql_real_escape_string() is insufficient for escaping data used in a query.</span></text><author><a class="comment-user" href="/users/15099/jasonbar" title="9,526 reputation">jasonbar</a></author></comment><comment><text><span class="comment-copy"><code>mysql_real_escape_string</code> was designed to take the connection character set into account, and yes, it is safe.  <code>addslashes()</code> is not safe in all circumstances.</span></text><author><a class="comment-user" href="/users/64004/gahooa" title="68,537 reputation">gahooa</a></author></comment><comment><text><span class="comment-copy">Actually no, mysql_real_escape_string isn't always safe.  you should red my post.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@The Rook: It's not mysql_real_escape_and_quote_string(). Failure to correctly quote (or in your example cast the value as an integer) is not a problem with mysql_real_escape_string().</span></text><author><a class="comment-user" href="/users/15099/jasonbar" title="9,526 reputation">jasonbar</a></author></comment><comment><text><span class="comment-copy">hello all, i have updated my answer in an endeavor to do away with the confusion created. plz check thanks.</span></text><author><a class="comment-user" href="/users/139459/sarfraz" title="253,288 reputation">Sarfraz</a></author></comment><comment><text><span class="comment-copy">And do not forget the performance boost you get from using Prepared Statements!</span></text><author><a class="comment-user" href="/users/274080/dr-hydralisk" title="525 reputation">Dr Hydralisk</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The answer to your question is No.  mysql_real_escape_string() is not suitable for all user input and mysql_real_escape_string() does not stop all sql injection.  addslashes() is another popular function to use in php, and it has the same problem. </p>
<p>vulnerable code:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">"select * from user where id="</span><span class="pun">.</span><span class="pln">mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="pln">id</span><span class="pun">]));</span></code></pre>
<p>poc exploit:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">http</span><span class="pun">:</span><span class="com">//localhost/sql_test.php?id=1 or sleep(500)</span></code></pre>
<p>The patch is to use quote marks around id:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">mysql_query</span><span class="pun">(</span><span class="str">"select * from user where id='"</span><span class="pun">.</span><span class="pln">mysql_real_escape_string</span><span class="pun">(</span><span class="pln">$_GET</span><span class="pun">[</span><span class="pln">id</span><span class="pun">]).</span><span class="str">"'"</span><span class="pun">);</span></code></pre>
<p>Really the best approach is to use parametrized queries which a number of people ahve pointed out.  Pdo works well,  adodb is another popular library for php. </p>
<p>If you do use mysql_real_escape_string is should only be used for sql injection,  and nothing else.  Vulnerabilities are highly dependent on how the data is being used. One should apply security measures on a function by function basis.  And yes,  XSS is a <strong>VERY SERIOUS PROBLEM</strong>.   Not filtering for html is a serious mistake that a hacker will use to pw3n you.   Please read the <a href="http://www.cgisecurity.com/xss-faq.html" rel="noreferrer">xss faq</a>.</p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments><comment><text><span class="comment-copy">What does that have to do with mysql_real_escape_string()'s ability to prevent injection? Properly quote or cast your value as an integer.</span></text><author><a class="comment-user" href="/users/15099/jasonbar" title="9,526 reputation">jasonbar</a></author></comment><comment><text><span class="comment-copy">@jasonbar You could cast it,  you could also forget to cast it.  If you use parametrized quires so you KNOW it is always safe,  even if you have 15 drunken monkeys working on the project.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Right, but that doesn't make <code>mysql_real_escape_string()</code> unsuitable for <i>escaping</i> strings for SQL. Edit: Yes, prepared statements are better.</span></text><author><a class="comment-user" href="/users/15099/jasonbar" title="9,526 reputation">jasonbar</a></author></comment><comment><text><span class="comment-copy">@jasonbar no one on this thread has pointed out it was just for strings.  Many vulnerabilities have been written by people who have posted on this very thread becuase of this misunderstanding. This is also true for addslashes().</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">Right, again. But like I mentioned above it's not <code>mysql_real_escape_and_quote_string()</code>. And again, not inherently a problem with the function but with its <i>incorrect use</i>. I'd still like to see an example where <code>mysql_real_escape_string()</code> is insufficient.</span></text><author><a class="comment-user" href="/users/15099/jasonbar" title="9,526 reputation">jasonbar</a></author></comment><comment><text><span class="comment-copy">Wow, you just don't get it.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">No, clearly I don't. Your argument seems akin to saying while() is not useful for iteration because you can do while(1);</span></text><author><a class="comment-user" href="/users/15099/jasonbar" title="9,526 reputation">jasonbar</a></author></comment><comment><text><span class="comment-copy">Thank you for pointing this out. In this situation, I like like to wrap a floatval() around anything that is going in as a number.</span></text><author><a class="comment-user" href="/users/88310/jage" title="6,120 reputation">Jage</a></author></comment><comment><text><span class="comment-copy">erm what? (int)$_GET... problem solved. no escape needed.</span></text><author><a class="comment-user" href="/users/350598/tobias" title="1,007 reputation">Tobias</a></author></comment><comment><text><span class="comment-copy">@Tobias if you aren't using parameterized queries you have bigger problems on your hands.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>To the database, yes. You'll want to consider adequately escaping / encoding data for output as well.</p>
<p>You should also consider <em>validating</em> the input against what you expect it to be.</p>
<p>Have you considered using <a href="http://dev.mysql.com/tech-resources/articles/4.1/prepared-statements.html" rel="noreferrer">prepared statements</a>? PHP offers numerous ways to interact with your database. Most of which are better than the mysql_* functions.</p>
<p><a href="http://php.net/manual/en/book.pdo.php" rel="noreferrer">PDO</a>, <a href="http://pear.php.net/package/MDB2" rel="noreferrer">MDB2</a> and the <a href="http://php.net/manual/en/book.mysqli.php" rel="noreferrer">MySQL Improved</a> should get you started.</p>
</div></text><author><a href="/users/15099/jasonbar">jasonbar</a></author><comments><comment><text><span class="comment-copy">"To the database" - so that would be output then. Not input.</span></text><author><a class="comment-user" href="/users/223992/symcbean" title="35,653 reputation">symcbean</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>What situations?</p>
<p>For SQL queries, it's great. (Prepared statements are better - I vote <a href="http://php.net/pdo" rel="nofollow noreferrer">PDO</a> for this - but the function escapes just fine.) For HTML and the like, it is not the tool for the job - try a generic <code>htmlspecialchars</code> or a more precise tool like <a href="http://www.htmlpurifier.org/" rel="nofollow noreferrer">HTML Purifier</a>.</p>
<p><strong>To address the edit</strong>: The only other layer you could add is data valdation, e.g. confirm that if you are putting an integer into the database, and you are expecting a positive integer, you return an error to the user on attempting to put in a negative integer. As far as data integrity is concerned, <code>mysql_real_escape_string</code> is the best you have for escaping (though, again, prepared statements are a cleaner system that avoids escaping entirely).</p>
</div></text><author><a href="/users/107415/matchu">Matchu</a></author><comments><comment><text><span class="comment-copy">Again, the answer is nearly right - but the question was about input - not output</span></text><author><a class="comment-user" href="/users/223992/symcbean" title="35,653 reputation">symcbean</a></author></comment><comment><text><span class="comment-copy">Sometimes input goes straight to the output, e.g. <code>&lt;?php echo $_GET['name']; ?&gt;</code>.</span></text><author><a class="comment-user" href="/users/107415/matchu" title="55,337 reputation">Matchu</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><code>mysql_real_escape_string()</code> is useful for preventing SQL injection attacks only. It won't help you with preventing cross site scripting attacks. For that, you should use <code>htmlspecialchars()</code> just before outputting data that was originally collected from user input.</p>
</div></text><author><a href="/users/166339/asaph">Asaph</a></author><comments><comment><text><span class="comment-copy">SQL injection is so easy to understand, XSS is a huge problem right now though. Thank you for bringing this up.</span></text><author><a class="comment-user" href="/users/203731/chuck-vose" title="3,852 reputation">Chuck Vose</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There are two ways, one is to use prepared statements (as mentioned in other answers), but that will slow down your app, because you now have to send two requests to the Database, instead of one. If you can live with the reduced performance, then go for it; Prepared Statements makes your code prettier and easier to deal with.</p>
<p>If you chose to use mysql_real_escape_string, then make sure that you escape all the strings that are untrusted. <strong>An (mysql_real_escape_string) escaped string is SQL Injection secure</strong>. If you don't escape all the strings, then you are not secure. You should really combine mysql_real_escape_string with input validation; checking that a variable you expect to hold a number really is a number and within the expected range. Remember, never trust the user.</p>
</div></text><author><a href="/users/1585/marius">Marius</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are different types of "cleaning".</p>
<p><a href="http://php.net/manual/en/function.mysql-real-escape-string.php" rel="nofollow noreferrer">mysql_real_escape_string</a> is sufficient for database data, but will still be evaluated by the browser upon display if it is HTML.</p>
<p>To remove HTML from user input, you can use <a href="http://php.net/manual/en/function.strip-tags.php" rel="nofollow noreferrer">strip_tags</a>.</p>
<p>I would suggest you look into using <a href="http://php.net/manual/en/book.pdo.php" rel="nofollow noreferrer">PDO</a> instead of regular MySQL stuff, as it supports prepared statements right out of the box, and those handle the escaping of invalid data for you.</p>
</div></text><author><a href="/users/117603/mike-trpcic">Mike Trpcic</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You can try both, as in</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> clean_input</span><span class="pun">(</span><span class="pln">$instr</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

     </span><span class="com">// Note that PHP performs addslashes() on GET/POST data.</span><span class="pln">
     </span><span class="com">// Avoid double escaping by checking the setting before doing this.</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">get_magic_quotes_gpc</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $str </span><span class="pun">=</span><span class="pln"> stripslashes</span><span class="pun">(</span><span class="pln">$instr</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> mysql_real_escape_string</span><span class="pun">(</span><span class="pln">strip_tags</span><span class="pun">(</span><span class="pln">trim</span><span class="pun">(</span><span class="pln">$instr</span><span class="pun">)));</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/475178/crafter">crafter</a></author><comments><comment><text><span class="comment-copy">I used this technique. Thanks @crafter.</span></text><author><a class="comment-user" href="/users/3173328/kabir-hossain" title="747 reputation">Kabir Hossain</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The best way to go would be to use <a href="http://dev.mysql.com/tech-resources/articles/4.1/prepared-statements.html" rel="nofollow noreferrer">Prepared Statements</a></p>
</div></text><author><a href="/users/77017/marek-karbarz">Marek Karbarz</a></author><comments><comment><text><span class="comment-copy">Broken link....</span></text><author><a class="comment-user" href="/users/431965/damien" title="1,143 reputation">Damien</a></author></comment><comment><text><span class="comment-copy">2 years ago, tons of other answers in this thread - does it really matter?</span></text><author><a class="comment-user" href="/users/77017/marek-karbarz" title="21,281 reputation">Marek Karbarz</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I thought I'd add that PHP 5.2+ has input filter functions that can sanitize user input in a variety of ways.</p>
<p>Here's the <a href="http://us2.php.net/manual/en/ref.filter.php" rel="nofollow noreferrer">manual entry</a> as well as a <a href="http://www.phparch.com/2010/07/08/never-use-_get-again/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+phpa+%28php%7Carchitect+News%29&amp;utm_content=Google+Reader" rel="nofollow noreferrer">blog post</a> [by Matt Butcher] about why they're great.</p>
</div></text><author><a href="/users/164468/thomas">Thomas</a></author><comments><comment><text><span class="comment-copy">be aware that this does not help you against sql-injections, but against XSS!</span></text><author><a class="comment-user" href="/users/11926/alfred" title="40,598 reputation">Alfred</a></author></comment></comments></answer></answers></post>