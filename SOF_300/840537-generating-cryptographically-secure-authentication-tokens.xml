<?xml version="1.0" encoding="utf-8"?>
<post><title>c# - Generating cryptographically secure authentication tokens - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p><strong>Background:</strong></p>
<p>This is really a general best-practices question, but some background about the specific situation might be helpful:</p>
<p>We are developing a "connected" application for the iPhone.  It will communicate with the backend application via REST services.  In order to not have to prompt the user for a username and password every time they launch the application, we will expose a "Login" service that validates their username and password on initial launch and returns an authentication token that can be used for future web service requests for real data.  The token may have an expiration time after which we'll ask them to re-authenticate with their username/password.</p>
<p><strong>The Question:</strong></p>
<p>What are the best practices for generating this sort of token to be used for authentication?</p>
<p>For example, we could...</p>
<ul>
<li>Hash (SHA-256, etc) a random string and store it in the database for the given user along with an expiration date.  Do a simple lookup of the token on subsequent requests to make sure it matches.</li>
<li>Encrypte the user id and some additional information (timestamp, etc) with a secret key.  Decrypt the token on subsequent requests to make sure it was issued by us.</li>
</ul>
<p>This feels like it must be a solved problem.</p>
</div></text><author><a href="/users/31910/erv-walter">Erv Walter</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Based on the feedback from the other answers to this question, additional research, and offline discussions, here is what we ended up doing...</p>
<p>It was pointed out pretty quickly that the interaction model here is essentially exactly the same as the model used by Forms Authentication in ASP.NET when a "remember me" checkbox is checked.  It's just not a web browser making the HTTP requests.  Our "ticket" is equivilant to the cookie that Forms Authentication sets.  Forms Authentication uses essentially an "encrypt some data with a secret key" approach by default.</p>
<p>In our login web service, we use this code to create a ticket:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="kwd">string</span><span class="pun">[]</span><span class="pln"> userData </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">string</span><span class="pun">[</span><span class="lit">4</span><span class="pun">];</span><span class="pln">

</span><span class="com">// fill the userData array with the information we need for subsequent requests</span><span class="pln">
userData</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">...;</span><span class="pln"> </span><span class="com">// data we need</span><span class="pln">
userData</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">...;</span><span class="pln"> </span><span class="com">// other data, etc</span><span class="pln">

</span><span class="com">// create a Forms Auth ticket with the username and the user data. </span><span class="pln">
</span><span class="typ">FormsAuthenticationTicket</span><span class="pln"> formsTicket </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FormsAuthenticationTicket</span><span class="pun">(</span><span class="pln">
    </span><span class="lit">1</span><span class="pun">,</span><span class="pln">
    username</span><span class="pun">,</span><span class="pln">
    </span><span class="typ">DateTime</span><span class="pun">.</span><span class="typ">Now</span><span class="pun">,</span><span class="pln">
    </span><span class="typ">DateTime</span><span class="pun">.</span><span class="typ">Now</span><span class="pun">.</span><span class="typ">AddMinutes</span><span class="pun">(</span><span class="typ">DefaultTimeout</span><span class="pun">),</span><span class="pln">
    </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
    </span><span class="kwd">string</span><span class="pun">.</span><span class="typ">Join</span><span class="pun">(</span><span class="typ">UserDataDelimiter</span><span class="pun">,</span><span class="pln"> userData</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">

</span><span class="com">// encrypt the ticket</span><span class="pln">
</span><span class="kwd">string</span><span class="pln"> encryptedTicket </span><span class="pun">=</span><span class="pln"> </span><span class="typ">FormsAuthentication</span><span class="pun">.</span><span class="typ">Encrypt</span><span class="pun">(</span><span class="pln">formsTicket</span><span class="pun">);</span></code></pre>
<p>Then we have an operation behavior attribute for the WCF services that adds an IParameterInspector that checks for a valid ticket in the HTTP headers for the request.  Developers put this operation behavior attribute on operations that require authentication.  Here is how that code parses the ticket:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="com">// get the Forms Auth ticket object back from the encrypted Ticket</span><span class="pln">
</span><span class="typ">FormsAuthenticationTicket</span><span class="pln"> formsTicket </span><span class="pun">=</span><span class="pln"> </span><span class="typ">FormsAuthentication</span><span class="pun">.</span><span class="typ">Decrypt</span><span class="pun">(</span><span class="pln">encryptedTicket</span><span class="pun">);</span><span class="pln">

</span><span class="com">// split the user data back apart</span><span class="pln">
</span><span class="kwd">string</span><span class="pun">[]</span><span class="pln"> userData </span><span class="pun">=</span><span class="pln"> formsTicket</span><span class="pun">.</span><span class="typ">UserData</span><span class="pun">.</span><span class="typ">Split</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">string</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">UserDataDelimiter</span><span class="pln"> </span><span class="pun">},</span><span class="pln"> </span><span class="typ">StringSplitOptions</span><span class="pun">.</span><span class="typ">None</span><span class="pun">);</span><span class="pln">

</span><span class="com">// verify that the username in the ticket matches the username that was sent with the request</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">formsTicket</span><span class="pun">.</span><span class="typ">Name</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> expectedUsername</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ticket is valid</span><span class="pln">
    </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/31910/erv-walter">Erv Walter</a></author><comments><comment><text><span class="comment-copy">how are you finding this approach? I may be wrong, however, I think there is a bit of a flaw with it. The only thing required for the client request to be authorized is that the ticket can be decrypted on the server. If the ticket is intercepted during transit (e.g. packet sniffing) or even extracted from the mobile device it could be re-used by an attacker to send malicious requests. If you are using SSL then the first attack would be mitigated, however, the second is still viable.</span></text><author><a class="comment-user" href="/users/82586/james" title="52,002 reputation">James</a></author></comment><comment><text><span class="comment-copy">We are still quite happy with this approach.  We do use SSL, so the sniffing issue isn't a concern.  The ticket being extracted from a mobile device requires the mobile device be compromised and/or physically in the hands of an attacker.  At that point, the attacker has already "won" and it's game over.  No matter the technical details, this will always be the case if there is "remember my password" functionality.  In our case, this is somewhat mitigated by the fact that a ticket is only good for 8 hours, so the attacker has a limited window of time to make use of the stolen ticket.</span></text><author><a class="comment-user owner" href="/users/31910/erv-walter" title="9,187 reputation">Erv Walter</a></author></comment><comment><text><span class="comment-copy">the reason I ask is because I actually thought it was a clever way of generating a token without actually having to write any security code yourself. However, I asked a <a href="http://security.stackexchange.com/questions/19676/token-based-authentication-securing-the-token">question</a> on the IT Security site for some advice with regards to <i>how</i> secure it actually was and the opinion differs. It was more to do with the fact your using encryption to secure the token rather than a <a href="http://en.wikipedia.org/wiki/Message_authentication_code" rel="nofollow noreferrer">MAC</a>.</span></text><author><a class="comment-user" href="/users/82586/james" title="52,002 reputation">James</a></author></comment><comment><text><span class="comment-copy">I think in particular the concern was the ability to "forge" requests. (see the comments)</span></text><author><a class="comment-user" href="/users/82586/james" title="52,002 reputation">James</a></author></comment><comment><text><span class="comment-copy">ASP.NET's forms authentication uses HMAC with SHA256 followed by AES encryption.  You can use Reflector to verify this.  SO there is a MAC involved and it is not simply encryption even though that is what the method name might imply.</span></text><author><a class="comment-user owner" href="/users/31910/erv-walter" title="9,187 reputation">Erv Walter</a></author></comment><comment><text><span class="comment-copy">"<i>The ticket is encrypted and <b>signed</b> using the &lt;machineKey&gt; configuration element of the server's Machine.config</i>" - I must have skimmed over that part in the documentation! Cheers</span></text><author><a class="comment-user" href="/users/82586/james" title="52,002 reputation">James</a></author></comment><comment><text><span class="comment-copy">Correct me if I'm wrong but basically any token based security scheme is vulnerable to a man in the middle attack and replaying of requests or capturing the token and using it for other requests. The advantage of a token is that its lifetime is limited typically and doesn't reference the user directly. But it can still be captured and abused...</span></text><author><a class="comment-user" href="/users/11197/rick-strahl" title="8,192 reputation">Rick Strahl</a></author></comment><comment><text><span class="comment-copy">@RickStrahl, of course our token is only used over TLS / HTTPS connections and therefore can not be intercepted unless an attacker has compromised the actual mobile device (in which case, all hope is lost as they could just log keystrokes to get the user's password).</span></text><author><a class="comment-user owner" href="/users/31910/erv-walter" title="9,187 reputation">Erv Walter</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Building your own authentication system is always a "worst practice". That's the kind of thing best left to professionals who specialize in authentication systems.</p>
<p>If you're bent on building your own "expiring ticket from a login service" architecture rather than re-using an existing one, it's probably a good idea to at least familiarize yourself with the issues that drove the design of similar systems, like Kerberos. A gentle introduction is here:</p>
<p><a href="http://web.mit.edu/kerberos/dialogue.html" rel="noreferrer">http://web.mit.edu/kerberos/dialogue.html</a></p>
<p>It would also be a good idea to take a look at what security holes have been found in Kerberos (and similar systems) over the last 20 years and make sure you don't replicate them. Kerberos was built by security experts and carefully reviewed for decades, and still serious algorithmic flaws are being found in it, like this one:</p>
<p><a href="http://web.mit.edu/kerberos/www/advisories/MITKRB5-SA-2003-004-krb4.txt" rel="noreferrer">http://web.mit.edu/kerberos/www/advisories/MITKRB5-SA-2003-004-krb4.txt</a></p>
<p>It's a lot better to learn from their mistakes than your own.</p>
</div></text><author><a href="/users/88656/eric-lippert">Eric Lippert</a></author><comments><comment><text><span class="comment-copy">If there is a pre-existing authentication system that works between iPhone apps and REST WCF web services, post a link and I'll be happy to use it instead of inventing our own...  Baring that, I'll certainly take a look at the kerberos links you provided.</span></text><author><a class="comment-user owner" href="/users/31910/erv-walter" title="9,187 reputation">Erv Walter</a></author></comment><comment><text><span class="comment-copy">Please direct to a best practice as a RESTful API Login is exactly what I'm looking into right now =) The OP is clearly asking for best practice and not trying to build his own as well.</span></text><author><a class="comment-user" href="/users/1966525/jpk" title="619 reputation">JPK</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Amazon.com uses a <a href="http://docs.amazonwebservices.com/AmazonS3/latest/index.html?RESTAuthentication.html" rel="noreferrer">HMAC SHA-1 message token</a> to authenticate and authorize requests. They use this for a fairly large commercial service, so I'd be liable to trust their engineering decisions. Google publishes the <a href="http://code.google.com/apis/opensocial/" rel="noreferrer">OpenSocial API</a> which is somewhat similar. Based on Google and Amazon.com using similar and openly published approaches to securing web requests, I suspect these are probably good ways to go.</p>
</div></text><author><a href="/users/19410/alex-reynolds">Alex Reynolds</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Either of the two answers you've provided will suffice.  You may find frameworks out there that do this for you, but the truth is it's not that hard to build.  (Every company I've worked for has rolled their own.)  The choice of database-stored tokens versus encrypted data "cookies" is an architectural decision -- do you want to incur a database lookup on every page view, or would you rather chew up CPU with cookie decryption?  In most applications, using encrypted cookies provides a performance win at scale (if that's a concern).  Otherwise it's just a matter of taste.</p>
</div></text><author><a href="/users/58671/neil-mix">Neil Mix</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Since you're using WCF, you have a variety of options if using CFNetwork -- for instance NTLM or Digest Authentication:</p>
<p><a href="http://developer.apple.com/documentation/Networking/Conceptual/CFNetwork/Concepts/Concepts.html#//apple_ref/doc/uid/TP30001132-CH4-SW7" rel="nofollow noreferrer">http://developer.apple.com/documentation/Networking/Conceptual/CFNetwork/Concepts/Concepts.html#//apple_ref/doc/uid/TP30001132-CH4-SW7</a></p>
<p>I know this doesn't answer your specific question, but I have also been faced with this problem (iPhone - Tomcat) and decided to use the authentication services on the web server as much as possible. There's no significant penalty for including the authentication information with each request in most cases. A quick Google turns up lots of blog posts about WCF and RESTful services (and some related questions on StackOverflow).</p>
<p>Hope this helps!</p>
</div></text><author><a href="/users/104181/sehugg">sehugg</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>You should implement:</p>
<ol>
<li>OAuth2 Implicit Grant - for third-party applications <a href="http://tools.ietf.org/html/rfc6749#section-1.3.2" rel="nofollow">http://tools.ietf.org/html/rfc6749#section-1.3.2</a></li>
<li>OAuth2 Resource Owner Password Credentials — for your own mobile application <a href="http://tools.ietf.org/html/rfc6749#section-1.3.3" rel="nofollow">http://tools.ietf.org/html/rfc6749#section-1.3.3</a></li>
</ol>
<p>which are exactly the workflows, from OAuth2, that you are looking for. Do not reinvent the wheel.</p>
</div></text><author><a href="/users/784635/irakli">irakli</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>This simply sounds like a session identifier with a long expiration time. The same principles used for this in web applications could apply here.</p>
<p>Rather than encoding information, session identifiers are randomly chosen from a very large space (128 bits). The server keeps a record associating the session identifier with the user and other desired information such as expiration time. The client presents the session identifier over a secure channel with each request.</p>
<p>Security relies on the unpredictability of the session identifiers. Generate them with a cryptographic RNG, from a very large space.</p>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments/></answer></answers></post>