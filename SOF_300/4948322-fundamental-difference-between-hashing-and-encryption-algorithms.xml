<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Fundamental difference between Hashing and Encryption algorithms - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I see a lot of confusion between hashes and encryption algorithms and I would like to hear some more expert advice about:</p>
<ol>
<li><p>When to use hashes vs encryptions</p></li>
<li><p>What makes a hash or encryption algorithm different (from a theoretical/mathematical level)
i.e. what makes hashes irreversible (without aid of a rainbow tree) </p></li>
</ol>
<p>Here are some <em>similar</em> SO Questions that didn't go into as much detail as I was looking for:</p>
<p><a href="http://stackoverflow.com/questions/184328/what-is-the-difference-between-obfuscation-hashing-and-encryption">What is the difference between Obfuscation, Hashing, and Encryption?</a><br/>
<a href="http://stackoverflow.com/questions/3080976/difference-between-encryption-and-hashing">Difference between encryption and hashing</a></p>
</div></text><author><a href="/users/105971/adam-lear">Adam Lear</a></author><comments><comment><text><span class="comment-copy">I can foresee this being <i>the</i> question to refer people to when they confuse the terms. :)</span></text><author><a class="comment-user" href="/users/41619/adam-paynter" title="31,499 reputation">Adam Paynter</a></author></comment><comment><text><span class="comment-copy">hashing is one way (cannot be reverted), encryption is two-way (can be decrypted)</span></text><author><a class="comment-user" href="/users/554431/bestsss" title="8,229 reputation">bestsss</a></author></comment><comment><text><span class="comment-copy">Hashes are also useful for indexing large structures and objects, e.g. files. See <a href="http://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash table</a>.</span></text><author><a class="comment-user" href="/users/92546/habo" title="9,029 reputation">HABO</a></author></comment><comment><text><span class="comment-copy">Hashing is like a meat grinder. You can turn a cow to hamburger, but not the reverse.</span></text><author><a class="comment-user" href="/users/223478/neil-mcguigan" title="25,761 reputation">Neil McGuigan</a></author></comment><comment><text><span class="comment-copy">I noticed my question was edited. I had always known the top level differences between the two but was more curious about low level/mathematical differences. :) Either way, lots of good content for SO! Many thanks!</span></text><author><a class="comment-user owner" href="/users/403682/kenny-cason" title="5,717 reputation">Kenny Cason</a></author></comment><comment><text><span class="comment-copy">I updated my answer as per edit. <a href="http://stackoverflow.com/questions/4948322/fundamental-difference-between-hashing-and-encryption-algorithms/10053109#10053109">link to it</a></span></text><author><a class="comment-user" href="/users/1592191/mrsrinivas" title="6,483 reputation">mrsrinivas</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Well, you could look it up in <a href="http://en.wikipedia.org/wiki/Hash_function">Wikipedia</a>...  But since you want an explanation, I'll do my best here:</p>
<h2>Hash Functions</h2>
<p>They provide a mapping between an arbitrary length input, and a (usually) fixed length (or smaller length) output.  It can be anything from a simple crc32, to a full blown cryptographic hash function such as MD5 or SHA1/2/256/512.  The point is that there's a one-way mapping going on.  It's always a many:1 mapping (meaning there will always be collisions) since every function produces a smaller output than it's capable of inputting (If you feed every possible 1mb file into MD5, you'll get a ton of collisions).</p>
<p>The reason they are hard (or impossible in practicality) to reverse is because of how they work internally.  Most cryptographic hash functions iterate over the input set many times to produce the output.  So if we look at each fixed length chunk of input (which is algorithm dependent), the hash function will call that the current state.  It will then iterate over the state and change it to a new one and use that as feedback into itself (MD5 does this 64 times for each 512bit chunk of data).  It then somehow combines the resultant states from all these iterations back together to form the resultant hash.</p>
<p>Now, if you wanted to decode the hash, you'd first need to figure out how to split the given hash into its iterated states (1 possibility for inputs smaller than the size of a chunk of data, many for larger inputs).  Then you'd need to reverse the iteration for each state.  Now, to explain why this is VERY hard, imagine trying to deduce <code>a</code> and <code>b</code> from the following formula: <code>10 = a + b</code>.  There are 10 positive combinations of <code>a</code> and <code>b</code> that can work.  Now loop over that a bunch of times: <code>tmp = a + b; a = b; b = tmp</code>. For 64 iterations, you'd have over 10^64 possibilities to try.  And that's just a simple addition where some state is preserved from iteration to iteration.  Real hash functions do a lot more than 1 operation (MD5 does about 15 operations on 4 state variables). And since the next iteration depends on the state of the previous and the previous is destroyed in creating the current state, it's all but impossible to determine the input state that led to a given output state (for each iteration no less).  Combine that, with the large number of possibilities involved, and decoding even an MD5 will take a near infinite (but not infinite) amount of resources. So many resources that it's actually significantly cheaper to brute-force the hash if you have an idea of the size of the input (for smaller inputs) than it is to even try to decode the hash. </p>
<h2>Encryption Functions</h2>
<p>They provide a 1:1 mapping between an arbitrary length input and and output.  And they are always reversible.  The important thing to note is that it's reversible using some method.  And it's always 1:1 for a given key.  Now, there are multiple input:key pairs that might generate the same output (in fact there usually are, depending on the encryption function).  Good encrypted data is indistinguishable from random noise.  This is different from a good hash output which is always of a consistent format.</p>
<h2>Use Cases</h2>
<p>Use a hash function when you want to compare a value but can't store the plain representation (for any number of reasons).  Passwords should fit this use-case very well since you don't want to store them plain-text for security reasons (and shouldn't).  But what if you wanted to check a filesystem for pirated music files?  It would be impractical to store 3 mb per music file.  So instead, take the hash of the file, and store that (md5 would store 16 bytes instead of 3mb).  That way, you just hash each file and compare to the stored database of hashes (This doesn't work as well in practice because of re-encoding, changing file headers, etc, but it's an example use-case).</p>
<p>Use a hash function when you're checking validity of input data.  That's what they are designed for.  If you have 2 pieces of input, and want to check to see if they are the same, run both through a hash function.  The probability of a collision is astronomically low for small input sizes (assuming a good hash function).  That's why it's recommended for passwords.  For passwords up to 32 characters, md5 has 4 times the output space.  SHA1 has 6 times the output space (approximately).  SHA512 has about 16 times the output space.  You don't really care what the password <em>was</em>, you care if it's the same as the one that was stored.  That's why you should use hashes for passwords.</p>
<p>Use encryption whenever you need to get the input data back out.  Notice the word <strong>need</strong>.  If you're storing credit card numbers, you need to get them back out at some point, but don't want to store them plain text.  So instead, store the encrypted version and keep the key as safe as possible. </p>
<p>Hash functions are also great for signing data.  For example, if you're using HMAC, you sign a piece of data by taking a hash of the data concatenated with a known but not transmitted value (a secret value).  So you send the plain-text and the HMAC hash.  Then, the receiver simply hashes the submitted data with the known value and checks to see if it matches the transmitted HMAC.  If it's the same, you know it wasn't tampered with by a party without the secret value.  This is commonly used in secure cookie systems by HTTP frameworks, as well as in message transmission of data over HTTP where you want some assurance of integrity in the data.</p>
<h2>A note on hashes for passwords:</h2>
<p>A key feature of cryptographic hash functions is that they should be very fast to create, and <strong>very</strong> difficult/slow to reverse (so much so that it's practically impossible).  This poses a problem with passwords.  If you store <code>sha512(password)</code>, you're not doing a thing to guard against rainbow tables or brute force attacks. Remember, the hash function was designed for speed.  So it's trivial for an attacker to just run a dictionary through the hash function and test each result.</p>
<p>Adding a salt helps matters since it adds a bit of unknown data to the hash.  So instead of finding anything that matches <code>md5(foo)</code>, they need to find something that when added to the known salt produces <code>md5(foo.salt)</code> (which is very much harder to do).  But it still doesn't solve the speed problem since if they know the salt it's just a matter of running the dictionary through.</p>
<p>So, there are ways of dealing with this.  One popular method is called <a href="http://en.wikipedia.org/wiki/Key_strengthening">key strengthening</a> (or key stretching).  Basically, you iterate over a hash many times (thousands usually).  This does two things.  First, it slows down the runtime of the hashing algorithm significantly.  Second, if implemented right (passing the input and salt back in on each iteration) actually increases the entropy (available space) for the output, reducing the chances of collisions.  A trivial implementation is:</p>
<pre><code>var hash = password + salt;
for (var i = 0; i &lt; 5000; i++) {
    hash = sha512(hash + password + salt);
}
</code></pre>
<p>There are other, more standard implementations such as <a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>, <a href="http://www.openwall.com/crypt/">BCrypt</a>.  But this technique is used by quite a few security related systems (such as PGP, WPA, Apache and OpenSSL).</p>
<p>The bottom line, <code>hash(password)</code> is not good enough.  <code>hash(password + salt)</code> is better, but still not good enough...  Use a stretched hash mechanism to produce your password hashes...</p>
<h2>Another note on trivial stretching</h2>
<p><strong>Do not under any circumstances feed the output of one hash directly back into the hash function</strong>:</p>
<pre><code>hash = sha512(password + salt); 
for (i = 0; i &lt; 1000; i++) {
    hash = sha512(hash); // &lt;-- Do NOT do this!
}
</code></pre>
<p>The reason for this has to do with collisions.  Remember that all hash functions have collisions because the possible output space (the number of possible outputs) is smaller than then input space.  To see why, let's look at what happens.  To preface this, let's make the assumption that there's a 0.001% chance of collision from <code>sha1()</code> (it's <strong>much</strong> lower in reality, but for demonstration purposes).</p>
<pre><code>hash1 = sha1(password + salt);
</code></pre>
<p>Now, hash1 has a probability of collision of 0.001%.  But when we do the next <code>hash2 = sha1(hash1);</code>, <strong>all collisions of <code>hash1</code> automatically become collisions of <code>hash2</code></strong>.  So now, we have hash1's rate at 0.001%, and the 2nd <code>sha1()</code> call adds to that.  So now, <code>hash2</code> has a probability of collision of 0.002%.  That's twice as many chances!  Each iteration will add another <code>0.001%</code> chance of collision to the result.  So, with 1000 iterations, the chance of collision jumped from a trivial 0.001% to 1%.  Now, the degradation is linear, and the real probabilities are <strong>far</strong> smaller, but the effect is the same (an estimation of the chance of a single collision with <code>md5</code> is about <code>1/(2^128)</code> or <code>1/3e38</code>.  While that seems small, thanks to <a href="http://en.wikipedia.org/wiki/Birthday_attack">the birthday attack</a> it's not really as small as it seems).</p>
<p>Instead, by re-appending the salt and password each time, you're re-introducing data back into the hash function.  So any collisions of any particular round are no longer collisions of the next round.  So:</p>
<pre><code>hash = sha512(password + salt);
for (i = 0; i &lt; 1000; i++) {
    hash = sha512(hash + password + salt);
}
</code></pre>
<p>Has the same chance of collision as the native <code>sha512</code> function.  Which is what you want.  Use that instead.</p>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">@ircmaxell : I think the main reason for not decoding the hash output is that you don't know the size of the input. Whatever be the input you get the same size of hte output. So you don't know what the size of the original messasge was.</span></text><author><a class="comment-user" href="/users/1139023/ashwin" title="3,317 reputation">Ashwin</a></author></comment><comment><text><span class="comment-copy">@ircmaxell : I did not quite understand the reversing of iteration. MD5 provides 15 functions like you said. The functions can be inverted to find the inout for each iteration right?</span></text><author><a class="comment-user" href="/users/1139023/ashwin" title="3,317 reputation">Ashwin</a></author></comment><comment><text><span class="comment-copy">@Ashwin: Kind of, but not really: <a href="http://stackoverflow.com/questions/7523625/is-there-a-way-to-reverse-a-hash-without-rainbow-tables/7691164#7691164" title="is there a way to reverse a hash without rainbow tables">stackoverflow.com/questions/7523625/…</a> The point is the data used as input to those (the 4 state variables) is destroyed on each iteration. So the number of possible inputs is huge, even though only one is correct...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">Too bad the programmers at LinkedIn didn't read this before they stored passwords as unsalted SHA1 hashes... <a href="http://money.cnn.com/2012/06/06/technology/linkedin-password-hack/index.htm" rel="nofollow noreferrer">money.cnn.com/2012/06/06/technology/linkedin-password-hack/…</a></span></text><author><a class="comment-user" href="/users/141172/eric-j" title="109,071 reputation">Eric J.</a></author></comment><comment><text><span class="comment-copy">Why does this answer give so little emphasis on encryption?</span></text><author><a class="comment-user" href="/users/632951/pacerier" title="33,795 reputation">Pacerier</a></author></comment><comment><text><span class="comment-copy">@Pacerier: it gives a little bit of emphasis on hashing as well. It goes into detail specifically on password hashing...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">I don't understand how it can be 1 to 1 mapping if there can be multiple keys resulting in the same output. For DES, the key length is 56 bits and the block sizes are 64 bits. Therefore, aren't there 256 different keys that can map to the same output block?</span></text><author><a class="comment-user" href="/users/2759719/mrqwerty" title="997 reputation">mrQWERTY</a></author></comment><comment><text><span class="comment-copy">@Renren29 yes. You are correct. In practice, the entire cipher neither surjective nor injective. However, for a given key, it's surjective (each plain text has exactly one ciphertext) but not necessarily injective (not every possible ciphertext has a mapping back). That's why I said <i>it's always 1:1 for a given key</i>. If there weren't multiple keys that could output to the same output block, then the cipher wouldn't be useful since the ciphertext would tell you something about the key (without knowing it).</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">Great answer. My only nitpick is that the degradation of trivial stretching can't be linear or it would eventually pass 100%. I think in your example with .001% the second step should be .001 + (1 - 0.001) * .001, or 0.001999.</span></text><author><a class="comment-user" href="/users/733760/alexdev" title="1,884 reputation">AlexDev</a></author></comment><comment><text><span class="comment-copy">Based on this valuable information, Could you explain how ETEE works?</span></text><author><a class="comment-user" href="/users/3426825/some-folk" title="5,077 reputation">some Folk</a></author></comment><comment><text><span class="comment-copy">I come from a web content writing space and I think this is a content most suitable for a blog!</span></text><author><a class="comment-user" href="/users/643634/navin-israni" title="309 reputation">Navin Israni</a></author></comment><comment><text><span class="comment-copy">Well deserved bounty. Thanks for explaining it in a way that even <i>I</i> understand.</span></text><author><a class="comment-user" href="/users/4228942/norbertpy" title="1,380 reputation">norbertpy</a></author></comment><comment><text><span class="comment-copy">I couldn't understand many:1 meaning. Does it mean different inputs have same has values? Could anyone answer please?</span></text><author><span class="comment-user">user5773634</span></author></comment><comment><text><span class="comment-copy">@VikasKumar yes, that is what it means. Different inputs can have the same output- a collision.</span></text><author><a class="comment-user" href="/users/6149679/david-prichard" title="81 reputation">David Prichard</a></author></comment><comment><text><span class="comment-copy">This is probably one of the best explanations of encryption and hashing algorithms I've ever read. Extremely clear and well written. Thanks so much for taking the time to do this.</span></text><author><a class="comment-user" href="/users/1424549/ami-schreiber" title="156 reputation">Ami Schreiber</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A hash function could be considered the same as baking a loaf of bread. You start out with inputs (flour, water, yeast, etc...) and after applying the hash function (mixing + baking), you end up with an output: a loaf of bread.</p>
<p>Going the other way is extraordinarily difficult - you can't really separate the bread back into flour, water, yeast - some of that was lost during the baking process, and you can never tell exactly how much water or flour or yeast was used for a particular loaf, because that information was destroyed by the hashing function (aka the oven).</p>
<p>Many different variants of inputs will theoretically produce identical loaves (e.g. 2 cups of water and 1 tsbp of yeast produce exactly the same loaf as 2.1 cups of water and 0.9tsbp of yeast), but given one of those loaves, you can't tell exactly what combo of inputs produced it.</p>
<p>Encryption, on the other hand, could be viewed as a safe deposit box. Whatever you put in there comes back out, as long as you possess the key with which it was locked up in the first place. It's a symmetric operation. Given a key and some input, you get a certain output. Given that output, and the same key, you'll get back the original input. It's a 1:1 mapping.</p>
</div></text><author><a href="/users/118068/marc-b">Marc B</a></author><comments><comment><text><span class="comment-copy">I prefer the "hamburger back to cow" analogy for reversing a hash function ;)</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">Except that you can't easily show that a particular hamburger came entirely from a particular cow, which is a fundamental property of a hash, so it's a funny idea but a dreadful analogy.</span></text><author><a class="comment-user" href="/users/467257/user467257" title="955 reputation">user467257</a></author></comment><comment><text><span class="comment-copy">@caf <i>lol</i> indeed and a classic at that. However, the cow hardly ever makes it to market, it's the "bull" that does ;-) Cow: milk. Bull: meat.</span></text><author><a class="comment-user" href="/users/1415724/fred-ii" title="74,461 reputation">Fred -ii-</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Use hashes when you don't want to be able to get back the original input, use encryption when you do.</p>
<p>Hashes take some input and turn it into some bits (usually thought of as a number, like a 32 bit integer, 64 bit integer, etc).  The same input will always produce the same hash, but you PRINCIPALLY lose information in the process so you can't reliably reproduce the original input (there are a few caveats to that however).</p>
<p>Encryption principally preserves all of the information you put into the encryption function, just makes it hard (ideally impossible) for anyone to reverse back to the original input without possessing a specific key.</p>
<p><strong>Simple Example of Hashing</strong></p>
<p>Here's a trivial example to help you understand why hashing can't (in the general case) get back the original input.  Say I'm creating a 1-bit hash.  My hash function takes a bit string as input and sets the hash to 1 if there are an even number of bits set in the input string, else 0 if there were an odd number.  </p>
<p>Example:</p>
<pre><code>Input    Hash
0010     0
0011     1
0110     1
1000     0
</code></pre>
<p>Note that there are many input values that result in a hash of 0, and many that result in a hash of 1.  If you know the hash is 0, you can't know for sure what the original input was.</p>
<p>By the way, this 1-bit hash isn't exactly contrived... have a look at <a href="http://en.wikipedia.org/wiki/Parity_bit" rel="noreferrer">parity bit</a>.</p>
<p><strong>Simple Example of Encryption</strong></p>
<p>You might encrypt text by using a simple letter substitution, say if the input is A, you write B.  If the input is B, you write C.  All the way to the end of the alphabet, where if the input is Z, you write A again.</p>
<pre><code>Input   Encrypted
CAT     DBU
ZOO     APP
</code></pre>
<p>Just like the simple hash example, this type of encryption has <a href="http://en.wikipedia.org/wiki/Substitution_cipher" rel="noreferrer">been used historically</a>.</p>
</div></text><author><a href="/users/141172/eric-j">Eric J.</a></author><comments><comment><text><span class="comment-copy">The first sentence is great for answering the question "When to use which?". +1</span></text><author><a class="comment-user" href="/users/7199922/tadej" title="888 reputation">Tadej</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>My one liner... generally Interviewer wanted the below answer.</p>
<p>Hashing is one way . You can not get convert your data/ string from a hash code.</p>
<p>Encryption is 2 way - you can decrypt again the encrypted string if you have the key with you. </p>
</div></text><author><a href="/users/939429/shiv-mohan">Shiv Mohan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Let me add some basic overview about hashing and encryption/decryption techniques.</p>
<blockquote>
<p><strong>Hashing:</strong></p>
<p>If you <strong>hash</strong> any <strong>plain text</strong> again you <strong>can not get the same plain
  text from hashed text</strong>. Simply, It's a one-way process.</p>
<p><img alt="hashing" src="https://i.stack.imgur.com/WEKK4.png"/></p>
<hr/>
<p><strong>Encryption and Decryption:</strong></p>
<p>If you <strong>encrypt</strong> any <strong>plain text</strong> with a key again you <strong>can
  get same plain text</strong> by doing <strong>decryption</strong> on encrypted text with same(symetric)/diffrent(asymentric) key.</p>
<p><img alt="encryption and decryption" src="https://i.stack.imgur.com/23lmb.png"/></p>
</blockquote>
<hr/>
<p><strong>UPDATE:</strong>
To address the points mentioned in the edited question.</p>
<blockquote>
<blockquote>
<p><strong>1. When to use hashes vs encryptions</strong></p>
</blockquote>
<p><strong>Hashing</strong> is useful if you want to send someone a file. But you are afraid that someone else might intercept the file and change it. So a
  way that the recipient can make sure that it is the right file is if
  you post the hash value publicly. That way the recipient can compute
  the hash value of the file received and check that it matches the hash
  value. </p>
<p><strong>Encryption</strong> is good if you say have a message to send to someone. You encrypt the message with a key and the recipient decrypts with the
  same (or maybe even a different) key to get back the original message.
  <a href="https://crypto.stackexchange.com/questions/2887/difference-between-encrypting-something-and-hashing-something">credits</a></p>
<hr/>
<blockquote>
<p><strong>2. What makes a hash or encryption algorithm different (from a theoretical/mathematical level) i.e. what makes hashes irreversible
    (without aid of a rainbow tree)</strong> </p>
</blockquote>
<p>Basically <strong>hashing is an
  operation that loses information but not encryption</strong>. Let's look at
  the difference in simple mathematical way <em>for our easy understanding</em>,
  of course both have much more complicated mathematical operation with
  repetitions involved in it</p>
<blockquote>
<h2>Encryption/Decryption (Reversible):</h2>
<p><strong>Addition</strong>:  </p>
<pre><code>4 + 3 = 7  
</code></pre>
<p>This can be reversed by taking the sum and subtracting one of the
    addends</p>
<pre><code>7 - 3 = 4     
</code></pre>
<p><strong>Multiplication</strong>:</p>
<pre><code>4 * 5 = 20  
</code></pre>
<p>This can be reversed by taking the product and dividing by one of the
    factors</p>
<pre><code>20 / 4 = 5    
</code></pre>
<p>So, here we could assume one of the addends/factors is a decrpytion key and result(7,20) is an excrypted text.</p>
<hr/>
<h2>Hashing (Not Reversible):</h2>
<p><strong>Modulo division</strong>:</p>
<pre><code>22 % 7 = 1   
</code></pre>
<p>This can not be reversed because there is no operation that you can do to the quotient and the dividend to
    reconstitute the divisor (or vice versa).   </p>
<p>Can you find an operation to fill in where the '?' is?   </p>
<pre><code>1  ?  7 = 22  
1  ?  22 = 7
</code></pre>
<p>So hash functions have the same mathematical quality as modulo division and looses the information.</p>
</blockquote>
<p><a href="http://stackoverflow.com/questions/2112685/how-do-one-way-hash-functions-work">credits</a></p>
</blockquote>
</div></text><author><a href="/users/1592191/mrsrinivas">mrsrinivas</a></author><comments><comment><text><span class="comment-copy">Not necessarily the same key.</span></text><author><a class="comment-user" href="/users/3573213/dramzy" title="1,143 reputation">dramzy</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Hash function</strong> turns a variable-sized amount of text into a fixed-sized output</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/IUNeO.jpg"/></p>
<p><strong>Encryption function</strong>  transforms a text into a nonsensical ciphertext by using an encryption key, and vice versa.
<img alt="enter image description here" src="https://i.stack.imgur.com/aQkNY.png"/></p>
<p>Source: <a href="https://en.wikipedia.org/wiki/Encryption" rel="nofollow noreferrer">Wikipedia</a></p>
</div></text><author><a href="/users/1280520/julian">Julian</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>when it comes to security for transmitting data i.e Two way communication you use encryption.All encryption requires a key</p>
<p>when it comes to authorization you use hashing.There is no key in hashing</p>
<p>Hashing takes any amount of data (binary or text) and creates a constant-length hash representing a checksum for the data. For example, the hash might be 16 bytes. Different hashing algorithms produce different size hashes. You obviously cannot re-create the original data from the hash, but you can hash the data again to see if the same hash value is generated. One-way Unix-based passwords work this way. The password is stored as a hash value, and to log onto a system, the password you type is hashed, and the hash value is compared against the hash of the real password. If they match, then you must've typed the correct password </p>
<p>why is hashing irreversible :</p>
<p><strong>Hashing isn't reversible because the input-to-hash mapping is not 1-to-1.</strong>
Having two inputs map to the same hash value is usually referred to as a "hash collision". For security purposes, one of the properties of a "good" hash function is that collisions are rare in practical use. </p>
</div></text><author><a href="/users/455257/ayush">ayush</a></author><comments><comment><text><span class="comment-copy">"Hashing isn't reversible because the input-to-hash mapping is not 1-to-1", Thanks, I think that is a very important factor when it comes to differentiating hashes from encryptions! :)</span></text><author><a class="comment-user owner" href="/users/403682/kenny-cason" title="5,717 reputation">Kenny Cason</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><strong>Symmetric Encryption:</strong></p>
<p>Symmetric encryption may also be referred to as shared key or shared secret encryption. In symmetric encryption, a single key is used both to encrypt and decrypt traffic.</p>
<p><a href="https://i.stack.imgur.com/Yt9x6.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Yt9x6.png"/></a></p>
<p><strong>Asymmetric Encryption:</strong></p>
<p>Asymmetric encryption is also known as public-key cryptography. Asymmetric encryption differs from symmetric encryption primarily in that two keys are used: one for encryption and one for decryption. The most common asymmetric encryption algorithm is <code>RSA</code>.</p>
<p>Compared to symmetric encryption, asymmetric encryption imposes a high computational burden, and tends to be much slower. Thus, it isn't typically employed to protect payload data. Instead, its major strength is its ability to establish a secure channel over a nonsecure medium (for example, the Internet). This is accomplished by the exchange of public keys, which can only be used to encrypt data. The complementary private key, which is never shared, is used to decrypt.</p>
<p><a href="https://i.stack.imgur.com/OcHpG.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/OcHpG.png"/></a></p>
<p><strong>Hashing:</strong></p>
<p>Finally, hashing is a form of cryptographic security which differs from encryption. Whereas encryption is a two step process used to first encrypt and then decrypt a message, hashing condenses a message into an irreversible fixed-length value, or hash. Two of the most common hashing algorithms seen in networking are <code>MD5</code> and <code>SHA-1</code>.</p>
<p><a href="https://i.stack.imgur.com/Jlmsx.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Jlmsx.png"/></a></p>
<p>Read more here:<a href="http://packetlife.net/blog/2010/nov/23/symmetric-asymmetric-encryption-hashing/" rel="noreferrer">http://packetlife.net/blog/2010/nov/23/symmetric-asymmetric-encryption-hashing/</a></p>
</div></text><author><a href="/users/1666800/vahid-farahmandian">Vahid Farahmandian</a></author><comments><comment><text><span class="comment-copy">Sorry, I'm a security newb, but can you explain the meaning of "typically employed to protect payload data" further please?</span></text><author><a class="comment-user" href="/users/3040381/abdul" title="623 reputation">Abdul</a></author></comment><comment><text><span class="comment-copy">@Abdul Asymmetric encryption has high computational burden so it's not used for protecting the data which is sent over a network as packets(payload). Instead, it is used for establishing secure network connection using exchange of public keys to protect the data.</span></text><author><a class="comment-user" href="/users/1793718/lucky" title="6,826 reputation">Lucky</a></author></comment><comment><text><span class="comment-copy">@Lucky Thank you</span></text><author><a class="comment-user" href="/users/3040381/abdul" title="623 reputation">Abdul</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<ol>
<li><p>Use hashes when you only need to go one way.  For example, for passwords in a system, you use hashing because you will only ever verify that the value a user entered, after hashing, matches the value in your repository.  With encryption, you can go two ways.</p></li>
<li><p>hashing algorithms and encryption algorithms are just mathematical algorithms.  So in that respect they are not different -- its all just mathematical formulas.  Semantics wise, though, there is the very big distinction between hashing (one-way) and encryption(two-way).  Why are hashes irreversible?  Because they are designed to be that way, because sometimes you want a one-way operation.</p></li>
</ol>
</div></text><author><a href="/users/305644/hvgotcodes">hvgotcodes</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Encryption and hash algorithms work in similar ways.  In each case, there is a need to create <a href="http://en.wikipedia.org/wiki/Confusion_and_diffusion" rel="nofollow">confusion and diffusion</a> amongst the bits.  Boiled down, <em>confusion</em> is creating a complex relationship between the key and the ciphertext, and <em>diffusion</em> is spreading the information of each bit around.</p>
<p>Many hash functions actually use encryption algorithms (or primitives of encryption algorithms.  For example, the SHA-3 candidate <a href="http://en.wikipedia.org/wiki/Skein_%28hash_function%29" rel="nofollow">Skein</a> uses Threefish as the underlying method to process each block.  The difference is that instead of keeping each block of ciphertext, they are destructively, deterministically merged together to a fixed length</p>
</div></text><author><a href="/users/599168/justin-morgan">Justin Morgan</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p><strong>Encryption</strong>The Purpose of encryption is to transform data in order to keep it secret E.g (Sending someone a secret text that they only should able to read,sending passwords through Internet).</p>
<p>Instead of focusing the usability the goal is to ensure the  data send can be send secretely and it can only seen by the user whom you sent.</p>
<p>It Encrypts the data into another format of transforming it into unique pattern it can be encrypt with the secret key and those users who having the secret key can able to see the message by reversible the process.
  E.g(AES,BLOWFISH,RSA)</p>
<p>The encryption may simply look like this <strong>FhQp6U4N28GITVGjdt37hZN</strong></p>
<p><strong>Hashing</strong> In technically we can say it as takes a arbitary input and produced a fixed length string.</p>
<p>Most important thing in these is you can't go from the output to the input.It prodeuce the strong ouptut that the given information has not been modified.
  The process is to takes a input and hash it and then send with the sender's private key once the receiver received they can validate it with sender's public key.</p>
<p>If the hash is wrong and did't match with hash we can't see any of the information. E.g(MD5,SHA.....)</p>
</blockquote>
</div></text><author><a href="/users/5371629/neevan">neevan</a></author><comments/></answer></answers></post>