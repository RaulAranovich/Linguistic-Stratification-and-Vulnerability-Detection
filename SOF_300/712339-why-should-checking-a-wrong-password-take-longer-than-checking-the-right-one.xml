<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Why should checking a wrong password take longer than checking the right one? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>This question has always troubled me.</p>
<p>On Linux, when asked for a password, if your input is the correct one, it checks right away, with almost no delay. But, on the other hand, if you type the wrong password, it takes longer to check. Why is that?</p>
<p>I observed this in all <a href="http://en.wikipedia.org/wiki/Linux_distribution" rel="noreferrer">Linux distributions</a> I've ever tried.</p>
</div></text><author><a href="/users/90002/novelocrat">Novelocrat</a></author><comments><comment><text><span class="comment-copy">You will find this to be true of Windows as well. Also, changing the Title to something like, "Why have wrong passwords take longer than correct ones." Would make it more programming related.</span></text><author><a class="comment-user" href="/users/34435/he-the-great" title="4,997 reputation">he_the_great</a></author></comment><comment><text><span class="comment-copy">I just logged into my Ubuntu system, entered the wrong password and asked myself the same question. :-)</span></text><author><a class="comment-user" href="/users/364651/aakashbhowmick" title="939 reputation">aakashbhowmick</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>It's actually to prevent brute force attacks from trying millions of passwords per second. The idea is to limit how fast passwords can be checked and there are a number of rules that should be followed.</p>
<ul>
<li>A successful user/password pair should succeed immediately.</li>
<li>There should be <em>no</em> discernible difference in reasons for failure that can be detected.</li>
</ul>
<p>That last one is particularly important. It means no helpful messages like:</p>
<pre><code>Your user name is correct but your password is wrong, please try again
</code></pre>
<p>or:</p>
<pre><code>Sorry, password wasn't long enough
</code></pre>
<p>Not even a time difference in response between the "invalid user and password" and "valid user but invalid password" failure reasons.</p>
<p><em>Every</em> failure should deliver exactly the same information, textual and otherwise.</p>
<p>Some systems take it even further, increasing the delay with each failure, or only allowing three failures then having a massive delay before allowing a retry.</p>
</div></text><author><a href="/users/14860/paxdiablo">paxdiablo</a></author><comments><comment><text><span class="comment-copy">How does this prevent an app from forking, trying a password, and if it doesn't return success in some amount of time, kill -9 the child and fork again. Yes that only works if you can log in as some user but when has that stopped anyone?</span></text><author><a class="comment-user" href="/users/1343/bcs" title="27,490 reputation">BCS</a></author></comment><comment><text><span class="comment-copy">It doesn't stop anyone but you still have to delay for that "some amount of time". Even a tiny delay makes checking millions of passwords useless, and you <i>will</i> be detected if you're doing it while logged on - do you think nothing is logged for failed logins?</span></text><author><a class="comment-user" href="/users/14860/paxdiablo" title="525,442 reputation">paxdiablo</a></author></comment><comment><text><span class="comment-copy">BCS: if you already have a valid login with enough privileges to do what you propose, chances are that you no longer need brute force attacks (because there are other attack vectors available to you). The delay is most useful against external attackers.</span></text><author><a class="comment-user" href="/users/65464/ammoq" title="26,298 reputation">ammoQ</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>This makes it take longer to guess passwords. </p>
</div></text><author><a href="/users/20754/rossfabricant">RossFabricant</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I am not sure, but it is quite common to integrate a delay after entering a wrong password to make attacks harder. This makes a attack practicaly infeasible, because it will take you a long time to check only a few passwords.</p>
<p>Even trying a few passwords - birthdates, the name of the cat, and things like that - is turned into no fun.</p>
</div></text><author><a href="/users/77507/daniel-br%c3%bcckner">Daniel Br√ºckner</a></author><comments><comment><text><span class="comment-copy">And often the timeout on the second failure is longer than the timeout on the first - which is good too.</span></text><author><a class="comment-user" href="/users/15168/jonathan-leffler" title="472,035 reputation">Jonathan Leffler</a></author></comment><comment><text><span class="comment-copy">Did you see the news post about the most likely passwords?  123456 is very very popular!</span></text><author><a class="comment-user" href="/users/53771/spence" title="19,549 reputation">Spence</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Basically to mitigate against brute force and dictionary attacks.</p>
<p>From <a href="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/old/pam_appl-3.html" rel="nofollow noreferrer">The Linux-PAM Application Developer's Guide</a>:  </p>
<blockquote>
<p>Planning for delays</p>
<pre><code>extern int pam_fail_delay(pam_handle_t *pamh, unsigned int micro_sec);
</code></pre>
<p>This function is offered by Linux-PAM
  to facilitate time delays following a
  failed call to pam_authenticate() and
  before control is returned to the
  application. When using this function
  the application programmer should
  check if it is available with,</p>
<pre><code>#ifdef PAM_FAIL_DELAY
    ....
#endif /* PAM_FAIL_DELAY */
</code></pre>
<p>Generally, an application requests
  that a user is authenticated by
  Linux-PAM through a call to
  pam_authenticate() or pam_chauthtok().
  These functions call each of the
  stacked authentication modules listed
  in the relevant Linux-PAM
  configuration file. As directed by
  this file, one of more of the modules
  may fail causing the pam_...() call to
  return an error. It is desirable for
  there to also be a pause before the
  application continues. The principal
  reason for such a delay is security: a
  delay acts to discourage brute force
  dictionary attacks primarily, but also
  helps hinder timed (covert channel)
  attacks.</p>
</blockquote>
</div></text><author><a href="/users/32542/user32542">user32542</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>It's a very simple, virtually effortless way to greatly increase security.  Consider:</p>
<ol>
<li><p>System <code>A</code> has no delay.  An attacker has a program that creates username/password combinations.  At a rate of thousands of attempts per minute, it takes only a few hours to try every combination and record all successful logins.</p></li>
<li><p>System <code>B</code> generates a 5-second delay after each incorrect guess.  The attacker's efficiency has been reduced to 12 attempts per minute, effectively crippling the brute-force attack.  Instead of hours, it can take months to find a valid login.  If  hackers were that patient, they'd go legit.  :-)</p></li>
</ol>
</div></text><author><a href="/users/29157/adam-liss">Adam Liss</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Failed authentification delays are there to reduce the rate of login attempt. The idea that if somebody is trying a dictionary or a brute force attack against one or may user accounts that attacker will be required to wait the fail delay and thus forcing him to take more time and giving you more chance to detect it.</p>
<p>You might also be interested in knowing that, depending on what you are using as a login shell there is usually a way to configure this delay. </p>
<p>In GDM, the delay is set in the gdm.conf file (usually in /etc/gdm/gdm.conf). you need to set RetryDelay=x where x is a value in seconds.</p>
<p>Most linux distribution these day also support having FAIL_DELAY defined in /etc/login.defs allowing you to set a wait time after a failed login attempt.</p>
<p>Finally, PAM also allows you to set a nodelay attribute on your auth line to bypass the fail delay. (<a href="http://www.enterprisenetworkingplanet.com/netsecur/article.php/3514511" rel="nofollow noreferrer">Here's an article on PAM and linux</a>)</p>
</div></text><author><a href="/users/68554/pierre-luc-simard">Pierre-Luc Simard</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I don't see that it can be as simple as the responses suggest.</p>
<p>If response to a correct password is (some value of) immediate, don't you only have to wait until longer than that value to know the password is wrong? (at least know probabilistically, which is fine for cracking purposes) And anyway you'd be running this attack in parallel... is this all one big DoS welcome mat?</p>
</div></text><author><a>NONE</a></author><comments><comment><text><span class="comment-copy">that's not what they meant. there is an obvious difference between getting the password wrong, or right. what they meant was that there should be no difference between an incorrect username, and an incorrect password. and do you mean running this attack in parallel? how can you run it in parallel?</span></text><author><a class="comment-user" href="/users/65387/mpen" title="94,547 reputation">mpen</a></author></comment><comment><text><span class="comment-copy">@Mark, running in parallel probably would entail opening multiple connections and trying to login. Still time consuming and not very practical.</span></text><author><a class="comment-user" href="/users/34435/he-the-great" title="4,997 reputation">he_the_great</a></author></comment><comment><text><span class="comment-copy">If you can run a million checks per second on a non-slowed connection and the connection then has a 1-second delay added for failed attempts, you'd need a million attack clients to get the same effect. I doubt the server will allow that many telnet sessions to be created.</span></text><author><a class="comment-user" href="/users/14860/paxdiablo" title="525,442 reputation">paxdiablo</a></author></comment><comment><text><span class="comment-copy">the point is you don't have to wait out the delay before you try the next password, so what's the use?</span></text><author><span class="comment-user">Greg M</span></author></comment><comment><text><span class="comment-copy">@Pax, that's what I meant by DoS welcome mat</span></text><author><span class="comment-user">Greg M</span></author></comment><comment><text><span class="comment-copy">@Greg, you do have to re-connect to the host and, if necessary, the next step would be to check IP addresses to catch this as well.</span></text><author><a class="comment-user" href="/users/14860/paxdiablo" title="525,442 reputation">paxdiablo</a></author></comment><comment><text><span class="comment-copy">Or just have successful attempts take a second as well. You don't log on often enough for that to be a problem but it would be for an attack node.</span></text><author><a class="comment-user" href="/users/14860/paxdiablo" title="525,442 reputation">paxdiablo</a></author></comment><comment><text><span class="comment-copy">@Pax: yes of course, but without the next step what's the point?</span></text><author><span class="comment-user">Greg M</span></author></comment><comment><text><span class="comment-copy">@All:  Remember that it takes time to establish a network connection, so it's far more efficient to "piggyback" several attempts on one (network) session than to try once, disconnect, reconnect, try again, da capa ad infinitum.  A good system will disconnect a user after a small number of failures.</span></text><author><a class="comment-user" href="/users/29157/adam-liss" title="35,998 reputation">Adam Liss</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>What I tried before appeared to work, but actually did not; if you care you must review the wiki edit history...</p>
<p>What <strong>does</strong> work (for me) is, to <strong>both</strong> lower the value of pam_faildelay.so delay=X in <strong>/etc/pam.d/login</strong> (I lowered it to 500000, half a second), <strong>and also</strong> add nodelay (preceded by a space) to the end of the line in <strong>common-auth</strong>, as described by Gabriel in his answer.</p>
<p><code>auth    [success=1 default=ignore]      pam_unix.so nullok_secure nodelay</code></p>
<p>At least for me (debian sid), only making one of these changes will not shorten the delay appreciably below the default 3 seconds, although it is possible to lengthen the delay by only changing the value in /etc/pam.d/login.</p>
<p>This kind of crap is enough to make a grown man cry!</p>
</div></text><author><a href="/users/383869/user383869">user383869</a></author><comments><comment><text><span class="comment-copy">This solved it for me on Xubuntu 15.04.</span></text><author><a class="comment-user" href="/users/1420399/shrx" title="470 reputation">shrx</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>On Ubuntu 9.10, and I think new versions too, the file you're looking for is located on </p>
<blockquote>
<p>/etc/pam.d/login</p>
</blockquote>
<p>edit the line:</p>
<blockquote>
<p>auth       optional   pam_faildelay.so  delay=3000000</p>
</blockquote>
<p>changing the number 3 with another you may want.</p>
<p>Note that to have a 'nodelay' authentication, I THINK you should edit the file </p>
<blockquote>
<p>/etc/pam.d/common-auth</p>
</blockquote>
<p>too. On the line:</p>
<blockquote>
<p>auth    [success=1 default=ignore]      pam_unix.so nullok_secure</p>
</blockquote>
<p>add 'nodelay' to the final (without quotes).
But this final explanation about the 'nodelay' is what I think.</p>
</div></text><author><a href="/users/334872/gabriel-l-oliveira">Gabriel L. Oliveira</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I would like to add a note from a developers perspective. Though this wouldn't be obvious to the naked eye a smart developer would break out of a match query when the match is found. In witness, a successful match would complete faster than a failed match. Because, the matching function would compare the credentials to all known accounts until it finds the correct match. In other words, let's say there are 1,000,000 user accounts in order by IDs; 001, 002, 003 and so on. Your ID is 43,001. So, when you put in a correct username and password, the scan stops at 43,001 and logs you in. If your credentials are incorrect then it scans all 1,000,000 records. The difference in processing time on a dual core server might be in the milliseconds. On Windows Vista with 5 user accounts it would be in the nanoseconds.</p>
</div></text><author><a href="/users/368580/user368580">user368580</a></author><comments><comment><text><span class="comment-copy">I think you'll find 99% of the posters here are developers of one level or another. Stop sounding so pompous.</span></text><author><span class="comment-user">delete me</span></author></comment><comment><text><span class="comment-copy">I use Ubuntu and there is only one user. However, when i submit a wrong password it takes 3 seconds for me to get a response. So, you are wrong :)</span></text><author><a class="comment-user" href="/users/2650759/halil-b%c4%b0lg%c4%b0n" title="440 reputation">Halil Bƒ∞LGƒ∞N</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I agree. This is an arbitrary programming decision.  Putting the delay to one second instead of three doesn't really hurt the crackability of the password, but makes it more user-friendly. </p>
</div></text><author><a href="/users/910985/jim">Jim</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Technically, this <strong>deliberate delay</strong> is to prevent attacks like the <strong>"Linearization attack"</strong> <em>(there are other attacks and reasons as well)</em>.</p>
<blockquote>
<p>To illustrate the attack, <strong>consider a program (without this
  deliberate delay), which checks an entered serial to see whether it
  matches the correct serial, which in this case happens to be
  "<em>xyba</em>"</strong>. For efficiency, the programmer decided to check one
  character at a time and to exit as soon as an incorrect character is
  found, before beginning the lengths are also checked.</p>
<p><strong>The correct serial length will take longer to process than an incorrect serial length. Even better (for attacker), a serial number
  that has the first character correct will take longer than any that
  has an incorrect first character. The successive steps in waiting time
  is because each time there's one more loop, comparison to go through
  on correct input.</strong> </p>
<ul>
<li>So, attacker can select a <em>four-character string</em> and that the string beginning with <em>x</em> takes the most time. <em>(by guess work)</em></li>
<li>Attacker can then fix character as <em>x</em> and vary the second character,    in which case they will find that <em>y</em> takes the longest.</li>
<li>Attacker can then fix the first two characters as <em>xy</em> and vary the third character, in which case they will find that <em>b</em> takes the
  longest.</li>
<li>Attacker can then fix the first three character as <em>xyb</em> and vary the fourth character,in which case they will find that <em>a</em> takes the
  longest.</li>
</ul>
<p>Hence, the attackers can recover the serial one character at a time.</p>
</blockquote>
<p><strong><a href="https://github.com/user501254/TE_IT_6_SWS/blob/master/attack_Linearization/Linearization.java" rel="nofollow">Linearization.java.</a></strong></p>
<p><strong><a href="https://github.com/user501254/TE_IT_6_SWS/blob/master/attack_Linearization/Linearization.docx" rel="nofollow">Linearization.docx, sample output</a></strong></p>
<blockquote>
<p>The serial number is four characters long ans each character has 128
  possible values. <strong>Then there are 128<sup>4</sup> = 2<sup>28</sup> =
  268,435,456 possible serials</strong>. If attacker must randomly guess
  complete serial numbers, she would guess the serial number in about
  <strong>2<sup>27</sup> = 134,217,728 tries, which is an enormous amount of work</strong>. On the other hand, by using the linearization attack above, an
  average of only 128/2 = 64 guesses are required for each letter, for a
  total <strong>expected work of about 4 * 64 = 2<sup>8</sup> = 256 guesses,</strong>
  which is a trivial amount of work.</p>
</blockquote>
<p><em>Much of the written martial is adapted from <a href="https://bookstreet.in/questions/what-is-malware-explain-salami-and-linearization-attacks-10-marks-925" rel="nofollow">this</a> (taken from Mark Stamp's "Information Security: Principles and Practice"). Also the calculations above do not take into account the amount of guesswork needed to to figure out the correct serial length.</em></p>
</div></text><author><a href="/users/2534513/ashesh-kumar-singh">Ashesh Kumar Singh</a></author><comments/></answer></answers></post>