<?xml version="1.0" encoding="utf-8"?>
<post><title>security - Best practices around generating OAuth tokens? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I realize that the <a href="http://oauth.net/core/1.0a#rfc.section.6" rel="noreferrer">OAuth spec</a> doesn't specify anything about the origin of the ConsumerKey, ConsumerSecret, AccessToken, RequestToken, TokenSecret, or Verifier code, but I'm curious if there are any best practices for creating significantly secure tokens (especially Token/Secret combinations).</p>
<p>As I see it, there are a few approaches to creating the tokens:</p>
<ol>
<li>Just use random bytes, store in DB associated to consumer/user</li>
<li>Hash some user/consumer-specific data, store in DB associated to consumer/user</li>
<li>Encrypt user/consumer-specific data</li>
</ol>
<p>Advantages to (1) is the database is the only source of the information which seems the most secure. It would be harder to run an attack against than (2) or (3).</p>
<p>Hashing real data (2) would allow re-generating the token from presumably already known data. Might not really provide any advantages to (1) since would need to store/lookup anyway. More CPU intensive than (1).</p>
<p>Encrypting real data (3) would allow decrypting to know information. This would require less storage &amp; potentially fewer lookups than (1) &amp; (2), but potentially less secure as well.</p>
<p>Are there any other approaches / advantages / disadvantages that should be considered?</p>
<p><strong>EDIT:</strong> another consideration is that there MUST be some sort of random value in the Tokens as there must exist the ability to expire and reissue new tokens so it must not be only comprised of real data.</p>
<p><strong>Follow On Questions</strong>:</p>
<p>Is there a minimum Token length to make significantly cryptographically secure? As I understand it, longer Token Secrets would create more secure signatures. Is this understanding correct?</p>
<p>Are there advantages to using a particular encoding over another from a hashing perspective? For instance, I see a lot of APIs using hex encodings (e.g. GUID strings). In the OAuth signing algorithm the Token is used as a string. With a hex string, the available character set would be much smaller (more predictable) than say with a Base64 encoding. It seems to me that for two strings of equal length, the one with the larger character set would have a better/wider hash distribution. This seems to me that it would would improve the security. Is this assumption correct?</p>
<p>The OAuth spec raises this very issue in <a href="http://oauth.net/core/1.0a#rfc.section.11.10" rel="noreferrer">11.10 Entropy of Secrets</a>.</p>
</div></text><author><a href="/users/43217/mckamey">mckamey</a></author><comments><comment><text><span class="comment-copy">Why the encryption? Isn't hashing good enough? If just hashing is good enough for password, shouldn't it be even better for longer access tokens?</span></text><author><a class="comment-user" href="/users/435605/alikelzin-kilaka" title="13,167 reputation">AlikElzin-kilaka</a></author></comment><comment><text><span class="comment-copy">It has been 7.5 years since I asked the question. I honestly can't remember.</span></text><author><a class="comment-user owner" href="/users/43217/mckamey" title="9,931 reputation">mckamey</a></author></comment><comment><text><span class="comment-copy">Reading again, hashing and encryption were two different approaches suggested. Encryption would allow server to get some info without a DB lookup. It was one trade off among many.</span></text><author><a class="comment-user owner" href="/users/43217/mckamey" title="9,931 reputation">mckamey</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>OAuth says nothing about token except that it has a secret associated with it. So all the schemes you mentioned would work. Our token evolved as the sites get bigger. Here are the versions we used before,</p>
<ol>
<li><p>Our first token is an encrypted BLOB with username, token secret and expiration etc. The problem is that we can't revoke tokens without any record on host.</p></li>
<li><p>So we changed it to store everything in database and the token is simply an random number used as the key to the database. It has an username index so it's easy to list all the tokens for an user and revoke it.</p></li>
<li><p>We get quite few hacking activities. With random number, we have to go to database to know if the token is valid. So we went back to encrypted BLOB again. This time, the token only contains encrypted value of the key and expiration. So we can detect invalid or expired tokens without going to the database.</p></li>
</ol>
<p>Some implementation details that may help you,</p>
<ol>
<li>Add a version in the token so you can change token format without breaking existing ones. All our token has first byte as version.</li>
<li>Use URL-safe version of Base64 to encode the BLOB so you don't have to deal with the URL-encoding issues, which makes debugging more difficult with OAuth signature, because you may see triple encoded basestring.</li>
</ol>
</div></text><author><a href="/users/149808/zz-coder">ZZ Coder</a></author><comments><comment><text><span class="comment-copy">Excellent, thanks. The version idea is a good one. I've got the URL-friendly Base64 going, but I am wishing I had a strictly alpha-numeric encoding for even easier reading.</span></text><author><a class="comment-user owner" href="/users/43217/mckamey" title="9,931 reputation">mckamey</a></author></comment><comment><text><span class="comment-copy">Hadn't thought of that before, very interesting! I was planning on APC key-caching to keep unneccessay load off the DB before i read this. Still unsure if this may not be way slower than a shared-memory lookup APC does (at least on the 2nd, 3rd, etc... request within reasonable timespan).</span></text><author><a class="comment-user" href="/users/1246547/philzen" title="1,618 reputation">Philzen</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>What about putting ip adress in token ? </p>
<p>Then you could on each request decrypt token and check request ip adress with token ip adress.</p>
<p>Maybe that aproach would be more secure against random generated attacks.</p>
<p>Best!</p>
<p>Edited:
Ok i think maybe i was not clear enaugh. My post was question not an answer. I will not try to find article on the internet where i read implementation with IP adress and i  agree that if you put IP adress in token, clients with dynamic ip adresses and mobile connections will have token problems.</p>
</div></text><author><a href="/users/1896029/dean-barisic">Dean Barisic</a></author><comments><comment><text><span class="comment-copy">I think it is a terrible idea. It should never be possible to reconstruct and find out how an access token is constructed. You can use user data to generate distinct tokens but always mixed with both random data and secret data.  Beside, it could be desirable to use the same access token in different networks in order to allow roaming (Wifi -&gt; Mobile)</span></text><author><a class="comment-user" href="/users/435855/urizev" title="462 reputation">Urizev</a></author></comment><comment><text><span class="comment-copy">Ok i think maybe i was not clear enaugh.</span></text><author><a class="comment-user" href="/users/1896029/dean-barisic" title="13 reputation">Dean Barisic</a></author></comment></comments></answer></answers></post>