<?xml version="1.0" encoding="utf-8"?>
<post><title>security - The necessity of hiding the salt for a hash - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>At work we have two competing theories for salts.  The products I work on use something like a user name or phone number to salt the hash.  Essentially something that is different for each user but is readily available to us.  The other product randomly generates a salt for each user and changes each time the user changes the password.  The salt is then encrypted in the database.</p>
<p>My question is if the second approach is really necessary?  I can understand from a purely theoretical perspective that it is more secure than the first approach, but what about from a practicality point of view.  Right now to authenticate a user, the salt must be unencrypted and applied to the login information.  </p>
<p>After thinking about it, I just don't see a real security gain from this approach.  Changing the salt from account to account, still makes it extremely difficult for someone to attempt to brute force the hashing algorithm even if the attacker was aware of how to quickly determine what it was for each account.  This is going on the assumption that the  passwords are sufficiently strong.  (Obviously finding the correct hash for a set of passwords where they are all two digits is significantly easier than finding the correct hash of passwords which are 8 digits).  Am I incorrect in my logic, or is there something that I am missing?</p>
<p><strong>EDIT:</strong> Okay so here's the reason why I think it's really moot to encrypt the salt.  (lemme know if I'm on the right track).  </p>
<p>For the following explanation, we'll assume that the passwords are always 8 characters and the salt is 5 and all passwords are comprised of lowercase letters (it just makes the math easier).</p>
<p>Having a different salt for each entry means that I can't use the same rainbow table (actually technically I could if I had one of sufficient size, but let's ignore that for the moment).  This is the real key to the salt from what I understand, because to crack every account I have to reinvent the wheel so to speak for each one.  Now if I know how to apply the correct salt to a password to generate the hash, I'd do it because a salt really just extends the length/complexity of the hashed phrase.  So I would be cutting the number of possible combinations I would need to generate to "know" I have the password + salt from 13^26 to 8^26 because I know what the salt is.  Now that makes it easier, but still really hard.  </p>
<p>So onto encrypting the salt.  If I know the salt is encrypted, I wouldn't try and decrypt (assuming I know it has a sufficient level of encryption) it first.  I would ignore it.  Instead of trying to figure out how to decrypt it, going back to the previous example I would just generate a larger rainbow table containing all keys for the 13^26.  Not knowing the salt would definitely slow me down, but I don't think it would add the monumental task of trying to crack the salt encryption first.  That's why I don't think it's worth it.  Thoughts?</p>
<p>Here is a link describing how long passwords will hold up under a brute force attack:
<a href="http://www.lockdown.co.uk/?pg=combi" rel="noreferrer">http://www.lockdown.co.uk/?pg=combi</a></p>
</div></text><author><a href="/users/57611/erike">ErikE</a></author><comments><comment><text><span class="comment-copy">Good question, Kevin, very timely. I can't comment on security, but there is a performance hit for all this encrypting and decrypting, for sure.</span></text><author><a class="comment-user" href="/users/27637/dok" title="25,814 reputation">DOK</a></author></comment><comment><text><span class="comment-copy">Thanks guys.  This has been bugging me for a while, and now I have a place to ask it :)</span></text><author><a class="comment-user owner" href="/users/1942/kevin" title="82,085 reputation">Kevin</a></author></comment><comment><text><span class="comment-copy">You don't need to ignore the rainbow table of decent size - that table also makes the encrypted salt moot since it can decrypt the salted hash and be used again to decrypt the original hash.  The good news is that table would take probably centuries to create.</span></text><author><a class="comment-user" href="/users/14092/tloach" title="7,312 reputation">tloach</a></author></comment><comment><text><span class="comment-copy">The thing that gets me is that I'm not totally certain a rainbow table of that size would take that long to create.  He is a wacky idea, take a distributed computing platform like Kraken (really that's kinda what it is) to generate it. How long would it take then?</span></text><author><a class="comment-user owner" href="/users/1942/kevin" title="82,085 reputation">Kevin</a></author></comment><comment><text><span class="comment-copy">@Kevin: SHA1 returns a 40-character hex string, so there are 40^16 possible return values.  Assuming a single computer can calculate 1000 hashes every second I calculate 1 000 000 computers would take about 10 billion years to generate a rainbow table capable of determining a string that size.</span></text><author><a class="comment-user" href="/users/14092/tloach" title="7,312 reputation">tloach</a></author></comment><comment><text><span class="comment-copy">+1 good question and you are well read.  I think think that you got the wrong answer to this question.  The should always be a secret because the hash cannot be broken until it is obtained.  You should read about CWE-760 (<a href="http://cwe.mitre.org/data/definitions/760.html" rel="nofollow noreferrer">cwe.mitre.org/data/definitions/760.html</a>)</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@tloach There are software that can do peaks 5600M/s MD5 hashes and 2300M/s SHA1 hashes. <a href="http://golubev.com/hashgpu.htm" rel="nofollow noreferrer">golubev.com/hashgpu.htm</a></span></text><author><a class="comment-user" href="/users/67517/franklin" title="800 reputation">Franklin</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The answer here is to ask yourself what you're really trying to protect from?  If someone has access to your database, then they have access to the encrypted salts, and they probably have access to your code as well.  With all that could they decrypt the encrypted salts?  If so then the encryption is pretty much useless anyway.  The salt really is there to make it so it isn't possible to form a rainbow table to crack your entire password database in one go if it gets broken into. From that point of view, so long as each salt is unique there is no difference, a brute force attack would be required with your salts or the encrypted salts for each password individually.</p>
</div></text><author><a href="/users/14092/tloach">tloach</a></author><comments><comment><text><span class="comment-copy">Any resources on a rainbow table?</span></text><author><a class="comment-user" href="/users/3469725/thomas" title="1,307 reputation">Thomas</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Hiding a salt is unnecessary.</p>
<p>A different salt should be used for every hash. In practice, this is easy to achieve by getting 8 or more bytes from cryptographic quality random number generator.</p>
<p>From a <a href="http://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904">previous answer of mine</a>:</p>
<p>Salt helps to thwart pre-computed dictionary attacks.</p>
<p>Suppose an attacker has a list of likely passwords. He can hash each and compare it to the hash of his victim's password, and see if it matches. If the list is large, this could take a long time. He doesn't want spend that much time on his next target, so he records the result in a "dictionary" where a hash points to its corresponding input. If the list of passwords is very, very long, he can use techniques like a Rainbow Table to save some space.</p>
<p>However, suppose his next target salted their password. Even if the attacker knows what the salt is, his precomputed table is worthless—the salt changes the hash resulting from each password. He has to re-hash all of the passwords in his list, affixing the target's salt to the input. Every different salt requires a different dictionary, and if enough salts are used, the attacker won't have room to store dictionaries for them all. Trading space to save time is no longer an option; the attacker must fall back to hashing each password in his list for each target he wants to attack.</p>
<p>So, it's not necessary to keep the salt secret. Ensuring that the attacker doesn't have a pre-computed dictionary corresponding to that particular salt is sufficient.</p>
<hr/>
<p>After thinking about this a bit more, I've realized that fooling yourself into thinking the salt can be hidden is dangerous. It's much better to assume the salt cannot be hidden, and design the system to be safe in spite of that. I provide a more detailed explanation <a href="http://stackoverflow.com/questions/4807677/why-does-php-crypt-prepend-the-salt-to-the-hash/4808616#4808616">in another answer.</a></p>
</div></text><author><a href="/users/3474/erickson">erickson</a></author><comments><comment><text><span class="comment-copy">Hiding the salt is necessary because the hash cannot be broken until it is obtained.  This is related to CWE-760 (<a href="http://cwe.mitre.org/data/definitions/760.html" rel="nofollow noreferrer">cwe.mitre.org/data/definitions/760.html</a>)</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">@The Rook - No, you are misinterpreting that issue. It refers to the use of predictable salts. It does not say anything about keeping the salt secret. Indeed, you can't really keep the salt secret without using another secret... in which case, why wouldn't you use the second secret as the salt? Using the username as a salt is bad because its likely that multiple systems share the same username, making it more worthwhile to build a table for that particular salt. Random salts are best, but they <b>do not</b> need to be kept secret.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment><comment><text><span class="comment-copy">See also: <a href="http://stackoverflow.com/questions/1645161/salt-generation-and-open-source-software/1645190#1645190" title="salt generation and open source software">stackoverflow.com/questions/1645161/…</a></span></text><author><a class="comment-user" href="/users/22674/jacco" title="15,768 reputation">Jacco</a></author></comment><comment><text><span class="comment-copy">@erickson, I think you are mixing up terminology here.  Salts do not thwart dictionary attacks unless they are hidden.  Alot of salts are stored openly.  And if you know the salt, you're dictionary attack is only slowed by the time it takes to append the salt to your dictionary term :)  Salts prevent Rainbow table look ups.... which are pretty darn fast.  If the attacker knows your salt, you are not protected from a dictionary attack.  If the attacker does not know your salt though, you are protected from a dictionary attack and they must use a brute force attack.</span></text><author><a class="comment-user" href="/users/498915/ultratrunks" title="930 reputation">Ultratrunks</a></author></comment><comment><text><span class="comment-copy">@Ultratrunks Yes, I have clarified some of my answers on this topic, using the term "pre-computed dictionary attacks." More general than Rainbow tables, it refers to any structure that allows a reverse lookup of a plaintext using its hash as a key. Regardless of the terms you choose, my explains explicitly that salt is intended to defeat Rainbow tables and similar mechanisms. You should always assume the attacker knows the salt. If it were possible to keep it secret, you wouldn't need to hash the password.</span></text><author><a class="comment-user" href="/users/3474/erickson" title="191,743 reputation">erickson</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>My understanding of "salt" is that it makes cracking more difficult, but it doesn't try to hide the extra data.  If you are trying to get more security by making the salt "secret", then you really just want more bits in your encryption keys.</p>
</div></text><author><a href="/users/19512/gbarry">gbarry</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The second approach is only slightly more secure.  Salts protect users from dictionary attacks and rainbow table attacks.  They make it harder for an ambitious attacker to compromise your entire system, but are still vulnerable to attacks that are focused on one user of your system.  If you use information that's publicly available, like a telephone number, <em>and the attacker becomes aware of this</em>, then you've saved them a step in their attack.  Of course the question is moot if the attacker gets your whole database, salts and all.</p>
<p><strong>EDIT:</strong> After re-reading over this answer and some of the comments, it occurs to me that some of the confusion may be due to the fact that I'm only comparing the two very specific cases presented in the question: random salt vs. non-random salt.  The question of <em>using a telephone number as a salt</em> is moot if the attacker gets your whole database, <strong>not</strong> the question of using a salt at all.</p>
</div></text><author><a href="/users/1288/bill-the-lizard">Bill the Lizard</a></author><comments><comment><text><span class="comment-copy">How do they protect against dictionary attacks?</span></text><author><a class="comment-user" href="/users/14092/tloach" title="7,312 reputation">tloach</a></author></comment><comment><text><span class="comment-copy">By forcing the attacker to make a new dictionary for each password+salt combination.  Without salt, one dictionary can be used against your whole passwords table.</span></text><author><a class="comment-user" href="/users/1288/bill-the-lizard" title="240,849 reputation">Bill the Lizard</a></author></comment><comment><text><span class="comment-copy">"Of course the question is moot if the attacker gets your whole database, salts and all." Isn't that why the salt is encrypted?</span></text><author><a class="comment-user" href="/users/437/patrick-mcelhaney" title="31,358 reputation">Patrick McElhaney</a></author></comment><comment><text><span class="comment-copy">@Bill: You just described a rainbow table.  A dictionary attack is where I take normal words and attempt to authenticate with them.  It's a brute-force with a greatly reduced answer space.  No hash defends against brute force.</span></text><author><a class="comment-user" href="/users/14092/tloach" title="7,312 reputation">tloach</a></author></comment><comment><text><span class="comment-copy">I've never heard of this practice, but I'm not a security expert.  It seems like encrypting unique salts would add an extra layer of protection against rainbow table attacks.</span></text><author><a class="comment-user" href="/users/1288/bill-the-lizard" title="240,849 reputation">Bill the Lizard</a></author></comment><comment><text><span class="comment-copy">@tloach:  I don't see your point.  Hashing and salting defend by forcing the attacker to use brute force.  That's an attractive quality.</span></text><author><a class="comment-user" href="/users/1288/bill-the-lizard" title="240,849 reputation">Bill the Lizard</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Here is a simple example showing why it is bad to have the same salt for each hash</p>
<p>Consider the following table</p>
<pre><code>UserId  UserName,   Password
     1  Fred       Hash1 =  Sha(Salt1+Password1)    
     2  Ted        Hash2 =  Sha(Salt2+Password2)    
</code></pre>
<p><strong>Case 1    when salt 1 is the same as salt2</strong> 
If Hash2 is replaced with Hash1 then user 2  could logon with user  1 password</p>
<p><strong>Case 2    when salt 1 not the same salt2</strong> 
If Hash2 is replaced with Hash1 then user2  can not   logon with users 1 password.</p>
</div></text><author><a href="/users/17560/charles-faiga">Charles Faiga</a></author><comments><comment><text><span class="comment-copy">We're not using the same hash for each account, we're using the same type of information for each hash.  For example, the salt for an account is the account's phonenumber etc.</span></text><author><a class="comment-user owner" href="/users/1942/kevin" title="82,085 reputation">Kevin</a></author></comment><comment><text><span class="comment-copy">I know this is a long time later, but...  you cannot rely on salts to protect against this type of attack. We must assume than an attacker knows everything about the authentication system other than the secret (i.e. password). Therefore we must assume that the attacker knows a) what we are using as the salt (most times this is stored in the same database &amp; table in plaintext) and b) how we are hashing with the salt (i.e. appending, hashing-twice, etc). If the user has the ability to switch the hashes then we must assume they can also switch the salt. Salts will not help here.</span></text><author><a class="comment-user" href="/users/3267940/davidsatch" title="836 reputation">davidsatch</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>There are two techniques, with different goals:</p>
<ul>
<li><p>The "salt" is used to make two otherwise equal passwords encrypt differently. This way, an intruder can't efficiently use a dictionary attack against a whole list of encrypted passwords.</p></li>
<li><p>The (shared) "secret" is added before hashing a message, so that an intruder can't create his own messages and have them accepted.</p></li>
</ul>
</div></text><author><a href="/users/11649/javier">Javier</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>... something like a user name or phone number to salt the hash. ...</p>
<p>My question is if the second approach is really necessary? I can understand from a purely theoretical perspective that it is more secure than the first approach, but <strong>what about from a practicality point of view?</strong></p>
</blockquote>
<p>From a practical point of view, a salt is an implementation detail. If you ever change how user info is collected or maintained – and both user names and phone numbers sometimes change, to use your exact examples – then you may have compromised your security. Do you want such an outward-facing change to have much deeper security concerns?</p>
<p>Does stopping the requirement that each account have a phone number need to involve a complete security review to make sure you haven't opened up those accounts to a security compromise?</p>
</div></text><author><a href="/users/1526405/anon">Anon</a></author><comments><comment><text><span class="comment-copy">Not to mention if you're using some arbitrary bit of user information, when they change that information you need them to input their password again so you can encrypt it again with the new salt.</span></text><author><a class="comment-user" href="/users/687538/treborbob" title="971 reputation">Treborbob</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A hidden salt is no longer salt. It's pepper. It has its use.  It's different from salt.</p>
<p>Pepper is a secret key added to the password + salt which makes the hash into an HMAC (Hash Based Message Authentication Code).  A hacker with access to the hash output and the salt can theoretically brute force guess an input which will generate the hash (and therefore pass validation in the password textbox).  By adding pepper you increase the problem space in a cryptographically random way, rendering the problem intractable without serious hardware.</p>
<p>For more information on pepper, check <a href="https://security.stackexchange.com/questions/3272/password-hashing-add-salt-pepper-or-is-salt-enough">here</a>.</p>
<p>See also <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code" rel="nofollow noreferrer">hmac</a>.</p>
</div></text><author><a href="/users/2791540/john-wu">John Wu</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Really, it depends on from what type of attack you're trying to protect your data.</p>
<p>The purpose of a unique salt for each password is to prevent a dictionary attack against the entire password database.</p>
<p>Encrypting the unique salt for each password would make it more difficult to crack an individual password, yes, but you must weigh whether there's really much of a benefit. If the attacker, by brute force, finds that this string:</p>
<pre><code>Marianne2ae85fb5d
</code></pre>
<p>hashes to a hash stored in the DB, is it really that hard to figure out what which part is the pass and which part is the salt?</p>
</div></text><author><a href="/users/6726/lucas-oman">Lucas Oman</a></author><comments><comment><text><span class="comment-copy">If someone brute forces such an impossible to guess password, I'd say you're hosed anyway, because apparently they have technology no one has even thought of yet.</span></text><author><a class="comment-user" href="/users/65393/instance-hunter" title="5,455 reputation">Instance Hunter</a></author></comment></comments></answer></answers></post>