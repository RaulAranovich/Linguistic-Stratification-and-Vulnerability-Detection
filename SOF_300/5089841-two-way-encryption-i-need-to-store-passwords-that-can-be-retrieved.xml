<?xml version="1.0" encoding="utf-8"?>
<post><title>php - Two-way encryption: I need to store passwords that can be retrieved - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am creating an application that will store passwords, which the user can retrieve and see.  The passwords are for a hardware device, so checking against hashes are out of the question.</p>
<p>What I need to know is:</p>
<ol>
<li><p>How do I encrypt and decrypt a password in PHP?</p></li>
<li><p>What is the safest algorithm to encrypt the passwords with?</p></li>
<li><p>Where do I store the private key?</p></li>
<li><p>Instead of storing the private key, is it a good idea to require users to enter the private key any time they need a password decrypted? (Users of this application can be trusted)</p></li>
<li><p>In what ways can the password be stolen and decrypted? What do I need to be aware of?</p></li>
</ol>
</div></text><author><a href="/users/608639/jww">jww</a></author><comments><comment><text><span class="comment-copy">Ugh. For one moment I thought this question was about PHP 2 ;)</span></text><author><a class="comment-user" href="/users/192741/franz" title="8,008 reputation">Franz</a></author></comment><comment><text><span class="comment-copy">I'm impressed! A question about encrypting passwords where the person asking the question actually knows the definition of "encrypt" (people often mean "hash") <i>and</i> they understand that there are implications to storing the secret key. I salute you!</span></text><author><a class="comment-user" href="/users/41619/adam-paynter" title="31,499 reputation">Adam Paynter</a></author></comment><comment><text><span class="comment-copy">Also see Openwall's <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">PHP password hashing framework</a> (PHPass). Its portable and hardened against a number of common attacks on user passwords. The guy who wrote the framework (SolarDesigner) is the same guy who wrote <a href="http://www.openwall.com/john/" rel="nofollow noreferrer">John The Ripper</a>. So he knows a thing or two about attacks on passwords.</span></text><author><a class="comment-user" href="/users/608639/jww" title="41,097 reputation">jww</a></author></comment><comment><text><span class="comment-copy">Funny how Adam mentions that OP finally knows the difference between encrypt and hash then jww comes and mentions a hashing class</span></text><author><a class="comment-user" href="/users/1454056/philippe-gilbert" title="150 reputation">Philippe Gilbert</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Personally, I would use <code>mcrypt</code> like others posted.  But there is much more to note...</p>
<ol>
<li><p>How do I encrypt and decrypt a password in PHP?</p>
<p>See below for a strong class that takes care of everything for you:</p></li>
<li><p>What is the safest algorithm to encrypt the passwords with?</p>
<p><em>safest</em>?  any of them.  The safest method if you're going to encrypt is to protect against information disclosure vulnerabilities (XSS, remote inclusion, etc).  If it gets out, the attacker can eventually crack the encryption (no encryption is 100% un-reversible without the key - As @NullUserException points out this is not entirely true.  There are some encryption schemes that are impossible to crack such as <a href="http://en.wikipedia.org/wiki/One-time_pad" rel="noreferrer">OneTimePad</a>).</p></li>
<li><p>Where do I store the private key?</p>
<p>What I would do is use 3 keys.  One is user supplied, one is application specific and the other is user specific (like a salt).  The application specific key can be stored anywhere (in a config file outside of the web-root, in an environmental variable, etc).  The user specific one would be stored in a column in the db next to the encrypted password.  The user supplied one would not be stored.  Then, you'd do something like this:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$key </span><span class="pun">=</span><span class="pln"> $userKey </span><span class="pun">.</span><span class="pln"> $serverKey </span><span class="pun">.</span><span class="pln"> $userSuppliedKey</span><span class="pun">;</span></code></pre>
<p>The benefit there, is that any 2 of the keys can be compromised without the data being compromised.  If there's a SQL Injection attack, they can get the <code>$userKey</code>, but not the other 2.  If there's a local server exploit, they can get <code>$userKey</code> and <code>$serverKey</code>, but not the third <code>$userSuppliedKey</code>.  If they go beat the user with a wrench, they can get the <code>$userSuppliedKey</code>, but not the other 2 (but then again, if the user is beaten with a wrench, you're too late anyway).  </p></li>
<li><p>Instead of storing the private key, is it a good idea to require users to enter the private key any time they need a password decrypted? (Users of this application can be trusted)</p>
<p>Absolutely.  In fact, that's the only way I would do it.  Otherwise you'd need to store an unencrypted version in a durable storage format (shared memory such as APC or memcached, or in a session file).  That's exposing yourself to additional compromises.  Never store the unencrypted version of the password in anything except a local variable.</p></li>
<li><p>In what ways can the password be stolen and decrypted? What do I need to be aware of?</p>
<p>Any form of compromise of your systems will let them view encrypted data.  If they can inject code or get to your filesystem, they can view decrypted data (since they can edit the files that decrypt the data).  Any form of Replay or MITM attack will also give them full access to the keys involved.  Sniffing the raw HTTP traffic will also give them the keys.</p>
<p>Use SSL for all traffic.  And make sure nothing on the server has any kind of vulnerabilities (CSRF, XSS, SQL Injection, Privilege Escalation, Remote Code Execution, etc).</p></li>
</ol>
<p><strong>Edit:</strong> Here's a PHP class implementation of a strong encryption method:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">/**
 * A class to handle secure encryption and decryption of arbitrary data
 *
 * Note that this is not just straight encryption.  It also has a few other
 *  features in it to make the encrypted data far more secure.  Note that any
 *  other implementations used to decrypt data will have to do the same exact
 *  operations.  
 *
 * Security Benefits:
 *
 * - Uses Key stretching
 * - Hides the Initialization Vector
 * - Does HMAC verification of source data
 *
 */</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Encryption</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="com">/**
     * @var string $cipher The mcrypt cipher to use for this instance
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> $cipher </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">

    </span><span class="com">/**
     * @var int $mode The mcrypt cipher mode to use
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> $mode </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">

    </span><span class="com">/**
     * @var int $rounds The number of rounds to feed into PBKDF2 for key generation
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> $rounds </span><span class="pun">=</span><span class="pln"> </span><span class="lit">100</span><span class="pun">;</span><span class="pln">

    </span><span class="com">/**
     * Constructor!
     *
     * @param string $cipher The MCRYPT_* cypher to use for this instance
     * @param int    $mode   The MCRYPT_MODE_* mode to use for this instance
     * @param int    $rounds The number of PBKDF2 rounds to do on the key
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> __construct</span><span class="pun">(</span><span class="pln">$cipher</span><span class="pun">,</span><span class="pln"> $mode</span><span class="pun">,</span><span class="pln"> $rounds </span><span class="pun">=</span><span class="pln"> </span><span class="lit">100</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $this</span><span class="pun">-&gt;</span><span class="pln">cipher </span><span class="pun">=</span><span class="pln"> $cipher</span><span class="pun">;</span><span class="pln">
        $this</span><span class="pun">-&gt;</span><span class="pln">mode </span><span class="pun">=</span><span class="pln"> $mode</span><span class="pun">;</span><span class="pln">
        $this</span><span class="pun">-&gt;</span><span class="pln">rounds </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> $rounds</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Decrypt the data with the provided key
     *
     * @param string $data The encrypted datat to decrypt
     * @param string $key  The key to use for decryption
     * 
     * @returns string|false The returned string if decryption is successful
     *                           false if it is not
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> decrypt</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $salt </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">128</span><span class="pun">);</span><span class="pln">
        $enc </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> </span><span class="lit">128</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">64</span><span class="pun">);</span><span class="pln">
        $mac </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">64</span><span class="pun">);</span><span class="pln">

        list </span><span class="pun">(</span><span class="pln">$cipherKey</span><span class="pun">,</span><span class="pln"> $macKey</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">getKeys</span><span class="pun">(</span><span class="pln">$salt</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">hash_equals</span><span class="pun">(</span><span class="pln">hash_hmac</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $enc</span><span class="pun">,</span><span class="pln"> $macKey</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">),</span><span class="pln"> $mac</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
             </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        $dec </span><span class="pun">=</span><span class="pln"> mcrypt_decrypt</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cipher</span><span class="pun">,</span><span class="pln"> $cipherKey</span><span class="pun">,</span><span class="pln"> $enc</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">mode</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">

        $data </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">unpad</span><span class="pun">(</span><span class="pln">$dec</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">return</span><span class="pln"> $data</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Encrypt the supplied data using the supplied key
     * 
     * @param string $data The data to encrypt
     * @param string $key  The key to encrypt with
     *
     * @returns string The encrypted data
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> encrypt</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $salt </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="lit">128</span><span class="pun">,</span><span class="pln"> MCRYPT_DEV_URANDOM</span><span class="pun">);</span><span class="pln">
        list </span><span class="pun">(</span><span class="pln">$cipherKey</span><span class="pun">,</span><span class="pln"> $macKey</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">getKeys</span><span class="pun">(</span><span class="pln">$salt</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">

        $data </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">pad</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">);</span><span class="pln">

        $enc </span><span class="pun">=</span><span class="pln"> mcrypt_encrypt</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cipher</span><span class="pun">,</span><span class="pln"> $cipherKey</span><span class="pun">,</span><span class="pln"> $data</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">mode</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">

        $mac </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $enc</span><span class="pun">,</span><span class="pln"> $macKey</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $salt </span><span class="pun">.</span><span class="pln"> $enc </span><span class="pun">.</span><span class="pln"> $mac</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Generates a set of keys given a random salt and a master key
     *
     * @param string $salt A random string to change the keys each encryption
     * @param string $key  The supplied key to encrypt with
     *
     * @returns array An array of keys (a cipher key, a mac key, and a IV)
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> getKeys</span><span class="pun">(</span><span class="pln">$salt</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $ivSize </span><span class="pun">=</span><span class="pln"> mcrypt_get_iv_size</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cipher</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">mode</span><span class="pun">);</span><span class="pln">
        $keySize </span><span class="pun">=</span><span class="pln"> mcrypt_get_key_size</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cipher</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">mode</span><span class="pun">);</span><span class="pln">
        $length </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> $keySize </span><span class="pun">+</span><span class="pln"> $ivSize</span><span class="pun">;</span><span class="pln">

        $key </span><span class="pun">=</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">pbkdf2</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">rounds</span><span class="pun">,</span><span class="pln"> $length</span><span class="pun">);</span><span class="pln">

        $cipherKey </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$key</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $keySize</span><span class="pun">);</span><span class="pln">
        $macKey </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$key</span><span class="pun">,</span><span class="pln"> $keySize</span><span class="pun">,</span><span class="pln"> $keySize</span><span class="pun">);</span><span class="pln">
        $iv </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$key</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> $keySize</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> array</span><span class="pun">(</span><span class="pln">$cipherKey</span><span class="pun">,</span><span class="pln"> $macKey</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
     * Stretch the key using the PBKDF2 algorithm
     *
     * @see http://en.wikipedia.org/wiki/PBKDF2
     *
     * @param string $algo   The algorithm to use
     * @param string $key    The key to stretch
     * @param string $salt   A random salt
     * @param int    $rounds The number of rounds to derive
     * @param int    $length The length of the output key
     *
     * @returns string The derived key.
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> pbkdf2</span><span class="pun">(</span><span class="pln">$algo</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">,</span><span class="pln"> $rounds</span><span class="pun">,</span><span class="pln"> $length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $size   </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">hash</span><span class="pun">(</span><span class="pln">$algo</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">));</span><span class="pln">
        $len    </span><span class="pun">=</span><span class="pln"> ceil</span><span class="pun">(</span><span class="pln">$length </span><span class="pun">/</span><span class="pln"> $size</span><span class="pun">);</span><span class="pln">
        $result </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">&lt;=</span><span class="pln"> $len</span><span class="pun">;</span><span class="pln"> $i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            $tmp </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="pln">$algo</span><span class="pun">,</span><span class="pln"> $salt </span><span class="pun">.</span><span class="pln"> pack</span><span class="pun">(</span><span class="str">'N'</span><span class="pun">,</span><span class="pln"> $i</span><span class="pun">),</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
            $res </span><span class="pun">=</span><span class="pln"> $tmp</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> $j </span><span class="pun">&lt;</span><span class="pln"> $rounds</span><span class="pun">;</span><span class="pln"> $j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                 $tmp  </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="pln">$algo</span><span class="pun">,</span><span class="pln"> $tmp</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
                 $res </span><span class="pun">^=</span><span class="pln"> $tmp</span><span class="pun">;</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
            $result </span><span class="pun">.=</span><span class="pln"> $res</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$result</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $length</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> pad</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $length </span><span class="pun">=</span><span class="pln"> mcrypt_get_block_size</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cipher</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">mode</span><span class="pun">);</span><span class="pln">
        $padAmount </span><span class="pun">=</span><span class="pln"> $length </span><span class="pun">-</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> $length</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$padAmount </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            $padAmount </span><span class="pun">=</span><span class="pln"> $length</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> $data </span><span class="pun">.</span><span class="pln"> str_repeat</span><span class="pun">(</span><span class="pln">chr</span><span class="pun">(</span><span class="pln">$padAmount</span><span class="pun">),</span><span class="pln"> $padAmount</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> unpad</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $length </span><span class="pun">=</span><span class="pln"> mcrypt_get_block_size</span><span class="pun">(</span><span class="pln">$this</span><span class="pun">-&gt;</span><span class="pln">cipher</span><span class="pun">,</span><span class="pln"> $this</span><span class="pun">-&gt;</span><span class="pln">mode</span><span class="pun">);</span><span class="pln">
        $last </span><span class="pun">=</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">[</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$last </span><span class="pun">&gt;</span><span class="pln"> $length</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">substr</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> $last</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> str_repeat</span><span class="pun">(</span><span class="pln">chr</span><span class="pun">(</span><span class="pln">$last</span><span class="pun">),</span><span class="pln"> $last</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> $last</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Note that I'm using a function added in PHP 5.6: <a href="http://php.net/manual/en/function.hash-equals.php" rel="noreferrer"><code>hash_equals</code></a>. If you're on lower than 5.6, you can use this substitute function which implements a <a href="http://blog.ircmaxell.com/2014/11/its-all-about-time.html" rel="noreferrer">timing-safe comparison</a> function using <a href="https://www.isecpartners.com/blog/2011/february/double-hmac-verification.aspx" rel="noreferrer">double HMAC verification</a>:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> hash_equals</span><span class="pun">(</span><span class="pln">$a</span><span class="pun">,</span><span class="pln"> $b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $key </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="lit">128</span><span class="pun">,</span><span class="pln"> MCRYPT_DEV_URANDOM</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $a</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $b</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Usage:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$e </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Encryption</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_CBC</span><span class="pun">);</span><span class="pln">
$encryptedData </span><span class="pun">=</span><span class="pln"> $e</span><span class="pun">-&gt;</span><span class="pln">encrypt</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span></code></pre>
<p>Then, to decrypt:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$e2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Encryption</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_CBC</span><span class="pun">);</span><span class="pln">
$data </span><span class="pun">=</span><span class="pln"> $e2</span><span class="pun">-&gt;</span><span class="pln">decrypt</span><span class="pun">(</span><span class="pln">$encryptedData</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">);</span></code></pre>
<p>Note that I used <code>$e2</code> the second time to show you different instances will still properly decrypt the data.</p>
<p>Now, how does it work/why use it over another solution:</p>
<ol>
<li><p>Keys</p>
<ul>
<li><p>The keys are not directly used.  Instead, the key is stretched by a standard PBKDF2 derivation.</p></li>
<li><p>The key used for encryption is unique for every encrypted block of text. The supplied key therefore becomes a "master key". This class therefore provides key rotation for cipher and auth keys.</p></li>
<li><p><strong>IMPORTANT NOTE</strong>, the <code>$rounds</code> parameter is configured for true random keys of sufficient strength (128 bits of Cryptographically Secure random at a minimum). If you are going to use a password, or non-random key (or less random then 128 bits of CS random), you <strong>must</strong> increase this parameter. I would suggest a minimum of 10000 for passwords (the more you can afford, the better, but it will add to the runtime)...</p></li>
</ul></li>
<li><p>Data Integrity</p>
<ul>
<li>The updated version uses ENCRYPT-THEN-MAC, which is a far better method for ensuring the authenticity of the encrypted data.</li>
</ul></li>
<li><p>Encryption:</p>
<ul>
<li>It uses mcrypt to actually perform the encryption.  I would suggest using either <code>MCRYPT_BLOWFISH</code> or <code>MCRYPT_RIJNDAEL_128</code> cyphers and <code>MCRYPT_MODE_CBC</code> for the mode.  It's strong enough, and still fairly fast (an encryption and decryption cycle takes about 1/2 second on my machine).  </li>
</ul></li>
</ol>
<p>Now, as to point 3 from the first list, what that would give you is a function like this:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> makeKey</span><span class="pun">(</span><span class="pln">$userKey</span><span class="pun">,</span><span class="pln"> $serverKey</span><span class="pun">,</span><span class="pln"> $userSuppliedKey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    $key </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $userKey</span><span class="pun">,</span><span class="pln"> $serverKey</span><span class="pun">);</span><span class="pln">
    $key </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha512'</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $userSuppliedKey</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $key</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>You could stretch it in the <code>makeKey()</code> function, but since it's going to be stretched later, there's not really a huge point to doing so.</p>
<p>As far as the storage size, it depends on the plain text.  Blowfish uses a 8 byte block size, so you'll have:</p>
<ul>
<li>16 bytes for the salt</li>
<li>64 bytes for the hmac</li>
<li>data length</li>
<li>Padding so that data length % 8 == 0</li>
</ul>
<p>So for a 16 character data source, there will be 16 characters of data to be encrypted. So that means the actual encrypted data size is 16 bytes due to padding.  Then add the 16 bytes for the salt and 64 bytes for the hmac and the total stored size is 96 bytes.  So there's at best a 80 character overhead, and at worst a 87 character overhead...</p>
<p>I hope that helps...</p>
<p><strong>Note:</strong> 12/11/12: I just updated this class with a MUCH better encryption method, using better derived keys, and fixing the MAC generation...</p>
</div></text><author><a href="/users/338665/ircmaxell">ircmaxell</a></author><comments><comment><text><span class="comment-copy">Aaaaaaaaaaaaaaaaand....BREAK!</span></text><author><a class="comment-user" href="/users/1228/will" title="100,617 reputation">Will</a></author></comment><comment><text><span class="comment-copy">@Rook FIPS-140-2 is an accreditation program. It says nothing about what the government does use. In fact: "This standard specifies the security requirements that will be satisfied by a cryptographic  module utilized  within a security system protecting sensitive but  <b>unclassified</b> information." So you <i>don't</i> know what they might use.</span></text><author><a class="comment-user" href="/users/396458/nulluserexception" title="56,528 reputation">NullUserException</a></author></comment><comment><text><span class="comment-copy">Somebody doesn't understand what it means "break". @IRC nice job on the class, that's pretty damned nice code.</span></text><author><a class="comment-user" href="/users/109749/jcolebrand" title="13,669 reputation">jcolebrand</a></author></comment><comment><text><span class="comment-copy">I think it's a good idea to have a user supplied key (like a password of some sorts), but what if they lose that? They would have to enter all details again ... it's safe though, for sure :)</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,248 reputation">Ja͢ck</a></author></comment><comment><text><span class="comment-copy">The following returns false. Any idea why? $x = new Encryption(MCRYPT_BlOWFISH, MCRYPT_MODE_CBC);  $test = $x-&gt;encrypt("test", "a"); echo var_dump($x-&gt;decrypt($test, "a"));</span></text><author><a class="comment-user" href="/users/1433564/the-wavelength" title="1,237 reputation">The Wavelength</a></author></comment><comment><text><span class="comment-copy">I think I fixed the problem you are having @TheWavelength (i had the same problem). In the decrypt function the line after <code>$dec = mcrypt_...</code> is <code>$data = $this-&gt;unpad($data);</code>. If you change that to <code>$data = $this-&gt;unpad($dec);</code> it appears to work for me</span></text><author><a class="comment-user" href="/users/1055382/cosmorogers" title="378 reputation">cosmorogers</a></author></comment><comment><text><span class="comment-copy">Oh and again in the decrypt function changing the two <code>-64</code>s to <code>-128</code> helped (so you get <code>$enc = substr($data, 128, -128)</code> and <code>$mac = substr($data, -128);</code></span></text><author><a class="comment-user" href="/users/1055382/cosmorogers" title="378 reputation">cosmorogers</a></author></comment><comment><text><span class="comment-copy">Yay, thanks :-)</span></text><author><a class="comment-user" href="/users/1433564/the-wavelength" title="1,237 reputation">The Wavelength</a></author></comment><comment><text><span class="comment-copy">@cosmorogers: no longer needed. I forgot to add the true parameter to <code>hash_hmac</code> to make it a binary hash (so it was hex, resulting in double the storage space). So with the edit, it should remove the need to update those values...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">is there any way to do this without the user input (the user enters his password only once and its encrypted, and later automatically decrypted without the users input)?</span></text><author><a class="comment-user" href="/users/1979982/gigala" title="134 reputation">Gigala</a></author></comment><comment><text><span class="comment-copy">@ircmaxell -- I presume it is okay for us to use this code in our own applications?  Do you need credit/payment/etc?  This is such a hugely useful piece of code...thank you so much for the answer.</span></text><author><a class="comment-user" href="/users/1149499/user1149499" title="160 reputation">user1149499</a></author></comment><comment><text><span class="comment-copy">I am using the exact same decrypt syntax and it works twice and fails twice: $crypt2 = new Encryption(MCRYPT_BLOWFISH, MCRYPT_MODE_CBC); $a = $crypt2-&gt;decrypt(base64_decode($first), $key); $b = $crypt2-&gt;decrypt(base64_decode($last), $key); $c = $crypt2-&gt;decrypt(base64_decode($email), $key); $d = $crypt2-&gt;decrypt(base64_decode($tel), $key);  $a and $b come back blank, yet $c and $d are fine.  Even if I substitute 'some-string-here' for vars $first and $last, it still comes back empty.  I have no clue why it works for certain lines and not for others.  Anyone know what's going on?  @ircmaxell?</span></text><author><a class="comment-user" href="/users/1149499/user1149499" title="160 reputation">user1149499</a></author></comment><comment><text><span class="comment-copy">Okay, so I figured out my issue:  the db had 128 char "VARCHAR" for the $first and $last fields.  What I didn't realize is that it fails <i>totally</i> (returns nothing) if it doesn't have the full data string.  Probably good for security, but I was expecting it would return some kind of value after decrypting the initial 128 chars.  But I am all set now.  Whew.  :-)</span></text><author><a class="comment-user" href="/users/1149499/user1149499" title="160 reputation">user1149499</a></author></comment><comment><text><span class="comment-copy">@ircmaxell It's been quite a while since the code was last revised so I'm wondering if it's up to date. I need to use something similar for a financial application and it would be nice if you gave an okay with this class :-)</span></text><author><a class="comment-user" href="/users/1623021/nt-bas" title="228 reputation">nt.bas</a></author></comment><comment><text><span class="comment-copy">This class looks fantastic, thank you. My only question is, how can I save encrypted data to mysql? I tried using PHP's <code>bin2hex</code> before inserting, then <code>hex2bin</code> before decrypting, but I have not been able to decrypt reliably. Any suggestions?</span></text><author><a class="comment-user" href="/users/1279133/jrob" title="3,430 reputation">JROB</a></author></comment><comment><text><span class="comment-copy">Warning! The mcrypt extension has been abandonware for nearly a decade now, and was also fairly complex to use. It has therefore been deprecated in favour of OpenSSL, where it will be removed from the core and into PECL in PHP 7.2.   <a href="http://th1.php.net/manual/en/migration71.deprecated.php" rel="nofollow noreferrer">th1.php.net/manual/en/migration71.deprecated.php</a></span></text><author><a class="comment-user" href="/users/128761/vee" title="1,482 reputation">vee</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><em><strong>How do I encrypt and decrypt a password in PHP?</strong></em>
By implementing one of many encryption algorithms. (or using one of many libraries)</p>
<p><em><strong>What is the safest algorithm to encrypt the passwords with?</strong></em>
There are tons of different algorithms, none of which are 100% secure. But many of them are secure enough for commerce and even military purposes</p>
<p><em><strong>Where do I store the private key?</strong></em>
If you have decided to implement public key - cryptography algorithm(eg RSA), you don't store private key. user have private key. your system has public key which could be stored anywhere you wish.</p>
<p><em><strong>Instead of storing the private key, is it a good idea to require users to enter the private key any time they need a password decrypted? (Users of this application can be trusted)</strong></em>
Well if your user can remember ridiculously long prime numbers then - yes, why not. But generally you would need to come up with the system which will allow user to store their key somewhere.</p>
<p><em><strong>In what ways can the password be stolen and decrypted? What do I need to be aware of?</strong></em>
This depends on the algorithm used. However always make sure that you don't send password unencrypted to or from the user. Either encrypt/decrypt it on the client side, or use https(or user other cryptographic means to secure connection between server and client). </p>
<p>However if all you need is to store passwords in encrypted way, I would suggest you to use a simple XOR Cipher. The main problem with this algorithm is that it could be easily broken by frequency analysis. However as generally passwords are not made from long paragraphs of English text I don't think you should worry about it. The second problem with XOR Cipher is that if you have a message in both encrypted and decrypted form you could easily find out password with which it was encrypted. Again, not a big problem in your case as it only affects the user who already was compromised by other means.</p>
</div></text><author><a href="/users/509597/ivan">Ivan</a></author><comments><comment><text><span class="comment-copy">On answer 3, when you say users have private key, I don't understand what that means. You don't recommend passing private keys into the application manually by the user, so how else are private keys passed to the application?</span></text><author><a class="comment-user owner" href="/users/157837/hydera" title="5,550 reputation">HyderA</a></author></comment><comment><text><span class="comment-copy">Well that's a bit of a problem. Private key could be stored in the text file and then copy pasted to the app. Key could also be stored on the server but in this case it still should be encrypted with some other encryption algorithm like XOR. Using XOR here in this case is secure enough as there is only one password-message pair and message is quite random so frequency analysis cold not be used.</span></text><author><a class="comment-user" href="/users/509597/ivan" title="2,899 reputation">Ivan</a></author></comment><comment><text><span class="comment-copy">I certainly wouldn't recommend implementing an encryption algorithm yourself, there's too many potential pitfalls and the existing libraries have been tested and analysed by many people.</span></text><author><a class="comment-user" href="/users/629635/long-ears" title="3,866 reputation">Long Ears</a></author></comment><comment><text><span class="comment-copy">The main problem with XOR is that if someone steals your application data and knows just one of a user's passwords, they can decrypt all the other passwords for that user.</span></text><author><a class="comment-user" href="/users/629635/long-ears" title="3,866 reputation">Long Ears</a></author></comment><comment><text><span class="comment-copy">@Lacking Ideas  Both your comments are valid, however some of the ciphers are quite simple and easy to implement(eg XOR, TEA (btw I know that TEA has quite a few weaknesses)) but implementing those yourself could give you a good understanding of how cryptography works as well as decent security. Again it's all just about how paranoid you are or how likely attacks are. Even simplest ciphers will fend off 99% of attacks. Every next hundredth of percent will come of a cost of more and more time spent on development.</span></text><author><a class="comment-user" href="/users/509597/ivan" title="2,899 reputation">Ivan</a></author></comment><comment><text><span class="comment-copy">@Ivan: yes, but this is one of the cases when I think DIY is really <b>really</b> bad unless you REALLY understand cryptography.  There are strong ciphers that exist, why not use them?</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">@irc at no point in my answer I've tried to convince anyone to invent new ciphers. However carefully implementing existing ciphers could be beneficial as it gives better understanding of cryptography</span></text><author><a class="comment-user" href="/users/509597/ivan" title="2,899 reputation">Ivan</a></author></comment><comment><text><span class="comment-copy">@Ivan: fair enough.  I was just trying to point out that people shouldn't be trying to build their own algos (even a simple XOR cipher) for anything they care about.  It's a great learning experience, but for practical use cases, stick to a public algo that's been vetted...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">This is a very long non-answer.  q: "how would I do this?"  a: "there are many ways, identify and pick one".</span></text><author><a class="comment-user" href="/users/177920/madbreaks" title="12,384 reputation">Madbreaks</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<ol>
<li>The PHP function you are after is Mcrypt (<a href="http://www.php.net/manual/en/intro.mcrypt.php" rel="nofollow noreferrer">http://www.php.net/manual/en/intro.mcrypt.php</a>).</li>
</ol>
<p>The example from the manual is slightly edited for this example):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">&lt;?</span><span class="pln">php
$iv_size </span><span class="pun">=</span><span class="pln"> mcrypt_get_iv_size</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">);</span><span class="pln">
$iv </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="pln">$iv_size</span><span class="pun">,</span><span class="pln"> MCRYPT_RAND</span><span class="pun">);</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> </span><span class="str">"This is a very secret key"</span><span class="pun">;</span><span class="pln">
$pass </span><span class="pun">=</span><span class="pln"> </span><span class="str">"PasswordHere"</span><span class="pun">;</span><span class="pln">
echo strlen</span><span class="pun">(</span><span class="pln">$pass</span><span class="pun">)</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">

$crypttext </span><span class="pun">=</span><span class="pln"> mcrypt_encrypt</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $pass</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">
echo strlen</span><span class="pun">(</span><span class="pln">$crypttext</span><span class="pun">)</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
</span><span class="pun">?&gt;</span></code></pre>
<p>You would use <a href="http://www.php.net/manual/en/function.mcrypt-decrypt.php" rel="nofollow noreferrer"><strong>mcrypt_decrypt</strong></a> to decrypt your password.</p>
<ol start="2">
<li><p>The best <a href="http://www.php.net/manual/en/mcrypt.ciphers.php" rel="nofollow noreferrer">algorithm</a> is rather subjective - ask 5 people, get 5 answers.  Personally if the the default (Blowfish) isn't good enough for you, you probably have bigger problems!  </p></li>
<li><p>Given that it is needed by PHP to encrypt - not sure you can hide it anywhere - welcome comments on this.  Standard PHP best coding practices apply of course!</p></li>
<li><p>Given that the encryption key will be in your code anyway, not sure what you will gain, providing the rest of your application is secure.</p></li>
<li><p>Obviously, if the encrypted password and the encryption key are stolen, then game over. </p></li>
</ol>
<p>I'd put a rider on my answer - I'm not a PHP crypto expert, but, I think what I have answered is standard practice - I welcome comments other may have. </p>
</div></text><author><a href="/users/89994/jon-rhoades">Jon Rhoades</a></author><comments><comment><text><span class="comment-copy">The interesting thing about your code sample is that variable $pass is never used ;)</span></text><author><a class="comment-user" href="/users/509597/ivan" title="2,899 reputation">Ivan</a></author></comment><comment><text><span class="comment-copy"><code>$pass = $text</code>. I think he changed that to cater to the question, and didn't notice the second occurrence.</span></text><author><a class="comment-user owner" href="/users/157837/hydera" title="5,550 reputation">HyderA</a></author></comment><comment><text><span class="comment-copy">@ivan whoops, edited to correct that - thanks!</span></text><author><a class="comment-user" href="/users/89994/jon-rhoades" title="324 reputation">Jon Rhoades</a></author></comment><comment><text><span class="comment-copy">Two things to note.  First, <code>MCRYPT_MODE_ECB</code> doesn't use an IV.  Second, if it did, you'd need to store the IV as you can't decrypt the data without it...</span></text><author><a class="comment-user" href="/users/338665/ircmaxell" title="119,301 reputation">ircmaxell</a></author></comment><comment><text><span class="comment-copy">"The best algorithm is rather subjective - ask 5 people, get 5 answers. Personally if the the default (Blowfish) isn't good enough for you, you probably have bigger problems!" This is totally wrong. Any crypto expert will more-or-less agree with <a href="https://gist.github.com/tqbf/be58d2d39690c3b366ad" rel="nofollow noreferrer">gist.github.com/tqbf/be58d2d39690c3b366ad</a> which specifically excludes blowfish</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>A lot of users have suggested using mcrypt... which is correct, but I like to go a step further to make it easily stored and transfered (as sometimes encrypted values can make them hard to send using other technologies like curl, or json).</p>
<p>After you have successfully encrypted using mcrypt, run it through base64_encode and then convert it to hex code. Once in hex code it's easy to transfer in a variety of ways.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$td </span><span class="pun">=</span><span class="pln"> mcrypt_module_open</span><span class="pun">(</span><span class="str">'tripledes'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln"> </span><span class="str">'ecb'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">);</span><span class="pln">
$iv </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv </span><span class="pun">(</span><span class="pln">mcrypt_enc_get_iv_size</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">),</span><span class="pln"> MCRYPT_RAND</span><span class="pun">);</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="str">"SUPERSECRETKEY"</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="pln">mcrypt_enc_get_key_size</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">));</span><span class="pln">
mcrypt_generic_init</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">
$encrypted </span><span class="pun">=</span><span class="pln"> mcrypt_generic</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">,</span><span class="pln"> $unencrypted</span><span class="pun">);</span><span class="pln">
$encrypted </span><span class="pun">=</span><span class="pln"> $ua</span><span class="pun">.</span><span class="str">"||||"</span><span class="pun">.</span><span class="pln">$iv</span><span class="pun">;</span><span class="pln">
mcrypt_generic_deinit</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">);</span><span class="pln">
mcrypt_module_close</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">);</span><span class="pln">
$encrypted </span><span class="pun">=</span><span class="pln"> base64_encode</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">);</span><span class="pln">
$encrypted </span><span class="pun">=</span><span class="pln"> array_shift</span><span class="pun">(</span><span class="pln">unpack</span><span class="pun">(</span><span class="str">'H*'</span><span class="pun">,</span><span class="pln"> $encrypted</span><span class="pun">));</span></code></pre>
<p>And on the other side:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$encrypted </span><span class="pun">=</span><span class="pln"> pack</span><span class="pun">(</span><span class="str">'H*'</span><span class="pun">,</span><span class="pln"> $encrypted</span><span class="pun">);</span><span class="pln">
$encrypted </span><span class="pun">=</span><span class="pln"> base64_decode</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">);</span><span class="pln">
list</span><span class="pun">(</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="pln">$iv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> explode</span><span class="pun">(</span><span class="str">"||||"</span><span class="pun">,</span><span class="pln">$encrypted</span><span class="pun">,</span><span class="lit">2</span><span class="pun">);</span><span class="pln">
$td </span><span class="pun">=</span><span class="pln"> mcrypt_module_open</span><span class="pun">(</span><span class="str">'tripledes'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln"> </span><span class="str">'ecb'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">);</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="str">"SUPERSECRETKEY"</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="pln">mcrypt_enc_get_key_size</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">));</span><span class="pln">
mcrypt_generic_init</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">
$unencrypted </span><span class="pun">=</span><span class="pln"> mdecrypt_generic</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">,</span><span class="pln"> $encrypted</span><span class="pun">);</span><span class="pln">
mcrypt_generic_deinit</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">);</span><span class="pln">
mcrypt_module_close</span><span class="pun">(</span><span class="pln">$td</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/82242/bradley">Bradley</a></author><comments><comment><text><span class="comment-copy"><a href="https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong" rel="nofollow noreferrer">Mcrypt isn't a great option</a></span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">Well - it was in 2011 :P</span></text><author><a class="comment-user" href="/users/82242/bradley" title="1,126 reputation">Bradley</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'd only suggest public key encryption if you want the ability to set a user's password without their interaction (this can be handy for resets and shared passwords).</p>
<h1>Public key</h1>
<ol>
<li>The <a href="http://www.php.net/manual/en/book.openssl.php" rel="nofollow">OpenSSL</a> extension, specifically <code>openssl_public_encrypt</code> and <code>openssl_private_decrypt</code> </li>
<li>This would be straight RSA assuming your passwords will fit in key size - padding, otherwise you need a symmetric layer</li>
<li>Store both keys for each user, the private key's passphrase is their application password</li>
</ol>
<h1>Symmetric</h1>
<ol>
<li>The <a href="http://www.php.net/manual/en/ref.mcrypt.php" rel="nofollow">Mcrypt</a> extension</li>
<li>AES-256 is probably a safe bet, but this could be a SO question in itself</li>
<li>You don't - this would be their application password</li>
</ol>
<h1>Both</h1>
<p><code>4</code>. Yes - users would have to enter their application password every time, but storing it in the session would raise other issues</p>
<p><code>5</code>.</p>
<ul>
<li>If someone steals the application data, it's as secure as the symmetric cipher (for the public key scheme, it's used to protect the private key with the passphrase.)</li>
<li>Your application should definitely be only accessible over SSL, preferably using client certificates.</li>
<li>Consider adding a second factor for authentication which would only be used once per session, like a token sent via SMS.</li>
</ul>
</div></text><author><a href="/users/629635/long-ears">Long Ears</a></author><comments><comment><text><span class="comment-copy">Avoid mcrypt, be careful with <a href="http://framework.zend.com/security/advisory/ZF2015-10" rel="nofollow noreferrer"><code>openssl_private_decrypt()</code></a>.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I tried something like this but please note that I am not cryptographer nor I hold in-depth knowledge about <code>php</code> or any programming language. It's just an idea. My idea is to store <code>key</code> in some file or <code>database</code> (or enter manually) which(location) cannot be easily predicted(And of course anything will be decrypted someday, the concept is to lengthen the decryption time) and encrypt sensitive information.</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$iv_size </span><span class="pun">=</span><span class="pln"> mcrypt_get_iv_size</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH </span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">);</span><span class="pln">
$iv </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="pln">$iv_size</span><span class="pun">,</span><span class="pln"> MCRYPT_RAND</span><span class="pun">);</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> </span><span class="str">"evenifyouaccessmydatabaseyouwillneverfindmyemail"</span><span class="pun">;</span><span class="pln">
$text </span><span class="pun">=</span><span class="pln"> </span><span class="str">"myemail@domain.com"</span><span class="pun">;</span><span class="pln">
echo </span><span class="str">"Key : "</span><span class="pun">.</span><span class="pln">$key</span><span class="pun">.</span><span class="str">"&lt;br/&gt;"</span><span class="pun">;</span><span class="pln">
echo </span><span class="str">"Text : "</span><span class="pun">.</span><span class="pln">$text </span><span class="pun">.</span><span class="pln"> </span><span class="str">"&lt;br/&gt;"</span><span class="pun">;</span><span class="pln">
echo </span><span class="str">"Md5 : "</span><span class="pun">.</span><span class="pln">md5</span><span class="pun">(</span><span class="pln">$text</span><span class="pun">).</span><span class="pln"> </span><span class="str">"&lt;br/&gt;"</span><span class="pun">;</span><span class="pln">
echo </span><span class="str">"Sha1 : "</span><span class="pun">.</span><span class="pln">sha1</span><span class="pun">(</span><span class="pln">$text</span><span class="pun">).</span><span class="pln"> </span><span class="str">"&lt;br/&gt;"</span><span class="pun">;</span><span class="pln">



$crypttext </span><span class="pun">=</span><span class="pln"> mcrypt_encrypt</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH </span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $text</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">
echo </span><span class="str">"Crypted Data : "</span><span class="pun">.</span><span class="pln">$crypttext</span><span class="pun">.</span><span class="str">"&lt;br&gt;"</span><span class="pun">;</span><span class="pln">

$base64 </span><span class="pun">=</span><span class="pln"> base64_encode</span><span class="pun">(</span><span class="pln">$crypttext</span><span class="pun">);</span><span class="pln">
echo </span><span class="str">"Encoded Data : "</span><span class="pun">.</span><span class="pln">$base64</span><span class="pun">.</span><span class="str">"&lt;br/&gt;"</span><span class="pun">;</span><span class="pln">
$decode </span><span class="pun">=</span><span class="pln">  base64_decode</span><span class="pun">(</span><span class="pln">$base64</span><span class="pun">);</span><span class="pln">


$decryptdata </span><span class="pun">=</span><span class="pln"> mcrypt_decrypt</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH </span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $crypttext</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">

echo </span><span class="str">"Decoded Data : "</span><span class="pun">.</span><span class="pln">ereg_replace</span><span class="pun">(</span><span class="str">"?"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">,</span><span class="pln">  $decryptdata</span><span class="pun">);</span><span class="pln"> 
</span><span class="com">//event if i add '?' to the sting to the text it works, I don't know why.</span></code></pre>
<p>Please note that it is just a concept. Any improvement on this code would be highly appreciable.</p>
</div></text><author><a href="/users/447023/santosh-linkha">Santosh Linkha</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>The passwords are for a hardware device, so checking against hashes are out of the question</p>
</blockquote>
<p>Eh? I don't understand. Do you just mean that password must be recoverable?</p>
<p>As others have said, the mcrypt extension provides access to lots of cryptographic functions - however you are inviting your users to put all their eggs in one basket - one which will be potentially be a target for attackers - and if you don't even know how to start solving the problem then you are doing your users a disservice. You are not in a position to understand how to protect the data.</p>
<p>Most security vulnerabilities come about not because the underlying algorithm is flawed or insecure - but because of problems with the way the algorithm is used within the application code.</p>
<p>Having said that, it is <strong>possible</strong> to build a reasonably secure system.</p>
<p>You should only consider asymmetric encryption if you have a requirement for a user to create a secure message which is readable by another (specific) user. The reason being that its computationally expensive. If you just want to provide a repository for users to enter and retrieve their own data, symmetric encryption is adequate.</p>
<p>If, however, you store the key for decrypting the message in the same place as the encrypted message (or where the encrypted message is stored) then the system is not secure. Use the same token for authenticating the user as for the decryption key (or in the case of assymetric encryption, use the token as the private key pass phrase). Since you will need to store the token on the server where the decryption takes place at least temporarily, you might want to consider using a non-searchable session storage substrate, or passing the token directly to a daemon associated with the session which would store the token in memory and perform the decryption of messages on demand.</p>
</div></text><author><a href="/users/223992/symcbean">symcbean</a></author><comments/></answer></answers></post>