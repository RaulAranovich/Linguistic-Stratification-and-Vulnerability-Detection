<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How to encrypt/decrypt data in php? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I'm currently a student and I'm studying PHP, I'm trying to make a simple encrypt/decrypt of data in PHP. I made some online research and some of them were quite confusing(at least for me).</p>
<p>Here's what I'm trying to do:</p>
<p>I have a table consisting of these fields <strong>(UserID,Fname,Lname,Email,Password)</strong></p>
<p>What I want to have is have the all fields encrypted and then be decrypted(Is it possible to use <code>sha256</code> for encryption/decryption, if not any encryption algorithm)</p>
<p>Another thing I want to learn is how to create a one way <code>hash(sha256)</code> combined with a good "salt".
(Basically I just want to have a simple implementation of encryption/decryption, <code>hash(sha256)+salt)
</code>
Sir/Ma'am, your answers would be of great help and be very much appreciated. Thank you++</p>
</div></text><author><a href="/users/2224584/scott-arciszewski">Scott Arciszewski</a></author><comments><comment><text><span class="comment-copy"><a href="http://thenextweb.com/socialmedia/2012/06/06/bad-day-for-linkedin-6-5-million-hashed-passwords-reportedly-leaked-change-yours-now/" rel="nofollow noreferrer">The horrors of Sha-1 encryption!</a></span></text><author><a class="comment-user" href="/users/561731/neal" title="97,990 reputation">Neal</a></author></comment><comment><text><span class="comment-copy"><a href="http://php.net/manual/en/faq.passwords.php" rel="nofollow noreferrer">php.net/manual/en/faq.passwords.php</a></span></text><author><a class="comment-user" href="/users/92176/steve-ross" title="1,028 reputation">Steve Ross</a></author></comment><comment><text><span class="comment-copy">SHA is a hash, not encryption. The key point is that a hash cannot be reversed to the original data (not easily, anyway). You probably want <a href="http://php.net/manual/en/book.mcrypt.php" rel="nofollow noreferrer">mcrypt</a> or if it is not available I would recommend <a href="http://phpseclib.sourceforge.net/" rel="nofollow noreferrer">phpseclib</a> - although it's important to note that any pure-PHP implementation of anything that involves a lot of low-level mathematics will be sloooooowww... That's why I like phpseclib, because it uses mcrypt first if it's available and only falls back to PHP implementations as a last resort.</span></text><author><a class="comment-user" href="/users/889949/daverandom" title="59,698 reputation">DaveRandom</a></author></comment><comment><text><span class="comment-copy">You normally don't want to be able to decrypt a password!</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,258 reputation">JaÍ¢ck</a></author></comment><comment><text><span class="comment-copy">Basically you should not think of encryption at this level, you should think about access control, confidentiality, integrity and authentication. After that check how you can achieve this, <i>possibly</i> using encryption or secure hashing. You might want to read into PBKDF2 and bcrypt/scrypt to understand secure hashing of passwords and the like.</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<h1>Foreword</h1>
<p>Starting with your table definition:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pun">-</span><span class="pln"> </span><span class="typ">UserID</span><span class="pln">
</span><span class="pun">-</span><span class="pln"> </span><span class="typ">Fname</span><span class="pln">
</span><span class="pun">-</span><span class="pln"> </span><span class="typ">Lname</span><span class="pln">
</span><span class="pun">-</span><span class="pln"> </span><span class="typ">Email</span><span class="pln">
</span><span class="pun">-</span><span class="pln"> </span><span class="typ">Password</span><span class="pln">
</span><span class="pun">-</span><span class="pln"> IV</span></code></pre>
<p>Here are the changes:</p>
<ol>
<li>The fields <code>Fname</code>, <code>Lname</code> and <code>Email</code> will be encrypted using a symmetric cipher, provided by <a href="http://php.net/openssl">OpenSSL</a>,</li>
<li>The <code>IV</code> field will store the <a href="http://en.wikipedia.org/wiki/Initialization_vector">initialisation vector</a> used for encryption. The storage requirements depend on the cipher and mode used; more about this later.</li>
<li>The <code>Password</code> field will be hashed using a <em>one-way</em> password hash,</li>
</ol>
<h1>Encryption</h1>
<p><strong>Cipher and mode</strong></p>
<p>Choosing the best encryption cipher and mode is beyond the scope of this answer, but the final choice affects the size of both the encryption key and initialisation vector; for this post we will be using AES-256-CBC which has a fixed block size of 16 bytes and a key size of either 16, 24 or 32 bytes.</p>
<p><strong>Encryption key</strong></p>
<p>A good encryption key is a binary blob that's generated from a reliable random number generator. The following example would be recommended (&gt;= 5.3):</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$key_size </span><span class="pun">=</span><span class="pln"> </span><span class="lit">32</span><span class="pun">;</span><span class="pln"> </span><span class="com">// 256 bits</span><span class="pln">
$encryption_key </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="pln">$key_size</span><span class="pun">,</span><span class="pln"> $strong</span><span class="pun">);</span><span class="pln">
</span><span class="com">// $strong will be true if the key is crypto safe</span></code></pre>
<p>This can be done once or multiple times (if you wish to create a chain of encryption keys). Keep these as private as possible.</p>
<p><strong>IV</strong></p>
<p>The initialisation vector adds randomness to the encryption and required for CBC mode. These values should be ideally be used only once (technically once per encryption key), so an update to any part of a row should regenerate it.</p>
<p>A function is provided to help you generate the IV:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$iv_size </span><span class="pun">=</span><span class="pln"> </span><span class="lit">16</span><span class="pun">;</span><span class="pln"> </span><span class="com">// 128 bits</span><span class="pln">
$iv </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="pln">$iv_size</span><span class="pun">,</span><span class="pln"> $strong</span><span class="pun">);</span></code></pre>
<h3>Example</h3>
<p>Let's encrypt the name field, using the earlier <code>$encryption_key</code> and <code>$iv</code>; to do this, we have to pad our data to the block size:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> pkcs7_pad</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> $size</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    $length </span><span class="pun">=</span><span class="pln"> $size </span><span class="pun">-</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> $size</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> $data </span><span class="pun">.</span><span class="pln"> str_repeat</span><span class="pun">(</span><span class="pln">chr</span><span class="pun">(</span><span class="pln">$length</span><span class="pun">),</span><span class="pln"> $length</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

$name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Jack'</span><span class="pun">;</span><span class="pln">
$enc_name </span><span class="pun">=</span><span class="pln"> openssl_encrypt</span><span class="pun">(</span><span class="pln">
    pkcs7_pad</span><span class="pun">(</span><span class="pln">$name</span><span class="pun">,</span><span class="pln"> </span><span class="lit">16</span><span class="pun">),</span><span class="pln"> </span><span class="com">// padded data</span><span class="pln">
    </span><span class="str">'AES-256-CBC'</span><span class="pun">,</span><span class="pln">        </span><span class="com">// cipher and mode</span><span class="pln">
    $encryption_key</span><span class="pun">,</span><span class="pln">      </span><span class="com">// secret key</span><span class="pln">
    </span><span class="lit">0</span><span class="pun">,</span><span class="pln">                    </span><span class="com">// options (not used)</span><span class="pln">
    $iv                   </span><span class="com">// initialisation vector</span><span class="pln">
</span><span class="pun">);</span></code></pre>
<h3>Storage requirements</h3>
<p>The encrypted output, like the IV, is binary; storing these values in a database can be accomplished by using designated column types such as <code>BINARY</code> or <code>VARBINARY</code>.</p>
<p>The output value, like the IV, is binary; to store those values in MySQL, consider using <a href="http://dev.mysql.com/doc/refman/5.0/en/binary-varbinary.html"><code>BINARY</code> or <code>VARBINARY</code></a> columns. If this is not an option, you can also convert the binary data into a textual representation using <a href="http://php.net/base64_encode"><code>base64_encode()</code></a> or <a href="http://php.net/bin2hex"><code>bin2hex()</code></a>, doing so requires between 33% to 100% more storage space.</p>
<h1>Decryption</h1>
<p>Decryption of the stored values is similar:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">function</span><span class="pln"> pkcs7_unpad</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">ord</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">[</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">$data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

$row </span><span class="pun">=</span><span class="pln"> $result</span><span class="pun">-&gt;</span><span class="pln">fetch</span><span class="pun">(</span><span class="pln">PDO</span><span class="pun">::</span><span class="pln">FETCH_ASSOC</span><span class="pun">);</span><span class="pln"> </span><span class="com">// read from database result</span><span class="pln">
</span><span class="com">// $enc_name = base64_decode($row['Name']);</span><span class="pln">
</span><span class="com">// $enc_name = hex2bin($row['Name']);</span><span class="pln">
$enc_name </span><span class="pun">=</span><span class="pln"> $row</span><span class="pun">[</span><span class="str">'Name'</span><span class="pun">];</span><span class="pln">
</span><span class="com">// $iv = base64_decode($row['IV']);</span><span class="pln">
</span><span class="com">// $iv = hex2bin($row['IV']);</span><span class="pln">
$iv </span><span class="pun">=</span><span class="pln"> $row</span><span class="pun">[</span><span class="str">'IV'</span><span class="pun">];</span><span class="pln">

$name </span><span class="pun">=</span><span class="pln"> pkcs7_unpad</span><span class="pun">(</span><span class="pln">openssl_decrypt</span><span class="pun">(</span><span class="pln">
    $enc_name</span><span class="pun">,</span><span class="pln">
    </span><span class="str">'AES-256-CBC'</span><span class="pun">,</span><span class="pln">
    $encryption_key</span><span class="pun">,</span><span class="pln">
    </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
    $iv
</span><span class="pun">));</span></code></pre>
<h1>Authenticated encryption</h1>
<p>You can further improve the integrity of the generated cipher text by appending a signature that's generated from a secret key (different from the encryption key) and the cipher text. Before the cipher text is decrypted, the signature is first verified (preferably with a constant-time comparison method).</p>
<h3>Example</h3>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">// generate once, keep safe</span><span class="pln">
$auth_key </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="lit">32</span><span class="pun">,</span><span class="pln"> $strong</span><span class="pun">);</span><span class="pln">

</span><span class="com">// authentication</span><span class="pln">
$auth </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $enc_name</span><span class="pun">,</span><span class="pln"> $auth_key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
$auth_enc_name </span><span class="pun">=</span><span class="pln"> $auth </span><span class="pun">.</span><span class="pln"> $enc_name</span><span class="pun">;</span><span class="pln">

</span><span class="com">// verification</span><span class="pln">
$auth </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$auth_enc_name</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">32</span><span class="pun">);</span><span class="pln">
$enc_name </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">$auth_enc_name</span><span class="pun">,</span><span class="pln"> </span><span class="lit">32</span><span class="pun">);</span><span class="pln">
$actual_auth </span><span class="pun">=</span><span class="pln"> hash_hmac</span><span class="pun">(</span><span class="str">'sha256'</span><span class="pun">,</span><span class="pln"> $enc_name</span><span class="pun">,</span><span class="pln"> $auth_key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hash_equals</span><span class="pun">(</span><span class="pln">$auth</span><span class="pun">,</span><span class="pln"> $actual_auth</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// perform decryption</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>See also: <a href="http://php.net/hash_equals"><code>hash_equals()</code></a></p>
<h1>Hashing</h1>
<p>Storing a reversible password in your database must be avoided as much as possible; you only wish to verify the password rather than knowing its contents. If a user loses their password, it's better to allow them to reset it rather than sending them their original one (make sure that password reset can only be done for a limited time).</p>
<p>Applying a hash function is a one-way operation; afterwards it can be safely used for verification without revealing the original data; for passwords, a brute force method is a feasible approach to uncover it due to its relatively short length and poor password choices of many people.</p>
<p>Hashing algorithms such as MD5 or SHA1 were made to verify file contents against a known hash value. They're greatly optimized to make this verification as fast as possible while still being accurate. Given their relatively limited output space it was easy to build a database with known passwords and their respective hash outputs, the rainbow tables.</p>
<p>Adding a salt to the password before hashing it would render a rainbow table useless, but recent hardware advancements made brute force lookups a viable approach. That's why you need a hashing algorithm that's deliberately slow and simply impossible to optimize. It should also be able to increase the load for faster hardware without affecting the ability to verify existing password hashes to make it future proof.</p>
<p>Currently there are two popular choices available:</p>
<ol>
<li>PBKDF2 (Password Based Key Derivation Function v2)</li>
<li>bcrypt (aka Blowfish)</li>
</ol>
<p>This answer will use an example with bcrypt.</p>
<p><strong>Generation</strong></p>
<p>A password hash can be generated like this:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$password </span><span class="pun">=</span><span class="pln"> </span><span class="str">'my password'</span><span class="pun">;</span><span class="pln">
$random </span><span class="pun">=</span><span class="pln"> openssl_random_pseudo_bytes</span><span class="pun">(</span><span class="lit">18</span><span class="pun">);</span><span class="pln">
$salt </span><span class="pun">=</span><span class="pln"> sprintf</span><span class="pun">(</span><span class="str">'$2y$%02d$%s'</span><span class="pun">,</span><span class="pln">
    </span><span class="lit">13</span><span class="pun">,</span><span class="pln"> </span><span class="com">// 2^n cost factor</span><span class="pln">
    substr</span><span class="pun">(</span><span class="pln">strtr</span><span class="pun">(</span><span class="pln">base64_encode</span><span class="pun">(</span><span class="pln">$random</span><span class="pun">),</span><span class="pln"> </span><span class="str">'+'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'.'</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">22</span><span class="pun">)</span><span class="pln">
</span><span class="pun">);</span><span class="pln">

$hash </span><span class="pun">=</span><span class="pln"> crypt</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> $salt</span><span class="pun">);</span></code></pre>
<p>The salt is generated with <a href="http://php.net/openssl_random_pseudo_bytes"><code>openssl_random_pseudo_bytes()</code></a> to form a random blob of data which is then run through <code>base64_encode()</code> and <code>strtr()</code> to match the required alphabet of <code>[A-Za-z0-9/.]</code>.</p>
<p>The <a href="http://php.net/crypt"><code>crypt()</code></a> function performs the hashing based on the algorithm (<code>$2y$</code> for Blowfish), the cost factor (a factor of 13 takes roughly 0.40s on a 3GHz machine) and the salt of 22 characters.</p>
<p><strong>Validation</strong></p>
<p>Once you have fetched the row containing the user information, you validate the password in this manner:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$given_password </span><span class="pun">=</span><span class="pln"> $_POST</span><span class="pun">[</span><span class="str">'password'</span><span class="pun">];</span><span class="pln"> </span><span class="com">// the submitted password</span><span class="pln">
$db_hash </span><span class="pun">=</span><span class="pln"> $row</span><span class="pun">[</span><span class="str">'Password'</span><span class="pun">];</span><span class="pln"> </span><span class="com">// field with the password hash</span><span class="pln">

$given_hash </span><span class="pun">=</span><span class="pln"> crypt</span><span class="pun">(</span><span class="pln">$given_password</span><span class="pun">,</span><span class="pln"> $db_hash</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isEqual</span><span class="pun">(</span><span class="pln">$given_hash</span><span class="pun">,</span><span class="pln"> $db_hash</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// user password verified</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// constant time string compare</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> isEqual</span><span class="pun">(</span><span class="pln">$str1</span><span class="pun">,</span><span class="pln"> $str2</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    $n1 </span><span class="pun">=</span><span class="pln"> strlen</span><span class="pun">(</span><span class="pln">$str1</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">$str2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> $n1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $diff </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> $i </span><span class="pun">!=</span><span class="pln"> $n1</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">$i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        $diff </span><span class="pun">|=</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">$str1</span><span class="pun">[</span><span class="pln">$i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">$str2</span><span class="pun">[</span><span class="pln">$i</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">!</span><span class="pln">$diff</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>To verify a password, you call <code>crypt()</code> again but you pass the previously calculated hash as the salt value. The return value yields the same hash if the given password matches the hash. To verify the hash, it's often recommended to use a constant-time comparison function to avoid timing attacks.</p>
<p><strong>Password hashing with PHP 5.5</strong></p>
<p>PHP 5.5 introduced the <a href="http://www.php.net/manual/en/ref.password.php">password hashing functions</a> that you can use to simplify the above method of hashing:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$hash </span><span class="pun">=</span><span class="pln"> password_hash</span><span class="pun">(</span><span class="pln">$password</span><span class="pun">,</span><span class="pln"> PASSWORD_BCRYPT</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="str">'cost'</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="lit">13</span><span class="pun">]);</span></code></pre>
<p>And verifying:</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">password_verify</span><span class="pun">(</span><span class="pln">$given_password</span><span class="pun">,</span><span class="pln"> $db_hash</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// password valid</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>See also: <a href="http://php.net/password_hash"><code>password_hash()</code></a>, <a href="http://php.net/password_verify"><code>password_verify()</code></a></p>
</div></text><author><a href="/users/1338292/ja%cd%a2ck">JaÍ¢ck</a></author><comments><comment><text><span class="comment-copy">This is great stuff! One of the best answers I seen on Stackoverflow.</span></text><author><a class="comment-user" href="/users/1856126/stenw" title="731 reputation">StenW</a></author></comment><comment><text><span class="comment-copy">What length should I use to store name, surname, email etc for safest bet? varbinary(???)</span></text><author><a class="comment-user" href="/users/1251684/bentcoder" title="4,771 reputation">BentCoder</a></author></comment><comment><text><span class="comment-copy">@MadMax That's entirely up to you; my answer covers the different encoding you could use to store the values, whether it be binary, hex or base64 and how much storage is required per character.</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,258 reputation">JaÍ¢ck</a></author></comment><comment><text><span class="comment-copy">I agree with @MaartenBodewes that your ciphertexts should be authenticated (e.g. HMAC) and verified in constant-time.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">@Scott For transport protocols I would use TLS, which is a good standard for transport encryption; for the in-place encryption scenario you could still use HMAC, but a) that's a separate concern (as mentioned earlier) and b) you wouldn't need constant-time verification.</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,258 reputation">JaÍ¢ck</a></author></comment><comment><text><span class="comment-copy">Sure, but it depends on how it's being used. If you publish an encryption library, you don't know how developers will implement it. That's why <a href="https://github.com/defuse/php-encryption" rel="nofollow noreferrer">github.com/defuse/php-encryption</a> provides authenticated symmetric-key encryption and doesn't let developers weaken it without editing its code.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">@Scott Very well, I've added an example of authenticated encryption; thanks for the push :)</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,258 reputation">JaÍ¢ck</a></author></comment><comment><text><span class="comment-copy">+1 for authenticated encryption. There's not enough information in the question to say that AE isn't necessary here. Certainly SQL traffic often goes over a network with unknown security properties, as does traffic from database to storage. Backups and replication too. What's the threat model? The question doesn't say, and it might be dangerous to make assumptions.</span></text><author><a class="comment-user" href="/users/94977/jason-orendorff" title="26,083 reputation">Jason Orendorff</a></author></comment><comment><text><span class="comment-copy">@JasonOrendorff I'm not exactly sure what point you're trying to make; it should be obvious that AE is supplementary.</span></text><author><a class="comment-user" href="/users/1338292/ja%cd%a2ck" title="128,258 reputation">JaÍ¢ck</a></author></comment><comment><text><span class="comment-copy">@JaÍ¢ck it might be prudent to <a href="https://news.ycombinator.com/item?id=9865276" rel="nofollow noreferrer">stress the importance of authenticated encryption</a>.</span></text><author><a class="comment-user" href="/users/2224584/scott-arciszewski" title="15,046 reputation">Scott Arciszewski</a></author></comment><comment><text><span class="comment-copy">How can you select specific rows in the database when an IV is used? Is this possible?</span></text><author><a class="comment-user" href="/users/3120665/steve-chang" title="152 reputation">Steve Chang</a></author></comment><comment><text><span class="comment-copy">Instead of hard-coding<code>$iv_size = 16;</code>, I would use: <code>$iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length("AES-25ââ6-CBC"))</code> in order to indicate the link between iv's size to use with the cipher used. You could also expand a bit on the need (or not) of <code>pkcs7_pad()</code>/<code>pkcs7_unpad()</code>, or just simplify the post by getting rid of them and use "aes-256-ctr". Great post @JaÍ¢ck</span></text><author><a class="comment-user" href="/users/201453/patrick-allaert" title="832 reputation">Patrick Allaert</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm think this has been answered before...but anyway, if you want to encrypt/decrypt data, you can't use SHA256</p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">//Key</span><span class="pln">
$key </span><span class="pun">=</span><span class="pln"> </span><span class="str">'SuperSecretKey'</span><span class="pun">;</span><span class="pln">

</span><span class="com">//To Encrypt:</span><span class="pln">
$encrypted </span><span class="pun">=</span><span class="pln"> mcrypt_encrypt</span><span class="pun">(</span><span class="pln">MCRYPT_RIJNDAEL_256</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> </span><span class="str">'I want to encrypt this'</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">);</span><span class="pln">

</span><span class="com">//To Decrypt:</span><span class="pln">
$decrypted </span><span class="pun">=</span><span class="pln"> mcrypt_decrypt</span><span class="pun">(</span><span class="pln">MCRYPT_RIJNDAEL_256</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $encrypted</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_ECB</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/1074110/romo">romo</a></author><comments><comment><text><span class="comment-copy">You should not use ECB either, for that matter.</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy">Keys should be random bytes, or you should use a secure key derivation function.</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy">MCRYPT_RIJNDAEL_256 is not a standardized function, you should use AES (MCRYPT_RIJNDAEL_128)</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<h2>Answer Background and Explanation</h2>
<p>To understand this question, you must first understand what SHA256 is.  SHA256 is a <strong>Cryptographic Hash Function</strong>.    A Cryptographic Hash Function is a one-way function, whose output is cryptographically secure.  This means it is easy to compute a hash (equivalent to encrypting data), but hard to get the original input using the hash (equivalent to decrypting the data).  Since using a Cryptographic hash function means decrypting is computationally infeasible, so therefore you cannot perform decryption with SHA256.  </p>
<p>What you want to use is a two-way function, but more specifically, a <strong>Block Cipher</strong>.  A function that allows for both encryption and decryption of data.  The functions <code>mcrypt_encrypt</code> and <code>mcrypt_decrypt</code> by default use the Blowfish algorithm.  PHP's use of mcrypt can be found in this <a href="http://www.php.net/manual/en/intro.mcrypt.php">manual</a>.  A list of <a href="http://www.php.net/manual/en/mcrypt.ciphers.php">cipher definitions</a> to select the cipher mcrypt uses also exists.  A wiki on Blowfish can be found at <a href="http://en.wikipedia.org/wiki/Blowfish_%28cipher%29">Wikipedia</a>.  A block cipher encrypts the input in blocks of known size and position with a known key, so that the data can later be decrypted using the key.  This is what SHA256 cannot provide you.</p>
<h2>Code</h2>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="pln">$key </span><span class="pun">=</span><span class="pln"> </span><span class="str">'ThisIsTheCipherKey'</span><span class="pun">;</span><span class="pln">

$ciphertext </span><span class="pun">=</span><span class="pln"> mcrypt_encrypt</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> </span><span class="str">'This is plaintext.'</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_CFB</span><span class="pun">);</span><span class="pln">

$plaintext </span><span class="pun">=</span><span class="pln"> mcrypt_decrypt</span><span class="pun">(</span><span class="pln">MCRYPT_BLOWFISH</span><span class="pun">,</span><span class="pln"> $key</span><span class="pun">,</span><span class="pln"> $encrypted</span><span class="pun">,</span><span class="pln"> MCRYPT_MODE_CFB</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/863553/cytinus">cytinus</a></author><comments><comment><text><span class="comment-copy">You should not use ECB either, for that matter.</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy">Keys should be random bytes, or you should use a secure key derivation function.</span></text><author><a class="comment-user" href="/users/589259/maarten-bodewes" title="47,642 reputation">Maarten Bodewes</a></author></comment><comment><text><span class="comment-copy"><b>Never ever</b> use the ECB mode. It is insecure and most of the time doesn't really help in actually encrypting the data (rather than just encoding it). See the <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29" rel="nofollow noreferrer">excellent Wikipedia article on the subject</a> for more information.</span></text><author><a class="comment-user" href="/users/421705/holger-just" title="29,167 reputation">Holger Just</a></author></comment><comment><text><span class="comment-copy">It is best not to use mcrypt, it is abandonware, has not been updated in years and does not support standard PKCS#7 (nÃ©e PKCS#5) padding, only non-standard null padding that can't even be used with binary data. mcrypt had many outstanding <a href="https://sourceforge.net/p/mcrypt/bugs/" rel="nofollow noreferrer">bugs</a> dating back to 2003.. Instead consider using <a href="https://github.com/defuse/php-encryption" rel="nofollow noreferrer">defuse</a>, it is being maintained and is correct.</span></text><author><a class="comment-user" href="/users/451475/zaph" title="83,978 reputation">zaph</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Here is an example using openssl_encrypt </p>
<pre class="lang-php prettyprint prettyprinted" style=""><code><span class="com">//Encryption:</span><span class="pln">
$textToEncrypt </span><span class="pun">=</span><span class="pln"> </span><span class="str">"My Text to Encrypt"</span><span class="pun">;</span><span class="pln">
$encryptionMethod </span><span class="pun">=</span><span class="pln"> </span><span class="str">"AES-256-CBC"</span><span class="pun">;</span><span class="pln">
$secretHash </span><span class="pun">=</span><span class="pln"> </span><span class="str">"encryptionhash"</span><span class="pun">;</span><span class="pln">
$iv </span><span class="pun">=</span><span class="pln"> mcrypt_create_iv</span><span class="pun">(</span><span class="lit">16</span><span class="pun">,</span><span class="pln"> MCRYPT_RAND</span><span class="pun">);</span><span class="pln">
$encryptedText </span><span class="pun">=</span><span class="pln"> openssl_encrypt</span><span class="pun">(</span><span class="pln">$textToEncrypt</span><span class="pun">,</span><span class="pln">$encryptionMethod</span><span class="pun">,</span><span class="pln">$secretHash</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">

</span><span class="com">//Decryption:</span><span class="pln">
$decryptedText </span><span class="pun">=</span><span class="pln"> openssl_decrypt</span><span class="pun">(</span><span class="pln">$encryptedText</span><span class="pun">,</span><span class="pln"> $encryptionMethod</span><span class="pun">,</span><span class="pln"> $secretHash</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> $iv</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"My Decrypted Text: "</span><span class="pun">.</span><span class="pln"> $decryptedText</span><span class="pun">;</span></code></pre>
</div></text><author><a href="/users/2310819/vivek">Vivek</a></author><comments><comment><text><span class="comment-copy">Instead of <code>mcrypt_create_iv()</code>, I would use: <code>openssl_random_pseudo_bytes(openssl_cipher_iv_length($encrypââtionMethod))</code>, this way the methodology works for any value of $encryptionMethod and would use openssl extension only.</span></text><author><a class="comment-user" href="/users/201453/patrick-allaert" title="832 reputation">Patrick Allaert</a></author></comment></comments></answer></answers></post>