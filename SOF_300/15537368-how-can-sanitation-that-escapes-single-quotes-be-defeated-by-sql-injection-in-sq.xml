<?xml version="1.0" encoding="utf-8"?>
<post><title>security - How can sanitation that escapes single quotes be defeated by SQL injection in SQL Server? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>To start this off, I am well aware that parameterized queries are the best option, but I am asking what makes the strategy I present below vulnerable. People insist the below solution doesn't work, so I am look for an example of why it wouldn't.</p>
<p>If dynamic SQL is built in code using the following escaping before being sent to a SQL Server, what kind of injection can defeat this?</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">string userInput</span><span class="pun">=</span><span class="pln"> </span><span class="str">"N'"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> userInput</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"'"</span></code></pre>
<p>A similar question was answered <a href="http://stackoverflow.com/questions/139199/can-i-protect-against-sql-injection-by-escaping-single-quote-and-surrounding-use">here</a>, but I don't believe any of the answers are applicable here.</p>
<p>Escaping the single quote with a "\" isn't possible in SQL Server.</p>
<p>I believe <strong>SQL Smuggling</strong> with Unicode (outlined <a href="https://www.owasp.org/images/d/d4/OWASP_IL_2007_SQL_Smuggling.pdf">here</a>) would be thwarted by the fact that the string being produced is marked as Unicode by the N preceding the single quote. As far as I know, there are no other character sets that SQL Server would automatically translate to a single quote. Without an unescaped single quote, I don't believe injection is possible.</p>
<p>I don't believe <strong>String Truncation</strong> is a viable vector either. SQL Server certainly won't be doing the truncating since the max size for an <code>nvarchar</code> is 2GB <a href="http://msdn.microsoft.com/en-us/library/ms186939.aspx">according to microsoft</a>. A 2 GB string is unfeasible in most situations, and impossible in mine.</p>
<p><strong>Second Order Injection</strong> could be possible, but is it possible if:</p>
<ol>
<li>All data going into the database is sanitized using the above method</li>
<li>Values from the database are never appended into dynamic SQL (why would you ever do that anyways, when you can just reference the table value in the static part of any dynamic SQL string?).</li>
</ol>
<p>I'm not suggesting that this is better than or an alternative to using parameterized queries, but I want to know how what I outlined is vulnerable. Any ideas?</p>
</div></text><author><a href="/users/130352/chris-j">Chris J</a></author><comments><comment><text><span class="comment-copy">No. You're still susceptible to attacks in the form: <code>"SELECT * FROM MyTable WHERE Field = " + userInput</code> when <code>userInput</code> is <code>0; DROP TABLE OhNo;</code>.</span></text><author><a class="comment-user" href="/users/719034/yuck" title="31,541 reputation">Yuck</a></author></comment><comment><text><span class="comment-copy">This makes no sense. In the above example, your user input would be sanitized to N'0; DROP TABLE OhNo;' before ever being executed.</span></text><author><a class="comment-user owner" href="/users/577829/gbleaney" title="778 reputation">GBleaney</a></author></comment><comment><text><span class="comment-copy">This if for sanitizing string variables only. Things like "int" don't need to be sanitized if they are cast as an int before being added to the query. Regardless, I'm only asking about sanitizing strings right now. Also, there is no need rude here. If you can think of a way that this isn't secure, I'd love to know.</span></text><author><a class="comment-user owner" href="/users/577829/gbleaney" title="778 reputation">GBleaney</a></author></comment><comment><text><span class="comment-copy">Ok, how about userinput = "test'; drop table ohno; print '"</span></text><author><a class="comment-user" href="/users/2066467/kenneth-fisher" title="2,736 reputation">Kenneth Fisher</a></author></comment><comment><text><span class="comment-copy">The single quores are turned into two single quotes (that's how you escape single quotes), renderign them harmless. Your user input then becomes: N'test''; drop table ohno; print ''' which is harmless</span></text><author><a class="comment-user owner" href="/users/577829/gbleaney" title="778 reputation">GBleaney</a></author></comment><comment><text><span class="comment-copy">Not an interesting question as there are zero advantages of your approach vs using a parameterized query.  There are several disadvantages which include excessive compilations and plan cache bloat.</span></text><author><a class="comment-user" href="/users/1874012/straycatdba" title="1,652 reputation">StrayCatDBA</a></author></comment><comment><text><span class="comment-copy">Also, if the column in the table isn't unicode, you'll prevent the use of indexes on those columns due to implicit casting.</span></text><author><a class="comment-user" href="/users/1874012/straycatdba" title="1,652 reputation">StrayCatDBA</a></author></comment><comment><text><span class="comment-copy">There is absolutely no scenario where it you would be able to do full input sanitation, and not be able to write parametrized query. If you know enough about database schema to be able to sanitize input yourself, then you know enough to write parametrized query. Obvious choice is parametrized query because resulting code will be cleaner, less prone to errors and accidental security issues when code maintainer isn't careful.</span></text><author><a class="comment-user" href="/users/187955/nikola-radosavljevi%c4%87" title="5,764 reputation">Nikola Radosavljević</a></author></comment><comment><text><span class="comment-copy">Would this not be a good choice when dynamic SQL is unavoidable?</span></text><author><a class="comment-user owner" href="/users/577829/gbleaney" title="778 reputation">GBleaney</a></author></comment><comment><text><span class="comment-copy">There are reasons when literal parsing is required.  Imagine you are processing a list of strings of unknown length and need to generate a SQL statement to do it: SELECT x from y where text in ('A', 'B', 'C', ...) The only way to write this statement dynamically and efficiently is with literals.  GBleaney's method is safe, it looks like he is writing C# code which is unicode, the .Net driver is unicode and there is nothing wrong with it.</span></text><author><a class="comment-user" href="/users/1292941/rob" title="121 reputation">Rob</a></author></comment><comment><text><span class="comment-copy">@Rob I can still create the sql with the required ? for the parameters and provide the parameters separately. Especially since I have to do some parsing anyway since the length of an "in" clause is limited in many RDBMS.</span></text><author><a class="comment-user" href="/users/66686/jens-schauder" title="35,477 reputation">Jens Schauder</a></author></comment><comment><text><span class="comment-copy">Yes you can create a dynamic query string and place parameter markers instead of literals.</span></text><author><a class="comment-user" href="/users/1292941/rob" title="121 reputation">Rob</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>There are a few cases where this escape function will fail.   The most obvious is when a single quote isn't used:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">string </span><span class="kwd">table</span><span class="pun">=</span><span class="pln"> </span><span class="str">"\""</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">table</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"\""</span><span class="pln">
string var</span><span class="pun">=</span><span class="pln"> </span><span class="str">"`"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> var</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"`"</span><span class="pln">
string </span><span class="kwd">index</span><span class="pun">=</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">index</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">" "</span><span class="pln">
string query </span><span class="pun">=</span><span class="pln"> </span><span class="str">"select * from `"</span><span class="pun">+</span><span class="kwd">table</span><span class="pun">+</span><span class="str">"` where name=\""</span><span class="pun">+</span><span class="pln">var</span><span class="pun">+</span><span class="str">"\" or id="</span><span class="pun">+</span><span class="kwd">index</span></code></pre>
<p>In this case,  you can "break out" using a double-quote,  a back-tick.  In the last case there is nothing to "break out" of,  so you can just write <code>1 union select password from users--</code> or whatever sql payload the attacker desires. </p>
<p>The next condition where this escape function will fail is if a sub-string is taken after the string is escaped (and <strong>yes</strong> I have found vulnerabilities like this in the wild):</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">string userPassword</span><span class="pun">=</span><span class="pln"> userPassword</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln">
string userName</span><span class="pun">=</span><span class="pln"> userInput</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"''"</span><span class="pun">)</span><span class="pln">
userName </span><span class="pun">=</span><span class="pln"> substr</span><span class="pun">(</span><span class="pln">userName</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="lit">10</span><span class="pun">)</span><span class="pln">
string query </span><span class="pun">=</span><span class="pln"> </span><span class="str">"select * from users where name='"</span><span class="pun">+</span><span class="pln">userName</span><span class="pun">+</span><span class="str">"' and password='"</span><span class="pun">+</span><span class="pln">userPassword</span><span class="pun">+</span><span class="str">"'"</span><span class="pun">;</span></code></pre>
<p>In this case a username of <code>abcdefgji'</code> will be turned into <code>abcdefgji''</code> by the escape function and then turned back into <code>abcdefgji'</code> by taking the sub-string.  This can be exploited by setting the password value to any sql statement,  in this case <code>or 1=1--</code> would be interpreted as sql and the username would be interpreted as <code>abcdefgji'' and password=</code>.  The resulting query is as follows:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="kwd">select</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> users </span><span class="kwd">where</span><span class="pln"> name</span><span class="pun">=</span><span class="str">'abcdefgji'' and password='</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> </span><span class="lit">1</span><span class="pun">=</span><span class="lit">1</span><span class="com">-- </span></code></pre>
<p>T-SQL and other advanced sql injection techniques where already mentioned. <a href="http://www.thomascookegypt.com/holidays/pdfpkgs/931.pdf">Advanced SQL Injection In SQL Server Applications</a> is a great paper and you should read it if you haven't already. </p>
<p>The final issue is unicode attacks.  This class of vulnerabilities arises because the escape function is not aware of mulit-byte encoding, and this can be <a href="http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string">used by an attacker to "consume" the escape character</a>.  Prepending an "N" to the string will not help, as this doesn't affect the value of multi-byte chars later in the string.   However,  this type of attack is very uncommon because the database must be configured to accept GBK unicode strings (and I'm not sure that MS-SQL can do this).</p>
<p>Second-Order code injection is still possible,  this attack pattern is created by trusting attacker-controlled data sources.  Escaping is used to represent control characters as their character literal.  If the developer forgets to escape a value obtained from a <code>select</code> and then uses this value in another query then <strong>bam</strong> the attacker will have a character literal single quote at their disposal.</p>
<p><strong>Test everything, trust nothing.</strong> </p>
</div></text><author><a href="/users/183528/rook">rook</a></author><comments><comment><text><span class="comment-copy">While I agree playing with security instead parametrizing query is bad, if you read his question carefully he noted several steps he would take to "ensure" safety. 1) he's making sure an numeric value is actually a numeric value so id injection in your example would fail 2) he's asking about SQL Server which only accepts <code>'</code> as string delimiter. Using tick or double quote wouldn't help the attacker</span></text><author><a class="comment-user" href="/users/187955/nikola-radosavljevi%c4%87" title="5,764 reputation">Nikola Radosavljević</a></author></comment><comment><text><span class="comment-copy">@Nikola Radosavljević yes,  but back-tics and lack of quotes can still be a problem depending how he implanted this check.   Clearly this post is from the standpoint of an attacker not a defender.  The defense is well known and uninteresting.</span></text><author><a class="comment-user" href="/users/183528/rook" title="43,765 reputation">rook</a></author></comment><comment><text><span class="comment-copy">The code in the question is not vulnerable to attack. This is a good answer as a general guide to escaping string literals and it is both correct and interesting; but the scenarios listed would not be able to compromise the line of code in the original question.  Regarding 2nd hand attacks, it could happen whether the text was originally inserted with a parameter or as a literal if it contains a quote character.</span></text><author><a class="comment-user" href="/users/1292941/rob" title="121 reputation">Rob</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>With some additional stipulations, your approach above is not vulnerable to SQL injection.  The main vector of attack to consider is SQL Smuggling.  SQL Smuggling occurs when similiar unicode characters are translated in an unexpected fashion (e.g. ` changing to ' ). There are several locations where an application stack could be vulnerable to SQL Smuggling.  </p>
<ul>
<li><p><strong>Does the Programming language handle unicode strings appropriately?</strong>  If the language isn't unicode aware, it may mis-identify a byte in a unicode character as a single quote and escape it.</p></li>
<li><p><strong>Does the client database library (e.g. ODBC, etc) handle unicode strings appropriately?</strong>  System.Data.SqlClient in the .Net framework does, but how about old libraries from the windows 95 era?  Third party ODBC libraries actually do exist.  What happens if the ODBC driver doesn't support unicode in the query string?</p></li>
<li><p><strong>Does the DB handle the input correctly?</strong>  Modern versions of SQL are immune assuming you're using N'', but what about SQL 6.5? SQL 7.0?  I'm not aware of any particular vulnerabilities, however this wasn't on the radar for developers in the 1990's.  </p></li>
<li><p><strong>Buffer overflows?</strong> Another concern is that the quoted string is longer than the original string.  In which version of Sql Server was the 2GB limit for input introduced?  Before that what was the limit?  On older versions of SQL, what happened when a query exceeded the limit?  Do any limits exist on the length of a query from the standpoint of the network library? Or on the length of the string in the programming language?</p></li>
<li><p><strong>Are there any language settings that affect the comparison used in the Replace() function?</strong>  .Net always does a binary comparison for the Replace() function.  Will that always be the case?  What happens if a future version of .NET supports overriding that behavior at the app.config level?  What if we used a regexp instead of Replace() to insert a single quote? Does the computer's locale settings affect this comparison? If a change in behavior did occur, it might not be vulnerable to sql injection, however, it may have inadvertently edited the string by changing a uni-code character that looked like a single quote into a single quote before it ever reached the DB.</p></li>
</ul>
<p>So, assuming you're using the System.String.Replace() function in C# on the current version of .Net with the built-in SqlClient library against a current (2005-2012) version of SQL server, then your approach is not vulnerable.  As you start changing things, then no promises can be made. The parameterized query approach is the correct approach for efficiency, for performance, and (in some cases) for security.</p>
<p><strong>WARNING</strong> The above comments are not an endorsement of this technique.  There are several other very good  reasons why this the wrong approach to generating SQL.  However, detailing them is outside the scope for this question.</p>
<p><em><strong>DO NOT USE THIS TECHNIQUE FOR NEW DEVELOPMENT.</strong></em></p>
<p><em><strong>DO NOT USE THIS TECHNIQUE FOR NEW DEVELOPMENT.</strong></em></p>
<p><em><strong>DO NOT USE THIS TECHNIQUE FOR NEW DEVELOPMENT.</strong></em></p>
</div></text><author><a href="/users/1874012/straycatdba">StrayCatDBA</a></author><comments><comment><text><span class="comment-copy">If not this technique, then what should I use for <code>CREATE LOGIN</code> in new development?</span></text><author><a class="comment-user" href="/users/429091/binki" title="1,677 reputation">binki</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><a href="http://www.sommarskog.se/dynamic_sql.html" rel="nofollow">Using query parameters</a> is better, easier, and faster than escaping quotes.</p>
<hr/>
<p>Re your comment, I see that you acknowledged parameterization, but it deserves emphasis.  Why would you want to use escaping when you could parameterize?  </p>
<p>In <a href="http://www.thomascookegypt.com/holidays/pdfpkgs/931.pdf" rel="nofollow">Advanced SQL Injection In SQL Server Applications</a>, search for the word "replace" in the text, and from that point on read some examples where developers inadvertently allowed SQL injection attacks even after escaping user input.</p>
<hr/>
<p>There is an edge case where escaping quotes with <code>\</code> results in a vulnerability, because the <code>\</code> becomes half of a valid multi-byte character in some character sets.  But this is not applicable to your case since <code>\</code> isn't the escaping character.</p>
<p>As others have pointed out, you may also be adding dynamic content to your SQL for something other than a string literal or date literal.  Table or column identifiers are delimited by <code>"</code> in SQL, or <code>[</code> <code>]</code> in Microsoft/Sybase.  SQL keywords of course don't have any delimiters.  For these cases, I recommend <em>whitelisting</em> the values to interpolate.</p>
<p>Bottom line is that escaping <em>is</em> an effective defense, if you can ensure that you do it consistently.  That's the risk:  that one of the team of developers on your application could omit a step and do some string interpolation unsafely.</p>
<p>Of course, the same is true of other methods, like parameterization.  They're only effective if you do them consistently.  But I find it's easier to quicker to use parameters, than to figure out the right type of escaping.  And developers are more likely to use a method that is convenient and doesn't slow them down.</p>
</div></text><author><a href="/users/20860/bill-karwin">Bill Karwin</a></author><comments><comment><text><span class="comment-copy">As I state in the first line of my post, I am well aware of this. I am just asking if there is some specific reason that what I outlined is not safe.</span></text><author><a class="comment-user owner" href="/users/577829/gbleaney" title="778 reputation">GBleaney</a></author></comment><comment><text><span class="comment-copy">That is a great resource, but the possible issues suggested in there are not really an issue here. Firstly, constructing quotes using the "char(0x63)" method is useless, because that statement will be interpreted as a string and not be executed. As for the second order SQL injection, I already addressed that in the original post.</span></text><author><a class="comment-user owner" href="/users/577829/gbleaney" title="778 reputation">GBleaney</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>SQL injection occur if user supplied inputs are interpreted as commands. Here command means anything that is not interpreted as a recognized <a href="http://msdn.microsoft.com/en-us/library/ms187752.aspx" rel="nofollow">data type</a> literal.</p>
<p>Now if you’re using the user’s input only in data literals, specifically only in string literals, the user input would only be interpreted as something different than string data if it would be able to leave the string literal context. For character string or Unicode string literals, it’s the single quotation mark that encloses the literal data while embedded single quotation mark need to be represented with two single quotation marks.</p>
<p>So to leave a string literal context, one would need to supply a single single quotation mark (sic) as two single quotation marks are interpreted as string literal data and not as the string literal end delimiter.</p>
<p>So if you’re replacing any single quotation mark in the user supplied data by two single quotation marks, it will be impossible for the user to leave the string literal context.</p>
</div></text><author><a href="/users/53114/gumbo">Gumbo</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>SQL Injection can occur via unicode.  If the web app has a URL like this:</p>
<p><a href="http://mywebapp/widgets/?Code=ABC" rel="nofollow">http://mywebapp/widgets/?Code=ABC</a></p>
<p>which generates SQL like 
select * from widgets where Code = 'ABC'</p>
<p>but a hacker enters this:</p>
<p><a href="http://mywebapp/widgets/?Code=ABC%CA%BC;drop" rel="nofollow">http://mywebapp/widgets/?Code=ABC%CA%BC;drop</a> table widgets--</p>
<p>the SQL will look like 
select * from widgets where Code = 'ABC’;drop table widgets--'</p>
<p>and SQL Server will run two SQL Statements.  One to do the select and one to do the drop.
Your code probably converts the url-encoded %CA%BC into unicode U02BC which is a "Modifier letter apostrophe".  The Replace function in .Net will NOT treat that as a single quote.  However Microsoft SQL Server treats it like a single quote.  Here is an example that will probably allow SQL Injection:</p>
<pre class="lang-sql prettyprint prettyprinted" style=""><code><span class="pln">string badValue </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((</span><span class="pln">char</span><span class="pun">)</span><span class="lit">0x02BC</span><span class="pun">).</span><span class="pln">ToString</span><span class="pun">();</span><span class="pln">
badValue </span><span class="pun">=</span><span class="pln"> badValue </span><span class="pun">+</span><span class="pln"> </span><span class="str">";delete from widgets--"</span><span class="pun">;</span><span class="pln">
string sql </span><span class="pun">=</span><span class="pln"> </span><span class="str">"SELECT * FROM WIDGETS WHERE ID="</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> badValue</span><span class="pun">.</span><span class="pln">Replace</span><span class="pun">(</span><span class="str">"'"</span><span class="pun">,</span><span class="str">"''"</span><span class="pun">);</span><span class="pln">
TestTheSQL</span><span class="pun">(</span><span class="pln">sql</span><span class="pun">);</span></code></pre>
</div></text><author><a href="/users/37749/rob-kraft">Rob Kraft</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There is probably no 100% safe way if you are doing string concatenation. What you can do is try to check data type for each parameter and if all parameters pass such validation then go ahead with execution. For example, if your parameter should be type int and you’re getting something that can’t be converted to int then just reject it.</p>
<p>This doesn’t work though if you’re accepting nvarchar parameters.</p>
<p>As others already pointed out. Safest way is to use parameterized query.</p>
</div></text><author><a href="/users/2160463/george-wesley">George Wesley</a></author><comments/></answer></answers></post>