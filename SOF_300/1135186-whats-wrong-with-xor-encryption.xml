<?xml version="1.0" encoding="utf-8"?>
<post><title>security - What's wrong with XOR encryption? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I wrote a short C++ program to do XOR encryption on a file, which I may use for some personal files (if it gets cracked it's no big deal - I'm just protecting against casual viewers). Basically, I take an ASCII password and repeatedly XOR the password with the data in the file.</p>
<p>Now I'm curious, though: if someone wanted to crack this, how would they go about it? Would it take a long time? Does it depend on the length of the password (i.e., what's the big-O)?</p>
</div></text><author><a href="/users/131926/steven-sudit">Steven Sudit</a></author><comments><comment><text><span class="comment-copy">Or you could just break down and use something like TrueCrypt...</span></text><author><a class="comment-user" href="/users/131926/steven-sudit" title="16,297 reputation">Steven Sudit</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The problem with XOR encryption is that for long runs of the same characters, it is very easy to see the password. Such long runs are most commonly spaces in text files. Say your password is 8 chars, and the text file has 16 spaces in some line (for example, in the middle of ASCII-graphics table). If you just XOR that with your password, you'll see that output will have repeating sequences of characters. The attacker would just look for any such, try to guess the character in the original file (space would be the first candidate to try), and derive the length of the password from length of repeating groups.</p>
<p>Binary files can be even worse as they often contain repeating sequences of <code>0x00</code> bytes. Obviously, XORing with those is no-op, so your password will be visible in plain text in the output! An example of a very common binary format that has long sequences of nulls is <code>.doc</code>.</p>
</div></text><author><a href="/users/111335/pavel-minaev">Pavel Minaev</a></author><comments><comment><text><span class="comment-copy">Note that it is nearly trivial to XOR a whole file with a space character, at which point any sensible strings leap out as a likely password. For a binary file XORed with an ASCII string, any strings in the result <i>are</i> the password. The strings command at a shell prompt will find them.</span></text><author><a class="comment-user" href="/users/68204/rberteig" title="30,255 reputation">RBerteig</a></author></comment><comment><text><span class="comment-copy">FWIW you should be clear that you're talking about an XOR scheme when the "key" is less than the plaintext. If the key is the same size as the plaintext, and "truly" random (at least from the POV of the attacker) it's a OTP; aka unbreakable.</span></text><author><a class="comment-user" href="/users/154152/noon-silk" title="41,472 reputation">Noon Silk</a></author></comment><comment><text><span class="comment-copy">Good explanation. But couldn't XOR be made more secure if the password is the same length as the plaintext?</span></text><author><a class="comment-user" href="/users/1079573/rvighne" title="6,821 reputation">rvighne</a></author></comment><comment><text><span class="comment-copy">See comment above. Yes, if you have a one-time pad (same length, and crypto-quality random), then XOR is perfectly fine.</span></text><author><a class="comment-user" href="/users/111335/pavel-minaev" title="77,060 reputation">Pavel Minaev</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I concur with <a href="http://stackoverflow.com/users/111335/pavel-minaev">Pavel Minaev's</a> <a href="http://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption/1135197#1135197">explanation</a> of XOR's weaknesses. For those who are interested, here's a basic overview of the standard algorithm used to break the trivial XOR encryption in a few minutes:</p>
<ol>
<li><p>Determine how long the key is. <em>This
is done by XORing the encrypted data
with itself shifted various numbers
of places, and examining how many
bytes are the same.</em></p></li>
<li><p>If the bytes that are equal are
greater than a certain percentage
(6% accoridng to <strong>Bruce Schneier's
Applied Cryptography second
edition</strong>), then you have shifted the
data by a multiple of the keylength.
<em>By finding the smallest amount of
shifting that results in a large
amount of equal bytes, you find the
keylength.</em></p></li>
<li><p>Shift the cipher text by the
keylength, and XOR against itself.
<em>This removes the key and leaves you
with the plaintext XORed with the
plaintext shifted the length of the
key.</em> There should be enough
plaintext to determine the message
content.</p></li>
</ol>
<p>Read more at <a href="http://www.kuro5hin.org/?op=displaystory&amp;sid=2000/4/10/174741/423" rel="noreferrer">Encryption Matters, Part 1</a></p>
</div></text><author><a href="/users/22556/geneq">GeneQ</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>XOR encryption can be reasonably* strong if the following conditions are met:</p>
<ul>
<li>The plain text and the password are about the same length.</li>
<li>The password is not reused for encrypting more than one message.</li>
<li>The password cannot be guessed, IE by dictionary or other mathematical means.  In practice this means the bits are randomized.</li>
</ul>
<p>*Reasonably strong meaning it cannot be broken by trivial, mathematical means, as in GeneQ's post.  It is still no stronger than your password.</p>
</div></text><author><a href="/users/65696/singlenegationelimination">SingleNegationElimination</a></author><comments><comment><text><span class="comment-copy">This would be a one-time pad: <a href="http://en.wikipedia.org/wiki/One-time_pad" rel="nofollow noreferrer">en.wikipedia.org/wiki/One-time_pad</a></span></text><author><a class="comment-user" href="/users/49942/chrisw" title="43,288 reputation">ChrisW</a></author></comment><comment><text><span class="comment-copy">For a one-time pad, the key must be the same length as the plaintext.  When this is true, and the key is never reused, the one-time pad is absolutely secure.  If you're at all interested in the history of cryptography, I highly recommend The Codebreakers, by David Kahn: <a href="http://www.amazon.ca/Codebreakers-Comprehensive-History-Communication-Internet/dp/0684831309" rel="nofollow noreferrer">amazon.ca/â€¦</a></span></text><author><a class="comment-user" href="/users/52210/dale-hagglund" title="11,156 reputation">Dale Hagglund</a></author></comment><comment><text><span class="comment-copy"><i>"reasonably secure"</i> - One time pads cannot be broken by any means, ever (assuming the pad is completely random).  They are the <i>only</i> absolutely secure method of encryption.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment><comment><text><span class="comment-copy">One-time pad is not absolutely secure; it is only as secure as the method of sharing the pad between the encrypting end and the decrypting end.</span></text><author><a class="comment-user" href="/users/374746/russell-borogove" title="11,321 reputation">Russell Borogove</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>In addition to the points already mentioned, XOR encryption is completely vulnerable to known-plaintext attacks:</p>
<pre><code>cryptotext = plaintext XOR key
key = cryptotext XOR plaintext = plaintext XOR key XOR plaintext
</code></pre>
<p>where XORring the plaintexts cancel each other out, leaving just the key.</p>
<p>Not being vulnerable to known-plaintext attacks is a required but not sufficient property for any "secure" encryption method where the same key is used for more than one plaintext block (i.e. a one-time pad is still secure).</p>
</div></text><author><a href="/users/101361/laalto">laalto</a></author><comments><comment><text><span class="comment-copy">+1 it is worth mentioning that if even a small portion of the file is known (such as the headers used by most file-formats), the key can be easily obtained and the entire file decrypted.</span></text><author><a class="comment-user" href="/users/238419/blueraja-danny-pflughoeft" title="48,164 reputation">BlueRaja - Danny Pflughoeft</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Ways to make XOR work:</p>
<p>Use multiple keys with each key length equal to a prime number but never the same length for keys.
Use the original filename as another key but remember to create a mechanism for retrieving the filename.  Then create a new filename with an extension that will let you know it is an encrypted file.
The reason for using multiple keys of prime-number length is that they cause the resulting XOR key to be Key A TIMES Key B in length before it repeats.
Compress any repeating patterns out of the file before it is encrypted.
Generate a random number and XOR this number every X Offset (Remember, this number must also be recreatable.  You could use a RANDOM SEED of the Filelength.</p>
<p>After doing all this, if you use 5 keys of length 31 and greater, you would end up with a key length of approximately One Hundred Meg!</p>
<p>For keys, Filename being one (including the full path), STR(Filesize) + STR(Filedate) + STR(Date) + STR(Time), Random Generation Key, Your Full Name, A private key created one time.</p>
<p>A database to store the keys used for each file encrypted but keep the DAT file on a USB memory stick and NOT on the computer.</p>
<p>This should prevent the repeating pattern on files like Pictures and Music but movies, being four gigs in length or more, may still be vulnerable so may need a sixth key.</p>
<p>I personally have the dat file encrypted itself on the memory stick (Dat file for use with Microsoft Access).  I used a 3-Key method to encrypt it cause it will never be THAT large, being a directory of the files with the associated keys.</p>
<p>The reason for multiple keys rather than randomly generating one very large key is that primes times primes get large quick and I have some control over the creation of the key and you KNOW that there really is no such thing as a truely random number.  If I created one large random number, someone else can generate that same number.</p>
<p>Method to use the keys:  Encrypt the file with one key, then the next, then the next till all keys are used.  Each key is used over and over again till the entire file is encrypted with that key.</p>
<p>Because the keys are of different length, the overlap of the repeat is different for each key and so creates a derived key the length of Key one time Key two.  This logic repeats for the rest of the keys.  The reason for Prime numbers is that the repeating would occur on a division of the key length so you want the division to be 1 or the length of the key, hense, prime.</p>
<p>OK, granted, this is more than a simple XOR on the file but the concept is the same.</p>
<p>Lance</p>
</div></text><author><a href="/users/995185/lance-summers">Lance Summers</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>The target of a <a href="http://en.wikipedia.org/wiki/Cipher#Modern_ciphers" rel="nofollow noreferrer">good encryption</a> is to make it <strong>mathematically</strong> difficult to decrypt without the key.<br/>
This includes the desire to protect the key itself.<br/>
The <a href="http://en.wikipedia.org/wiki/XOR_cipher" rel="nofollow noreferrer">XOR technique</a> is basically a very simple cipher easily broken as described here.   </p>
<p>It is important to note that XOR is used within <a href="http://www.garykessler.net/library/crypto.html#algorithms" rel="nofollow noreferrer">cryptographic algorithms</a>.<br/>
These algorithms work on the introduction of mathematical difficulty around it.</p>
</div></text><author><a href="/users/70482/nik">nik</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Norton's Anti-virus used to use a technique of using the previous unencrypted letter as the key for next letter. That took me an extra half-hour to figure out, if I recall correctly.</p>
<p>If you just want to stop the casual viewer, it's good enough; I've used to hide strings within executables. It won't stand up 10 minutes to anyone who actually tries, however.</p>
<p>That all said, these days there are much better encryption methods readily available, so why not avail yourself of something better. If you are trying to just hide from the "casual" user, even something like gzip would do that job better.</p>
</div></text><author><a href="/users/25704/chris-arguin">Chris Arguin</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>I'm just protecting against casual viewers</p>
</blockquote>
<p>As long as this assumption holds, your encryption scheme is ok. People who think that Internet Explorer is "teh internets" are not capable of breaking it.</p>
<p>If not, just use some crypto library. There are already many good algorithms like Blowfish or AES for symmetric crypto.</p>
</div></text><author><a href="/users/1640962/john-smith">John Smith</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>I'm a <em>little</em> late in answering, but since no one has mentioned it yet:  this is called a VigenÃ¨re cipher.</p>
<p>Wikipedia gives a number of <a href="http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher#Cryptanalysis" rel="nofollow noreferrer">cryptanalysis attacks</a> to break it; even simpler, though, since most file-formats have a fixed header, would be to XOR the plaintext-header with the encrypted-header, giving you the key.</p>
</div></text><author><a href="/users/238419/blueraja-danny-pflughoeft">BlueRaja - Danny Pflughoeft</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>Another trick is to generate a md5() hash for your password. You can make it even more unique by using the length of the protected text as an offset or combining it with your password to provide better distribution for short phrases. And for long phrases, evolve your md5() hash by combining each 16-byte block with the previous hash -- making the entire XOR key "random" and non-repetitive.</p>
</div></text><author><a href="/users/460839/phil-mobley">Phil Mobley</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>RC4 is essentially XOR encryption! As are many stream ciphers - the key is the key (no pun intended!) you must NEVER reuse the key. EVER!</p>
</div></text><author><a href="/users/271424/michael-howard-msft">Michael Howard-MSFT</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>That "&gt;6%" GeneQ mentions is the index of coincidence for English telegraph text - 26 letters, with punctuation and numerals spelled out.  The actual value for long texts is 0.0665.</p>
<p>The &lt;4% is the index of coincidence for random text in a 26-character alphabet, which is 1/26, or 0.385.  </p>
<p>If you're using a different language or a different alphabet, the specific values will different.  If you're using the ASCII character set, Unicode, or binary bytes, the specific values will be very different.  But the difference between the IC of plaintext and random text will usually be present.  (Compressed binaries may have ICs very close to that of random, and any file encrypted with any modern computer cipher will have an IC that is exactly that of random text.)</p>
<p>Once you've XORed the text against itself, what you have left is equivalent to an autokey cipher.  Wikipedia has a good example of breaking such a cipher</p>
<p><a href="http://en.wikipedia.org/wiki/Autokey_cipher" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Autokey_cipher</a></p>
</div></text><author><a href="/users/243563/jeff-dege">Jeff Dege</a></author><comments/></answer></answers></post>