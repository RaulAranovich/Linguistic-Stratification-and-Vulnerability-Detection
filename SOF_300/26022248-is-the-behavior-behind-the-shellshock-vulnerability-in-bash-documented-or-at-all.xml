<?xml version="1.0" encoding="utf-8"?>
<post><title>function - Is the behavior behind the Shellshock vulnerability in Bash documented or at all intentional? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>A recent vulnerability, <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271" rel="nofollow">CVE-2014-6271</a>, in how <a href="http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29" rel="nofollow">Bash</a> interprets environment variables <a href="https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/" rel="nofollow">was disclosed</a>. The exploit relies on Bash parsing some environment variable declarations as function definitions, but then continuing to execute code following the definition:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ x</span><span class="pun">=</span><span class="str">'() { echo i do nothing; }; echo vulnerable'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">':'</span><span class="pln">
vulnerable</span></code></pre>
<p>But I don't get it. There's nothing I've been able to find in the Bash manual about interpreting environment variables as functions at all (except for <em>inheriting functions</em>, which is different). Indeed, a proper named function definition is just treated as a value:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ x</span><span class="pun">=</span><span class="str">'y() { :; }'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'echo $x'</span><span class="pln">
y</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">:;</span><span class="pln"> </span><span class="pun">}</span></code></pre>
<p>But a corrupt one prints nothing:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ x</span><span class="pun">=</span><span class="str">'() { :; }'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'echo $x'</span><span class="pln">

$ </span><span class="com"># Nothing but newline</span></code></pre>
<p>The corrupt function is unnamed, and so I can't just call it. Is this vulnerability a pure implementation bug, or is there an intended feature here, that I just can't see?</p>
<h2>Update</h2>
<p>Per Barmar's comment, I hypothesized the name of the function was the parameter name:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ n</span><span class="pun">=</span><span class="str">'() { echo wat; }'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'n'</span><span class="pln">
wat</span></code></pre>
<p>Which I could swear I tried before, but I guess I didn't try hard enough. It's repeatable now. Here's a little more testing:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ env n</span><span class="pun">=</span><span class="str">'() { echo wat; }; echo vuln'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'n'</span><span class="pln">
vuln
wat
$ env n</span><span class="pun">=</span><span class="str">'() { echo wat; }; echo $1'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'n 2'</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">--</span><span class="pln"> </span><span class="lit">4</span><span class="pln">

wat</span></code></pre>
<p>…so apparently the args are not set at the time the exploit executes.</p>
<p>Anyway, the basic answer to my question is, <em>yes, this is how Bash implements inherited functions</em>.</p>
</div></text><author><a href="/users/63550/peter-mortensen">Peter Mortensen</a></author><comments><comment><text><span class="comment-copy">How do you think inheriting functions works in the first place? The only type of inheritance available between processes is the environment. So exported functions have to be encoded in the environment somehow.</span></text><author><a class="comment-user" href="/users/1491895/barmar" title="310,483 reputation">Barmar</a></author></comment><comment><text><span class="comment-copy">the example code in the link you included starts with <code>env</code>, as in <code>env x='...</code>. Not sure how this makes a difference either. FYI <code>ksh</code> does not emit any output from these tests after changing references from <code>bash -c</code> to <code>ksh -c</code>.</span></text><author><a class="comment-user" href="/users/620097/shellter" title="24,034 reputation">shellter</a></author></comment><comment><text><span class="comment-copy">The lastet bash 4.3.25-1 closed the execution of the command after the strange function definition, but the function is still get defined...</span></text><author><a class="comment-user" href="/users/632407/jm666" title="36,005 reputation">jm666</a></author></comment><comment><text><span class="comment-copy">There is a new vulnerability coming down the pipe as well <b><a href="https://access.redhat.com/security/cve/CVE-2014-7169" rel="nofollow noreferrer">access.redhat.com/security/cve/CVE-2014-7169</a></b></span></text><author><a class="comment-user" href="/users/3422102/david-c-rankin" title="24,557 reputation">David C. Rankin</a></author></comment><comment><text><span class="comment-copy">Defining a function this way is an intended feature; the bug is the extra code following the function definition being executed as well.</span></text><author><a class="comment-user" href="/users/1126841/chepner" title="166,866 reputation">chepner</a></author></comment><comment><text><span class="comment-copy">@chepner:  To get this straight, can we still have this:  <code>export ls='(){ /bin/ls $@; echo "Caught you";}'</code>?</span></text><author><a class="comment-user" href="/users/736308/cdarke" title="21,728 reputation">cdarke</a></author></comment><comment><text><span class="comment-copy">Almost. The string must begin <i>explicitly</i> with <code>() {</code> (note the space). Otherwise, yes, <code>bash</code> will turn that into a function called <code>ls</code> if it sees that string in its environment on startup. The closing brace, it turns out, is somewhat optional.</span></text><author><a class="comment-user" href="/users/1126841/chepner" title="166,866 reputation">chepner</a></author></comment><comment><text><span class="comment-copy">@Barmar in my defense, I actually didn't know what <i>inherit</i> meant. Consider that you can set x=3 and access it in a subshell: <code>$(echo $x)</code>, but that's subtly different from exporting <code>x</code>. Until this bug came to light I didn't even know you could export functions.</span></text><author><a class="comment-user owner" href="/users/418413/kojiro" title="45,065 reputation">kojiro</a></author></comment><comment><text><span class="comment-copy">See <a href="http://unix.stackexchange.com/q/157329">What does env x='() { :;}; command' bash do and why is it insecure?</a></span></text><author><a class="comment-user" href="/users/821436/martin-schr%c3%b6der" title="1,922 reputation">Martin Schröder</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>This seems like an implementation bug.</p>
<p>Apparently, the way exported functions work in <code>bash</code> is that they use specially-formatted environment variables. If you export a function:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">f</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">}</span></code></pre>
<p>it defines an environment variable like:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">f</span><span class="pun">=</span><span class="str">'() { ... }'</span></code></pre>
<p>What's probably happening is that when the new shell sees an environment variable whose value begins with <code>()</code>, it prepends the variable name and executes the resulting string. The bug is that this includes executing anything <em>after</em> the function definition as well.</p>
<p>The fix described is apparently to parse the result to see if it's a valid function definition. If not, it prints the warning about the invalid function definition attempt.</p>
<p><a href="http://fedoramagazine.org/shellshock-how-does-it-actually-work/">This article</a> confirms my explanation of the cause of the bug. It also goes into a little more detail about how the fix resolves it: not only do they parse the values more carefully, but variables that are used to pass exported functions follow a special naming convention. This naming convention is different from that used for the environment variables created for CGI scripts, so an HTTP client should never be able to get its foot into this door.</p>
</div></text><author><a href="/users/1491895/barmar">Barmar</a></author><comments><comment><text><span class="comment-copy">How come environment variables let you execute functions but not bash commands directly.</span></text><author><a class="comment-user" href="/users/1402140/abbasfaisal" title="365 reputation">AbbasFaisal</a></author></comment><comment><text><span class="comment-copy">It's not "letting" you do anything. Bash uses these specially-formatted environment variables as the way to inherit functions. If it's not formatted like this, there's no reason to execute it, it's just plain data.</span></text><author><a class="comment-user" href="/users/1491895/barmar" title="310,483 reputation">Barmar</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>The following:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x</span><span class="pun">=</span><span class="str">'() { echo I do nothing; }; echo vulnerable'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'typeset -f'</span></code></pre>
<p>prints</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">vulnerable
x </span><span class="pun">()</span><span class="pln"> 
</span><span class="pun">{</span><span class="pln"> 
    echo I </span><span class="kwd">do</span><span class="pln"> nothing
</span><span class="pun">}</span><span class="pln">
declare </span><span class="pun">-</span><span class="pln">fx x</span></code></pre>
<p>seems, than Bash, after having parsed the <code>x=...</code>, discovered it as a function, exported it, saw the <code>declare -fx x</code> and allowed the execution of the command after the declaration. </p>
<p><code>echo vulnerable</code></p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x</span><span class="pun">=</span><span class="str">'() { x; }; echo vulnerable'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'typeset -f'</span></code></pre>
<p>prints:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">vulnerable
x </span><span class="pun">()</span><span class="pln"> 
</span><span class="pun">{</span><span class="pln"> 
    echo I </span><span class="kwd">do</span><span class="pln"> nothing
</span><span class="pun">}</span></code></pre>
<p>and running the <code>x</code></p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x</span><span class="pun">=</span><span class="str">'() { x; }; echo Vulnerable'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'x'</span></code></pre>
<p>prints</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="typ">Vulnerable</span><span class="pln">
</span><span class="typ">Segmentation</span><span class="pln"> fault</span><span class="pun">:</span><span class="pln"> </span><span class="lit">11</span></code></pre>
<p>segfaults - infinite recursive calls</p>
<p>It doesn't overrides already defined function</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ x</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> echo </span><span class="typ">Something</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
$ declare </span><span class="pun">-</span><span class="pln">fx x
$ x</span><span class="pun">=</span><span class="str">'() { x; }; echo Vulnerable'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'typeset -f'</span></code></pre>
<p>prints:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x </span><span class="pun">()</span><span class="pln"> 
</span><span class="pun">{</span><span class="pln"> 
    echo </span><span class="typ">Something</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
declare </span><span class="pun">-</span><span class="pln">fx x</span></code></pre>
<p>e.g. the x remains the previously (correctly) defined function.</p>
<p>For the Bash <code>4.3.25(1)-release</code> the vulnerability is closed, so</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x</span><span class="pun">=</span><span class="str">'() { echo I do nothing; }; echo Vulnerable'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">':'</span></code></pre>
<p>prints</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">bash</span><span class="pun">:</span><span class="pln"> warning</span><span class="pun">:</span><span class="pln"> x</span><span class="pun">:</span><span class="pln"> ignoring </span><span class="kwd">function</span><span class="pln"> definition attempt
bash</span><span class="pun">:</span><span class="pln"> error importing </span><span class="kwd">function</span><span class="pln"> definition </span><span class="kwd">for</span><span class="pln"> </span><span class="str">`x'</span></code></pre>
<p>but - <strong>what is strange</strong> (at least for me)</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x</span><span class="pun">=</span><span class="str">'() { x; };'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'typeset -f'</span></code></pre>
<p>STILL PRINTS</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x </span><span class="pun">()</span><span class="pln"> 
</span><span class="pun">{</span><span class="pln"> 
    x
</span><span class="pun">}</span><span class="pln">
declare </span><span class="pun">-</span><span class="pln">fx x</span></code></pre>
<p>and the</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">x</span><span class="pun">=</span><span class="str">'() { x; };'</span><span class="pln"> bash </span><span class="pun">-</span><span class="pln">c </span><span class="str">'x'</span></code></pre>
<p>segmentation faults too, so it STILL accept the strange function definition...</p>
</div></text><author><a href="/users/632407/jm666">jm666</a></author><comments><comment><text><span class="comment-copy">Your last test, showing <code>x</code> not being overridden, actually looks like a bug as well. I would expect the command environment override to take precedence; it does, at least, for "normal" environment variables. Consider <code>declare -x foo=5; bash -c 'echo $foo'; foo=9 bash -c 'echo $foo'</code>. The first outputs 5; the second outputs 9.</span></text><author><a class="comment-user" href="/users/1126841/chepner" title="166,866 reputation">chepner</a></author></comment><comment><text><span class="comment-copy">RE: update 2, that's the function export working as expected. The string assigned to <code>x</code> is a function definition and nothing more, so it is exported.</span></text><author><a class="comment-user" href="/users/1126841/chepner" title="166,866 reputation">chepner</a></author></comment><comment><text><span class="comment-copy">You can't define a function that way, at least not explicitly. Only an instance of <code>bash</code> that inherits such a value will "instantiate" it as an executable function. That is, with <code>export foo='() { echo 5; }'</code>, <code>foo</code> will remain a normal string parameter in the current shell, but a child <code>bash</code> will make it a function (<code>echo $foo</code> would print nothing, for example, because there is no parameter named <code>foo</code> in the child, just a function).</span></text><author><a class="comment-user" href="/users/1126841/chepner" title="166,866 reputation">chepner</a></author></comment><comment><text><span class="comment-copy">From what I can tell, this is <i>exactly</i> what <code>bash</code> did: it evaluated any string in the environment whose <i>prefix</i> was a valid function definition, without regard for whatever trailing code was evaluated along with it.</span></text><author><a class="comment-user" href="/users/1126841/chepner" title="166,866 reputation">chepner</a></author></comment><comment><text><span class="comment-copy">the vulnerability is NOT closed, the fix is incomplete and just make harder to use the vulnerability. CVE-2014-6271 has been closed, but CVE-2014-7169 has been opened. Another patch will follow. cheers</span></text><author><a class="comment-user" href="/users/1668605/lesto" title="1,261 reputation">lesto</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I think it's worth looking at the Bash code itself. <a href="http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-025" rel="nofollow">The patch</a> gives a bit of insight as to the problem. In particular,</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pun">***</span><span class="pln"> </span><span class="pun">../</span><span class="pln">bash</span><span class="pun">-</span><span class="lit">4.3</span><span class="pun">-</span><span class="pln">patched</span><span class="pun">/</span><span class="pln">variables</span><span class="pun">.</span><span class="pln">c </span><span class="lit">2014</span><span class="pun">-</span><span class="lit">05</span><span class="pun">-</span><span class="lit">15</span><span class="pln"> </span><span class="lit">08</span><span class="pun">:</span><span class="lit">26</span><span class="pun">:</span><span class="lit">50.000000000</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0400</span><span class="pln">
</span><span class="pun">---</span><span class="pln"> variables</span><span class="pun">.</span><span class="pln">c </span><span class="lit">2014</span><span class="pun">-</span><span class="lit">09</span><span class="pun">-</span><span class="lit">14</span><span class="pln"> </span><span class="lit">14</span><span class="pun">:</span><span class="lit">23</span><span class="pun">:</span><span class="lit">35.000000000</span><span class="pln"> </span><span class="pun">-</span><span class="lit">0400</span><span class="pln">
</span><span class="pun">***************</span><span class="pln">
</span><span class="pun">***</span><span class="pln"> </span><span class="lit">359</span><span class="pun">,</span><span class="lit">369</span><span class="pln"> </span><span class="pun">****</span><span class="pln">
      strcpy </span><span class="pun">(</span><span class="pln">temp_string </span><span class="pun">+</span><span class="pln"> char_index </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> string</span><span class="pun">);</span><span class="pln">

</span><span class="pun">!</span><span class="pln">     </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">posixly_correct </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> legal_identifier </span><span class="pun">(</span><span class="pln">name</span><span class="pun">))</span><span class="pln">
</span><span class="pun">!</span><span class="pln">       parse_and_execute </span><span class="pun">(</span><span class="pln">temp_string</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> SEVAL_NONINT</span><span class="pun">|</span><span class="pln">SEVAL_NOHIST</span><span class="pun">);</span><span class="pln">
</span><span class="pun">!</span><span class="pln">
</span><span class="pun">!</span><span class="pln">     </span><span class="pun">/*</span><span class="pln"> </span><span class="typ">Ancient</span><span class="pln"> backwards compatibility</span><span class="pun">.</span><span class="pln">  </span><span class="typ">Old</span><span class="pln"> versions of bash exported
</span><span class="pun">!</span><span class="pln">        functions like name</span><span class="pun">()=()</span><span class="pln"> </span><span class="pun">{...}</span><span class="pln"> </span><span class="pun">*/</span><span class="pln">
</span><span class="pun">!</span><span class="pln">     </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">name</span><span class="pun">[</span><span class="pln">char_index </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">')'</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">char_index </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">'('</span><span class="pun">)</span><span class="pln">
</span><span class="pun">!</span><span class="pln">       name</span><span class="pun">[</span><span class="pln">char_index </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'\0'</span><span class="pun">;</span><span class="pln">

      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">temp_var </span><span class="pun">=</span><span class="pln"> find_function </span><span class="pun">(</span><span class="pln">name</span><span class="pun">))</span><span class="pln">
</span><span class="pun">---</span><span class="pln"> </span><span class="lit">364</span><span class="pun">,</span><span class="lit">372</span><span class="pln"> </span><span class="pun">----</span><span class="pln">
      strcpy </span><span class="pun">(</span><span class="pln">temp_string </span><span class="pun">+</span><span class="pln"> char_index </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> string</span><span class="pun">);</span><span class="pln">

</span><span class="pun">!</span><span class="pln">     </span><span class="pun">/*</span><span class="pln"> </span><span class="typ">Don</span><span class="str">'t import function names that are invalid identifiers from the
!        environment, though we still allow them to be defined as shell
!        variables. */
!     if (legal_identifier (name))
!       parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);

      if (temp_var = find_function (name))</span></code></pre>
<p>When Bash exports a function, it shows up as an environment variable, for example:</p>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pln">$ foo</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> echo </span><span class="str">'hello world'</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
$ export </span><span class="pun">-</span><span class="pln">f foo
$ cat </span><span class="pun">/</span><span class="pln">proc</span><span class="pun">/</span><span class="pln">self</span><span class="pun">/</span><span class="pln">environ </span><span class="pun">|</span><span class="pln"> tr </span><span class="str">'\0'</span><span class="pln"> </span><span class="str">'\n'</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> grep </span><span class="pun">-</span><span class="pln">A1 foo
foo</span><span class="pun">=()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">  echo </span><span class="str">'hello world'</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>When a new Bash process finds a function defined this way in its environment, it evalutes the code in the variable using <code>parse_and_execute()</code>. For normal, non-malicious code, executing it simply defines the function in Bash and moves on. However, because it's passed to a generic execution function, Bash will correctly parse and execute <em>additional code</em> defined in that variable after the function definition.</p>
<p>You can see that in the new code, a flag called <code>SEVAL_ONECMD</code> has been added that tells Bash to only evaluate the first command (that is, the function definition) and <code>SEVAL_FUNCDEF</code> to only allow functio0n definitions.</p>
</div></text><author><a href="/users/1172428/fatalerror">FatalError</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>In regard to your question about documentation, notice here in the commandline documentation for the <code>env</code> command, that a study of the syntax shows that <code>env</code> is working as documented.</p>
<ul>
<li>There are, optionally, 4 possible options</li>
<li>An optional hyphen as a synonym for <code>-i</code> (for backward compatibility I assume)</li>
<li>Zero or more NAME=VALUE pairs. These are the variable assignment(s) which could include function definitions.</li>
<li>Note that no semicolon (;) is required between or following the assignments.</li>
<li>The last argument(s) can be a single command followed by its argument(s). It will run with whatever permissions have been granted to the login being used. Security is controlled by restricting permissions on the login user and setting permissions on user-accessible executables such that users other than the executable's owner can only read and execute the program, not alter it.</li>
</ul>
<blockquote>
<pre class="lang-sh prettyprint prettyprinted" style=""><code><span class="pun">[</span><span class="pln"> spot@LX03</span><span class="pun">:~</span><span class="pln"> </span><span class="pun">]</span><span class="pln"> env </span><span class="pun">--</span><span class="pln">help
</span><span class="typ">Usage</span><span class="pun">:</span><span class="pln"> env </span><span class="pun">[</span><span class="pln">OPTION</span><span class="pun">]...</span><span class="pln"> </span><span class="pun">[-]</span><span class="pln"> </span><span class="pun">[</span><span class="pln">NAME</span><span class="pun">=</span><span class="pln">VALUE</span><span class="pun">]...</span><span class="pln"> </span><span class="pun">[</span><span class="pln">COMMAND </span><span class="pun">[</span><span class="pln">ARG</span><span class="pun">]...]</span><span class="pln">
</span><span class="typ">Set</span><span class="pln"> each NAME to VALUE </span><span class="kwd">in</span><span class="pln"> the environment and run COMMAND</span><span class="pun">.</span><span class="pln">

  </span><span class="pun">-</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="pun">--</span><span class="pln">ignore</span><span class="pun">-</span><span class="pln">environment   start with an empty environment
  </span><span class="pun">-</span><span class="pln">u</span><span class="pun">,</span><span class="pln"> </span><span class="pun">--</span><span class="pln">unset</span><span class="pun">=</span><span class="pln">NAME           remove variable from the environment
      </span><span class="pun">--</span><span class="pln">help     display this help and exit
      </span><span class="pun">--</span><span class="pln">version  output version information and exit

A mere </span><span class="pun">-</span><span class="pln"> implies </span><span class="pun">-</span><span class="pln">i</span><span class="pun">.</span><span class="pln">  </span><span class="typ">If</span><span class="pln"> no COMMAND</span><span class="pun">,</span><span class="pln"> print the resulting environment</span><span class="pun">.</span><span class="pln">

</span><span class="typ">Report</span><span class="pln"> env bugs to bug</span><span class="pun">-</span><span class="pln">coreutils@gnu</span><span class="pun">.</span><span class="pln">org
GNU coreutils home page</span><span class="pun">:</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">http</span><span class="pun">://</span><span class="pln">www</span><span class="pun">.</span><span class="pln">gnu</span><span class="pun">.</span><span class="pln">org</span><span class="pun">/</span><span class="pln">software</span><span class="pun">/</span><span class="pln">coreutils</span><span class="pun">/&gt;</span><span class="pln">
</span><span class="typ">General</span><span class="pln"> help using GNU software</span><span class="pun">:</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">http</span><span class="pun">://</span><span class="pln">www</span><span class="pun">.</span><span class="pln">gnu</span><span class="pun">.</span><span class="pln">org</span><span class="pun">/</span><span class="pln">gethelp</span><span class="pun">/&gt;</span><span class="pln">
</span><span class="typ">Report</span><span class="pln"> env translation bugs to </span><span class="pun">&lt;</span><span class="pln">http</span><span class="pun">://</span><span class="pln">translationproject</span><span class="pun">.</span><span class="pln">org</span><span class="pun">/</span><span class="pln">team</span><span class="pun">/&gt;</span></code></pre>
</blockquote>
</div></text><author><a href="/users/470211/docsalvager">DocSalvager</a></author><comments/></answer></answers></post>