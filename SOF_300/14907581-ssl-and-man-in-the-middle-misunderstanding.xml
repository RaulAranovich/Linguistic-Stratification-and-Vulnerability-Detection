<?xml version="1.0" encoding="utf-8"?>
<post><title>security - SSL and man-in-the-middle misunderstanding - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I've read tons of documentation related to this problem but I still can't get all the pieces together, so I'd like to ask a couple of questions.</p>
<ol>
<li><p>First of all I'll describe briefly the authentication procedure as I understand it, as I may be mistaken in that regard: A client starts a connection, which a server responds to with a combination of public key, some metadata and digital signature of a trusted authority. Then the client takes the decision if she trusts the server, encrypts some random session key with the public key and sends it back. This session key can be decrypted only with private key stored on the server. Server does this and then the HTTPS session begins.</p></li>
<li><p>So, if I'm correct above, the question is how the man-in-the-middle attack can occur in such scenario? I mean, even if somebody intercepts the server (e.g. www.server.com) response with public key and has some means to make me think that he is www.server.com, he still wouldn't be able to decrypt my session key without the private key.</p></li>
<li><p>Speaking about the mutual authentication, is it all about the server confidence about the client identity? I mean, the client can already be sure that she is communicating with the right server, but now the server wants to find out who the client is, right?</p></li>
<li><p>And the last question is about the alternative to the mutual authentication. If I act as a client in the situation described, what if I send a login/password in the HTTP header after the SSL session is established? As I see it, this information can't be intercepted because the connection is already secured and the server can rely on it for my identification. Am I wrong? What are the downsides of such an approach compared with mutual authentication (only security issues are important, not the implementation complexity)?</p></li>
</ol>
</div></text><author><a href="/users/1011749/dfarrell07">dfarrell07</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Man-in-the-middle attacks on SSL are really only possible if one of SSL's preconditions is broken, here are some examples;</p>
<ul>
<li><p>The server key has been stolen - means the attacker can appear to be the server, and there is <em>no way</em> for the client to know.</p></li>
<li><p>The client trusts an untrustworthy CA (or one that has had it's root key stolen) - whoever holds a trusted CA key can generate a certificate pretending to be the server and the client will trust it. With the number of CAs pre-existing in browsers today, this may be a real problem. This means that the server certificate would appear to change to another valid one, which is something most clients will hide from you.</p></li>
<li><p>The client doesn't bother to validate the certificate correctly against its list of trusted CA's - anyone can create a CA. With no validation, "Ben's Cars and Certificates" will appear to be just as valid as Verisign.</p></li>
<li><p>The client has been attacked and a fake CA has been injected in his trusted root authorities - allows the attacker to generate any cert he likes, and the client will trust it. Malware tends to do this to for example redirect you to fake banking sites.</p></li>
</ul>
<p>Especially #2 is rather nasty, even if you pay for a highly trusted certificate, your site will not be in any way locked to that certificate, you have to trust <em>all</em> CAs in the client's browser since any of them can generate a fake cert for your site that is just as valid. It also does not require access to either the server or the client.</p>
</div></text><author><a href="/users/477878/joachim-isaksson">Joachim Isaksson</a></author><comments><comment><text><span class="comment-copy">There are also tools like <a href="http://www.thoughtcrime.org/software/sslstrip/" rel="nofollow noreferrer">sslstrip</a>, which will attempt to transparently rewrite https links into http links.</span></text><author><a class="comment-user" href="/users/77939/mpontillo" title="9,059 reputation">mpontillo</a></author></comment><comment><text><span class="comment-copy">Another point about certificate verification is that the client needs to verify the host name. It's not good enough to check that the cert is genuine, it has to be issue to the entity you want to talk to (see <a href="http://stackoverflow.com/a/13742121/372643">here</a> and <a href="http://security.stackexchange.com/q/22965/2435">here</a>). As for sslstrip, it's ultimately <a href="http://webmasters.stackexchange.com/a/28443/11628">up to the user to check they want to use SSL/TLS</a> unfortunately (although HSTS can help).</span></text><author><a class="comment-user" href="/users/372643/bruno" title="78,944 reputation">Bruno</a></author></comment><comment><text><span class="comment-copy">@Bruno Right, fixed, thanks :)</span></text><author><a class="comment-user" href="/users/477878/joachim-isaksson" title="123,108 reputation">Joachim Isaksson</a></author></comment><comment><text><span class="comment-copy">Could I write a chrome (or any other browser for that matter) plugin that intercepts the data BEFORE the browser encrypt it?</span></text><author><a class="comment-user" href="/users/193634/rosdi-kasim" title="8,907 reputation">Rosdi Kasim</a></author></comment><comment><text><span class="comment-copy">Another reason is "Misuse of trust", as in TÃ¼rkTrust issue.</span></text><author><a class="comment-user" href="/users/1952991/ceremcem" title="684 reputation">ceremcem</a></author></comment><comment><text><span class="comment-copy">Points 1 and 2 are more or less the same, aren't they? i.e. 2 is an elaboration of 1.</span></text><author><a class="comment-user" href="/users/183726/remover" title="1,090 reputation">Remover</a></author></comment><comment><text><span class="comment-copy">@Remover Not really... #1 is the private key on the server, paired with the genuine public key. In this scenario you'd talk to the real server but someone else could decrypt the traffic by being in the middle. They can't modify the certificate. #2 involves sending an entirely different certificate, issued by a "trusted" CA that will appear to be the legitimate to the client. The attacker can then proxy requests on your behalf and see messages that way. Both result in a compromise but #1 is under your control. #2, unfortunately, is not.</span></text><author><a class="comment-user" href="/users/156755/basic" title="17,013 reputation">Basic</a></author></comment><comment><text><span class="comment-copy">This answer, while not technically wrong, dates from the happy days before the NSA scandal, and the widespread use of ssl inspection. See my <a href="http://stackoverflow.com/a/32569050/1585345">answer</a> below.</span></text><author><a class="comment-user" href="/users/1585345/user1585345" title="2,189 reputation">user1585345</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>First of all I'll describe briefly the authentification procedure as I understand it, maybe I'm mistaken on that step. So, a client starts a connection and a server responds it with combination of public key, some metadata and digital signature of a trusted authority.</p>
</blockquote>
<p>The server responds with an X.509 certificate chain and a digital signature signed with its own private key.</p>
<blockquote>
<p>Then the client takes the decision if she trusts the server</p>
</blockquote>
<p>Correct.</p>
<blockquote>
<p>encrypts some random session key with the public key and sends it back.</p>
</blockquote>
<p>No. The client and server engage in a mutual session key generation process whereby the session key itself is never transmitted at all.</p>
<blockquote>
<p>This session key can be decrypted only with private key stored on the server.</p>
</blockquote>
<p>No.</p>
<blockquote>
<p>Server does this</p>
</blockquote>
<p>No.</p>
<blockquote>
<p>and then the HTTPS session begins.</p>
</blockquote>
<p>The <em>TLS/SSL</em> session begins, but there are more steps first.</p>
<blockquote>
<p>So, if I'm correct above, the question is how does the man-in-the-middle attack can occur in such scenario?</p>
</blockquote>
<p>By masquerading as the server and acting as the SSL endpoint. The client would have to omit any authorization step. Sadly the only authorization step in most HTTPS sessions is a hostname check.</p>
<blockquote>
<p>I mean that even if somebody intercepts the server (e.g. www.server.com) response with public key and then with some means let me think that he is www.server.com, he still wouldn't be able to decrypt my session key without the private key.</p>
</blockquote>
<p>See above. There is no session key to decrypt. The SSL connection itself is secure, it's <em>who you're talking to</em> that may not be secure.</p>
<blockquote>
<p>Speaking about the mutual authentication, is it all about the server confidence about the client identity? I mean, that the client can already be sure that she is communicating with the right server, but now the server wants to find out who is the client, right?</p>
</blockquote>
<p>Correct.</p>
<blockquote>
<p>And the last question is about the alternative to the mutual authentication. If I act as a client in the situation described, what if I send a login/password in the HTTP header after the SSL session is established? As I see, this information can't be intercepted because the connection is already secured and the server can rely on it for my identification. Am I wrong?</p>
</blockquote>
<p>No.</p>
<blockquote>
<p>What are the downsides of such approach comparing with mutual authentication (only security issues are important, not the implementation complexity)?</p>
</blockquote>
<p>It's only as secure as the username/password, which are a lot easier to leak than a private key.</p>
</div></text><author><a href="/users/207421/ejp">EJP</a></author><comments><comment><text><span class="comment-copy">Thank you for your explanation. The only thing I didn't get is why you said a client doesn't send a session key to a server? Well, maybe I've used wrong terminology, <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" rel="nofollow noreferrer">here</a> this piece of data is called "pre-master secret", but anyway, isn't it sent by the client and it is decrypted with the server private key?</span></text><author><a class="comment-user owner" href="/users/983637/vadim-chekry" title="338 reputation">Vadim Chekry</a></author></comment><comment><text><span class="comment-copy">@VadimChekry The pre-master secret is not the session key. It is one of several pieces of data used to generate the session key, independently at both ends. The process is described in RFC 2246.</span></text><author><a class="comment-user" href="/users/207421/ejp" title="214,361 reputation">EJP</a></author></comment><comment><text><span class="comment-copy">Thanks @EJP. I am out of my depth, but from this answer, can I assume that if you use the IP address to connect, you are not vulnerable to MITM attacks? It seems from everything I can find that MITM attacks depend on the mapping of a domain name to an illegitimate IP address. Apologies this is a dumb question to most people on this area of SO!</span></text><author><a class="comment-user" href="/users/1308967/chris" title="838 reputation">Chris</a></author></comment><comment><text><span class="comment-copy">@Chris You are much less vulnerable, however IP address spoofing is possible. There is no substitute for checking the peer identity in the certificate yourself.</span></text><author><a class="comment-user" href="/users/207421/ejp" title="214,361 reputation">EJP</a></author></comment><comment><text><span class="comment-copy">+1 This is quite a good answer, for the most part. However, some points are lacking explanation with one-word responses. You could make it a definitive answer if you were to  expand and/or elaborate on said points, (i.e. instead of, "no." you could briefly mention what <i>actually</i> happens.) in the main body. That would really clarify a few things. Thanks.</span></text><author><a class="comment-user" href="/users/5226966/tjt263" title="111 reputation">tjt263</a></author></comment><comment><text><span class="comment-copy">@tjt263 The first 'no' provides an explanation of what really happens. The next two 'no's refer to the same misconception that produced the first 'no', and have the same explanation. The next and final 'no' refers to 'am I wrong' and it refers to the information just quoted from the OP. It is difficult therefore to undertasnd what you think is actually missing here.</span></text><author><a class="comment-user" href="/users/207421/ejp" title="214,361 reputation">EJP</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Anyone on the road between client and server can stage a man in the middle attack on https. If you think this is unlikely or rare, consider that <strong><a href="http://cookbook.fortinet.com/why-you-should-use-ssl-inspection/" rel="noreferrer">there are commercial products</a> that systematically decrypt, scan and re-encrypt <em>all</em> ssl traffic across an internet gateway</strong>. They work by sending the client an ssl cert created on-the-fly with the details copied from the "real" ssl cert, but signed with a different certificate chain. If this chain terminates with any of the browser's trusted CA's, this MITM will be invisible to the user. These products are primarily sold to companies to "secure" (police) corporate networks, and should be used with the knowledge and assent of users. Technically though, there's nothing stopping their use by ISPs or any other network carrier. (It would be safe to assume the NSA <a href="https://www.schneier.com/blog/archives/2013/09/new_nsa_leak_sh.html" rel="noreferrer">has at least one trusted root CA signing key</a>)</p>
<p>If you're serving a page, <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning" rel="noreferrer">you can include an HTTP header</a> indicating what public key the page should be signed with. This may help to alert users to the MITM of their "secure" connection, but it's a trust-on-first-use technique. If Bob doesn't already have a record of the "real" public key pin, Mallory just rewrites the pkp header in the document. The list of web sites using this technology is depressingly short. It includes google and dropbox, to their credit.</p>
<p>Regarding passwords, everything on an https connection is secured by https, except the domain name, which needs to be in the clear so the request can be routed. In general, it's recommended not to put passwords in the query string, where they can hang around in logs, bookmarks etc. But the query string is not visible unless https is compromised.</p>
</div></text><author><a href="/users/1585345/user1585345">user1585345</a></author><comments><comment><text><span class="comment-copy">But this means this MITM equipment (the one that decrypts/scans and re-encrypts the traffic) needs to have access to one of the trusted CA right? (to "fake" the server certificate). Lets say this happens. Then someone busts this, the info becomes public, and there will be a scandal in the pres and the CA certificate will be removed from all browsers right? I mean, ideally...</span></text><author><a class="comment-user" href="/users/714733/jazzcat" title="2,135 reputation">jazzcat</a></author></comment><comment><text><span class="comment-copy">No no. The "SSL Inspection" on the gateway needs create and sign certificates on the fly, but it doesn't need a root cert to do this. It has some intermediate cert, that has a chain. Whether or not the root of the chain is trusted by your browser determines whether you will see a certificate error. At work, we were asked to install the fortinet root cert so our browsers wouldn't give certificate errors. But if the chain terminated with  an already trusted certificate, it's transparent.</span></text><author><a class="comment-user" href="/users/1585345/user1585345" title="2,189 reputation">user1585345</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<ol>
<li>Correct</li>
<li>Not so correct. In that kind of attack the itermediate server gets your request and send that to destination in behalf of you. and then respond to you with the result. Actually it is man-in-the-middle server which makes secure connection with you not actual server you are intended to comunicate. that is why you MUST always check the certicate is valid and trusted.</li>
<li>could be correct</li>
<li>If you are sure the secured connection is trusted then is would b safe to send username/password.</li>
</ol>
</div></text><author><a href="/users/1058125/boynux">Boynux</a></author><comments><comment><text><span class="comment-copy">About 2 - I'm assuming that the client is thoroughly checking the metadata sent by the server during the procedure of connection establishment and that the client doesn't trust to ALL certificates. So wouldn't such scenario be possible if - a) a client is not doing what I said above, or b)  a man-in-the-middle has got somewhere a certificate signed by trusted CA?</span></text><author><a class="comment-user owner" href="/users/983637/vadim-chekry" title="338 reputation">Vadim Chekry</a></author></comment><comment><text><span class="comment-copy">It happens very rare that the intermediate server sends valid certificate, last year it happend with Comodo CA if I remember well. But normally if it is a trusted connection then it is completely secure.</span></text><author><a class="comment-user" href="/users/1058125/boynux" title="1,894 reputation">Boynux</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Everything you have said is correct except the part about the session key. The point of CAs is to defeat a man-in-the-middle attack -- everything else is done by SSL itself. Client authentication is an alternative to a username and password scheme.</p>
</div></text><author><a href="/users/721269/david-schwartz">David Schwartz</a></author><comments/></answer></answers></post>