<?xml version="1.0" encoding="utf-8"?>
<post><title>c# - ASP.NET Identity default Password Hasher, how does it work and is it secure? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I am wondering wether the Password Hasher that is default implemented in the <a href="http://msdn.microsoft.com/en-us/library/dn468199%28v=vs.111%29.aspx">UserManager</a> that comes with MVC 5 and ASP.NET Identity Framework, is secure enough? And if so, if you could explain to me how it works?</p>
<p>IPasswordHasher interface looks like this:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">interface</span><span class="pln"> </span><span class="typ">IPasswordHasher</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">string</span><span class="pln"> </span><span class="typ">HashPassword</span><span class="pun">(</span><span class="kwd">string</span><span class="pln"> password</span><span class="pun">);</span><span class="pln">
    </span><span class="typ">PasswordVerificationResult</span><span class="pln"> </span><span class="typ">VerifyHashedPassword</span><span class="pun">(</span><span class="kwd">string</span><span class="pln"> hashedPassword</span><span class="pun">,</span><span class="pln"> 
                                                       </span><span class="kwd">string</span><span class="pln"> providedPassword</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>As you can see, it doesn't take a salt, but it is mentioned in this thread: "<a href="http://stackoverflow.com/questions/19957176/asp-net-identity-password-hashing?rq=1">Asp.net Identity password hashing</a>"
 that it does infact salt it behind the scenes. So I am wondering how does it do this? And where does this salt come from?</p>
<p>My concern is that the salt is static, rendering it quite insecure.</p>
</div></text><author><a href="/users/1044856/andr%c3%a9-snede-kock">André Snede Kock</a></author><comments><comment><text><span class="comment-copy">I don't think this directly answers your question, but Brock Allen has written about some of your concerns here =&gt;  <a href="http://brockallen.com/2013/10/20/the-good-the-bad-and-the-ugly-of-asp-net-identity/" rel="nofollow noreferrer">brockallen.com/2013/10/20/…</a> and also written an open source user identity management and authentication library that has various boiler-plate features like password reset, hashing etc etc. <a href="https://github.com/brockallen/BrockAllen.MembershipReboot" rel="nofollow noreferrer">github.com/brockallen/BrockAllen.MembershipReboot</a></span></text><author><a class="comment-user" href="/users/325521/shiva" title="10,613 reputation">Shiva</a></author></comment><comment><text><span class="comment-copy">@Shiva Thanks, I will look into the library and the video on the page. But I would rather not have to deal with an external library. Not if I can avoid it.</span></text><author><a class="comment-user owner" href="/users/1044856/andr%c3%a9-snede-kock" title="4,286 reputation">André Snede Kock</a></author></comment><comment><text><span class="comment-copy">FYI: the stackoverflow equivalent for security. So although you will often get a good/correct answer here. The experts are on <a href="http://security.stackexchange.com/">security.stackexchange.com</a>    especially the comment "is it secure"  I asked a similar sort of question and the depth and quality of answer was amazing.</span></text><author><a class="comment-user" href="/users/1347784/phil-soady" title="7,435 reputation">phil soady</a></author></comment><comment><text><span class="comment-copy">@philsoady Thanks, that makes sense of course, Im already on a few of the other "sub-forums", if I do not get an answer, I can use, I will move over to <code>securiry.stackexchange.com</code>. And thanks for the tip!</span></text><author><a class="comment-user owner" href="/users/1044856/andr%c3%a9-snede-kock" title="4,286 reputation">André Snede Kock</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Here is how the <a href="https://aspnetidentity.codeplex.com/SourceControl/latest#src/Microsoft.AspNet.Identity.Core/Crypto.cs" rel="nofollow noreferrer">default implementation</a> works. It uses a <a href="http://msdn.microsoft.com/en-us/library/h83s4e12%28v=vs.110%29.aspx" rel="nofollow noreferrer">Key Derivation Function</a> with random salt to produce the hash. The salt is included as part of the output of the KDF. Thus, each time you "hash" the same password you will get different hashes. To verify the hash the output is split back to the salt and the rest, and the KDF is run again on the password with the specified salt. If the result matches to the rest of the initial output the hash is verified.</p>
<p>Hashing:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="typ">HashPassword</span><span class="pun">(</span><span class="kwd">string</span><span class="pln"> password</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> salt</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> buffer2</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">password </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ArgumentNullException</span><span class="pun">(</span><span class="str">"password"</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    using </span><span class="pun">(</span><span class="typ">Rfc2898DeriveBytes</span><span class="pln"> bytes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Rfc2898DeriveBytes</span><span class="pun">(</span><span class="pln">password</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x3e8</span><span class="pun">))</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        salt </span><span class="pun">=</span><span class="pln"> bytes</span><span class="pun">.</span><span class="typ">Salt</span><span class="pun">;</span><span class="pln">
        buffer2 </span><span class="pun">=</span><span class="pln"> bytes</span><span class="pun">.</span><span class="typ">GetBytes</span><span class="pun">(</span><span class="lit">0x20</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> dst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[</span><span class="lit">0x31</span><span class="pun">];</span><span class="pln">
    </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">salt</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x10</span><span class="pun">);</span><span class="pln">
    </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">buffer2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x11</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x20</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Convert</span><span class="pun">.</span><span class="typ">ToBase64String</span><span class="pun">(</span><span class="pln">dst</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Verifying:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> </span><span class="typ">VerifyHashedPassword</span><span class="pun">(</span><span class="kwd">string</span><span class="pln"> hashedPassword</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> password</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> buffer4</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hashedPassword </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">password </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ArgumentNullException</span><span class="pun">(</span><span class="str">"password"</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> src </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Convert</span><span class="pun">.</span><span class="typ">FromBase64String</span><span class="pun">(</span><span class="pln">hashedPassword</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">src</span><span class="pun">.</span><span class="typ">Length</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0x31</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">src</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">))</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> dst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[</span><span class="lit">0x10</span><span class="pun">];</span><span class="pln">
    </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">src</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x10</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> buffer3 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[</span><span class="lit">0x20</span><span class="pun">];</span><span class="pln">
    </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">src</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x11</span><span class="pun">,</span><span class="pln"> buffer3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x20</span><span class="pun">);</span><span class="pln">
    using </span><span class="pun">(</span><span class="typ">Rfc2898DeriveBytes</span><span class="pln"> bytes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Rfc2898DeriveBytes</span><span class="pun">(</span><span class="pln">password</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0x3e8</span><span class="pun">))</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        buffer4 </span><span class="pun">=</span><span class="pln"> bytes</span><span class="pun">.</span><span class="typ">GetBytes</span><span class="pun">(</span><span class="lit">0x20</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">ByteArraysEqual</span><span class="pun">(</span><span class="pln">buffer3</span><span class="pun">,</span><span class="pln"> buffer4</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</div></text><author><a href="/users/284111/andrew-savinykh">Andrew Savinykh</a></author><comments><comment><text><span class="comment-copy">So if I understand this correctly, the <code>HashPassword</code> function, returns both in the same string? And when you verify it, it splits it again it up again, and hashes the incoming cleartext password, with the salt from the split, and compares it with the original hash?</span></text><author><a class="comment-user owner" href="/users/1044856/andr%c3%a9-snede-kock" title="4,286 reputation">André Snede Kock</a></author></comment><comment><text><span class="comment-copy">@AndréSnedeHansen, exactly. And I too recommend you asking either on security or on cryptography SE. The "is it secure" part may be addressed better in those respective contexts.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">Thanks for explaining that, now I can sleep peacefully :)!</span></text><author><a class="comment-user owner" href="/users/1044856/andr%c3%a9-snede-kock" title="4,286 reputation">André Snede Kock</a></author></comment><comment><text><span class="comment-copy">@zespri: Any idea <i>why</i> byte0 of the output is set to 0x00? Seen in <code>VerifyHashedPassword(..)</code> at <code>src[0] != 0</code></span></text><author><a class="comment-user" href="/users/862563/deepspace101" title="4,870 reputation">DeepSpace101</a></author></comment><comment><text><span class="comment-copy">@DeepSpace101, no. If I had to guess, I'd say, that this is a minimal precaution against invalid input, to filter out values that are <i>definitely</i> not a valid hash.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">Is aps.net identity using pbkdf2?</span></text><author><a class="comment-user" href="/users/1999271/jeeva-jsb" title="872 reputation">Jeeva Jsb</a></author></comment><comment><text><span class="comment-copy">@JeevaJsb 2.0 uses Rfc2898 as seen above. Identity 3.0 (rc1 went out Nov 18, 2016) uses PBKDF2</span></text><author><a class="comment-user" href="/users/250104/david" title="1,019 reputation">David</a></author></comment><comment><text><span class="comment-copy">I have one password in database which is hashed and saved.So if i am making password check at the time of login how I will get same hashed password??</span></text><author><a class="comment-user" href="/users/4537011/shajeer-puzhakkal" title="70 reputation">shajeer puzhakkal</a></author></comment><comment><text><span class="comment-copy">@shajeerpuzhakkal you don't.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">So how password hashing is using in password save</span></text><author><a class="comment-user" href="/users/4537011/shajeer-puzhakkal" title="70 reputation">shajeer puzhakkal</a></author></comment><comment><text><span class="comment-copy">@shajeerpuzhakkal as described in the answer above.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">By the way, what's the purpose of assigning hex values to int variables (like 'count')? Are there any performance advantages?</span></text><author><a class="comment-user" href="/users/4319695/andrew-cyrul" title="159 reputation">Andrew Cyrul</a></author></comment><comment><text><span class="comment-copy">@AndrewCyrul I'm sorry I do not understand the question. There is no <code>count</code> variable in the code above, and it does not matter if you use hexadecimals or not - they represent the same number no matter what the base is.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">@AndrewSavinykh BlockCopy has 5 parameters, the last one is 'count' and it is an int. So why use '0x10' or '0x20' instead of just '16' or '32'?</span></text><author><a class="comment-user" href="/users/4319695/andrew-cyrul" title="159 reputation">Andrew Cyrul</a></author></comment><comment><text><span class="comment-copy">@AndrewCyrul you can use either. Both mean the same.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">@AndrewSavinykh I know, that's why I'm asking - what's the point? To make the code look smarter? ;)  Cause for me counting stuff using decimal numbers is A LOT more intuitive (we have 10 fingers after all - at least most of us), so declaring a number of something using hexadecimals seems like an unnecessary code obfuscation.</span></text><author><a class="comment-user" href="/users/4319695/andrew-cyrul" title="159 reputation">Andrew Cyrul</a></author></comment><comment><text><span class="comment-copy">@AndrewCyrul to reiterate - this is equal choice. So the point would be the same in both cases - to express that number. I'm guessing what's intuitive is highly subjective, since it did not even occur to me when you asked the question, that a software developer might have a problem reading 0x10 as 16.  Now when you explained that this is what your problem is I understand your point. But that's not an issue I ever encountered with my peer. With experience people usually get quite comfortable with this stuff.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">@AndrewCyrul another thing that might help here is to realize that this code is obtained by decompiling the methods in question, so those variable names and literals is what decompiler produced.  If you look at the link that Bruno edited into my answer you will be pleased to discover, that human written source code has nice constants instead of these numbers and will be undoubtedly easier for you to read.</span></text><author><a class="comment-user" href="/users/284111/andrew-savinykh" title="12,058 reputation">Andrew Savinykh</a></author></comment><comment><text><span class="comment-copy">@AndrewSavinykh I'm not saying it's a problem. Hell, it wasn't even me, who found this code - I'm just asking for a coleague that doesn't have a SO account :) It's just more of a personal taste - when I think of the size of a 32-byte value, I see '32' instead of '0x20' :) And the fact, that this code has been decompiled, explains a bit more :D</span></text><author><a class="comment-user" href="/users/4319695/andrew-cyrul" title="159 reputation">Andrew Cyrul</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Because these days ASP.NET is open source, you can find it on <a href="https://github.com/aspnet/Identity/blob/a8ba99bc5b11c5c48fc31b9b0532c0d6791efdc8/src/Microsoft.AspNetCore.Identity/PasswordHasher.cs" rel="nofollow noreferrer">GitHub for AspNet.Identity 3.0</a> or on <a href="https://aspnetidentity.codeplex.com/SourceControl/latest#src/Microsoft.AspNet.Identity.Core/Crypto.cs" rel="nofollow noreferrer">Codeplex for AspNet.Identity 2.0</a>.</p>
<p>From the comments:</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="com">/* =======================
 * HASHED PASSWORD FORMATS
 * =======================
 * 
 * Version 2:
 * PBKDF2 with HMAC-SHA1, 128-bit salt, 256-bit subkey, 1000 iterations.
 * (See also: SDL crypto guidelines v5.1, Part III)
 * Format: { 0x00, salt, subkey }
 *
 * Version 3:
 * PBKDF2 with HMAC-SHA256, 128-bit salt, 256-bit subkey, 10000 iterations.
 * Format: { 0x01, prf (UInt32), iter count (UInt32), salt length (UInt32), salt, subkey }
 * (All UInt32s are stored big-endian.)
 */</span></code></pre>
</div></text><author><a href="/users/1746803/knelis">Knelis</a></author><comments><comment><text><span class="comment-copy">Yes, and worth noting, there are additions to the algorithm zespri is showing.</span></text><author><a class="comment-user owner" href="/users/1044856/andr%c3%a9-snede-kock" title="4,286 reputation">André Snede Kock</a></author></comment><comment><text><span class="comment-copy">The source on GitHub is Asp.Net.Identity 3.0 which is still in prerelease.  The source of the 2.0 hash function is on <a href="https://aspnetidentity.codeplex.com/SourceControl/latest#src/Microsoft.AspNet.Identity.Core/Crypto.cs" rel="nofollow noreferrer">CodePlex</a></span></text><author><a class="comment-user" href="/users/250104/david" title="1,019 reputation">David</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>For those like me who are brand new to this, here is code with const and an actual way to compare the byte[]'s.  I got all of this code from stackoverflow but defined consts so values could be changed and also</p>
<pre class="lang-cs prettyprint prettyprinted" style=""><code><span class="com">// 24 = 192 bits</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> </span><span class="typ">SaltByteSize</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">24</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> </span><span class="typ">HashByteSize</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">24</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> </span><span class="typ">HasingIterationsCount</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10101</span><span class="pun">;</span><span class="pln">


    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="typ">HashPassword</span><span class="pun">(</span><span class="kwd">string</span><span class="pln"> password</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// http://stackoverflow.com/questions/19957176/asp-net-identity-password-hashing</span><span class="pln">

        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> salt</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> buffer2</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">password </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ArgumentNullException</span><span class="pun">(</span><span class="str">"password"</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        using </span><span class="pun">(</span><span class="typ">Rfc2898DeriveBytes</span><span class="pln"> bytes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Rfc2898DeriveBytes</span><span class="pun">(</span><span class="pln">password</span><span class="pun">,</span><span class="pln"> </span><span class="typ">SaltByteSize</span><span class="pun">,</span><span class="pln"> </span><span class="typ">HasingIterationsCount</span><span class="pun">))</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            salt </span><span class="pun">=</span><span class="pln"> bytes</span><span class="pun">.</span><span class="typ">Salt</span><span class="pun">;</span><span class="pln">
            buffer2 </span><span class="pun">=</span><span class="pln"> bytes</span><span class="pun">.</span><span class="typ">GetBytes</span><span class="pun">(</span><span class="typ">HashByteSize</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> dst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[(</span><span class="typ">SaltByteSize</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">HashByteSize</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span><span class="pln">
        </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">salt</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="typ">SaltByteSize</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">buffer2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="typ">SaltByteSize</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="typ">HashByteSize</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Convert</span><span class="pun">.</span><span class="typ">ToBase64String</span><span class="pun">(</span><span class="pln">dst</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> </span><span class="typ">VerifyHashedPassword</span><span class="pun">(</span><span class="kwd">string</span><span class="pln"> hashedPassword</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> password</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> _passwordHashBytes</span><span class="pun">;</span><span class="pln">

        </span><span class="typ">int</span><span class="pln"> _arrayLen </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">SaltByteSize</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">HashByteSize</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hashedPassword </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">password </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ArgumentNullException</span><span class="pun">(</span><span class="str">"password"</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> src </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Convert</span><span class="pun">.</span><span class="typ">FromBase64String</span><span class="pun">(</span><span class="pln">hashedPassword</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">src</span><span class="pun">.</span><span class="typ">Length</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> _arrayLen</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">src</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">))</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> _currentSaltBytes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[</span><span class="typ">SaltByteSize</span><span class="pun">];</span><span class="pln">
        </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">src</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> _currentSaltBytes</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="typ">SaltByteSize</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> _currentHashBytes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[</span><span class="typ">HashByteSize</span><span class="pun">];</span><span class="pln">
        </span><span class="typ">Buffer</span><span class="pun">.</span><span class="typ">BlockCopy</span><span class="pun">(</span><span class="pln">src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">SaltByteSize</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> _currentHashBytes</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="typ">HashByteSize</span><span class="pun">);</span><span class="pln">

        using </span><span class="pun">(</span><span class="typ">Rfc2898DeriveBytes</span><span class="pln"> bytes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Rfc2898DeriveBytes</span><span class="pun">(</span><span class="pln">password</span><span class="pun">,</span><span class="pln"> _currentSaltBytes</span><span class="pun">,</span><span class="pln"> </span><span class="typ">HasingIterationsCount</span><span class="pun">))</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">
            _passwordHashBytes </span><span class="pun">=</span><span class="pln"> bytes</span><span class="pun">.</span><span class="typ">GetBytes</span><span class="pun">(</span><span class="typ">SaltByteSize</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AreHashesEqual</span><span class="pun">(</span><span class="pln">_currentHashBytes</span><span class="pun">,</span><span class="pln"> _passwordHashBytes</span><span class="pun">);</span><span class="pln">

    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> </span><span class="typ">AreHashesEqual</span><span class="pun">(</span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> firstHash</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">byte</span><span class="pun">[]</span><span class="pln"> secondHash</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">int</span><span class="pln"> _minHashLength </span><span class="pun">=</span><span class="pln"> firstHash</span><span class="pun">.</span><span class="typ">Length</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> secondHash</span><span class="pun">.</span><span class="typ">Length</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> firstHash</span><span class="pun">.</span><span class="typ">Length</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> secondHash</span><span class="pun">.</span><span class="typ">Length</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> xor </span><span class="pun">=</span><span class="pln"> firstHash</span><span class="pun">.</span><span class="typ">Length</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> secondHash</span><span class="pun">.</span><span class="typ">Length</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> _minHashLength</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
            xor </span><span class="pun">|=</span><span class="pln"> firstHash</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> secondHash</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> xor</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
<p>In in your custom ApplicationUserManager, you set the PasswordHasher property the name of the class which contains the above code.</p>
</div></text><author><a href="/users/791130/kfrosty">kfrosty</a></author><comments/></answer></answers></post>