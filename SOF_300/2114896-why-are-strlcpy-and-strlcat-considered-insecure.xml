<?xml version="1.0" encoding="utf-8"?>
<post><title>c - Why are strlcpy and strlcat considered insecure? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>I understand that strlcpy and strlcat were designed as secure replacements for strncpy and strncat. However, some people are still of the opinion that they are insecure, and simply cause a different type of problem.</p>
<p><a href="https://en.wikipedia.org/wiki/C_string_handling#strcpy_.2F_strcat" rel="noreferrer">https://en.wikipedia.org/wiki/C_string_handling#strcpy_.2F_strcat</a></p>
<p>Can someone give an example of how using strlcpy or strlcat (i.e., a function that <em>always</em> null terminates its strings) can lead to security problems?</p>
<p>Ulrich Drepper and James Antill state this is true, but never provide examples or clarify this point.</p>
</div></text><author><a href="/users/507761/matthew-read">Matthew Read</a></author><comments/></question><answers><answer><text><div class="post-text" itemprop="text">
<p>Firstly, <code>strlcpy</code> has never been intended as a secure version of <code>strncpy</code> (and <code>strncpy</code> has never been intended as a secure version of <code>strcpy</code>). These two functions are totally unrelated. <code>strncpy</code> is a function that has no relation to C-strings (i.e. null-terminated strings) at all. The fact that it has the <code>str...</code> prefix in its name is just a historical blunder. The history and purpose of <code>strncpy</code> is well-known and well-documented. This is a function created for working with so called "fixed width" strings (not with C-strings) used in some historical versions of Unix file system. Some programmers today get confused by its name and assume that <code>strncpy</code> is somehow supposed to serve as limited-length C-string copying function (a "secure" sibling of <code>strcpy</code>), which in reality is complete nonsense and leads to bad programming practice. C standard library in its current form has no function for limited-length C-string copying whatsoever. This is where <code>strlcpy</code> fits in. <code>strlcpy</code> is indeed a true limited-length copying function created for working with C-strings. <code>strlcpy</code> correctly does everything a limited-length copying function should do. The only criticism one can aim at it is that it is, regretfully, not standard.</p>
<p>Secondly, <code>strncat</code> on the other hand, is indeed a function that works with C-strings and performs a limited-length concatenation (it is indeed a "secure" sibling of <code>strcat</code>). In order to use this function properly the programmer has to take some special care, since the size parameter this function accepts is not really the size of the buffer that receives the result, but rather the size of its remaining part (also, the terminator character is counted implicitly). This could be confusing, since in order to tie that size to the size of the buffer, programmer has to remember to perform some additional calculations, which is often used to criticize the <code>strncat</code>. <code>strlcat</code> takes care of these issues, changing the interface so that no extra calculations are necessary (at least in the calling code). Again, the only basis I see one can criticise this on is that the function is not standard. Also, functions from <code>strcat</code> group is something you won't see in professional code very often due to the limited usability of the very idea of rescan-based string concatenation. </p>
<p>As for how these functions can lead to security problems... They simply can't. They can't lead to security problems in any greater degree than the C language itself can "lead to security problems". You see, for quite a while there was a strong sentiment out there that C++ language has to move in the direction of developing into some weird flavor of Java. This sentiment sometimes spills into the domain of C language as well, resulting in rather clueless and forced criticism of C language features and the features of C standard library. I suspect that we might be dealing with something like that in this case as well, although I surely hope things are not really that bad.</p>
</div></text><author><a href="/users/187690/ant">AnT</a></author><comments><comment><text><span class="comment-copy">I do not completely agree. It would be nice if <code>strlcpy</code> and <code>strlcat</code> would report some sort of error condition if they bumped against the destination buffer size limit. Though you can check the returned length to test this, it's not obvious. But I think that's a minor criticism. The 'they encourage the use of C strings, and so they are bad' argument is silly.</span></text><author><a class="comment-user" href="/users/167958/omnifarious" title="34,465 reputation">Omnifarious</a></author></comment><comment><text><span class="comment-copy">"how these functions can lead to security problems" - fwiw I think the issue here is that some C functions are harder to use correctly than others. Some people have a mistaken belief that there is a special threshold of difficulty, below which a function is "secure" and above which it is "insecure". Such people are also usually of the belief that <code>strcpy</code> is above the threshold and hence "insecure", and their preferred string-copying function (whether it is <code>strlcpy</code>, <code>strcpy_s</code> or even <code>strncpy</code>) is below the threshold and hence "secure".</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">Of course there are are few functions (like <code>gets</code>) that are actually <i>impossible</i> to use correctly, and hence can reasonably be called "insecure" without further qualification of what's insecure about them :-)</span></text><author><a class="comment-user" href="/users/13005/steve-jessop" title="211,507 reputation">Steve Jessop</a></author></comment><comment><text><span class="comment-copy">There are plenty of reasons for disliking strlcpy/strlcat, but you don't state any of them. The discussion of C++ and Java is irrelevant. This answer just isn't helpful to the subject matter the question actually asked about.</span></text><author><a class="comment-user" href="/users/591478/john-ripley" title="3,500 reputation">John Ripley</a></author></comment><comment><text><span class="comment-copy">@John Ripley: Firstly, I'm not "stating any of them" simply because I'm not aware of any reasons for disliking <code>strlcpy/strlcat</code>. One might "dislike" the general concept of zero-terminated string, but that's not what the question is about. If you know "plenty of reasons to dislike <code>strlcpy/strlcat</code>", you should probably write your own answer instead of expecting me to be able to read someone else's mind.</span></text><author><a class="comment-user" href="/users/187690/ant" title="218,961 reputation">AnT</a></author></comment><comment><text><span class="comment-copy">@John Ripley: Secondly, the question was specifically referring to some alleged "security problems" with <code>strlcpy/strlcat</code>. While I believe I understand what this is about, I personally refuse to recognize that as "security problems" within the realm of traditional C language, as I know it. That I stated in my answer.</span></text><author><a class="comment-user" href="/users/187690/ant" title="218,961 reputation">AnT</a></author></comment><comment><text><span class="comment-copy">"C standard library in its current form has no function for limited-length C-string copying whatsoever." Just sayin', <code>snprintf</code>...</span></text><author><a class="comment-user" href="/users/1989425/seb" title="10,324 reputation">Seb</a></author></comment><comment><text><span class="comment-copy">Most of this answer is useful, but the screed at the end about security problems is at best one person's (fairly extreme) opinion and at worst nonsense. You can get pedantic with your definition of what "security problem" means, but it is generally recognized that buffer overruns are a major source of software vulnerabilities, and C string functions without length checks are a major source of buffer overruns. I don't know why anyone would want to whitewash that, but it's not helpful.</span></text><author><a class="comment-user" href="/users/98077/jens-alfke" title="1,538 reputation">Jens Alfke</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>Ulrich's criticism is based on the idea that a string truncation that is not detected by the program can lead to security issues, through incorrect logic.  Therefore, to be secure, you need to check for truncation.  To do this for a string concatenation means that you are doing a check along the lines of this:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">destlen </span><span class="pun">+</span><span class="pln"> sourcelen </span><span class="pun">&gt;</span><span class="pln"> dest_maxlen</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="com">/* Bug out */</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Now, <code>strlcat</code> does effectively do this check, if the programmer remembers to check the result - so you <em>can</em> use it safely:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">strlcat</span><span class="pun">(</span><span class="pln">dest</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">,</span><span class="pln"> dest_bufferlen</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> dest_bufferlen</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="com">/* Bug out */</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Ulrich's point is that since you have to have <code>destlen</code> and <code>sourcelen</code> around (or recalculate them, which is what <code>strlcat</code> effectively does), you might as well just use the more efficient <code>memcpy</code> anyway:</p>
<pre class="lang-c prettyprint prettyprinted" style=""><code><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">destlen </span><span class="pun">+</span><span class="pln"> sourcelen </span><span class="pun">&gt;</span><span class="pln"> dest_maxlen</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">goto</span><span class="pln"> error_out</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
memcpy</span><span class="pun">(</span><span class="pln">dest </span><span class="pun">+</span><span class="pln"> destlen</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">,</span><span class="pln"> sourcelen </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
destlen </span><span class="pun">+=</span><span class="pln"> sourcelen</span><span class="pun">;</span></code></pre>
<p>(In the above code, <code>dest_maxlen</code> is the maximum length of the string that can be stored in <code>dest</code> - one less than the size of the <code>dest</code> buffer.  <code>dest_bufferlen</code> is the full size of the <code>dest buffer</code>).</p>
</div></text><author><a href="/users/134633/caf">caf</a></author><comments><comment><text><span class="comment-copy">The readability of Drepper's code is bad. With strlcpy (or any str function) I know directly that I'm copying a 0 terminated C string. With <code>memcpy</code> it can be any type of memory and I have a supplemental dimension to check when trying to understand the code. I had a legacy app to debug where everything was done with memcpy, it was a real PITA to correct. After porting to dedicated String function it is much easier to read (and faster because a lot of unnecessary <code>strlen</code> could be removed).</span></text><author><a class="comment-user" href="/users/146377/patrick-schl%c3%bcter" title="8,016 reputation">Patrick Schlüter</a></author></comment><comment><text><span class="comment-copy">Why wouldn't you just use <code>strcpy</code> instead of <code>memcpy</code> in the last example?</span></text><author><a class="comment-user" href="/users/421550/domen" title="798 reputation">domen</a></author></comment><comment><text><span class="comment-copy">@domen: Because the size to copy is already known, so <code>memcpy()</code> is sufficient (and is potentially more efficient than <code>strcpy()</code>).</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment><comment><text><span class="comment-copy">Well, it's confusing to have it in string operations. And as far as I know efficiency depends on implementation and is not standardized.</span></text><author><a class="comment-user" href="/users/421550/domen" title="798 reputation">domen</a></author></comment><comment><text><span class="comment-copy">@domen: <code>memcpy()</code> <i>is</i> a string operation - it's declared in <code>&lt;string.h&gt;</code>, after all.</span></text><author><a class="comment-user" href="/users/134633/caf" title="164,916 reputation">caf</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>When people say, "<code>strcpy()</code> is dangerous, use <code>strncpy()</code> instead" (or similar statements about <code>strcat()</code> etc., but I am going to use <code>strcpy()</code> here as my focus), they mean that there is no bounds checking in <code>strcpy()</code>.  Thus, an overly long string will result in buffer overruns.  They are correct.  Using <code>strncpy()</code> in this case will prevent buffer overruns.  </p>
<p>I feel that <code>strncpy()</code> really doesn't fix bugs: it solves a problem that can be easily avoided by a good programmer.</p>
<p>As a C programmer, you <em>must</em> know the destination size before you are trying to copy strings.  That is the assumption in <code>strncpy()</code> and <code>strlcpy()</code>'s last parameters too: you supply that size to them.  You can also know the source size before you copy strings.  Then, if the destination is not big enough, <em>don't call <code>strcpy()</code></em>.  Either reallocate the buffer, or do something else.</p>
<p>Why do I not like <code>strncpy()</code>?</p>
<ul>
<li><code>strncpy()</code> is a bad solution in most cases: your string is going to be truncated without any notice—I would rather write extra code to figure this out myself and then take the course of action that I want to take, rather than let some function decide for me about what to do.</li>
<li><code>strncpy()</code> is very inefficient.  It writes to every byte in the destination buffer.  You don't need those thousands of <code>'\0'</code> at the end of your destination.</li>
<li>It doesn't write a terminating <code>'\0'</code> if the destination is not big enough.  So, you must do so yourself anyway.  The complexity of doing this is not worth the trouble.</li>
</ul>
<p>Now, we come to <code>strlcpy()</code>.  The changes from <code>strncpy()</code> make it better, but I am not sure if the specific behavior of <code>strl*</code> warrants their existence: they are far too specific.  You still have to know the destination size.  It is more efficient than <code>strncpy()</code> because it doesn't necessarily write to every byte in the destination.  But it solves a problem that can be solved by doing: <code>*((char *)mempcpy(dst, src, n)) = 0;</code>.</p>
<p>I don't think anyone says that <code>strlcpy()</code> or <code>strlcat()</code> can lead to security issues, what they (and I) are saying that they can result in bugs, for example, when you expect the complete string to be written instead of a part of it.</p>
<p>The main issue here is: how many bytes to copy?  The programmer must know this and if he doesn't, <code>strncpy()</code> or <code>strlcpy()</code> won't save him.</p>
<p><code>strlcpy()</code> and <code>strlcat()</code> are not standard, neither ISO C nor POSIX.  So, their use in portable programs is impossible.  In fact, <code>strlcat()</code> has two different variants: <a href="http://www.linux.org/docs/ldp/howto/Secure-Programs-HOWTO/library-c.html" rel="noreferrer">the Solaris implementation is different from the others</a>.  This makes it even less useful than otherwise.</p>
</div></text><author><a href="/users/226621/alok-singhal">Alok Singhal</a></author><comments><comment><text><span class="comment-copy"><code>strlcpy</code> is faster than <code>memcpy</code> on many architectures, especially if the <code>memcpy</code> copies unnecessary trailing data. <code>strlcpy</code> also returns how much data you missed which might allow you to recover faster and with less code.</span></text><author><a class="comment-user" href="/users/14554/jbcreix" title="2,983 reputation">jbcreix</a></author></comment><comment><text><span class="comment-copy">@jbcreix: my point is that there should be no data to miss, and <code>n</code> in my memcpy call is the exact number of bytes to be written, so the efficiency isn't that much of a problem either.</span></text><author><a class="comment-user" href="/users/226621/alok-singhal" title="53,673 reputation">Alok Singhal</a></author></comment><comment><text><span class="comment-copy">And how do you get that n? The only n you can know in advance is the buffer size. Of course if you suggest re implementing <code>strlcpy</code> each time you need it using <code>memcpy</code> and <code>strlen</code> that is okay too, but then why stopping at <code>strlcpy</code>, you don't <i>need</i> a <code>memcpy</code> function either, you can copy the bytes one by one. The reference implementation only loops through the data once in the normal case and that is better for most architectures. But even if the best implementation used <code>strlen</code> + <code>memcpy</code>, that is still no reason to not having to re-implement a secure strcpy again and again.</span></text><author><a class="comment-user" href="/users/14554/jbcreix" title="2,983 reputation">jbcreix</a></author></comment><comment><text><span class="comment-copy">@jbcreix: I get the <code>n</code> by doing <code>strlen()</code> on the source string, and as I said, I make sure that the destination has enough space. Of course, if you're okay with the fact that your string may be truncated, you can use <code>strlcpy()</code>. Personally, I would rather call <code>strlen()</code> on the source and make sure the destination has enough space.  So, I am not reimplementing <code>strlcpy()</code> at all. The trade off is between speed and copying all data. My point is that <code>strcpy()</code> is/can be safe if the programmer is careful. I am not saying that <code>strlcpy()</code> is completely useless. (continued...)</span></text><author><a class="comment-user" href="/users/226621/alok-singhal" title="53,673 reputation">Alok Singhal</a></author></comment><comment><text><span class="comment-copy">...but it's also not standard. And <code>strncpy()</code>, although standard, has deficiencies.</span></text><author><a class="comment-user" href="/users/226621/alok-singhal" title="53,673 reputation">Alok Singhal</a></author></comment><comment><text><span class="comment-copy">Alok, with <code>strlcpy</code> you sweep over the input string only once in the good case (which should be the majority) and twice in the bad case, with your <code>strlen</code>+<code>memcpy</code> you go over it twice always. If it makes a difference in practice is another story.</span></text><author><a class="comment-user" href="/users/146377/patrick-schl%c3%bcter" title="8,016 reputation">Patrick Schlüter</a></author></comment><comment><text><span class="comment-copy">"*((char *)mempcpy(dst, src, n)) = 0;" - Correct - Yes, Obviously Correct, No. Fails code review......</span></text><author><a class="comment-user" href="/users/728454/mattnz" title="454 reputation">mattnz</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I think Ulrich and others think it'll give a false sense of security.  Accidentally truncating strings <em>can</em> have security implications for other parts of the code (for example, if a file system path is truncated, the program might not be performing operations on the intended file).</p>
</div></text><author><a href="/users/179715/jamesdlin">jamesdlin</a></author><comments><comment><text><span class="comment-copy">For example, an email client might truncate an email attachment's filename from <code>malware.exe.jpg</code> to <code>malware.exe</code>.</span></text><author><a class="comment-user" href="/users/61352/chris-peterson" title="1,987 reputation">Chris Peterson</a></author></comment><comment><text><span class="comment-copy">@ChrisPeterson Which is why a good developer always checks the return values, to, in the case of strl* functions, know if the data was truncated and act accordingly.</span></text><author><a class="comment-user" href="/users/1139533/tom-lint" title="393 reputation">Tom Lint</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p><em>There are two "problems" related to using strl functions:</em></p>
<ol>
<li><strong>You have to check return values
to avoid truncation.</strong></li>
</ol>
<p>The c1x standard draft writers and Drepper, argue that programmers won't check the return value. Drepper says we should somehow know the length and use memcpy and avoid string functions altogether, The standards committee argues that the secure strcpy should return nonzero on truncation unless otherwise stated by the <code>_TRUNCATE</code> flag. The idea is that people are more likely to use if(strncpy_s(...)).</p>
<ol start="2">
<li><strong>Cannot be used on non-strings.</strong></li>
</ol>
<p>Some people think that string functions should never crash even when fed bogus data. This affects standard functions such as strlen which in normal conditions will segfault. The new standard will include many such functions. The checks of course have a performance penalty.</p>
<p>The upside over the proposed standard functions is that you can know how much data you missed with <em>strl</em> functions.</p>
</div></text><author><a href="/users/14554/jbcreix">jbcreix</a></author><comments><comment><text><span class="comment-copy">note that <code>strncpy_s</code> is not a secure version of <code>strncpy</code> but basically a <code>strlcpy</code> replacement.</span></text><author><a class="comment-user" href="/users/14554/jbcreix" title="2,983 reputation">jbcreix</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<p>I don't think <code>strlcpy</code> and <code>strlcat</code> are consider <strong>insecure</strong> or it least it isn't the reason why they're not included in glibc - after all, glibc includes strncpy and even strcpy.</p>
<p>The criticism they got was that they are allegedly <strong>inefficient, not insecure</strong>.</p>
<p>According to the <a href="https://www.openbsd.org/papers/portability.pdf" rel="nofollow">Secure Portability</a> paper by Damien Miller:</p>
<blockquote>
<p>The strlcpy and strlcat API properly check the target buffer’s bounds,
  nul-terminate in all cases and return the length of the source string,
  allowing detection of truncation. This API has been adopted by most
  modern operating systems and many standalone software packages,
  including OpenBSD (where it originated), Sun Solaris, FreeBSD, NetBSD,
  the Linux kernel, rsync and the GNOME project. The notable exception
  is the GNU standard C library, glibc [12], whose maintainer
  steadfastly refuses to include these improved APIs, labelling them
  <strong>“horribly inefficient BSD crap”</strong> [4], despite prior evidence that they
  are faster is most cases than the APIs they replace [13]. As a result,
  over 100 of the software packages present in the OpenBSD ports tree
  maintain their own strlcpy and/or strlcat replacements or equivalent
  APIs - not an ideal state of affairs.</p>
</blockquote>
<p>That is why they are not available in glibc, but it is not true that they are not available on Linux. They are available on Linux in libbsd:</p>
<ul>
<li><a href="https://libbsd.freedesktop.org/" rel="nofollow">https://libbsd.freedesktop.org/</a></li>
</ul>
<p>They're packaged in Debian and Ubuntu and other distros. You can also just grab a copy and use in your project - it's short and under a permissive license:</p>
<ul>
<li><a href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/lib/libc/string/strlcpy.c?rev=1.11" rel="nofollow">http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/lib/libc/string/strlcpy.c?rev=1.11</a></li>
</ul>
</div></text><author><a href="/users/613198/rsp">rsp</a></author><comments/></answer></answers></post>