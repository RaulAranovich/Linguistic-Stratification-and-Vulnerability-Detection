<?xml version="1.0" encoding="utf-8"?>
<post><title>javascript - JSON security best practices? - Stack Overflow</title><question><text><div class="post-text" itemprop="text">
<p>While researching the issue of <a href="http://www.subbu.org/blog/2006/08/json-vs-xml" rel="noreferrer">JSON vs XML</a>, I came across <a href="http://stackoverflow.com/questions/325085/when-to-prefer-json-over-xml">this question</a>.  Now one of the reasons to prefer JSON was listed as the ease of conversion in Javascript, namely with the <code>eval()</code>.  Now this immediately struck me as potentially problematic from a security perspective.</p>
<p>So I started doing some research into the security aspects of JSON and across this blog post about how <a href="http://incompleteness.me/blog/2007/03/05/json-is-not-as-safe-as-people-think-it-is/" rel="noreferrer">JSON is not as safe as people think it is</a>.  This part stuck out:</p>
<blockquote>
<p><strong>Update:</strong> If you are doing JSON 100%
  properly, then you will only have
  objects at the top level. Arrays,
  Strings, Numbers, etc will all be
  wrapped. A JSON object will then fail
  to eval() because the JavaScript
  interpreter will think it's looking at
  a block rather than an object. This
  goes a long way to protecting against
  these attacks, however it's still best
  to protect your secure data with
  un-predictable URLs.</p>
</blockquote>
<p>Ok, so that's a good rule to start with: JSON objects at the top level should always be objects and never arrays, numbers or strings.  Sounds like a good rule to me.</p>
<p>Is there anything else to do or avoid when it comes to JSON and AJAX related security?</p>
<p>The last part of the above quote mentions unpredictable URLs.  Does anyone have more information on this, especially how you do it in PHP?  I'm far more experienced in Java than PHP and in Java it's easy (in that you can map a whole range of URLs to a single servlet) whereas all the PHP I've done have mapped a single URL to the PHP script.</p>
<p>Also, how exactly do you use unpredictable URLs to increase security?</p>
</div></text><author><a href="/users/759106/cees">Cees</a></author><comments><comment><text><span class="comment-copy">I don't get this at all! Surely any request made by the browser (to any URL - unpredictable or not) can be reported to the user, either using a console or some fancy GM script...</span></text><author><a class="comment-user" href="/users/21677/james" title="79,345 reputation">James</a></author></comment><comment><text><span class="comment-copy">"JSON is not as safe as people think it is" is dead</span></text><author><a class="comment-user" href="/users/893693/inf" title="14,101 reputation">inf</a></author></comment></comments></question><answers><answer><text><div class="post-text" itemprop="text">
<p>The main security hole from the blog (CSRF), is not JSON specific. It's just as big a hole using XML instead. Indeed, it's just as bad with no asynchronous calls at all; regular links are just as vulnerable.</p>
<p>When people talk about unique URLs, they generally DON'T mean <a href="http://yourbank.com/json-api/your-name/big-long-key-unique-to-you/statement" rel="noreferrer">http://yourbank.com/json-api/your-name/big-long-key-unique-to-you/statement</a>. Instead, it's more common to make something else about the request unique; namely a value in the FORM post, or a URL parameter.</p>
<p>Usually this involves a random token inserted into the FORM on the server side, and then checked when a request is made.</p>
<p>The array/object thing is news to me:</p>
<blockquote>
<p>Script-Tags: The attacker can embed a
  script tag pointing at a remote server
  and the browser will effectively
  eval() the reply for you, however it
  throws away the response and since
  JSON is all response, you're safe.</p>
</blockquote>
<p>In that case, your site doesn't need to use JSON at all to be vulnerable. But yeah, if an attacker can insert random HTML into your site, you're toast.</p>
</div></text><author><a href="/users/7679/chase-seibert">Chase Seibert</a></author><comments/></answer><answer><text><div class="post-text" itemprop="text">
<p>There are a number of security attacks against JSON, especially XSRF.</p>
<p>The vulnerability occurs when a web service uses cookies for authentication, and responds with a JSON array containing sensitive data in response to a GET request.</p>
<p>If an attacker can trick a user who is logged into a service, naive-webapp.com, into visiting their site (or any site that embeds an IFRAME they control, e.g. via embedded ads) then they can insert a <code>&lt;script&gt;</code> tag with a SRC to the naive-webapp.com, and potentially steal the user's data.
This depends on a javascript quirk with the JavaScript <code>Array</code> constructor like this:</p>
<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> </span><span class="tag">&lt;script&gt;</span><span class="pln">
   </span><span class="com">// Overload the Array constructor so we can intercept data</span><span class="pln">
   </span><span class="kwd">var</span><span class="pln"> stolenArrays </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[];</span><span class="pln">
   </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">RealArray</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">;</span><span class="pln">
   </span><span class="typ">Array</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
     </span><span class="kwd">var</span><span class="pln"> arr </span><span class="pun">=</span><span class="pln"> </span><span class="typ">RealArray</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="pln">arguments</span><span class="pun">);</span><span class="pln">
     stolenArrays</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">);</span><span class="pln">
     </span><span class="kwd">return</span><span class="pln"> arr</span><span class="pun">;</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
 </span><span class="tag">&lt;/script&gt;</span><span class="pln">
 </span><span class="com">&lt;!-- even though the attacker can't access the cookies,
   - he can cause the browser to send them to naive-webapp.com --&gt;</span><span class="pln">
 </span><span class="tag">&lt;script</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">"//naive-webapp.com/..."</span><span class="tag">&gt;&lt;/script&gt;</span><span class="pln">
 </span><span class="tag">&lt;script&gt;</span><span class="pln">
   </span><span class="com">// now stolenArrays contains any data from the parsed JSON</span><span class="pln">
 </span><span class="tag">&lt;/script&gt;</span></code></pre>
<p>EcmaScript 5 has fixed the confusing behavior that caused <code>[]</code> to look up <code>Array</code> on the global object and many modern browsers are no longer susceptible to this attack.</p>
<p>Incidentally, Oil is wrong about unpredictable URLs.  Cryptographically secure random identifiers in URLs are a fine way to protect resources.  Identity based security is not a panacea as Oil suggests.
See <a href="http://waterken.sourceforge.net/" rel="noreferrer">http://waterken.sourceforge.net/</a> for an example of a secure distributed application scheme based on cryptographically secure identifiers in URLs that does not require a concept of identity.</p>
<p>EDIT:</p>
<p>When considering JSON vs XML, you should be aware of XML specific attack vectors as well.</p>
<p><a href="http://projects.webappsec.org/w/page/13247003/XML%20External%20Entities" rel="noreferrer">XXE</a>, XML External entities attacks, use crafted XML to access file system and network resources through the firewall.</p>
<blockquote>
<pre class="default prettyprint prettyprinted" style=""><code><span class="dec">&lt;!DOCTYPE root 
[
&lt;!ENTITY foo SYSTEM "file:///c:/winnt/win.ini"&gt;</span><span class="pln">
]&gt;
...
</span><span class="tag">&lt;in&gt;</span><span class="pln">&amp;foo;</span><span class="tag">&lt;/in&gt;</span></code></pre>
<p>The Application embeds the input (parameter "in", which contains the win.ini file) to the web service response.</p>
</blockquote>
</div></text><author><a href="/users/20394/mike-samuel">Mike Samuel</a></author><comments><comment><text><span class="comment-copy">I see, so if the web server is sending out data intended only for a logged in user in response to a GET request, even if that data is JSON, it should keep in mind that an attacker can get and parse that data using a &lt;script&gt; tag.  So what's the solution?  Your web app should be careful not to send anything out that could be parsed as Javascript, even JSON, in response to a GET request.  It should be POST-only (perhaps with a token matching a cookie set by the server).  I think that's a similar solution to some other threats isn't it, like GIFAR?</span></text><author><a class="comment-user" href="/users/53212/thomasrutter" title="73,740 reputation">thomasrutter</a></author></comment><comment><text><span class="comment-copy">Or how secure would be it be just to rely on the outermost layer being an object and the parser breaking because {} is interpreted as a block?</span></text><author><a class="comment-user" href="/users/53212/thomasrutter" title="73,740 reputation">thomasrutter</a></author></comment><comment><text><span class="comment-copy">If you know the outermost layer is always an object, and you properly quote property names then the parser should break.</span></text><author><a class="comment-user" href="/users/20394/mike-samuel" title="79,660 reputation">Mike Samuel</a></author></comment><comment><text><span class="comment-copy">+1 for your positive remark about random identifiers in URLs</span></text><author><a class="comment-user" href="/users/268098/ta-sas" title="2,756 reputation">Ta Sas</a></author></comment></comments></answer><answer><text><div class="post-text" itemprop="text">
<blockquote>
<p>it's still <strong>best</strong> to protect your secure data with un-predictable URLs.</p>
</blockquote>
<p>Emphasis mine. What nonsense! It's <strong><em>best</em></strong> to protect your secure data with some proper authentication and possibly some encryption on top of that. JSON exchanges can still use existing authentication techniques (eg sessions through cookies) and SSL.</p>
<p>Relying on somebody not guessing a URL (what they're effectively talking about) will only be a reasonable technique (and even then, only just) when you're using JSON to export data to an anonymous third party (eg a web service). One example is Google's various web service API where anonymous users access Google-data through other websites. They use domain-referrer and API keys to make sure the man-in-the-middle website is allowed to provide Gooogle data.</p>
<p>If you're just using JSON to send private data to and from a direct, known user agent, use some real authentication and encryption. If you're trying to provide a webservice, then it really depends on how <em>"secure"</em> this data is going to be. If it's just public data and you don't mind who can read it, I don't see the point in making a hashy URL.</p>
<hr/>
<p>Edit: to demonstrate what they mean, consider this. Imagine your bank provided a JSON API for getting statements. If I could just type <code>http://yourbank.com/json-api/your-name/statement</code>, you probably wouldn't be best pleased.</p>
<p>They could generate a unique string for your account that was required in any JSON request though, eg: <code>http://yourbank.com/json-api/your-name/big-long-key-unique-to-you/statement</code></p>
<p>I would have far less chance of being able to guess that. But would you really want that being the only buffer between your genuinely secure data and potential identity thieves? No.</p>
</div></text><author><a href="/users/12870/oli">Oli</a></author><comments><comment><text><span class="comment-copy">I think you need to read the rest of the blog: he doesn't advocate no security other than unpredictable URLs.  What he says is that security through cookies is NOT ENOUGH and he demonstrates why.</span></text><author><a class="comment-user owner" href="/users/18393/cletus" title="433,061 reputation">cletus</a></author></comment><comment><text><span class="comment-copy">Authentication doesn't help -- that's the point of the question.  For example, If the user is logged into target.com (i.e. they have a session cookie), attacker.com might try something like <code>&lt;script type="text/javascript" src="http://target.com/secret-data-with-predictable-url.json‌​"/&gt;</code> and use the Array constructor trick described by Mike to get at the data, if the top-level element is an array.</span></text><author><a class="comment-user" href="/users/525872/jo-liss" title="11,415 reputation">Jo Liss</a></author></comment><comment><text><span class="comment-copy">Two problems -- you confuse authentication with authorization, and then you incorrectly assume that passwords are less easily guessed.  Which is easier to guess: a randomly generated identifier which usually has between 128 bits and 1024 bits of entropy, or a human generated password that has, on average, 18 bits of entry?  The main problem with URLs is that users are not as used to keeping URLs secret and some work has to be done to prevent leakage via referrer and the like.  Waterken attempts to address both problems.</span></text><author><a class="comment-user" href="/users/20394/mike-samuel" title="79,660 reputation">Mike Samuel</a></author></comment></comments></answer></answers></post>